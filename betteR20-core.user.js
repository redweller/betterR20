// ==UserScript==
// @name         betteR20-core-dev
// @namespace    https://5e.tools/
// @license      MIT (https://opensource.org/licenses/MIT)
// @version      1.35.1.42
// @description  Enhance your Roll20 experience
// @updateURL    https://github.com/redweller/betterR20/raw/run/betteR20-core.meta.js
// @downloadURL  https://github.com/redweller/betterR20/raw/run/betteR20-core.user.js
// @author       TheGiddyLimit

// @match        https://app.roll20.net/editor
// @match        https://app.roll20.net/editor#*
// @match        https://app.roll20.net/editor?*
// @match        https://app.roll20.net/editor/
// @match        https://app.roll20.net/editor/#*
// @match        https://app.roll20.net/editor/?*

// @grant        unsafeWindow
// @run-at       document-start

// @grant        GM_webRequest
// @webRequest   [{"selector": { "include": "*://www.google-analytics.com/analytics.js" },  "action": "cancel"}]
// @webRequest   [{"selector": { "include": "*://cdn.userleap.com/shim.js?*" },  "action": "cancel"}]
// @webRequest   [{"selector": { "include": "*://analytics.tiktok.com/*" },  "action": "cancel"}]

// ==/UserScript==


ART_HANDOUT = "betteR20-art";
CONFIG_HANDOUT = "betteR20-config";

// TODO automate to use mirror if main site is unavailable
// BASE_SITE_URL = "https://5e.tools/";
BASE_SITE_URL = "https://5etools-mirror-1.github.io/";

SITE_JS_URL = `${BASE_SITE_URL}js/`;
DATA_URL = `${BASE_SITE_URL}data/`;
DATA_URL_MODULES = `https://raw.githubusercontent.com/5etools-mirror-1/roll20-module/master`;

SCRIPT_EXTENSIONS = [];

EXT_LIB_SCRIPTS = [];
EXT_LIB_API_SCRIPTS = [];

JSON_DATA = {};

CONFIG_OPTIONS = {
	interface: {
		_name: "Interface",
		_player: true,
	},
};

addConfigOptions = function (category, options) {
	if (!CONFIG_OPTIONS[category]) CONFIG_OPTIONS[category] = options;
	else CONFIG_OPTIONS[category] = Object.assign(CONFIG_OPTIONS[category], options);
};

OBJECT_DEFINE_PROPERTY = Object.defineProperty;
OBJECT_DEFINED_COUNT = 0;
ACCOUNT_ORIGINAL_PERMS = {
	isPro: false,
	largefeats: false,
	xlfeats: false,
};
Object.defineProperty = function (obj, prop, vals) {
	try {
		if (prop === "largefeats" || prop === "xlfeats" || prop === "isPro") {
			ACCOUNT_ORIGINAL_PERMS[prop] = vals.value;
			vals.value = true;
			OBJECT_DEFINED_COUNT++;
		}
		OBJECT_DEFINE_PROPERTY.bind(Object)(obj, prop, vals);
		if (OBJECT_DEFINED_COUNT === 3) Object.defineProperty = OBJECT_DEFINE_PROPERTY.bind(Object);
	} catch (e) {
		// eslint-disable-next-line no-console
		console.log("failed to define property:", e, obj, prop, vals);
	}
};

FINAL_CANVAS_MOUSEDOWN_LIST = [];
FINAL_CANVAS_MOUSEMOVE_LIST = [];
FINAL_CANVAS_MOUSEDOWN = null;
FINAL_CANVAS_MOUSEMOVE = null;
EventTarget.prototype.addEventListenerBase = EventTarget.prototype.addEventListener;
EventTarget.prototype.addEventListener = function (type, listener, options, ...others) {
	if (typeof d20 !== "undefined") {
		if (type === "mousedown" && this === d20.engine.final_canvas) FINAL_CANVAS_MOUSEDOWN = listener;
		if (type === "mousemove" && this === d20.engine.final_canvas) FINAL_CANVAS_MOUSEMOVE = listener;
	} else {
		if (type === "mousedown") FINAL_CANVAS_MOUSEDOWN_LIST.push({listener, on: this});
		if (type === "mousemove") FINAL_CANVAS_MOUSEMOVE_LIST.push({listener, on: this});
	}
	this.addEventListenerBase(type, listener, options, ...others);
};


function baseLanguage () {
	d20plus.ln = { default: {} };

	d20plus.ln.en = {

		cfg_tab_tokens: [`Tokens`],
		cfg_tab_canvas: [`Canvas`],
		cfg_tab_import: [`Import`],
		cfg_tab_interface: [`Interface`],
		cfg_tab_chat: [`Chat`],
		cfg_option_whisper_name: [`Whisper Token Name to Mass-Rolls`],
		cfg_option_quick_init_sort: [`Add Quick Initiative Sort Button`],
		cfg_option_grid_snap: [`Grid Snap`],
		cfg_option_scaled_names: [`Scaled Names and Status Icons`],
		cfg_option_show_fl: [`Include the Floors layer (reload to apply changes)`],
		cfg_option_show_bg: [`Include the Background layer (reload to apply changes)`],
		cfg_option_show_fg: [`Include the Foreground layer (reload to apply changes)`],
		cfg_option_show_rf: [`Include the Roofs layer (reload to apply changes)`],
		cfg_option_show_light: [`Include (force) light sources button (reload to apply changes)`],
		cfg_option_show_weather: [`Include Weather layer and settings (reload to apply changes)`],
		cfg_option_import_interval: [`Rest Time between Each Map (msec)`],
		cfg_option_emoji: [`Add Emoji Replacement to Chat`],
		cfg_option_art_previews: [`Show Custom Art Previews`],
		cfg_option_toolbar_opac: [`Horizontal Toolbar Opacity`],
		cfg_option_layer_panel: [`Add Quick Layer Buttons panel`],
		cfg_option_layer_panel_position: [`-- Select left or right side to display this panel`],
		cfg_option_streamer_tags: [`Streamer-Friendly Chat Tags`],
		cfg_option_hide_r20search: [`Hide Default Journal Search Bar`],
		cfg_option_player_size: [`Set Player List size (0 - don't change)`],
		cfg_option_hide_dmswitch: [`Hide Roll20's Dark Mode switch`],
		cfg_option_hide_help: [`Hide Help Button on floating toolbar`],
		cfg_option_dm_tweaks: [`Enable background style fixes for default dark mode`],
		cfg_option_assume_ogl: [`Alternative mass rolls (only OGL 5e)`],
		cfg_option_silent_chat: [`Don't show welcome messages on load`],
		cfg_option_modest_chat: [`Use default chat style for betteR20 system messages`],
		cfg_option_select_jrnsearch: [`Select Journal search controls`],
		cfg_option_select_artlib: [`Select Art Library controls`],
		cfg_option_quick_init_clear: [`Add Quick Initiative tracker Clear Button`],
		cfg_option_hide_linesplit: [`Hide Line Splitter (reload to apply changes)`],
		cfg_option_neat_menus: [`Reorganized canvas context menu (reload to apply changes)`],
		cfg_option_quick_menu: [`Enable quick actions as copies of the menu entries added to the bottom of Reorganized menu for quick access (needs restart)<br> -- Quick action 1 is always Token to GM & back.`],
		cfg_option_quick_2: [`-- Quick action 2`],
		cfg_option_quick_3: [`-- Quick action 3`],
		cfg_option_minify_tracker: [`Shrink Initiative Tracker Text`],
		cfg_option_interiors_toggle: [`Add interior/outside mode switch`],
		cfg_option_legacy_chat: [`Use green/black style for betteR20 system messages`],
		cfg_option_resize_sidebar: [`Resize textbox & tabs with sidebar (requires restart)`],
		cfg_option_welcome_msg: [`Show welcome message on load`],
		cfg_option_log_players_in_chat: [`Show player connects messages`],
		cfg_option_enable_social: [`Enable chat social panel (requires restart)`],
		cfg_option_languages: [`Enable in-game languages (via social panel or /in)`],
		cfg_option_additional_commands: [`Additional text chat commands (/help for full list)`],
		cfg_option_highlight_ttms: [`Highlight text box when in TTMS mode`],
		cfg_option_versions_from_players: [`Show script version notifications from players`],
		cfg_option_share_version_info: [`Share script version numbers`],
		ui_bar_map: [`Map & Backdrop`],
		ui_bar_obj: [`Objects & Tokens`],
		ui_bar_fl: [`Floors`],
		ui_bar_bg: [`Background`],
		ui_bar_fg: [`Foreground`],
		ui_bar_rf: [`Roofs`],
		ui_bar_we: [`Weather Exclusions`],
		ui_bar_gm: [`GM's Hidden layer`],
		ui_bar_barriers: [`Dynamic Field of View`],
		ui_bar_light_n_barriers: [`Dynamic Lighting`],
		ui_bar_toggle_layer_title: [`Toggle layer visibility`],
		ui_bar_toggle_interior: [`Toggle inside/outside`],
		ui_cfg_property: [`Property`],
		ui_cfg_value: [`Value`],
		ui_cfg_save: [`Save`],
		ui_dialog_title: [`Input value`],
		ui_dialog_select: [`Select`],
		ui_dialog_submit: [`Submit`],
		ui_dialog_cancel: [`Cancel`],
		ui_updated: [`Updated`],
		ui_tokened_details: [`Details`],
		ui_tokened_gmnotes: [`GM Notes`],
		ui_tokened_dynlight: [`Dynamic Lighting`],
		ui_tokened_leglight: [`Legacy Lighting`],
		ui_lang_subst_title: [`Choose transcription`],
		ui_lang_subst_subtitle: [`What does $0 language sound like?`],
		ui_lang_subst_p1: [`It seems you're trying to speak language not included in the standard list of D&D 5e PHB.`],
		ui_lang_subst_p2: [`That's not a problem. Please select one of the languages from the dropdown below, and it will be used for the imitated message.`],
		ui_lang_subst_p3: [`Your choice is purely cosmetic and will not affect who can or can not understand it. This will be remembered until you refresh the page.`],
		ui_lang_subst_select: [`Transcribe as:`],
		ui_lang_subst_p_eg: [`This is what your message will look like with the current selection to those who don't speak $0:`],
		menu_unlock: [`Unlock...`],
		menu_card_title: [`Decks`],
		menu_take_card: [`Take Card`],
		menu_flip_card: [`Flip Card`],
		menu_edit_title: [`Edit`],
		menu_edit_del: [`Delete`],
		menu_edit_copy: [`Copy`],
		menu_edit_paste: [`Paste`],
		menu_edit_undo: [`Undo`],
		menu_move_title: [`Move`],
		menu_move_tofront: [`To Front`],
		menu_move_forwone: [`Forward One`],
		menu_move_backone: [`Back One`],
		menu_move_toback: [`To Back`],
		menu_view_title: [`Assign view`],
		menu_layer_title: [`Layer`],
		menu_layer_map: [`Map`],
		menu_layer_fl: [`Floors`],
		menu_layer_bg: [`Background`],
		menu_layer_obj: [`Tokens`],
		menu_layer_fg: [`Foreground`],
		menu_layer_rf: [`Roofs`],
		menu_layer_gm: [`GM Hidden`],
		menu_layer_barriers: [`Field of view`],
		menu_layer_weather: [`Weather`],
		menu_util_title: [`Utilities`],
		menu_util_start: [`Start Scene`],
		menu_util_animate: [`Animate`],
		menu_util_flight: [`Set&nbsp;Flight&nbsp;Height`],
		menu_util_light: [`Set&nbsp;Light`],
		menu_adv_title: [`Advanced`],
		menu_adv_grp: [`Group`],
		menu_adv_regrp: [`Reroup`],
		menu_adv_ungrp: [`Ungroup`],
		menu_adv_isdrv: [`Is Drawing`],
		menu_adv_flh: [`Flip Horizontal`],
		menu_adv_flv: [`Flip Vertical`],
		menu_adv_dimens: [`Set Dimensions`],
		menu_adv_align: [`Align to Grid`],
		menu_adv_lock: [`Lock`],
		menu_adv_unlock: [`Unlock`],
		menu_adv_tokenid: [`View Token ID`],
		menu_adv_pathid: [`View Path ID`],
		menu_token_title: [`Token Tasks`],
		menu_token_turn: [`Add Turn`],
		menu_mass_title: [`Mass Roll`],
		menu_mass_init: [`Initiative`],
		menu_mass_save: [`Saving Throw`],
		menu_mass_skill: [`Skill Check`],
		menu_multi_title: [`Multi-Sided`],
		menu_multi_rnd: [`Random Side`],
		menu_multi_select: [`Choose Side`],
		menu_multi_size: [`Set Side Size`],
		menu_quick_togm: [`Hide from layer`],
		menu_quick_tofg: [`To visible layer`],
		menu_quick_toback: [`Move behind`],
		menu_quick_save: [`Roll save`],
		stat_save_str: [`Strength`],
		stat_save_dex: [`Dexterity`],
		stat_save_con: [`Constitution`],
		stat_save_int: [`Intelligence`],
		stat_save_wis: [`Wisdom`],
		stat_save_cha: [`Charisma`],
		stat_ab_athl: [`Athletics`],
		stat_ab_acrb: [`Acrobatics`],
		stat_ab_sloh: [`Sleight of Hand`],
		stat_ab_stel: [`Stealth`],
		stat_ab_arcn: [`Arcana`],
		stat_ab_hist: [`History`],
		stat_ab_invs: [`Investigation`],
		stat_ab_natr: [`Nature`],
		stat_ab_relg: [`Religion`],
		stat_ab_anih: [`Animal Handling`],
		stat_ab_insg: [`Insight`],
		stat_ab_medc: [`Medicine`],
		stat_ab_perc: [`Perception`],
		stat_ab_surv: [`Survival`],
		stat_ab_decp: [`Deception`],
		stat_ab_intm: [`Intimidation`],
		stat_ab_perf: [`Performance`],
		stat_ab_pers: [`Persuasion`],
		stat_init: [`INITIATIVE`],
		lang_common: [`Common`],
		lang_dwarvish: [`Dwarvish`],
		lang_elvish: [`Elvish`],
		lang_giant: [`Giant`],
		lang_gnomish: [`Gnomish`],
		lang_goblin: [`Goblin`],
		lang_halfling: [`Halfling`],
		lang_orcish: [`Orcish`],
		lang_abyssal: [`Abyssal`],
		lang_celestial: [`Celestial`],
		lang_draconic: [`Draconic`],
		lang_deepspeech: [`Deepspeech`],
		lang_infernal: [`Infernal`],
		lang_primordial: [`Primordial`],
		lang_sylvan: [`Sylvan`],
		lang_undercommon: [`Undercommon`],
		lang_alias_common: [``],
		lang_alias_dwarvish: [``],
		lang_alias_elvish: [``],
		lang_alias_giant: [``],
		lang_alias_gnomish: [``],
		lang_alias_goblin: [``],
		lang_alias_halfling: [``],
		lang_alias_orcish: [``],
		lang_alias_abyssal: [``],
		lang_alias_celestial: [``],
		lang_alias_draconic: [``],
		lang_alias_deepspeech: [``],
		lang_alias_infernal: [``],
		lang_alias_primordial: [``],
		lang_alias_sylvan: [``],
		lang_alias_undercommon: [``],
		msg_chat_help_w: [`private message (whisper)`],
		msg_chat_help_wgm: [`private message to your GM`],
		msg_chat_help_wb: [`PM back to last contact`],
		msg_chat_help_ws: [`PM to selected tokens (GM)`],
		msg_chat_help_versions: [`get script versions (GM)`],
		msg_chat_help_em: [`emote (action from your POV)`],
		msg_chat_help_in: [`speak in a language`],
		msg_chat_help_inname: [`skip word (for in-language)`],
		msg_chat_help_cl: [`comprehend language switch`],
		msg_chat_help_sm: [`silent mode on/off`],
		msg_chat_help_ttms: [`shortcut to /talktomyself`],
		msg_chat_help_mtms: [`execute silently`],
		msg_chat_help_ooc: [`out of character emote`],
		msg_chat_help_r: [`roll dice, e.g. /r 2d6`],
		msg_chat_help_gr: [`roll only for GM`],
		msg_chat_help_desc: [`GM-only describe events`],
		msg_chat_help_as: [`GM-only speak as Name`],
		msg_chat_help_emas: [`GM-only emote as Name`],
		msg_chat_help_il: [`inline dice roll`],
		msg_chat_help_fi: [`format text: italic`],
		msg_chat_help_fb: [`format text: bold`],
		msg_chat_help_fc: [`format text: code`],
		msg_chat_help_fs: [`format text: strikethrough`],
		msg_chat_help_fx: [`show visual effect`],
		msg_chat_help_m: [`run specified macro`],
		msg_chat_help: [`show this list of chat commands`],
		msg_chat_lang_title: [`You understand this because one of your characters speaks`],
		msg_b20_chat_help: [`<li>Full list of chat commands<br>type or press $0<br>or visit <a target='blank' href='$1'>roll20 wiki</a></li>`],
		msg_b20_chat_help_title: [`<strong>List of chat commands:</strong><br>betteR20 commands marked with &#42;`],
		msg_b20_vtte_init: [`VTTE detected and $0 successfully loaded.<br>`],
		msg_b20_version_stream: [`<br>A newer version of $0 is available.<br><br>`],
		msg_b20_version: [`<br>A newer version of $0 is available.<br>Get $1 <a href="$2">5etools</a> OR <a href="$3">core</a>.<br><br>`],
		msg_welcome_versions: [`VTTES v$1 detected<br>$0 loaded`],
		msg_welcome_faq: [`Need help? Visit our <a href="$0/index.php/BetteR20_FAQ"><strong>wiki</strong></a> or join our`],
		msg_welcome_sarcasm: [`You'd think this would be obvious.`],
		msg_welcome_p1: [`Please DO NOT post about this script or any related content in official channels, including the Roll20 forums.`],
		msg_welcome_p2: [`Before reporting a bug on the Roll20 forums, please disable the script and check if the problem persists.`],
		msg_player_connected: [`connected`],
		msg_player_joined: [`joined`],
		msg_status_name: [`status`],
		msg_player_disconnected: [`disconnected`],
	};

	d20plus.ln.ru = {

		cfg_tab_tokens: [`Токены`],
		cfg_tab_canvas: [`Слои`],
		cfg_tab_import: [`Импорт`],
		cfg_tab_interface: [`Интерфейс`],
		cfg_tab_chat: [`Чат`],
		cfg_option_whisper_name: [`Шептать в чат имена при групповых бросках`],
		cfg_option_quick_init_sort: [`Добавить кнопку быстрой сортировки Инициативы`],
		cfg_option_grid_snap: [`Шаг "прилипания" к сетке`],
		cfg_option_scaled_names: [`Масштабируемые имена и иконки статусов`],
		cfg_option_show_fl: [`Включить слой Полов (нужен перезапуск)`],
		cfg_option_show_bg: [`Включить слой Задний план (нужен перезапуск)`],
		cfg_option_show_fg: [`Включить слой Передний план (нужен перезапуск)`],
		cfg_option_show_rf: [`Включить слой Крыши (нужен перезапуск)`],
		cfg_option_show_light: [`Включить кнопку для источников света (нужен перезапуск)`],
		cfg_option_show_weather: [`Включить слой и настройки Погоды (нужен перезапуск)`],
		cfg_option_import_interval: [`Время ожидания перед каждой картой (при импорте)`],
		cfg_option_emoji: [`Добавить в чат замену эмотиконов`],
		cfg_option_art_previews: [`Использовать предпросмотр для библиотеки изображений`],
		cfg_option_toolbar_opac: [`Прозрачность горизонтальной панели инструментов`],
		cfg_option_layer_panel: [`Добавить панель Быстрого выбора слоя`],
		cfg_option_layer_panel_position: [`-- Слева или справа отображать эту панель`],
		cfg_option_streamer_tags: [`Обезличенные названия в чате (для стримеров)`],
		cfg_option_hide_r20search: [`Спрятать дефолтную панель поиска в Журнале`],
		cfg_option_player_size: [`Выберите размер списка игроков (0 - не менять)`],
		cfg_option_hide_dmswitch: [`Спрятать переключатель темного режима от Roll20`],
		cfg_option_hide_help: [`Спрятать кнопку Помощь на панели инструментов`],
		cfg_option_dm_tweaks: [`Включить исправления стилей для темного режима`],
		cfg_option_assume_ogl: [`Альтернативные групповые броски (только лист OGL)`],
		cfg_option_silent_chat: [`Не выводить в чат приветствие при загрузке`],
		cfg_option_modest_chat: [`Использовать родной стиль чата для уведомлений betteR20`],
		cfg_option_select_jrnsearch: [`Выберите тип строки поиска в Журнале`],
		cfg_option_select_artlib: [`Выберите элементы управления для Библиотеки`],
		cfg_option_quick_init_clear: [`Добавить кнопку быстрой очистки Трекера`],
		cfg_option_hide_linesplit: [`Спрятать кнопку разрезания линий (нужен перезапуск)`],
		cfg_option_neat_menus: [`Упорядоченное контекстное меню слоя (нужен перезапуск)`],
		cfg_option_quick_menu: [`Включить быстрые действия, которые отображаются в самом низу Упорядоченного меню и дублируют обычные пункты (нужен перезапуск)<br> -- Быстрое действие 1, всегда "На слой ГМа" и обратно`],
		cfg_option_quick_2: [`-- Быстрое действие 2`],
		cfg_option_quick_3: [`-- Быстрое действие 3`],
		cfg_option_minify_tracker: [`Уменьшить размер элементов трекера инициативы`],
		cfg_option_interiors_toggle: [`Добавить переключатель режима в помещении/снаружи`],
		cfg_option_legacy_chat: [`Черно-зелёный (классический) стиль уведомлений betteR20`],
		cfg_option_resize_sidebar: [`Подгонять размер текстбокса под панель (нужен перезапуск)`],
		cfg_option_welcome_msg: [`Выводить в чат приветствие при загрузке`],
		cfg_option_log_players_in_chat: [`Выводить сообщения о подключении игроков`],
		cfg_option_enable_social: [`Включить панель опций чата (нужен перезапуск)`],
		cfg_option_languages: [`Включить внутриигровые языки (через панель чата или /in)`],
		cfg_option_additional_commands: [`Дополнительные команды чата (/help - список)`],
		cfg_option_highlight_ttms: [`Подсвечивать область ввода в режиме TTMS`],
		cfg_option_versions_from_players: [`Показывать уведомления о версиях скриптов`],
		cfg_option_share_version_info: [`Делиться информацией о версиях скриптов`],
		ui_bar_map: [`Карта и фон`],
		ui_bar_obj: [`Объекты и токены`],
		ui_bar_fl: [`Полы`],
		ui_bar_bg: [`Задний план`],
		ui_bar_fg: [`Передний план`],
		ui_bar_rf: [`Крыши`],
		ui_bar_we: [`Исключения погоды`],
		ui_bar_gm: [`Скрытый слой Мастера`],
		ui_bar_barriers: [`Динамические преграды`],
		ui_bar_light_n_barriers: [`Динамическое освещение`],
		ui_bar_toggle_layer_title: [`Переключить видимость слоя`],
		ui_bar_toggle_interior: [`Переключить вид`],
		ui_cfg_property: [`Свойство`],
		ui_cfg_value: [`Значение`],
		ui_cfg_save: [`Сохранить`],
		ui_dialog_title: [`Введите значение`],
		ui_dialog_select: [`Выберите`],
		ui_dialog_submit: [`Подтвердить`],
		ui_dialog_cancel: [`Отмена`],
		ui_tokened_details: [`Детали`],
		ui_lang_subst_title: [`Выбрать звучание`],
		ui_lang_subst_subtitle: [`На что похож $0 по звучанию?`],
		ui_lang_subst_p1: [`Похоже, вы пытаетесь общаться на языке, который не включён в Книгу Игрока D&D 5e.`],
		ui_lang_subst_p2: [`Это не проблема. Пожалуйста выберите один из готовых языков в выпадающем списке ниже, и его словарь будет использован для сообщений на вашем языке.`],
		ui_lang_subst_p3: [`Этот выбор чисто косметический, и не повлияет на то, кто поймёт или не поймёт вашу речь. Выбор будет сохранён до перезагрузки страницы.`],
		ui_lang_subst_select: [`Выберите словарь:`],
		ui_lang_subst_p_eg: [`Вот как будет звучать ваша фраза с текущим выбранным словарём для тех, кто не понимает $0:`],
		menu_unlock: [`Снять блок...`],
		menu_card_title: [`Колода`],
		menu_take_card: [`Взять карту`],
		menu_flip_card: [`Перевернуть`],
		menu_edit_title: [`Правка`],
		menu_edit_del: [`Удалить`],
		menu_edit_copy: [`Копировать`],
		menu_edit_paste: [`Вставить`],
		menu_edit_undo: [`Отмена`],
		menu_move_title: [`Наложение`],
		menu_move_tofront: [`Перед всеми`],
		menu_move_forwone: [`На шаг вперед`],
		menu_move_backone: [`На шаг назад`],
		menu_move_toback: [`На задний план`],
		menu_view_title: [`Связать вид`],
		menu_layer_title: [`Слой`],
		menu_layer_map: [`Карта`],
		menu_layer_fl: [`Полы`],
		menu_layer_bg: [`Задний`],
		menu_layer_obj: [`Основной`],
		menu_layer_fg: [`Передний`],
		menu_layer_rf: [`Крыши`],
		menu_layer_gm: [`Слой ГМа`],
		menu_layer_barriers: [`Преграды`],
		menu_layer_weather: [`Погода`],
		menu_util_title: [`Утилиты`],
		menu_util_start: [`Старт сцены`],
		menu_util_animate: [`Анимировать`],
		menu_util_flight: [`Высота полета`],
		menu_util_light: [`Источник света`],
		menu_adv_title: [`Свойства`],
		menu_adv_grp: [`Группировать`],
		menu_adv_ungrp: [`Разгруппировка`],
		menu_adv_regrp: [`Перегруппиров.`],
		menu_adv_isdrv: [`Это рисунок`],
		menu_adv_flh: [`Отразить гор.`],
		menu_adv_flv: [`Отразить верт.`],
		menu_adv_dimens: [`Размеры`],
		menu_adv_align: [`Выровнять`],
		menu_adv_lock: [`Блокировать`],
		menu_adv_unlock: [`Разблокировать`],
		menu_adv_tokenid: [`ID токена`],
		menu_adv_pathid: [`ID линии`],
		menu_token_title: [`Действия`],
		menu_token_turn: [`В трекер`],
		menu_mass_title: [`Кинуть кубы`],
		menu_mass_init: [`Инициатива`],
		menu_mass_save: [`Спасбросок`],
		menu_mass_skill: [`Умения`],
		menu_multi_title: [`Мультитокен`],
		menu_multi_rnd: [`Случайно`],
		menu_multi_select: [`Выбрать`],
		menu_multi_size: [`Размер`],
		menu_quick_togm: [`Спрятать токен`],
		menu_quick_tofg: [`Вернуть на слой`],
		menu_quick_toback: [`Уровень вниз`],
		menu_quick_save: [`Спасброски`],
		stat_save_str: [`Сила`],
		stat_save_dex: [`Ловкость`],
		stat_save_con: [`Телосложение`],
		stat_save_int: [`Интеллект`],
		stat_save_wis: [`Мудрость`],
		stat_save_cha: [`Харизма`],
		stat_ab_athl: [`Атлетика`],
		stat_ab_acrb: [`Акробатика`],
		stat_ab_sloh: [`Ловкость рук`],
		stat_ab_stel: [`Скрытность`],
		stat_ab_arcn: [`Магия`],
		stat_ab_hist: [`История`],
		stat_ab_invs: [`Расследование`],
		stat_ab_natr: [`Природа`],
		stat_ab_relg: [`Религия`],
		stat_ab_anih: [`Уход за животными`],
		stat_ab_insg: [`Проницательность`],
		stat_ab_medc: [`Медицина`],
		stat_ab_perc: [`Восприятие`],
		stat_ab_surv: [`Выживание`],
		stat_ab_decp: [`Обман`],
		stat_ab_intm: [`Запугивание`],
		stat_ab_perf: [`Выступление`],
		stat_ab_pers: [`Убеждение`],
		stat_init: [`ИНИЦИАТИВА`],
		lang_common: [`Общий`],
		lang_dwarvish: [`Дварфийский`],
		lang_elvish: [`Эльфийский`],
		lang_giant: [`Великаний`],
		lang_gnomish: [`Гномий`],
		lang_goblin: [`Гоблинский`],
		lang_halfling: [`Полуросликов`],
		lang_orcish: [`Орочий`],
		lang_abyssal: [`Бездны`],
		lang_celestial: [`Небесный`],
		lang_draconic: [`Драконий`],
		lang_deepspeech: [`Глубинная речь`],
		lang_infernal: [`Инфернальный`],
		lang_primordial: [`Первичный`],
		lang_sylvan: [`Сильван`],
		lang_undercommon: [`Подземный`],
		lang_alias_common: [`человеческий`],
		lang_alias_dwarvish: [`дварфский, дварфов`],
		lang_alias_elvish: [`эльфский, эльфов`],
		lang_alias_giant: [`гигантский, гигантов, великанов, огров`],
		lang_alias_gnomish: [`гномский, гномов`],
		lang_alias_goblin: [`гоблинов`],
		lang_alias_halfling: [`халфлингский, халфлингов`],
		lang_alias_orcish: [`оркский, орков`],
		lang_alias_abyssal: [`абиссальный`],
		lang_alias_celestial: [`целестиалов`],
		lang_alias_draconic: [`дарконский, драконов`],
		lang_alias_deepspeech: [`глубинный`],
		lang_alias_infernal: [`инферналов`],
		lang_alias_primordial: [`элементальный, элементалей, акван, игнан, ауран, реттан`],
		lang_alias_sylvan: [`фейский, фей`],
		lang_alias_undercommon: [`подземья`],
		msg_chat_help_w: [`личное сообщение`],
		msg_chat_help_wgm: [`личное сообщение ГМу`],
		msg_chat_help_wb: [`ЛС последнему контакту`],
		msg_chat_help_ws: [`ЛС выбранным токенам (ГМ)`],
		msg_chat_help_versions: [`запрос инфо скриптов (ГМ)`],
		msg_chat_help_em: [`эмоция (персонаж делает...)`],
		msg_chat_help_in: [`говорить на языке`],
		msg_chat_help_inname: [`пропустить слово (в языке)`],
		msg_chat_help_cl: [`понимание языков`],
		msg_chat_help_sm: [`только себе вкл/выкл`],
		msg_chat_help_ttms: [`сокращение /talktomyself`],
		msg_chat_help_mtms: [`одна команда /ttms`],
		msg_chat_help_ooc: [`вне персонажа (как игрок)`],
		msg_chat_help_r: [`кубы, напр. /r 2d6`],
		msg_chat_help_gr: [`бросок ГМу`],
		msg_chat_help_desc: [`ГМ: описать события`],
		msg_chat_help_as: [`ГМ: реплика от персонажа`],
		msg_chat_help_emas: [`ГМ: эмоция от персонажа`],
		msg_chat_help_il: [`бросок внутри строки`],
		msg_chat_help_fi: [`формат: курсив`],
		msg_chat_help_fb: [`формат: полужирный`],
		msg_chat_help_fc: [`формат: код`],
		msg_chat_help_fs: [`формат: зачеркнуть`],
		msg_chat_help_fx: [`визуальные эффекты`],
		msg_chat_help_m: [`запустить макрос`],
		msg_chat_help: [`показать этот список`],
		msg_chat_lang_title: [`Вы понимаете это потому что ваш персонаж знает`],
		msg_b20_chat_help: [`<li>Полный список команд чата:<br>-нажмите $0<br>-или посетите <a target='blank' href='$1'>roll20 wiki</a></li>`],
		msg_b20_chat_help_title: [`<strong>Список команд чата:</strong><br>Команды от betteR20 отмечены &#42;`],
		msg_b20_vtte_init: [`VTTE обнаружен и $0 успешно загрузился.<br>`],
		msg_b20_version_stream: [`<br>$0 обновился, доступна новая версия.<br><br>`],
		msg_b20_version: [`<br>$0 обновился, доступна новая версия. Загрузите $1 в варианте <a href="$2">5etools</a> ИЛИ <a href="$3">core</a>.<br><br>`],
		msg_welcome_versions: [`VTTES v$1 найден<br>$0 загружен`],
		msg_welcome_faq: [`Нужна помощь? Посетите <a href="$0/index.php/BetteR20_FAQ"><strong>вики</strong></a> или зайдите в`],
		msg_welcome_sarcasm: [`Вроде, это должно быть очевидно`],
		msg_welcome_p1: [`Пожалуйста, НЕ НАДО постить про этот скрипт или относящийся к нему контент в официальных каналах, включая форумы Roll20.`],
		msg_welcome_p2: [`Перед тем, как сообщить о баге на форумах Roll20, пожалуйста отключите данный скрипт и проверьте, сохраняется ли проблема.`],
		msg_player_connected: [`подключился`],
		msg_player_joined: [`присоединился`],
		msg_status_name: [`статус`],
		msg_player_disconnected: [`отключился`],
	};

	for (const id in d20plus.ln.en) {
		d20plus.ln.default[id] = d20plus.ln.en[id];
	}
}

SCRIPT_EXTENSIONS.push(baseLanguage);


function baseUtil () {
	const vttesUrl = "https://justas-d.github.io/roll20-enhancement-suite/";
	let shownHardDickWarning = false;

	d20plus.ut = {};

	// d20plus.ut.WIKI_URL = "https://wiki.5e.tools"; // I'll be back ...
	d20plus.ut.WIKI_URL = "https://web.archive.org/web/20210826155610/https://wiki.5e.tools";

	d20plus.ut.log = (...args) => {
		// eslint-disable-next-line no-console
		console.log("%cD20Plus > ", "color: #3076b9; font-size: large", ...args);
		$("#boring-progress").html(`<span>&gt;</span>${args.join(" ").toLocaleLowerCase()}`);
	};

	d20plus.ut.error = (...args) => {
		// eslint-disable-next-line no-console
		console.error("%cD20Plus > ", "color: #b93032; font-size: large", ...args);
	}; // RB20 EXCLUDE START

	d20plus.ut.localize = (str, substitutes) => {
		if (substitutes) {
			output = `${d20plus.ln.default[str]}`;
			for (const needle in substitutes) {
				output = output.replace(`$${needle}`, substitutes[needle]);
			}
			return output;
		} else if (d20plus.ln.default[str]) {
			return d20plus.ln.default[str];
		} else {
			return str;
		}
	}

	window.__ = d20plus.ut.localize;

	d20plus.ut.selectLocale = () => {
		const lan = (typeof LANGUAGE !== "undefined" ? LANGUAGE : "en");
		if ((lan === "en") || (!d20plus.ln[lan])) return;
		for (const id in d20plus.ln.en) {
			if (d20plus.ln[lan][id]) {
				d20plus.ln.default[id][0] = d20plus.ln[lan][id][0];
			}
		}
	} // RB20 EXCLUDE END

	d20plus.ut.chatLog = (arg) => {
		d20.textchat.incoming(
			false,
			{
				who: "betteR20",
				type: "general",
				content: (arg || "").toString(),
				playerid: window.currentPlayer.id,
				id: d20plus.ut.generateRowId(),
				target: window.currentPlayer.id,
				avatar: "https://i.imgur.com/bBhudno.png",
			},
		);
	};

	d20plus.ut.ascSort = (a, b) => {
		if (b === a) return 0;
		return b < a ? 1 : -1;
	};

	d20plus.ut.fix3dDice = () => {
		Object.defineProperty(Array.prototype, "filter", {
			enumerable: false,
			value: Array.prototype.filter,
		});

		Object.defineProperty(Array.prototype, "map", {
			enumerable: false,
			value: Array.prototype.map,
		});
	};

	d20plus.ut.injectCode = (object, method, injectedCode) => {
		const original = object[method].bind(object);
		object[method] = (...initParams) => {
			return injectedCode.bind(object)(original, initParams);
		}
	}// RB20 EXCLUDE START

	d20plus.ut.interceptCode = (object, method, injectedCode) => {
		const original = object[method].bind(object);
		object[method] = (...initParams) => {
			const passParams = injectedCode(initParams);
			return original.apply(original, initParams);
		}
	}// RB20 EXCLUDE END

	d20plus.ut.checkVersion = () => { // RB20 EXCLUDE START
		d20plus.ut.plantVersionInfo();// RB20 EXCLUDE END
		d20plus.ut.log("Checking current version");

		const isStreamer = !!d20plus.cfg.get("chat", "streamerChatTag");
		const scriptName = isStreamer ? "Script" : "betteR20";
		$.ajax({
			url: `https://raw.githubusercontent.com/redweller/betterR20/run/betteR20-version`,
			success: (data) => {
				if (data) {
					const curr = d20plus.version;
					const avail = data;
					const cmp = d20plus.ut.cmpVersions(curr, avail);
					if (cmp < 0) {
						setTimeout(() => {
							if (!isStreamer) {
								const rawToolsInstallUrl = "https://github.com/redweller/betterR20/raw/run/betteR20-5etools.user.js";
								const rawCoreInstallUrl = "https://github.com/redweller/betterR20/raw/run/betteR20-core.user.js";
								d20plus.ut.sendHackerChat(__("msg_b20_version", [scriptName, avail, rawToolsInstallUrl, rawCoreInstallUrl]));
							} else {
								d20plus.ut.sendHackerChat(__("msg_b20_version_stream", [scriptName]));
							}
						}, 1000);
					}
				}
			},
			error: () => {
				d20plus.ut.log("Failed to check version");
			},
		})
	};

	d20plus.ut.showHardDickMessage = (scriptName) => {
		if (shownHardDickWarning) return;
		shownHardDickWarning = true;

		d20plus.ut.sendHackerChat(`
			${scriptName} needs VTT Enhancement Suite! Please install it from <a href="${vttesUrl}">here</a>.
			<br>
		`, true);
	};

	d20plus.ut.chatTag = () => {
		const legacyStyle = !!d20plus.cfg.getOrDefault("chat", "legacySystemMessagesStyle");
		const showWelcome = !!d20plus.cfg.getOrDefault("chat", "showWelcomeMessage");
		const isStreamer = !!d20plus.cfg.get("chat", "streamerChatTag");
		const classname = !legacyStyle ? "userscript-b20intro" : "userscript-hackerintro";
		const scriptName = isStreamer ? "Script" : d20plus.scriptName;
		const data = [
			d20plus.scriptName,
			window.r20es?.hooks?.welcomeScreen?.config?.previousVersion,
			d20plus.ut.WIKI_URL,
		];
		const welcomeTemplate = (b20v, vttv, faq) => `
			<div class="${classname}">
				<img src="" class="userscript-b20img" style="content: unset; width:30px;position: relative;top: 10px;float: right;">
				<h1 style="display: inline-block;line-height: 25px;margin-top: 5px; font-size: 22px;">
					betteR20 
					<span style=" font-size: 13px ; font-weight: normal">by 5etools</span>
					<p style="font-size: 11px;line-height: 15px;font-family: monospace;color: rgb(32, 194, 14);">${__("msg_welcome_versions", [b20v, vttv])}</p>
				</h1>
				<p>${__("msg_welcome_faq", [faq])} <a href="https://discord.gg/nGvRCDs"><strong>Discord</strong></a>.</p>
				<span title="${__("msg_welcome_sarcasm")}">
					<p>${__("msg_welcome_p1")}</p>
					<p>${__("msg_welcome_p2")}</p>
				</span>
			</div>
		`;
		const $boringProgress = $("#boring-progress");
		if (showWelcome) {
			if (!isStreamer) {
				d20plus.ut.sendHackerChat(welcomeTemplate(...data));
			} else {
				d20plus.ut.sendHackerChat(__("msg_b20_vtte_init", [scriptName]));
			}
		}
		if (window.enhancementSuiteEnabled) {
			$boringProgress.before(`<span><span>&gt;</span>vtt enhancement suite detected</span>`)
		} else {
			d20plus.ut.showHardDickMessage(scriptName);
		}
		$boringProgress
			.before(`<span><span>&gt;</span>all systems operational</span>`)
			.html("");// RB20 EXCLUDE START
		/* if (d20plus.cfg.getOrDefault("chat", "resizeSidebarElements")) {
			$("#rightsidebar").on("mouseout", d20plus.ut.resizeSidebar);
			$("body").on("mouseup", d20plus.ut.resizeSidebar);
			d20plus.ut.resizeSidebar("startup");
		} */ // RB20 EXCLUDE END
		setTimeout(() => {
			const $bored = $(`.boring-chat`);
			$bored.css("height", "0px");
			setTimeout(() => {
				$bored.remove();
				clearInterval(d20plus.ut.cursor);
			}, 2000);
		}, 6000);
	};

	d20plus.ut.showInitMessage = () => {
		const consTemplate = `<div class="boring-chat">
			<span><span>&gt;</span>initializing, please wait...</span>
			<span id="boring-progress"><span>&gt;</span>loading data</span>
			<span id="boring-cursor"><span>&gt;</span><aside>|</aside></span>
			<style type="text/css">
			.boring-chat {
				font-family: Menlo, Monaco, Consolas, monospace;
				font-size: small;
				background: black;
				display: inline-block;
				font-weight: bold;
				color: rgb(32, 194, 14);
				width: 100%;
				position: sticky;
				z-index: 1000;
				top: 0px;
				height: 110px;
				transition: height 2s;
				overflow: hidden;
				border-bottom: 1px solid rgb(32, 194, 14);
			}
			.boring-chat > span {
				display: block; white-space: nowrap;
				padding: 0px 5px 0px 45px;
			}
			.boring-chat > span > span {
				float: left; margin-left: -39px;
			}
			</style>
		</div>`;
		$(`#textchat`).prepend(consTemplate);
		let blink = false;
		const $bored = $(`.boring-chat`);
		d20plus.ut.cursor = setInterval(() => {
			$bored.append($(`.boring-cursor`));
			if (blink) $bored.find(`aside`).html("|");
			else $bored.find(`aside`).html("");
			blink = !blink;
		}, 300);
	};

	d20plus.ut.showLoadingMessage = () => {
		const isStreamer = !!d20plus.cfg?.get("chat", "streamerChatTag");
		const scriptName = isStreamer ? "Script" : d20plus.scriptName;
		const loadMsgTemplate = `<span><span>&gt;</span>loading ${d20plus.scriptName}</span>`;
		if (!isStreamer) $(".boring-chat > span:first-child").after(loadMsgTemplate);
		if (!window.enhancementSuiteEnabled) d20plus.ut.showHardDickMessage(scriptName);
		// to get rid of an uncaught error that keeps appearing on timely basis
		if (!window.DD_RUM) window.DD_RUM = {addAction: () => {} };
	}

	d20plus.ut.sendHackerChat = (message, error = false) => {
		const legacyStyle = !!d20plus.cfg.get("chat", "legacySystemMessagesStyle");
		if (!message) return;
		d20.textchat.incoming(false, ({
			who: "system",
			type: !legacyStyle && error ? "error" : "system",
			content: (legacyStyle ? `<span class="${error ? "hacker-chat-error" : "hacker-chat"}">
				${message}
			</span>` : message),
		}));
	};// RB20 EXCLUDE START

	d20plus.ut.plantVersionInfo = () => {
		const thisPlayer = d20?.Campaign.players.get(d20_player_id);
		if (!thisPlayer) return;
		if (thisPlayer.get("script")) {
			thisPlayer.set("script", null, true);
			thisPlayer.save();
		}
	}// RB20 EXCLUDE END

	d20plus.ut.generateVersionInfo = () => {
		d20plus.ut.log("Generating version info");
		const b20n = encodeURI(d20plus.scriptName.split("-")[1].split(" v")[0]);
		const b20v = encodeURI(d20plus.version);
		const vtte = encodeURI(window.r20es?.hooks?.welcomeScreen?.config?.previousVersion);
		const phdm = d20plus.ut.detectDarkModeScript();
		const date = Number(new Date());
		const info = btoa(JSON.stringify({b20n, b20v, vtte, phdm, dnd20: window.b20, date}));
		return info;
	}

	d20plus.ut.parseVersionInfo = (raw) => {
		const info = JSON.parse(decodeURI(atob(raw)));
		const time = d20plus.ut.timeAgo(info.date);
		const phdm = info.phdm ? "<br>Detected DarkMode script" : "";
		const dnd20 = info.dnd20 ? "<br>Detected Beyond20 extension" : "";
		let html = `Detected betteR20-${info.b20n} v${info.b20v}<br>Detected VTTES v${info.vtte}${phdm}${dnd20}<br>Info updated ${time}`;
		if (d20plus.ut.cmpVersions(info.b20v, d20plus.version) < 0) html += `<br>Player's betteR20 may be outdated`;
		if (d20plus.ut.cmpVersions(info.vtte, window.r20es?.hooks?.welcomeScreen?.config?.previousVersion) < 0) html += `<br>Player's VTTES may be outdated`;
		return html;
	}

	d20plus.ut.cmpVersions = (present, latest) => {
		if (!present || !latest) return 0;
		const regExStrip0 = /(\.0+)+$/;
		const segmentsA = present.replace(regExStrip0, "").split(".");
		const segmentsB = latest.replace(regExStrip0, "").split(".");
		const l = Math.min(segmentsA.length, segmentsB.length);

		for (let i = 0; i < l; i++) {
			const diff = parseInt(segmentsA[i], 10) - parseInt(segmentsB[i], 10);
			if (diff) {
				return diff;
			}
		}
		return segmentsA.length - segmentsB.length;
	}

	d20plus.ut.detectDarkModeScript = () => {
		d20plus.ut.dmscriptDetected = false;
		// Detect if player is using Roll20 Dark Theme
		// https://github.com/Pharonix/Roll20-Dark-Theme
		$("style").each((i, el) => {
			if (el.textContent.indexOf("/*New Characteristics Menu*/") >= 0) {
				d20plus.ut.dmscriptDetected = true;
				return false;
			}
		});
		return d20plus.ut.dmscriptDetected;
	}// RB20 EXCLUDE START
	/*
	d20plus.ut.resizeSidebar = (init) => {
		const $sidebar = $("#rightsidebar");
		if (init === "startup" || $sidebar.hasClass("ui-resizable-resizing")) {
			const sidebarwidth = $sidebar.width();
			const tabmenuwidth = sidebarwidth < 310 ? 299 : sidebarwidth - 11;
			let textdelta = 9;
			if (d20plus.ut.dmscriptDetected) textdelta = 6;
			$("#textchat-input").width(sidebarwidth - textdelta);
			$(".tabmenu").width(tabmenuwidth);
		}
	} */ // RB20 EXCLUDE END

	d20plus.ut.addCSS = (selectors, rules) => {
		if (!(selectors instanceof Array)) selectors = [selectors];

		selectors.forEach(selector => {
			try {
				const index = d20plus.css.sheet.cssRules.length;
				if ("insertRule" in d20plus.css.sheet) {
					d20plus.css.sheet.insertRule(`${selector}{${rules}}`, index);
				} else if ("addRule" in d20plus.css.sheet) {
					d20plus.css.sheet.addRule(selector, rules, index);
				}
			} catch (e) {
				if ((!selector && selector.startsWith("-webkit-"))) {
					// eslint-disable-next-line no-console
					console.error(`Selector was "${selector}"; rules were "${rules}"`, e);
				}
			}
		});
	};

	d20plus.ut.addAllCss = () => {
		d20plus.ut.log("Adding CSS");

		const sheetElement = document.createElement("style");
		d20plus.css.sheet = document.head.appendChild(sheetElement).sheet;

		_.each(d20plus.css.baseCssRules, function (r) {
			d20plus.ut.addCSS(r.s, r.r);
		});
		if (!window.is_gm) {
			_.each(d20plus.css.baseCssRulesPlayer, function (r) {
				d20plus.ut.addCSS(r.s, r.r);
			});
		}
		_.each(d20plus.css.cssRules, function (r) {
			d20plus.ut.addCSS(r.s, r.r);
		});
	};

	d20plus.ut.timeAgo = (ts) => {
		const difInteger = Number(new Date()) - Number(ts);
		const difMinutes = Math.ceil((difInteger - 60000) / 60000);
		const difHours = Math.ceil((difInteger - 3600000) / 3600000);
		const difDays = Math.ceil((difInteger - 86400000) / 86400000);
		if (difDays > 0) return `${difDays} ${__("d ago")}`;
		if (difHours > 0) return `${difHours} ${__("hr ago")}`;
		if (difMinutes > 0) return `${difMinutes} ${__("min ago")}`;
		return `0 ${__("min ago")}`;
	}

	d20plus.ut.getAntiCacheSuffix = () => {
		return `?${(new Date()).getTime()}`;
	};

	d20plus.ut.generateRowId = () => {
		return window.generateUUID().replace(/_/g, "Z");
	};

	d20plus.ut.randomRoll = (roll, success, error) => {
		d20.textchat.diceengine.process(roll, success, error);
	};

	d20plus.ut.getJournalFolderObj = () => {
		d20.journal.refreshJournalList();
		let journalFolder = d20.Campaign.get("journalfolder");
		if (journalFolder === "") {
			d20.journal.addFolderToFolderStructure("Characters");
			d20.journal.refreshJournalList();
			journalFolder = d20.Campaign.get("journalfolder");
		}
		return JSON.parse(journalFolder);
	}; // RB20 EXCLUDE START

	d20plus.ut.charFetchAndRetry = ({char, callback, params = []} = {}) => {
		const attribs = char?.attribs;
		if (!attribs) return true;
		if (!attribs.length) {
			if (attribs.fetching) return true;
			attribs.fetch(attribs);
			attribs.fetching = true;
			const wait = setInterval(function () {
				if (attribs.length) {
					clearInterval(wait);
					delete char.attribs.fetching;
					callback(...params);
				}
			}, 20);
			return true;
		}
	} // RB20 EXCLUDE END

	d20plus.ut.fetchCharAttribs = async (char) => {
		const attribs = char?.attribs;
		if (!attribs) return false;
		if (attribs.length) {
			return char;
		}
		if (!attribs.fetching) {
			attribs.fetch(attribs);
			attribs.fetching = true;
		}
		return new Promise(resolve => {
			let inProgress = 0;
			const wait = setInterval(() => {
				inProgress++;
				if (attribs.length) resolve(char);
				if (attribs.length || inProgress > 100) {
					resolve(false);
					clearInterval(wait);
					delete attribs.fetching;
					d20plus.ut.log(`Tried fetching ${char.attributes.name}`);
				}
			}, 30);
		});
	}

	d20plus.ut._lastInput = null;
	d20plus.ut.getNumberRange = (promptText, min, max) => {
		function alertInvalid () {
			alert("Please enter a valid range.");
		}

		function isOutOfRange (num) {
			return num < min || num > max;
		}

		function addToRangeVal (range, num) {
			range.add(num);
		}

		function addToRangeLoHi (range, lo, hi) {
			for (let i = lo; i <= hi; ++i) {
				range.add(i);
			}
		}

		function alertOutOfRange () {
			alert(`Please enter numbers in the range ${min}-${max} (inclusive).`);
		}

		while (true) {
			const res = prompt(promptText, d20plus.ut._lastInput || "E.g. 1-5, 8, 11-13");
			if (res && res.trim()) {
				d20plus.ut._lastInput = res;
				const clean = res.replace(/\s*/g, "");
				if (/^((\d+-\d+|\d+),)*(\d+-\d+|\d+)$/.exec(clean)) {
					const parts = clean.split(",");
					const out = new Set();
					let failed = false;

					for (const part of parts) {
						if (part.includes("-")) {
							const spl = part.split("-");
							const numLo = Number(spl[0]);
							const numHi = Number(spl[1]);

							if (isNaN(numLo) || isNaN(numHi) || numLo === 0 || numHi === 0 || numLo > numHi) {
								alertInvalid();
								failed = true;
								break;
							}

							if (isOutOfRange(numLo) || isOutOfRange(numHi)) {
								alertOutOfRange();
								failed = true;
								break;
							}

							if (numLo === numHi) {
								addToRangeVal(out, numLo);
							} else {
								addToRangeLoHi(out, numLo, numHi);
							}
						} else {
							const num = Number(part);
							if (isNaN(num) || num === 0) {
								alertInvalid();
								failed = true;
								break;
							} else {
								if (isOutOfRange(num)) {
									alertOutOfRange();
									failed = true;
									break;
								}
								addToRangeVal(out, num);
							}
						}
					}

					if (!failed) {
						d20plus.ut._lastInput = null;
						return out;
					}
				} else {
					alertInvalid();
				}
			} else {
				d20plus.ut._lastInput = null;
				return null;
			}
		}
	};

	d20plus.ut.getPathById = (pathId) => {
		return d20plus.ut._getCanvasElementById(pathId, "thepaths");
	};

	d20plus.ut.getTokenById = (tokenId) => {
		return d20plus.ut._getCanvasElementById(tokenId, "thegraphics");
	};

	d20plus.ut.getAccountById = (playerId) => {
		return d20.Campaign.players.get(playerId)?.attributes?.d20userid;
	};

	d20plus.ut.getPlayerNameById = (playerId) => {
		return d20.Campaign.players.get(playerId)?.attributes?.displayname;
	};

	d20plus.ut._getCanvasElementById = (id, prop) => {
		const found = d20.Campaign.pages.models.find(model => model[prop]?.get(id));
		return found ? found[prop].get(id) : null;
	};

	d20plus.ut.getMacroByName = (macroName) => {
		const macros = d20.Campaign.players.map(p => p.macros.find(m => m.get("name") === macroName && (p.id === window.currentPlayer.id || m.visibleToCurrentPlayer())))
			.filter(Boolean);
		if (macros.length) {
			return macros[0];
		}
		return null;
	};

	d20plus.ut.getCharacter = (charRef) => {
		if (charRef === "selected") return d20.engine.selected()[0]?.model?.character;
		const characters = d20.Campaign.characters;
		if (charRef.id) return characters._byId[charRef.id];
		return characters._byId[charRef]
			|| characters.models.find(char => char.attributes.name === charRef);
	}

	d20plus.ut.getCharAttribByName = (char, attribName) => {
		return char.attribs?.models?.find(prop => prop?.attributes?.name === attribName);
	};

	d20plus.ut.getCharAbilityByName = (char, abilbName) => {
		return char.abilities?.models?.find(prop => prop?.attributes?.name === abilbName);
	};

	d20plus.ut.getCharMetaAttribByName = (char, attribNamePart, caseInsensitive) => {
		const extract = /^repeating_(?:attack|inventory|proficiencies|resource|spell_(?:\d?|cantrip)|traits)_[^_]*(?:_resource_(?:right|left)|)/;
		const toFind = caseInsensitive ? attribNamePart.toLowerCase() : attribNamePart;
		const metaAttrib = {_ref: {}};
		char.attribs?.models.forEach(prop => {
			const find = caseInsensitive
				? prop.attributes?.name.toLowerCase().includes(toFind)
				: prop.attributes?.name.includes(toFind);
			if (!find) return;
			metaAttrib._ref._id = metaAttrib._ref._id
				|| prop.attributes.name.match(extract)?.last()
				|| attribNamePart;
			const attribName = prop.attributes.name.replace(metaAttrib._ref._id, "").slice(1);
			metaAttrib[attribName || "current"] = prop.attributes.current;
			metaAttrib._ref[attribName || "current"] = prop;
			if (prop.attributes.max) {
				metaAttrib[`${attribName}max`] = prop.attributes.max;
				metaAttrib._ref[`${attribName}max`] = prop;
			}
		});
		if (Object.entries(metaAttrib).length > 1) return metaAttrib;
	}

	d20plus.ut.getActionTmpl = (template) => {
		const res = {noDice: template};
		const getIndex = () => {
			const index = res.path[2]?.slice(1);
			if (!res.path[2] || res.path[2][0] !== "$" || isNaN(index)) return;
			const repquery = ["_reporder"].concat(res.path.slice(0, 2)).join("_");
			const reporder = d20plus.ut.getCharAttribByName(res.char, repquery)?.attributes.current;
			if (reporder) {
				res.path[2] = reporder.split(",")[index];
			} else {
				const reporder = res.char.attribs?.models?.filter(prop => {
					const check = prop?.attributes?.name.split("_");
					return check[1] === res.path[1] && check.last() === "name";
				}).map(prop => prop.attributes.name.split("_")[2]);
				res.path[2] = reporder[index] || res.path[2];
			}
		}
		const getRoll = (tmpl) => `${tmpl}`.replace(/@\{(?<attr>\w*)\}/g, (...group) => {
			const prop = group.last().attr;
			const subAttr = res.action[prop];
			const preserveRef = ["_mod", "d20", "npc_name_flag"].some(ref => prop.includes(ref));
			const preloadRef = prop === "show_desc"
				? res.action.description || ""
				: d20plus.ut.getCharAttribByName(res.char, prop)?.attributes.current;
			d20plus.ut.log("--REPLACING", group[0], " FOR ", (subAttr !== undefined ? getRoll(subAttr) : preloadRef) || (preserveRef ? `@{${prop}}` : ""))
			return (subAttr !== undefined ? getRoll(subAttr) : preloadRef) || (preserveRef ? `@{${prop}}` : "");
		}).replace("repeating_attack_spelldesc_link", () => {
			return [`${res.char.id}|`, "repeating_attack_", res.path[2], "_spelldesc_link"].join("");
		});
		const getTemplate = (template) => {
			const [charRef, actionId] = template.slice(2, -1).split("|");
			if (!charRef || !actionId) return;
			res.char = res.char || d20plus.ut.getCharacter(charRef);
			res.path = actionId?.split("_");
			getIndex();
			d20plus.ut.log("Evaluating template", charRef, actionId);
			if (["link", "output"].includes(res.path.last())) {
				return;
			}
			if (res.path[0] !== "repeating") {
				const abil = d20plus.ut.getCharAbilityByName(res.char, actionId)?.attributes.action;
				if (abil && abil.includes("template:")) res.tmpl = abil;
				else if (abil) getTemplate(abil);
			} else if (res.path[1].includes("spell-")) {
				const spellname = res.path.slice(0, 3).join("_");
				res.action = d20plus.ut.getCharMetaAttribByName(res.char, spellname);
				const spell = res.action?.rollcontent;
				if (spell && spell.includes("template:")) res.tmpl = getRoll(spell);
				else if (spell) getTemplate(spell);
			} else if (res.path[1] === "attack" || res.path[1] === "npcaction") {
				const actionId = res.path.slice(0, 3).join("_");
				res.action = d20plus.ut.getCharMetaAttribByName(res.char, actionId);
				if (res.action?.rollbase && res.action.rollbase.includes("template:")) {
					res.tmpl = getRoll(res.action.rollbase);
				}
			}
		}
		getTemplate(template);
		res.tmpl = res.tmpl
			?.replace(/@{([^|^}^{]*?)}/g, `@{${res.char.attributes.name}|$1}`);
		return res.tmpl || res.noDice;
	}

	/*
	const char = d20plus.ut.getCharacter(charRef);
	if (!char) return noDice;
	const addName = tmpl => tmpl.replace(/@{([^|^}^{]*?)}/g, `@{${char.attributes.name}|$1}`);
	const abil = d20plus.ut.getCharAbilityByName(char, actionId)?.attributes.action;
	if (abil && abil.includes("template:")) return addName(abil);
	else if (abil) actionId = abil.split("|")[1]?.split("_").slice(0, -1).join("_");
	const path = actionId.split("_");
	d20plus.ut.log("Evaluating template", abil, path)
	if (path[0] !== "repeating") return noDice;
	if (path[2][0] === "$") {
		const index = path[2].slice(1);
		const repquery = ["_reporder"].concat(path.slice(0, 2)).join("_");
		const reporder = d20plus.ut.getCharAttribByName(char, repquery)?.attributes.current;
		if (reporder) {
			path[2] = reporder.split(",")[index];
		} else {
			const reporder = char.attribs?.models?.filter(prop => {
				const path = prop?.attributes?.name.split("_");
				return path[1] === "npcaction" && path.last() === "name"
			}).map(prop => prop.attributes.name.split("_")[2]);
			path[2] = reporder[index] || path[2];
		}
	}
	if (path[1] === "npcaction") {
		actionId = path.slice(0, 3).join("_");
	} else if (path.last() === "spell") {
		const spellname = path.slice(0, -1).concat(["rollcontent"]).join("_");
		const spell = d20plus.ut.getCharAttribByName(char, spellname)?.attributes.current;
		d20plus.ut.log("Query spell", spellname, spell)
		if (spell && spell.includes("template:")) return addName(spell);
		else if (spell) actionId = spell.split("|")[1]?.split("_").slice(0, -1).join("_");
	} else if (path.last() === "attack") {
		actionId = path.slice(0, -1).join("_");
	} else return noDice;
	d20plus.ut.log("Search action", actionId)
	const attr = d20plus.ut.getCharMetaAttribByName(char, actionId);
	if (!attr?.rollbase) return noDice;
	const getRoll1 = (tmpl) => `${tmpl}`.replace(/@\{(?<attr>\w*)\}/g, (...group) => {
		const prop = group.last().attr;
		const subAttr = attr[prop];
		const preserveRef = ["_mod", "d20", "npc_name_flag"].some(ref => prop.includes(ref));
		const preloadRef = prop === "show_desc"
			? attr.description || ""
			: d20plus.ut.getCharAttribByName(char, prop)?.attributes.current;
		d20plus.ut.log("--CHECKING", prop, subAttr, preserveRef, preloadRef)
		return (subAttr !== undefined ? getRoll(subAttr) : preloadRef) || (preserveRef ? `@{${prop}}` : "");
	});
	// return getRoll(attr.rollbase); */

	d20plus.ut._BYTE_UNITS = ["kB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
	d20plus.ut.getReadableFileSizeString = (fileSizeInBytes) => {
		let i = -1;
		do {
			fileSizeInBytes = fileSizeInBytes / 1024;
			i++;
		} while (fileSizeInBytes > 1024);
		return Math.max(fileSizeInBytes, 0.1).toFixed(1) + d20plus.ut._BYTE_UNITS[i];
	};

	d20plus.ut.sanitizeFilename = function (str) {
		return str.trim().replace(/[^-\w]/g, "_");
	};// RB20 EXCLUDE START

	d20plus.ut.transliterate = (word) => {
		const a = {"Ё": "YO", "Й": "I", "Ц": "TS", "У": "U", "К": "K", "Е": "E", "Н": "N", "Г": "G", "Ш": "SH", "Щ": "SCH", "З": "Z", "Х": "H", "Ъ": "'", "ё": "yo", "й": "i", "ц": "ts", "у": "u", "к": "k", "е": "e", "н": "n", "г": "g", "ш": "sh", "щ": "sch", "з": "z", "х": "h", "ъ": "'", "Ф": "F", "Ы": "I", "В": "V", "А": "А", "П": "P", "Р": "R", "О": "O", "Л": "L", "Д": "D", "Ж": "ZH", "Э": "E", "ф": "f", "ы": "i", "в": "v", "а": "a", "п": "p", "р": "r", "о": "o", "л": "l", "д": "d", "ж": "zh", "э": "e", "Я": "Ya", "Ч": "CH", "С": "S", "М": "M", "И": "I", "Т": "T", "Ь": "'", "Б": "B", "Ю": "YU", "я": "ya", "ч": "ch", "с": "s", "м": "m", "и": "i", "т": "t", "ь": "'", "б": "b", "ю": "yu"};
		if (!word.split) return "";
		return word.split("").map(function (char) {
			return a[char] || char;
		}).join("");
	}// RB20 EXCLUDE END

	d20plus.ut.saveAsJson = function (filename, data) {
		const blob = new Blob([JSON.stringify(data, null, "\t")], {type: "application/json"});
		d20plus.ut.saveAs(blob, `${filename}.json`);
	};

	// based on:
	/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/src/FileSaver.js */
	d20plus.ut.saveAs = (function () {
		const view = window;
		let
			doc = view.document;
			// only get URL when necessary in case Blob.js hasn't overridden it yet
		let get_URL = function () {
			return view.URL || view.webkitURL || view;
		};
		let save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a");
		let can_use_save_link = "download" in save_link;
		let click = function (node) {
			let event = new MouseEvent("click");
			node.dispatchEvent(event);
		};
		let is_safari = /constructor/i.test(view.HTMLElement) || view.safari;
		let is_chrome_ios = /CriOS\/[\d]+/.test(navigator.userAgent);
		let setImmediate = view.setImmediate || view.setTimeout;
		let throw_outside = function (ex) {
			setImmediate(function () {
				throw ex;
			}, 0);
		};
		let force_saveable_type = "application/octet-stream";
		// the Blob API is fundamentally broken as there is no "downloadfinished" event to subscribe to
		let arbitrary_revoke_timeout = 1000 * 40; // in ms
		let revoke = function (file) {
			let revoker = function () {
				if (typeof file === "string") { // file is an object URL
					get_URL().revokeObjectURL(file);
				} else { // file is a File
					file.remove();
				}
			};
			setTimeout(revoker, arbitrary_revoke_timeout);
		};
		let dispatch = function (filesaver, event_types, event) {
			event_types = [].concat(event_types);
			let i = event_types.length;
			while (i--) {
				let listener = filesaver[`on${event_types[i]}`];
				if (typeof listener === "function") {
					try {
						listener.call(filesaver, event || filesaver);
					} catch (ex) {
						throw_outside(ex);
					}
				}
			}
		};
		let auto_bom = function (blob) {
			// prepend BOM for UTF-8 XML and text/* types (including HTML)
			// note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF
			if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
				return new Blob([String.fromCharCode(0xFEFF), blob], {type: blob.type});
			}
			return blob;
		};
		let FileSaver = function (blob, name, no_auto_bom) {
			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			// First try a.download, then web filesystem, then object URLs
			let
				filesaver = this;
			let type = blob.type;
			let force = type === force_saveable_type;
			let object_url;
			let dispatch_all = function () {
				dispatch(filesaver, "writestart progress write writeend".split(" "));
			};
			// on any filesys errors revert to saving with object URLs
			let fs_error = function () {
				if ((is_chrome_ios || (force && is_safari)) && view.FileReader) {
					// Safari doesn't allow downloading of blob urls
					let reader = new FileReader();
					reader.onloadend = function () {
						let url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, "data:attachment/file;");
						let popup = view.open(url, "_blank");
						if (!popup) view.location.href = url;
						url = undefined; // release reference before dispatching
						filesaver.readyState = filesaver.DONE;
						dispatch_all();
					};
					reader.readAsDataURL(blob);
					filesaver.readyState = filesaver.INIT;
					return;
				}
				// don't create more object URLs than needed
				if (!object_url) {
					object_url = get_URL().createObjectURL(blob);
				}
				if (force) {
					view.location.href = object_url;
				} else {
					let opened = view.open(object_url, "_blank");
					if (!opened) {
						// Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html
						view.location.href = object_url;
					}
				}
				filesaver.readyState = filesaver.DONE;
				dispatch_all();
				revoke(object_url);
			};
			filesaver.readyState = filesaver.INIT;

			if (can_use_save_link) {
				object_url = get_URL().createObjectURL(blob);
				setImmediate(function () {
					save_link.href = object_url;
					save_link.download = name;
					click(save_link);
					dispatch_all();
					revoke(object_url);
					filesaver.readyState = filesaver.DONE;
				}, 0);
				return;
			}

			fs_error();
		};
		let FS_proto = FileSaver.prototype;
		let saveAs = function (blob, name, no_auto_bom) {
			return new FileSaver(blob, name || blob.name || "download", no_auto_bom);
		};
		// IE 10+ (native saveAs)
		if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
			return function (blob, name, no_auto_bom) {
				name = name || blob.name || "download";

				if (!no_auto_bom) {
					blob = auto_bom(blob);
				}
				return navigator.msSaveOrOpenBlob(blob, name);
			};
		}
		FS_proto.abort = function () {};
		FS_proto.readyState = FS_proto.INIT = 0;
		FS_proto.WRITING = 1;
		FS_proto.DONE = 2;
		FS_proto.error =
			FS_proto.onwritestart =
				FS_proto.onprogress =
					FS_proto.onwrite =
						FS_proto.onabort =
							FS_proto.onerror =
								FS_proto.onwriteend =
									null;

		return saveAs;
	}());

	d20plus.ut.promiseDelay = function (delay) {
		return new Promise(resolve => {
			setTimeout(() => resolve(), delay);
		})
	};

	d20plus.ut.LAYERS = ["map", "floors", "background", "objects", "roofs", "foreground", "gmlayer", "walls", "weather"];
	d20plus.ut.layerToName = (l) => {
		switch (l) {
			case "map": return "Map";
			case "floors": return "Floors";
			case "background": return "Background";
			case "objects": return "Objects & Tokens";
			case "roofs": return "Roofs";
			case "foreground": return "Foreground";
			case "gmlayer": return "GM Info Overlay";
			case "walls": return "Dynamic Lighting";
			case "weather": return "Weather Exclusions";
		}
	};

	d20plus.ut.get$SelValue = ($sel) => {
		return $sel[0].options[$sel[0].selectedIndex].value;
	};

	d20plus.ut.isUseSharedJs = () => {
		return BASE_SITE_URL.includes("://5e.tools")
			|| BASE_SITE_URL.includes("://5etools.com")
			|| /:\/\/5etools-mirror-\d+\./.test(BASE_SITE_URL);
	};

	d20plus.ut.fixSidebarLayout = () => {
		$(`#textchat-input`).insertAfter(`#textchat`);
		const cached = d20.textchat.showPopout;
		d20.textchat.showPopout = function () {
			cached();
			const cached2 = d20.textchat.childWindow.onbeforeunload;
			d20.textchat.childWindow.onbeforeunload = function () {
				cached2();
				$(`#textchat-input`).insertAfter(`#textchat`);
			}
		}
	};

	d20plus.ut.dynamicStyles = (slug) => {
		if (!d20plus.css.dynamic) d20plus.css.dynamic = {};
		if (!d20plus.css.dynamic[slug]) {
			d20plus.css.dynamic[slug] = $("<style></style>").appendTo(document.body);
		}
		return d20plus.css.dynamic[slug];
	}

	/**
	* Assumes any other lists have been searched using the same term
	*/
	d20plus.ut.getSearchTermAndReset = (list, ...otherLists) => {
		let lastSearch = null;
		if (list.searched) {
			lastSearch = $(`#search`).val();
			list.search();
			otherLists.forEach(l => l.search());
		}
		list.filter();
		otherLists.forEach(l => l.filter());
		return lastSearch;
	};
}

SCRIPT_EXTENSIONS.push(baseUtil);

/*

map
afow
grid
background
objects
foreground
gmlayer
walls
weather

 */


function baseJsLoad () {
	d20plus.js = {};

	d20plus.js.scripts = [
		// {name: "listjs", url: "https://raw.githubusercontent.com/javve/list.js/v1.5.0/dist/list.min.js"},
		// {name: "localforage", url: "https://raw.githubusercontent.com/localForage/localForage/1.7.3/dist/localforage.min.js"},
		// {name: "JSZip", url: `https://raw.githubusercontent.com/Stuk/jszip/master/dist/jszip.min.js`},
	];

	if (d20plus.ut.isUseSharedJs()) {
		// d20plus.js.scripts.push({name: "5etoolsShared", url: `${SITE_JS_URL}shared.js`});
	} else {
		// d20plus.js.scripts.push({name: "5etoolsParser", url: `${SITE_JS_URL}parser.js`});
		// d20plus.js.scripts.push({name: "5etoolsUtils", url: `${SITE_JS_URL}utils.js`});
	}

	d20plus.js.apiScripts = [
		// {name: "VecMath", url: "https://raw.githubusercontent.com/Roll20/roll20-api-scripts/master/Vector%20Math/1.0/VecMath.js"},
		// {name: "MatrixMath", url: "https://raw.githubusercontent.com/Roll20/roll20-api-scripts/master/MatrixMath/1.0/matrixMath.js"},
		// {name: "PathMath", url: "https://raw.githubusercontent.com/Roll20/roll20-api-scripts/master/PathMath/1.5/PathMath.js"}
	];

	d20plus.js._unpackScript = script => {
		return script.trim().split("\n").slice(1, -1).join("\n");
	};

	d20plus.js.pAddScripts = async () => {
		d20plus.ut.log("Add JS");

		EXT_LIB_SCRIPTS.forEach(script => {
			d20plus.js._addScript("???", d20plus.js._unpackScript(script));
		});

		await Promise.all(d20plus.js.scripts.map(async it => {
			const js = await d20plus.js.pLoadWithRetries(it.name, it.url);
			d20plus.js._addScript(it.name, js)
		}));

		// Monkey patch JSON loading
		const cached = DataUtil.loadJSON;
		DataUtil.loadJSON = async (url, ...others) => {
			const xUrl = new URL(url);

			const cleanPathName = xUrl.pathname.replace(/^\//, "");
			// If d20plus.debug.forceExternalRequests is set to true as a parameter, load from chosen url rather than built in data
			if (!d20plus.debug?.forceExternalRequests && JSON_DATA[cleanPathName]) {
				const out = JSON_DATA[cleanPathName];
				await DataUtil.pDoMetaMerge(cleanPathName, out);
				return out;
			}

			if (url.startsWith("data/")) {
				url = BASE_SITE_URL + url;
			}

			return cached.bind(DataUtil)(url, ...others);
		};
	};

	d20plus.js.pAddApiScripts = async () => {
		d20plus.ut.log("Add Builtin API Scripts");

		EXT_LIB_API_SCRIPTS.forEach(script => {
			d20plus.js._addScript("???", d20plus.js._unpackScript(script));
		});

		await Promise.all(d20plus.js.apiScripts.map(async it => {
			const js = await d20plus.js.pLoadWithRetries(it.name, it.url);
			d20plus.js._addScript(it.name, js);
		}));
	};

	d20plus.js._addScript = (name, js) => {
		// sanity check
		if (js instanceof Promise) throw new Error(`Promise was passed instead of text! This is a bug.`);
		try {
			// eslint-disable-next-line no-eval
			window.eval(js);
			d20plus.ut.log(`JS [${name}] Loaded`);
		} catch (e) {
			d20plus.ut.log(`Error loading [${name}]`);
			d20plus.ut.log(e);
			throw e;
		}
	};

	d20plus.js.pLoadWithRetries = async (name, url) => {
		let retries = 3;

		function pFetchData () {
			return new Promise((resolve, reject) => {
				$.ajax({
					type: "GET",
					url: `${url}${d20plus.ut.getAntiCacheSuffix()}${retries}`,
					success: function (data) {
						resolve(data);
					},
					error: function (resp, qq, pp) {
						if (resp && resp.status >= 400 && retries-- > 0) {
							// eslint-disable-next-line no-console
							console.error(resp, qq, pp);
							d20plus.ut.log(`Error loading ${name}; retrying`);
							setTimeout(() => {
								reject(new Error(`Loading "${name}" failed (status ${resp.status}): ${resp} ${qq} ${pp}`));
							}, 500);
						} else {
							// eslint-disable-next-line no-console
							console.error(resp, qq, pp);
							setTimeout(() => {
								reject(new Error(`Loading "${name}" failed (status ${resp.status}): ${resp} ${qq} ${pp}`));
							}, 500);
						}
					},
				});
			})
		}

		let data;
		do {
			try {
				data = await pFetchData();
			} catch (e) {
				// error handling is done as part of data fetching
			}
		} while (!data && --retries > 0);

		if (data) return data;
		else throw new Error(`Failed to load ${name} from URL ${url}`);
	};

	d20plus.js.pLoadJsonWithRetries = async (name, url) => {
		let retries = 3;

		let out;
		let lastErr = null;
		while (retries-- > 0) {
			try {
				out = await DataUtil.loadJSON(`${url}${d20plus.ut.getAntiCacheSuffix()}${retries}`);
			} catch (e) {
				lastErr = e;
			}

			if (lastErr && retries) {
				d20plus.ut.log(`Error loading ${name}; retrying after 100ms`);
				await MiscUtil.pDelay(100);
			}
		}

		if (!retries) {
			d20plus.ut.error(`Failed to load "${name}" (URL was: ${url} )`);
			throw lastErr;
		}

		return out;
	};
}

SCRIPT_EXTENSIONS.push(baseJsLoad);


function baseQpi () {
	const qpi = {
		_version: "0.01-pre-pre-alpha",
		_: {
			log: {
				_ (...args) {
					qpi._log(...args)
				},
				works: 1,
			},

			// Campaign: { // FIXME this overwrites the window's campaign, which breaks stuff
			// 	_ () {
			// 		return Campaign;
			// 	},
			// 	works: 0
			// },

			on: {
				_preInit () {
					qpi._on_chatHandlers = [];
					if (d20.textchat.shoutref) {
						const seenMessages = new Set();
						d20.textchat.chatref = d20.textchat.shoutref.parent.child("chat");
						const handleChat = (e) => {
							if (!d20.textchat.chatstartingup) {
								e.id = e.key;
								if (!seenMessages.has(e.id)) {
									seenMessages.add(e.id);

									let t = e.val();
									if (t) {
										// eslint-disable-next-line no-console
										if (window.DEBUG) console.log("CHAT: ", t);

										qpi._on_chatHandlers.forEach(fn => fn(t));
									}
								}
							}
						};
						d20.textchat.chatref.on("child_added", handleChat);
						d20.textchat.chatref.on("child_changed", handleChat);
					} else {
						// eslint-disable-next-line no-console
						console.warn("%cQPI > ", "color: #b93032; font-size: large", "Can't properly initialize chat handler");
					}
				},
				_ (evtType, fn, ...others) {
					switch (evtType) {
						case "chat:message":
							qpi._on_chatHandlers.push(fn);
							break;
						default:
							// eslint-disable-next-line no-console
							console.error("Unhandled message type: ", evtType, "with args", fn, others)
							break;
					}
				},
				works: 0.01,
				notes: [
					`"chat:message" is the only available event.`,
				],
			},

			createObj: {
				_ (objType, obj, ...others) {
					switch (objType) {
						case "path": {
							const page = d20.Campaign.pages._byId[obj._pageid];
							obj.scaleX = obj.scaleX || 1;
							obj.scaleY = obj.scaleY || 1;
							obj.path = obj.path || obj._path
							return page.thepaths.create(obj)
						}
						default:
							// eslint-disable-next-line no-console
							console.error("Unhandled object type: ", objType, "with args", obj, others)
							break;
					}
				},
				works: 0.01,
				notes: [
					`Only supports "path" obects.`,
				],
			},

			sendChat: { // TODO lift code from doChatInput
				_ (speakingAs, input, callback, options) {
					const message = {
						who: speakingAs,
						type: "general",
						content: input,
						playerid: window.currentPlayer.id,
						avatar: null,
						inlinerolls: [],
					};

					const key = d20.textchat.chatref.push().key;
					d20.textchat.chatref.child(key).setWithPriority(message, Firebase.ServerValue.TIMESTAMP)
				},
				works: 0.01,
				notes: [
					`speakingAs: String only.`,
					`input: String only.`,
					`callback: Unimplemented.`,
					`options: Unimplemented.`,
					`Messages are always sent with the player ID of the QPI user.`,
				],
			},

			// findObjs: {
			// 	_ (attrs) {
			// 		// TODO
			// 		// const getters = {
			// 		// 	attribute: () => {},
			// 		// 	character: () => {},
			// 		// 	handout: () => {}
			// 		// };
			// 		// const getAll = () => {
			// 		// 	const out = [];
			// 		// 	Object.values(getters).forEach(fn => out.push(...fn()));
			// 		// 	return out;
			// 		// };
			//
			// 		// let out = attrs._type ? getters[attrs._type]() : getAll();
			//
			// 		throw new Error("findObjs is unimplemented!");
			// 	},
			// 	works: 0.00,
			// 	notes: [
			// 		`Unimplemented.`
			// 	]
			// }
		},

		_loadedScripts: null,
		async _init () {
			Object.keys(qpi._).forEach(k => {
				const it = qpi._[k];
				if (it._preInit) it._preInit();
				window[k] = it._;
			});

			qpi._loadedScripts = await StorageUtil.pGet("VeQpi") || {};

			$(`body`).append(`
				<div id="qpi-manager" title="Better20 - QPI Script Manager - v${qpi._version}">
					<div class="qpi-table"></div>
					<div>
						<input placeholder="URL*" class="qpi-url">
						<button class="btn qpi-add-url">Add URL</button>
					</div>
					<hr>
					<div>
						<input placeholder="Name*" class="qpi-name">
						<button class="btn qpi-add-text">Load Script</button>
						<br>
						<textarea class="qpi-text" style="width: 100%; height: 300px; resize: vertical;"></textarea>
					</div>
					<hr>
					<button class="btn qpi-help">Help/README</button> <i>Note that this tool is a for-testing faceplate over some internal code. It is intended for internal use only.</i>
				</div>
			`);
			$(`#qpi-manager`).dialog({
				autoOpen: false,
				resizable: true,
				width: 800,
				height: 600,
			});

			$(`body`).append(`
				<div id="qpi-manager-readme" title="QPI README - v${qpi._version}">
					<div class="qpi-readme"></div>
				</div>
			`);
			$(`#qpi-manager-readme`).dialog({
				autoOpen: false,
				resizable: true,
				width: 800,
				height: 600,
			});

			qpi._log("Initialised!");
		},

		man (name) {
			if (!name) {
				qpi._log(`Showing all...\n==== Available API Mimics ====\n  - ${Object.keys(qpi._).join("()\n  - ")}()`);
				return;
			}

			const found = Object.keys(qpi._).find(k => k === name);
			if (!found) qpi._log(`No mimic with ${name} found -- perhaps it's unimplemented?`);
			else {
				const it = qpi._[found];
				qpi._log(`Showing "${name}"...\n==== ${name} :: ${it.works * 100}% functional ====\n${(it.notes || []).join("\n")}`);
			}
		},

		_manHtml () {
			let stack = "";
			Object.keys(qpi._).forEach(k => {
				stack += `<h5>${k}</h5>`;
				const it = qpi._[k];
				stack += `<p><i>Estimated ${it.works * 100}% functional</i><br>${(it.notes || []).join("<br>")}</p>`;
			});
			return stack;
		},

		_openManager () {
			const $win = $(`#qpi-manager`);

			$win.find(`.qpi-help`).off("click").on("click", () => {
				const $winReadme = $(`#qpi-manager-readme`);
				$winReadme.dialog("open");

				$winReadme.find(`.qpi-readme`).html(qpi._manHtml());
			});

			$win.find(`.qpi-add-url`).off("click").on("click", () => {
				const url = $win.find(`.qpi-url`).val();
				if (url && script.trim()) {
					qpi._log(`Attempting to load: "${url}"`);
					d20plus.js.pLoadWithRetries(
						url,
						url,
					).then(data => {
						d20plus.js._addScript(url, data).then(() => {
							alert("Loaded successfully!");
							$win.find(`.qpi-url`).val("");
						}).catch(() => {
							alert(`Failed to load script! ${VeCt.STR_SEE_CONSOLE}`);
						});
					})
				} else {
					alert("Please enter a URL!");
				}
			});

			$win.find(`.qpi-add-text`).off("click").on("click", () => {
				const name = $win.find(`.qpi-name`).val();
				const script = $win.find(`.qpi-text`).val();
				if (name && script && name.trim() && script.trim()) {
					qpi._log(`Attempting to eval user script: ${name}`);
					d20plus.js._addScript(name, script).then(() => {
						alert("Loaded successfully!");
						$win.find(`.qpi-name`).val("");
						$win.find(`.qpi-text`).val("");
					}).catch(() => {
						alert("Failed to load script! See the console for more details (CTRL-SHIFT-J on Chrome)");
					});
				} else {
					alert("Please enter a name and some code!");
				}
			});

			$win.dialog("open");
		},

		_log (...args) {
			// eslint-disable-next-line no-console
			console.log("%cQPI > ", "color: #ff00ff; font-size: large", ...args);
		},
	};
	window.qpi = qpi;

	d20plus.qpi = {};
	d20plus.qpi.pInitMockApi = async () => { // TODO check if this needs to be enabled for players too
		d20plus.ut.log("Initialising mock API");
		await qpi._init();
	};
}

SCRIPT_EXTENSIONS.push(baseQpi);


// Borrowed with <3 from Stormy's JukeboxIO
function baseJukebox () {
	d20plus.jukebox = {
		playPlaylist (playlistId) {
			$(document)
				.find(`#jukeboxfolderroot .dd-folder[data-globalfolderid="${playlistId}"]`)
				.find("> .dd-content .play[data-isplaying=false]")
				.trigger("click");
		},

		playTrack (trackId) {
			$(document)
				.find(`#jukeboxfolderroot .dd-item[data-itemid="${trackId}"]`)
				.find("> .dd-content .play[data-isplaying=false]")
				.trigger("click");
		},

		stopPlaylist (playlistId) {
			$(document)
				.find(`#jukeboxfolderroot .dd-folder[data-globalfolderid="${playlistId}"]`)
				.find("> .dd-content .play[data-isplaying=true]")
				.trigger("click");
		},

		stopTrack (trackId) {
			$(document)
				.find(`#jukeboxfolderroot .dd-item[data-itemid="${trackId}"]`)
				.find("> .dd-content .play[data-isplaying=true]")
				.trigger("click");
		},

		play (id) {
			d20plus.jukebox.playPlaylist(id);
			d20plus.jukebox.playTrack(id);
		},

		stop (id) {
			d20plus.jukebox.stopPlaylist(id);
			d20plus.jukebox.stopTrack(id);
		},

		stopAll () {
			d20.jukebox.stopAllTracks();
		},

		skip () {
			const playlistId = d20plus.jukebox.getCurrentPlayingPlaylist();
			d20.jukebox.stopAllTracks();
			d20plus.jukebox.playPlaylist(playlistId);
		},

		getCurrentPlayingTracks () {
			let playlingTracks = [];
			window.Jukebox.playlist.each((track) => {
				if (track.get("playing")) {
					playlingTracks.push(track.attributes);
				}
			});
			return playlingTracks;
		},

		getCurrentPlayingPlaylist () {
			const id = d20.Campaign.attributes.jukeboxplaylistplaying;
			return id ? id.split("|")[0] : id;
		},

		addJukeboxChangeHandler (func) {
			d20plus.jukebox.addPlaylistChangeHandler(func);
			d20plus.jukebox.addTrackChangeHandler(func);
		},

		addPlaylistChangeHandler (func) {
			d20.Campaign.on("change:jukeboxplaylistplaying change:jukeboxfolder", func);
		},

		addTrackChangeHandler (func) {
			window.Jukebox.playlist.each((track) => {
				track.on("change:playing", func);
			});
		},

		getJukeboxFileStructure () {
			d20plus.jukebox.forceJukeboxRefresh();
			return window.d20.jukebox.lastFolderStructure;
		},

		getTrackById (id) {
			return window.Jukebox.playlist.get(id);
		},

		getJukeboxPlaylists () {
			const fs = d20plus.jukebox.getJukeboxFileStructure();
			const retVals = [];

			for (const fsItem of fs) {
				if (typeof (fsItem) === "string") continue;

				const rawPlaylist = fsItem;

				const playlist = {
					name: rawPlaylist.n,
					mode: rawPlaylist.s,
					tracks: [],
				};

				for (const trackId of rawPlaylist.i) {
					const track = d20plus.jukebox.getTrackById(trackId);
					if (!track) {
						// eslint-disable-next-line no-console
						console.warn(`Tried to get track id ${trackId} but the query returned a falsy value. Skipping`);
						continue;
					}

					playlist.tracks.push(track);
				}

				retVals.push(playlist);
			}

			return retVals;
		},

		getJukeboxTracks () {
			const fs = d20plus.jukebox.getJukeboxFileStructure();

			const retVals = [];

			for (const fsItem of fs) {
				if (typeof (fsItem) !== "string") continue;

				const track = d20plus.jukebox.getTrackById(fsItem);
				if (!track) {
					// eslint-disable-next-line no-console
					console.warn(`Tried to get track id ${fsItem} but the query returned a falsy value. Skipping`);
					continue;
				}

				retVals.push(track);
			}

			return retVals;
		},

		_getExportableTrack (s) {
			return {
				loop: s.attributes.loop,
				playing: s.attributes.playing,
				softstop: s.attributes.softstop,
				source: s.attributes.source,
				tags: s.attributes.tags,
				title: s.attributes.title,
				track_id: s.attributes.track_id,
				volume: s.attributes.volume,
			};
		},

		getExportablePlaylists () {
			return d20plus.jukebox.getJukeboxPlaylists().map(p => {
				return {
					name: p.name,
					mode: p.mode,
					tracks: p.tracks.map(d20plus.jukebox._getExportableTrack),
				};
			});
		},

		getExportableTracks () {
			return d20plus.jukebox.getJukeboxTracks().map(d20plus.jukebox._getExportableTrack);
		},

		importWrappedData (data) {
			d20plus.jukebox.forceJukeboxRefresh();

			const tracks = (data.tracks || []).map(t => d20plus.jukebox.createTrack(t).id);

			const playlists = (data.playlists || []).map(p => {
				const trackIds = p.tracks.map(s => d20plus.jukebox.createTrack(s).id);
				return d20plus.jukebox.makePlaylistStructure(p.name, p.mode, trackIds);
			});

			let fs = JSON.parse(d20.Campaign.attributes.jukeboxfolder);
			fs = fs.concat(tracks, playlists);

			d20.Campaign.save({
				jukeboxfolder: JSON.stringify(fs),
			});
		},

		createTrack (data) {
			return window.Jukebox.playlist.create(data);
		},

		makePlaylistStructure (name, mode, trackIds) {
			return {
				id: window.generateUUID(),
				n: name,
				s: mode,
				i: trackIds || [],
			};
		},

		forceJukeboxRefresh () {
			const $jukebox = $("#jukebox");
			const serializable = $jukebox.find("#jukeboxfolderroot").nestable("serialize");
			serializable && d20.Campaign.save({
				jukeboxfolder: JSON.stringify(serializable),
			});
		},
	};
}

SCRIPT_EXTENSIONS.push(baseJukebox);


function baseMath () {
	d20plus.math = {
		vec2: {
			/**
			 * Normalize a 2d vector.
			 * @param out Result storage
			 * @param a Vector to normalise
			 */
			normalize (out, a) {
				const x = a[0];
				const y = a[1];
				let len = x * x + y * y;
				if (len > 0) {
					len = 1 / Math.sqrt(len);
					out[0] = a[0] * len;
					out[1] = a[1] * len;
				}
				return out;
			},

			/**
			 * Scale a 2d vector.
			 * @param out Resulst storage
			 * @param a Vector to scale
			 * @param b Value to scale by
			 */
			scale (out, a, b) {
				out[0] = a[0] * b;
				out[1] = a[1] * b;
				return out;
			},

			/**
			 * Rotate a 2D vector
			 * @param {vec2} out The receiving vec2
			 * @param {vec2} a The vec2 point to rotate
			 * @param {vec2} b The origin of the rotation
			 * @param {Number} c The angle of rotation
			 * @returns {vec2} out
			 */
			rotate (out, a, b, c) {
				// Translate point to the origin
				let p0 = a[0] - b[0];
				let p1 = a[1] - b[1];
				let sinC = Math.sin(c);
				let cosC = Math.cos(c);

				// perform rotation and translate to correct position
				out[0] = p0 * cosC - p1 * sinC + b[0];
				out[1] = p0 * sinC + p1 * cosC + b[1];
				return out;
			},

			/**
			 * Adds two vec2's
			 *
			 * @param {vec2} out the receiving vector
			 * @param {vec2} a the first operand
			 * @param {vec2} b the second operand
			 * @returns {vec2} out
			 */
			add (out, a, b) {
				out[0] = a[0] + b[0];
				out[1] = a[1] + b[1];
				return out;
			},

			/**
			 * Subtracts vector b from vector a
			 *
			 * @param {vec2} out the receiving vector
			 * @param {vec2} a the first operand
			 * @param {vec2} b the second operand
			 * @returns {vec2} out
			 */
			sub (out, a, b) {
				out[0] = a[0] - b[0];
				out[1] = a[1] - b[1];
				return out;
			},

			/**
			 * Computes the cross product of two vec2's
			 * Note that the cross product must by definition produce a 3D vector
			 *
			 * @param {vec3} out the receiving vector
			 * @param {vec2} a the first operand
			 * @param {vec2} b the second operand
			 * @returns {vec3} out
			 */
			cross (out, a, b) {
				let z = a[0] * b[1] - a[1] * b[0];
				out[0] = out[1] = 0;
				out[2] = z;
				return out;
			},

			/**
			 * Multiplies two vec2's
			 *
			 * @param {vec2} out the receiving vector
			 * @param {vec2} a the first operand
			 * @param {vec2} b the second operand
			 * @returns {vec2} out
			 */
			mult (out, a, b) {
				out[0] = a[0] * b[0];
				out[1] = a[1] * b[1];
				return out;
			},

			/**
			 * Calculates the length of a vec2
			 *
			 * @param {vec2} a vector to calculate length of
			 * @returns {Number} length of a
			 */
			len (a) {
				const x = a[0]; const y = a[1];
				return Math.sqrt(x * x + y * y);
			},
		},

		/**
		 * Helper function to determine whether there is an intersection between the two polygons described
		 * by the lists of vertices. Uses the Separating Axis Theorem
		 *
		 * @param a an array of connected points [[x, y], [x, y],...] that form a closed polygon
		 * @param b an array of connected points [[x, y], [x, y],...] that form a closed polygon
		 * @return boolean true if there is any intersection between the 2 polygons, false otherwise
		 */
		doPolygonsIntersect (a, b) {
			const polygons = [a, b];
			let minA, maxA, projected, i, i1, j, minB, maxB;

			for (i = 0; i < polygons.length; i++) {
				// for each polygon, look at each edge of the polygon, and determine if it separates
				// the two shapes
				const polygon = polygons[i];
				for (i1 = 0; i1 < polygon.length; i1++) {
					// grab 2 vertices to create an edge
					const i2 = (i1 + 1) % polygon.length;
					const p1 = polygon[i1];
					const p2 = polygon[i2];

					// find the line perpendicular to this edge
					const normal = [p2[1] - p1[1], p1[0] - p2[0]];

					minA = maxA = undefined;
					// for each vertex in the first shape, project it onto the line perpendicular to the edge
					// and keep track of the min and max of these values
					for (j = 0; j < a.length; j++) {
						projected = normal[0] * a[j][0] + normal[1] * a[j][1];
						if (minA === undefined || projected < minA) minA = projected;
						if (maxA === undefined || projected > maxA) maxA = projected;
					}

					// for each vertex in the second shape, project it onto the line perpendicular to the edge
					// and keep track of the min and max of these values
					minB = maxB = undefined;
					for (j = 0; j < b.length; j++) {
						projected = normal[0] * b[j][0] + normal[1] * b[j][1];
						if (minB === undefined || projected < minB) minB = projected;
						if (maxB === undefined || projected > maxB) maxB = projected;
					}

					// if there is no overlap between the projects, the edge we are looking at separates the two
					// polygons, and we know there is no overlap
					if (maxA < minB || maxB < minA) {
						return false;
					}
				}
			}
			return true;
		},
	};
}

SCRIPT_EXTENSIONS.push(baseMath);


function baseConfig () {
	d20plus.cfg = {current: {}};

	d20plus.cfg.pLoadConfigFailed = false;

	addConfigOptions("token", {
		"_name": __("cfg_tab_tokens"),
		"massRollWhisperName": {
			"name": __("cfg_option_whisper_name"),
			"default": false,
			"_type": "boolean",
		}, // RB20 EXCLUDE START
		"massRollAssumesOGL": {
			"name": __("cfg_option_assume_ogl"),
			"default": true,
			"_type": "boolean",
		}, // RB20 EXCLUDE END
	});
	addConfigOptions("canvas", {
		"_name": __("cfg_tab_canvas"),
		"_player": true,
		"gridSnap": {
			"name": __("cfg_option_grid_snap"),
			"default": "1",
			"_type": "_enum",
			"__values": ["0.25", "0.5", "1"],
			"_player": true,
		},
		"quickLayerButtons": {
			"name": __("cfg_option_layer_panel"),
			"default": true,
			"_type": "boolean",
		},
		"quickLayerButtonsPosition": {
			"name": __("cfg_option_layer_panel_position"),
			"default": 1,
			"_type": "_slider",
			"__sliderMin": 0,
			"__sliderMax": 1,
			"__sliderStep": 1,
		},
		"showFloors": {
			"name": __("cfg_option_show_fl"),
			"default": false,
			"_type": "boolean",
			"_player": false,
		},
		"showBackground": {
			"name": __("cfg_option_show_bg"),
			"default": true,
			"_type": "boolean",
			"_player": false,
		},
		"showRoofs": {
			"name": __("cfg_option_show_rf"),
			"default": false,
			"_type": "boolean",
			"_player": false,
		},
		"showForeground": {
			"name": __("cfg_option_show_fg"),
			"default": true,
			"_type": "boolean",
			"_player": false,
		},
		"showWeather": {
			"name": __("cfg_option_show_weather"),
			"default": true,
			"_type": "boolean",
			"_player": false,
		}, // RB20 EXCLUDE START
		"scaleNamesStatuses": {
			"name": __("cfg_option_scaled_names"),
			"default": false,
			"_type": "boolean",
			"_player": true,
		},
		"enableNeatMenus": {
			"name": __("cfg_option_neat_menus"),
			"default": true,
			"_type": "boolean",
		}, // RB20 EXCLUDE END
	});
	addConfigOptions("import", {
		"_name": __("cfg_tab_import"),
		"importIntervalMap": {
			"name": __("cfg_option_import_interval"),
			"default": 2500,
			"_type": "integer",
		},
	});
	addConfigOptions("interface", {
		"_name": __("cfg_tab_interface"),
		"_player": true,
		"showCustomArtPreview": {
			"name": __("cfg_option_art_previews"),
			"default": true,
			"_type": "boolean",
		},
		"toolbarOpacity": {
			"name": __("cfg_option_toolbar_opac"),
			"default": 100,
			"_player": true,
			"_type": "_slider",
			"__sliderMin": 1,
			"__sliderMax": 100,
			"__sliderStep": 1,
		},
		"hideDarkModeSwitch": {
			"name": __("cfg_option_hide_dmswitch"),
			"default": false,
			"_type": "boolean",
			"_player": true,
		},
		"hideHelpButton": {
			"name": __("cfg_option_hide_help"),
			"default": false,
			"_type": "boolean",
			"_player": true,
		}, // RB20 EXCLUDE START
		"selectJournalSearchType": {
			"name": __("cfg_option_select_jrnsearch"),
			"default": "roll20",
			"_type": "_enum",
			"__values": [
				"Roll20",
				"betteR20",
			],
		},
		"selecArtLibraryType": {
			"name": __("cfg_option_select_artlib"),
			"default": "roll20",
			"_type": "_enum",
			"__values": [
				"Roll20",
				"betteR20",
			],
		}, // RB20 EXCLUDE END
		"quickInitButtons": {
			"name": __("cfg_option_quick_init_sort"),
			"default": true,
			"_type": "boolean",
		},
		"quickInitButtonsClear": {
			"name": __("cfg_option_quick_init_clear"),
			"default": true,
			"_type": "boolean",
		},
		"minifyTracker": {
			"name": __("cfg_option_minify_tracker"),
			"default": false,
			"_type": "boolean",
			"_player": true,
		},
	});
	addConfigOptions("chat", {
		"_name": __("cfg_tab_chat"),
		"_player": true,
		"playerPortraitSize": {
			"name": __("cfg_option_player_size"),
			"default": 30,
			"_type": "_slider",
			"__sliderMin": 30,
			"__sliderMax": 250,
			"__sliderStep": 20,
			"_player": true,
		},
		"streamerChatTag": {
			"name": __("cfg_option_streamer_tags"),
			"default": false,
			"_type": "boolean",
			"_player": true,
		},
		"legacySystemMessagesStyle": {
			"name": __("cfg_option_legacy_chat"),
			"default": false,
			"_type": "boolean",
			"_player": true,
		}, // RB20 EXCLUDE START
		/* "resizeSidebarElements": {
			"name": __("cfg_option_resize_sidebar"),
			"default": false,
			"_type": "boolean",
			"_player": true,
		}, */ // RB20 EXCLUDE END
		"showWelcomeMessage": {
			"name": __("cfg_option_welcome_msg"),
			"default": true,
			"_type": "boolean",
			"_player": true,
		},
		"languages": {
			"name": __("cfg_option_languages"),
			"default": true,
			"_type": "boolean",
			"_player": true,
		},
	});

	d20plus.cfg.pLoadConfig = async () => {
		d20plus.ut.log("Reading Config");
		let configHandout = d20plus.cfg.getConfigHandout();

		if (!configHandout) {
			d20plus.ut.log("No config found! Initialising new config...");
			await d20plus.cfg.pMakeDefaultConfig();
		}

		configHandout = d20plus.cfg.getConfigHandout();
		if (configHandout) {
			configHandout.view.render();
			return new Promise(resolve => {
				configHandout._getLatestBlob("gmnotes", async function (gmnotes) {
					try {
						const decoded = decodeURIComponent(gmnotes);

						d20plus.cfg.current = JSON.parse(decoded);

						d20plus.ut.log("Config Loaded:");
						d20plus.ut.log(d20plus.cfg.current);
						resolve();
					} catch (e) {
						// eslint-disable-next-line no-console
						console.error(e);
						if (!d20plus.cfg.pLoadConfigFailed) {
							// prevent infinite loops
							d20plus.cfg.pLoadConfigFailed = true;

							d20plus.ut.log("Corrupted config! Rebuilding...");
							await d20plus.cfg.pMakeDefaultConfig();
							await d20plus.cfg.pLoadConfig();
							resolve();
						} else {
							// if the config fails, continue to load anyway
							resolve();
						}
					}
				});
			});
		} else d20plus.ut.log("Failed to create config handout!");
	};

	d20plus.cfg.pLoadPlayerConfig = async () => {
		d20plus.ut.log("Reading player Config");
		const loaded = await StorageUtil.pGet(`Veconfig`);
		if (!loaded) {
			d20plus.ut.log("No player config found! Initialising new config...");
			const dfltConfig = d20plus.cfg.getDefaultConfig();
			d20plus.cfg.current = Object.assign(d20plus.cfg.current, dfltConfig);
			await StorageUtil.pSet(`Veconfig`, d20plus.cfg.current);
		} else {
			d20plus.cfg.current = loaded;
		}
		d20plus.ut.log("Player config Loaded:");
		d20plus.ut.log(d20plus.cfg.current);
	};

	d20plus.cfg.pMakeDefaultConfig = () => {
		return new Promise(resolve => {
			d20.Campaign.handouts.create({
				name: CONFIG_HANDOUT,
				archived: true,
			}, {
				success: function (handout) {
					notecontents = "The GM notes contain config options saved between sessions. If you want to wipe your saved settings, delete this handout and reload roll20. If you want to edit your settings, click the \"Edit Config\" button in the <b>Settings</b> (cog) panel.";

					// default settings
					// token settings mimic official content; other settings as vanilla as possible
					const gmnotes = JSON.stringify(d20plus.cfg.getDefaultConfig());

					handout.updateBlobs({notes: notecontents, gmnotes: gmnotes});
					handout.save({notes: (new Date()).getTime(), inplayerjournals: ""});

					resolve();
				},
			});
		});
	};

	d20plus.cfg.getConfigHandout = () => {
		d20plus.ut.getJournalFolderObj(); // ensure journal init

		return d20.Campaign.handouts.models.find(function (handout) {
			return handout.attributes.name === CONFIG_HANDOUT;
		});
	};

	d20plus.cfg.getCfgKey = (group, val) => {
		if (val === undefined || d20plus.cfg.current[group] === undefined) return undefined;
		const gr = d20plus.cfg.current[group];
		for (const key of Object.keys(d20plus.cfg.current[group])) {
			if (gr[key] !== undefined && gr[key] === val) {
				return key;
			}
		}
		return undefined;
	};

	d20plus.cfg.getRawCfgVal = (group, key) => {
		if (d20plus.cfg.current[group] === undefined) return undefined;
		if (d20plus.cfg.current[group][key] === undefined) return undefined;
		return d20plus.cfg.current[group][key];
	};

	d20plus.cfg.get = (group, key) => {
		if (d20plus.cfg.current[group] === undefined) return undefined;
		if (d20plus.cfg.current[group][key] === undefined) return undefined;
		if (CONFIG_OPTIONS[group][key]._type === "_SHEET_ATTRIBUTE") {
			if (!NPC_SHEET_ATTRIBUTES[d20plus.cfg.current[group][key]]) return undefined;
			return NPC_SHEET_ATTRIBUTES[d20plus.cfg.current[group][key]][d20plus.sheet];
		}
		if (CONFIG_OPTIONS[group][key]._type === "_SHEET_ATTRIBUTE_PC") {
			if (!PC_SHEET_ATTRIBUTES[d20plus.cfg.current[group][key]]) return undefined;
			return PC_SHEET_ATTRIBUTES[d20plus.cfg.current[group][key]][d20plus.sheet];
		}
		return d20plus.cfg.current[group][key];
	};

	d20plus.cfg.getDefault = (group, key) => {
		return d20plus.cfg._getProp("default", group, key);
	};

	d20plus.cfg.getPlaceholder = (group, key) => {
		return d20plus.cfg._getProp("_placeholder", group, key);
	};

	d20plus.cfg._getProp = (prop, group, key) => {
		if (CONFIG_OPTIONS[group] === undefined) return undefined;
		if (CONFIG_OPTIONS[group][key] === undefined) return undefined;
		return CONFIG_OPTIONS[group][key][prop];
	};

	d20plus.cfg.getOrDefault = (group, key) => {
		if (d20plus.cfg.has(group, key)) return d20plus.cfg.get(group, key);
		return d20plus.cfg.getDefault(group, key);
	};

	d20plus.cfg.getCfgEnumVals = (group, key) => {
		if (CONFIG_OPTIONS[group] === undefined) return undefined;
		if (CONFIG_OPTIONS[group][key] === undefined) return undefined;
		return CONFIG_OPTIONS[group][key].__values
	};

	d20plus.cfg.getCfgSliderVals = (group, key) => {
		if (CONFIG_OPTIONS[group] === undefined) return undefined;
		if (CONFIG_OPTIONS[group][key] === undefined) return undefined;
		const it = CONFIG_OPTIONS[group][key];
		return {
			min: it.__sliderMin,
			max: it.__sliderMax,
			step: it.__sliderStep,
		}
	};

	d20plus.cfg.getDefaultConfig = () => {
		const outCpy = {};
		$.each(CONFIG_OPTIONS, (sectK, sect) => {
			if ((window.is_gm && sect._player !== "only") || sect._player) {
				outCpy[sectK] = outCpy[sectK] || {};
				$.each(sect, (k, data) => {
					if (!k.startsWith("_") && (window.is_gm || data._player)) {
						outCpy[sectK][k] = data.default;
					}
				});
			}
		});
		return outCpy;
	};

	// Helpful for checking if a boolean option is set even if false
	d20plus.cfg.has = (group, key) => {
		if (d20plus.cfg.current[group] === undefined) return false;
		return d20plus.cfg.current[group][key] !== undefined;
	};

	d20plus.cfg.setCfgVal = (group, key, val) => {
		if (d20plus.cfg.current[group] === undefined) d20plus.cfg.current[group] = {};
		d20plus.cfg.current[group][key] = val;
	};

	d20plus.cfg.getWikiSummary = () => {
		const getDefaultValue = (group, key, setting) => {
			switch (setting.type) {
				case "_SHEET_ATTRIBUTE_PC": return Object.values(PC_SHEET_ATTRIBUTES).find(it => it.ogl === setting.default)?.name ?? setting.default;
				case "_SHEET_ATTRIBUTE": return Object.values(NPC_SHEET_ATTRIBUTES).find(it => it.ogl === setting.default)?.name ?? setting.default;

				default: return setting.default;
			}
		};

		const getOptions = (group, key, setting) => {
			switch (setting._type) {
				case "_enum": return d20plus.cfg.getCfgEnumVals(group, key, setting);

				case "_SHEET_ATTRIBUTE_PC": return Object.values(PC_SHEET_ATTRIBUTES).map(it => it.name);
				case "_SHEET_ATTRIBUTE": return Object.values(NPC_SHEET_ATTRIBUTES).map(it => it.name);

				case "_FORMULA": return d20plus.formulas._options;
				case "_WHISPERMODE": return d20plus.whisperModes;

				case "_ADVANTAGEMODE": return d20plus.advantageModes;
				case "_DAMAGEMODE": return d20plus.damageModes;

				case "_slider": {
					const sliderMeta = d20plus.cfg.getCfgSliderVals(group, key);
					return [sliderMeta.min, sliderMeta.max];
				}

				default: return null;
			}
		};

		return Object.entries(CONFIG_OPTIONS)
			.map(([group, groupMeta]) => {
				return {
					groupName: groupMeta._name,
					settings: Object.entries(groupMeta)
						.map(([key, setting]) => {
							if (key.startsWith("_")) return null;

							const options = getOptions(group, key, setting);

							return {
								name: setting.name,
								isPlayerEditable: !!setting._player,
								default: getDefaultValue(group, key, setting),
								options,
							};
						})
						.filter(Boolean),
				};
			});
	};

	d20plus.cfg.getWikiSummaryMarkdown = () => {
		return d20plus.cfg.getWikiSummary()
			.map(group => {
				let markdown = `## ${group.groupName}\n`;
				markdown += "TODO: Add description\n\n### Settings\n\n";

				group.settings
					.forEach(setting => {
						markdown += `- **${setting.name}**${(!setting.default && setting.default !== false) ? "" : ` *(default: ${setting.default})*`}\n`;

						if (setting.options) {
							markdown += "	Possible options are:\n";
							setting.options.forEach(option => markdown += `	- ${option}\n`);
						}
						markdown += "\n";
					});

				return markdown.replaceAll(/((&quot;)|")/g, "`");
			})
			.join("");
	};

	d20plus.cfg.makeTabPane = ($addTo, headers, content) => {
		if (headers.length !== content.length) throw new Error("Tab header and content length were not equal!");

		if ($addTo.attr("hastabs") !== "YES") {
			const $tabBar = $(`<ul class="nav nav-tabs"/>`);

			const tabList = [];
			const paneList = [];
			const $tabPanes = $(`<div class="tabcontent"/>`);

			$.each(content, (i, e) => {
				const toAdd = $(`<div class="plustab${i} tab-pane" ${i === 0 ? "" : `style="display: none"`}/>`);
				toAdd.append(e);
				paneList[i] = toAdd;
				$tabPanes.append(toAdd);
			});

			$.each(headers, (i, e) => {
				const toAdd = $(`<li ${i === 0 ? `class="active"` : ""}><a data-tab="plustab${i}" href="#">${e}</a></li>`).on("click", () => {
					paneList.forEach((p, i2) => {
						if (i2 === i) {
							tabList[i2].addClass("active");
							paneList[i2].show();
						} else {
							tabList[i2].removeClass("active");
							paneList[i2].hide();
						}
					});
				});
				tabList[i] = (toAdd);
				$tabBar.append(toAdd);
			});

			$addTo
				.append($tabBar)
				.append($tabPanes);

			$addTo.attr("hastabs", "YES");
		}
	};

	d20plus.cfg.openConfigEditor = () => {
		const cEdit = $("#d20plus-configeditor");
		cEdit.dialog("open");

		if (cEdit.attr("hastabs") !== "YES") {
			cEdit.attr("hastabs", "YES");
			const appendTo = $(`<div/>`);
			cEdit.prepend(appendTo);

			const configFields = {};

			let sortedKeys = Object.keys(CONFIG_OPTIONS).sort((a, b) => d20plus.ut.ascSort(CONFIG_OPTIONS[a]._name, CONFIG_OPTIONS[b]._name));
			if (!window.is_gm) sortedKeys = sortedKeys.filter(k => CONFIG_OPTIONS[k]._player);

			const tabList = sortedKeys.map(k => CONFIG_OPTIONS[k]._name);

			const makeTab = (cfgK) => {
				const cfgGroup = CONFIG_OPTIONS[cfgK];
				configFields[cfgK] = {};

				const content = $(`
						<div class="config-table-wrapper">
							<table class="config-table">
								<thead><tr><th>${__("ui_cfg_property")}</th><th>${__("ui_cfg_value")}</th></tr></thead>
								<tbody></tbody>
							</table>
						</div>
					`);
				const tbody = content.find(`tbody`);

				let sortedTabKeys = Object.keys(cfgGroup).filter(k => !k.startsWith("_"));
				if (!window.is_gm) sortedTabKeys = sortedTabKeys.filter(k => cfgGroup[k]._player);

				sortedTabKeys.forEach((grpK, idx) => {
					const prop = cfgGroup[grpK];

					// IDs only used for label linking
					const toAdd = $(`<tr><td><label for="conf_field_${idx}" class="config-name">${prop.name}</label></td></tr>`);

					// Each config `_type` should have a case here. Each case should add a function to the map [configFields:[cfgK:grpK]]. These functions should return the value of the input.
					switch (prop._type) {
						case "boolean": {
							const field = $(`<input type="checkbox" id="conf_field_${idx}" ${d20plus.cfg.getOrDefault(cfgK, grpK) ? `checked` : ""}>`);

							configFields[cfgK][grpK] = () => {
								return field.prop("checked")
							};

							const td = $(`<td/>`).append(field);
							toAdd.append(td);
							break;
						}
						case "String": {
							const curr = d20plus.cfg.get(cfgK, grpK) || "";
							const placeholder = d20plus.cfg.getPlaceholder(cfgK, grpK);
							const def = d20plus.cfg.getDefault(cfgK, grpK) || "";
							const field = $(`<input id="conf_field_${idx}" value="${curr}" ${placeholder ? `placeholder="${placeholder}"` : def ? `placeholder="Default: ${def}"` : ""}>`);

							configFields[cfgK][grpK] = () => {
								return field.val() ? field.val().trim() : "";
							};

							const td = $(`<td/>`).append(field);
							toAdd.append(td);
							break;
						}
						case "_SHEET_ATTRIBUTE_PC":
						case "_SHEET_ATTRIBUTE": {
							const DICT = prop._type === "_SHEET_ATTRIBUTE" ? NPC_SHEET_ATTRIBUTES : PC_SHEET_ATTRIBUTES;
							const sortedNpcsAttKeys = Object.keys(DICT).sort((at1, at2) => d20plus.ut.ascSort(DICT[at1].name, DICT[at2].name));
							const field = $(`<select id="conf_field_${idx}" class="cfg_grp_${cfgK}" data-item="${grpK}">${sortedNpcsAttKeys.map(npcK => `<option value="${npcK}">${DICT[npcK].name}</option>`)}</select>`);
							const cur = d20plus.cfg.get(cfgK, grpK);
							if (cur !== undefined) {
								field.val(cur);
							}

							configFields[cfgK][grpK] = () => {
								return field.val()
							};

							const td = $(`<td/>`).append(field);
							toAdd.append(td);
							break;
						}
						case "float":
						case "integer": {
							const def = d20plus.cfg.getDefault(cfgK, grpK);
							const curr = d20plus.cfg.get(cfgK, grpK);
							const field = $(`<input id="conf_field_${idx}" type="number" ${curr != null ? `value="${curr}"` : ""} ${def != null ? `placeholder="Default: ${def}"` : ""} step="any">`);

							configFields[cfgK][grpK] = () => {
								return Number(field.val());
							};

							const td = $(`<td/>`).append(field);
							toAdd.append(td);
							break;
						}
						case "_FORMULA": {
							const $field = $(`<select id="conf_field_${idx}" class="cfg_grp_${cfgK}" data-item="${grpK}">${d20plus.formulas._options.sort().map(opt => `<option value="${opt}">${opt}</option>`)}</select>`);

							const cur = d20plus.cfg.get(cfgK, grpK);
							if (cur !== undefined) {
								$field.val(cur);
							}

							configFields[cfgK][grpK] = () => {
								return $field.val();
							};

							const td = $(`<td/>`).append($field);
							toAdd.append(td);
							break;
						}
						case "_WHISPERMODE": {
							const $field = $(`<select id="conf_field_${idx}" class="cfg_grp_${cfgK}" data-item="${grpK}">${d20plus.whisperModes.map(mode => `<option value="${mode}">${mode}</option>`)}</select>`);

							const cur = d20plus.cfg.get(cfgK, grpK);
							if (cur !== undefined) {
								$field.val(cur);
							}

							configFields[cfgK][grpK] = () => {
								return $field.val();
							};

							const td = $(`<td/>`).append($field);
							toAdd.append(td);
							break;
						}
						case "_ADVANTAGEMODE": {
							const $field = $(`<select id="conf_field_${idx}" class="cfg_grp_${cfgK}" data-item="${grpK}">${d20plus.advantageModes.map(mode => `<option value="${mode}">${mode}</option>`)}</select>`);

							const cur = d20plus.cfg.get(cfgK, grpK);
							if (cur !== undefined) {
								$field.val(cur);
							}

							configFields[cfgK][grpK] = () => {
								return $field.val();
							};

							const td = $(`<td/>`).append($field);
							toAdd.append(td);
							break;
						}
						case "_DAMAGEMODE": {
							const $field = $(`<select id="conf_field_${idx}" class="cfg_grp_${cfgK}" data-item="${grpK}">${d20plus.damageModes.map(mode => `<option value="${mode}">${mode}</option>`)}</select>`);

							const cur = d20plus.cfg.get(cfgK, grpK);
							if (cur !== undefined) {
								$field.val(cur);
							}

							configFields[cfgK][grpK] = () => {
								return $field.val();
							};

							const td = $(`<td/>`).append($field);
							toAdd.append(td);
							break;
						}
						case "_enum": { // for generic String enums not covered above
							const texts = CONFIG_OPTIONS[cfgK][grpK]?.__texts;
							const $field = $(`<select id="conf_field_${idx}" class="cfg_grp_${cfgK}" data-item="${grpK}">${d20plus.cfg.getCfgEnumVals(cfgK, grpK).map((it, i) => {
								return `<option value="${it}">${texts ? texts[i] : it}</option>`
							})}</select>`);

							const cur = d20plus.cfg.get(cfgK, grpK);
							if (cur !== undefined) {
								$field.val(cur);
							} else {
								const def = d20plus.cfg.getDefault(cfgK, grpK);
								if (def !== undefined) {
									$field.val(def);
								}
							}

							configFields[cfgK][grpK] = () => {
								return $field.val();
							};

							const td = $(`<td/>`).append($field);
							toAdd.append(td);
							break;
						}
						case "_slider": {
							const def = d20plus.cfg.getDefault(cfgK, grpK);
							const curr = d20plus.cfg.get(cfgK, grpK);
							const sliderMeta = d20plus.cfg.getCfgSliderVals(cfgK, grpK);

							const field = $(`<input style="max-width: calc(100% - 40px);" type="range" min="${sliderMeta.min || 0}" max="${sliderMeta.max || 0}" step="${sliderMeta.step || 1}" value="${curr == null ? def : curr}">`);

							configFields[cfgK][grpK] = () => {
								return Number(field.val());
							};

							const td = $(`<td/>`).append(field);
							toAdd.append(td);
							break;
						}
						case "_color": {
							const value = d20plus.cfg.getOrDefault(cfgK, grpK);

							const field = $(`<input type="color" value="${value == null ? "" : value}">`);

							configFields[cfgK][grpK] = () => {
								return field.val();
							};

							const td = $(`<td/>`).append(field);
							toAdd.append(td);
							break;
						}
					}
					tbody.append(toAdd);
				});

				return content;
			}

			const contentList = sortedKeys.map(k => makeTab(k));

			d20plus.cfg.makeTabPane(
				appendTo,
				tabList,
				contentList,
			);

			const saveButton = $(`#configsave`);
			saveButton.unbind("click");
			saveButton.bind("click", () => {
				function _updateLoadedConfig () {
					$.each(configFields, (cfgK, grp) => {
						$.each(grp, (grpK, grpVField) => {
							d20plus.cfg.setCfgVal(cfgK, grpK, grpVField());
						})
					});
				}

				if (window.is_gm) {
					const doSave = () => {
						_updateLoadedConfig();

						const gmnotes = JSON.stringify(d20plus.cfg.current).replace(/%/g, "%25");
						handout.updateBlobs({gmnotes: gmnotes});
						handout.save({notes: (new Date()).getTime()});

						d20plus.ut.log("Saved config");

						d20plus.cfg.baseHandleConfigChange();
						if (d20plus.cfg5e) d20plus.cfg5e.handleConfigChange();
					};

					let handout = d20plus.cfg.getConfigHandout();
					if (!handout) {
						d20plus.cfg.pMakeDefaultConfig(doSave);
					} else {
						doSave();
					}
				} else {
					_updateLoadedConfig();
					StorageUtil.pSet(`Veconfig`, d20plus.cfg.current);
					d20plus.cfg.baseHandleConfigChange();
					if (d20plus.cfg5e) d20plus.cfg5e.handleConfigChange();
				}
			});
		}
	};

	/*
	// Left here for future use, in case anything similar is required
	d20plus.cfg._handleWeatherConfigChange = () => {
		function handleProp (prop) {
			const campaignKey = `bR20cfg_${prop}`;
			if (d20plus.cfg.has("weather", prop)) {
				Campaign && Campaign.save({[campaignKey]: d20plus.cfg.get("weather", prop)});
			} else {
				if (Campaign) {
					delete Campaign[campaignKey];
					Campaign.save();
				}
			}
		}
		if (window.is_gm) {
			handleProp("weatherType1");
			handleProp("weatherTypeCustom1");
			handleProp("weatherSpeed1");
			handleProp("weatherDir1");
			handleProp("weatherDirCustom1");
			handleProp("weatherOscillate1");
			handleProp("weatherOscillateThreshold1");
			handleProp("weatherIntensity1");
			handleProp("weatherTint1");
			handleProp("weatherTintColor1");
			handleProp("weatherEffect1");
		}
	};
	*/ // RB20 EXCLUDE START

	d20plus.cfg.handlePlayerImgSize = () => {
		const setSize = d20plus.cfg.getOrDefault("chat", "playerPortraitSize");
		const dynamicStyle = d20plus.ut.dynamicStyles("players");
		if (setSize === 30) {
			dynamicStyle.html("");
		} else {
			const setFont = Math.round((setSize / 150) * 16);
			const setCol = Math.round((setSize / 150) * 24);
			const setLine = Math.round((setSize / 150) * 18);
			const setStyle = `
				#playerzone .player .playername {width: ${setSize}px !important; font-size: ${setFont}px !important;line-height:${setLine}px}
				#playerzone .player .video {width: ${setSize}px; height: ${setSize}px; }
				#playerzone .player .playercolor, .player .color_picker {width: ${setCol}px; height: ${setCol}px; }
			`;
			dynamicStyle.html(setStyle);
		}
	} // RB20 EXCLUDE END

	d20plus.cfg.handleInitiativeShrink = () => {
		const doShrink = d20plus.cfg.getOrDefault("interface", "minifyTracker");
		const dynamicStyle = d20plus.ut.dynamicStyles("tracker");
		if (doShrink) {
			dynamicStyle.html(d20plus.css.miniInitStyle);
		} else {
			dynamicStyle.html("");
		}
	} // RB20 EXCLUDE START

	d20plus.cfg.HandleArtLibraryButtons = () => {
		if (d20plus.cfg.getOrDefault("interface", "selecArtLibraryType") !== "Roll20") {
			$(`#button-browse-external-art`).parent().parent().toggle(true);
			$(`#button-add-external-art`).detach().appendTo($(`#button-browse-external-art`).parent());
		} else {
			$(`#button-browse-external-art`).parent().parent().toggle(false);
			$(`#button-add-external-art`).detach().appendTo($(`.addlibraryfolder`).parent());
		}
	}

	d20plus.cfg.HandleCss = () => {
		// ugly hook to move VTTES menu items
		if (d20plus.cfg.getOrDefault("canvas", "enableNeatMenus")) {
			d20plus.ut.dynamicStyles("vttesHide").html(`
				.actions_menu.d20contextmenu > ul > li[style] {display:none;}
			`);
		}
		// more readable secondary bar (if it's too cluttered)
		if (d20plus.cfg.getOrDefault("canvas", "showRoofs")
			|| d20plus.cfg.getOrDefault("canvas", "showFloors")) {
			d20plus.ut.dynamicStyles("secBarGuide").html(`
				#floatinglayerbar li.choosegmlayer {border-top-width: 2px; border-top-style: solid;}
				#floatinglayerbar li.choosemap, 
				#floatinglayerbar li.chooseroofs, 
				#floatinglayerbar li.choosefloors {
					background-image: linear-gradient( 90deg, #8c8c8c5c 100%, #fff0 100%);
				}
			`);
		}
	} // RB20 EXCLUDE END

	d20plus.cfg.baseHandleConfigChange = () => {
		d20plus.cfg.handlePlayerImgSize();
		d20plus.cfg.handleInitiativeShrink();
		d20plus.cfg.HandleCss();

		if (window.is_gm) {
			d20plus.cfg.HandleArtLibraryButtons();
		}

		if (d20plus.cfg.has("interface", "toolbarOpacity")) {
			const v = Math.max(Math.min(Number(d20plus.cfg.get("interface", "toolbarOpacity")), 100), 0);
			$(`#secondary-toolbar`).css({opacity: v * 0.01});
		}

		$(`#floatinglayerbar`).toggle(d20plus.cfg.getOrDefault("canvas", "quickLayerButtons"));
		$(`#floatinglayerbar`).toggleClass("right", !!d20plus.cfg.getOrDefault("canvas", "quickLayerButtonsPosition"));

		$(`#init-quick-sort-desc`).toggle(d20plus.cfg.getOrDefault("interface", "quickInitButtons"));
		$(`#init-quick-reset`).toggle(d20plus.cfg.getOrDefault("interface", "quickInitButtonsClear"));

		$(`.dark-mode-switch`).toggle(!d20plus.cfg.get("interface", "hideDarkModeSwitch"));
		$(`#helpsite`).toggle(!d20plus.cfg.getOrDefault("interface", "hideHelpButton"));
		$(`#langpanel`).toggle(d20plus.cfg.getOrDefault("chat", "languages"));

		$(`#journal > .content.searchbox`).toggle(d20plus.cfg.getOrDefault("interface", "selectJournalSearchType") === "Roll20");
		$(`.content > #player-search`).toggle(d20plus.cfg.getOrDefault("interface", "selectJournalSearchType") !== "Roll20");
		$(`#journal > div.content > br`).toggle(d20plus.cfg.getOrDefault("interface", "selectJournalSearchType") !== "Roll20");
	};

	d20plus.cfg.startPlayerConfigHandler = () => {
		function handlePlayerCfg () {
			d20plus.cfg.baseHandleConfigChange();
			if (d20plus.handleConfigChange) d20plus.handleConfigChange(true);
		}

		// every 5 seconds, poll and apply any config changes the GM might have made
		if (!window.is_gm) {
			setInterval(() => {
				handlePlayerCfg();
			}, 5000);
		}
		handlePlayerCfg();
	};
}

SCRIPT_EXTENSIONS.push(baseConfig);


function baseTool () {
	d20plus.tool = {};

	/**
	 * Each tool should have:
	 *  - `name` List display name.
	 *  - `desc` List display description.
	 *  - `html` The html created when the button is clicked
	 *  - `dialogFn` Function called to initialize dialog.
	 *  - `openFn` Function called when tool is opened.
	 */
	d20plus.tool.tools = [
		{
			name: "Journal Cleaner",
			desc: "Quickly select and delete journal items, especially useful for cleaning up loose items after deleting a folder.",
			html: `
				<div id="d20plus-quickdelete" title="BetteR20 - Journal Root Cleaner">
				<p>A list of characters and handouts in the journal folder root, which allows them to be quickly deleted.</p>
				<label class="bold">Root Only <input type="radio" name="cb-mode" class="cb-shallow cb-mode"></label>
				<label class="bold">All Items <input type="radio" name="cb-mode" class="cb-deep cb-mode"></label>
				<label class="bold">All Items and Folders<input type="radio" name="cb-mode" class="cb-folder cb-mode"></label>
				<label class="bold">Rollable Tables <input type="radio" name="cb-mode" class="cb-tables cb-mode"></label>
				<hr>
				<p style="display: flex; justify-content: space-between"><label><input type="checkbox" title="Select all" id="deletelist-selectall"> Select All</label> <a class="btn" href="#" id="quickdelete-btn-submit">Delete Selected</a></p>
				<div id="delete-list-container">
					<input class="search" autocomplete="off" placeholder="Search list..." style="width: 100%;">
					<br><br>
					<ul class="list deletelist" style="max-height: 420px; overflow-y: scroll; display: block; margin: 0;"></ul>
				</div>
				</div>
				`,
			dialogFn: () => {
				$("#d20plus-quickdelete").dialog({
					autoOpen: false,
					resizable: true,
					width: 800,
					height: 700,
				});
			},
			openFn: () => {
				const $win = $("#d20plus-quickdelete");
				$win.dialog("open");

				// Create a variable for each box
				const $cbMode = $win.find(".cb-mode");
				const $cbShallow = $win.find(`.cb-shallow`);
				const $cbDeep = $win.find(`.cb-deep`);
				const $cbTables = $win.find(`.cb-tables`);
				const $cbFolder = $win.find(`.cb-folder`);

				const $cbAll = $("#deletelist-selectall").unbind("click");

				const $btnDel = $(`#quickdelete-btn-submit`).off("click");

				// When a a different box gets checked, populate the list
				$cbMode.off("change").on("change", () => populateList());

				// Don't even ask why populateList needs to be called twice
				$cbShallow.prop("checked", true);
				populateList();

				function populateList () {
					// collect a list of all journal items
					function getAllJournalItems () {
						const out = [];

						function recurse (entry, pos, isRoot) {
							if (entry.i) {
								if (!isRoot) pos.push(entry.n);
								entry.i.forEach(nxt => recurse(nxt, pos));
								pos.pop();
							} else out.push({id: entry, path: MiscUtil.copy(pos)});
						}

						const root = {i: d20plus.ut.getJournalFolderObj()};
						recurse(root, [], true);
						return out.map(it => getItemFromId(it.id, it.path.join(" / ")));
					}

					function getFolderJournalItems () {
						// Similar to get all Journal Items, but lists folders as well
						const out = [];

						// Go through the directory structure recursively
						function recurse (entry, pos, isRoot) {
							// I property is list of children, only folders have it
							if (entry.i) {
								// Add the folder name to the path
								if (!isRoot) pos.push(entry.n);

								// This adds directory names to out
								if (!isRoot) out.push({id: entry, path: MiscUtil.copy(pos)});

								// Run through the directory on each of the children
								entry.i.forEach(nxt => recurse(nxt, pos));

								// Remove the folder from the path when done
								pos.pop();
							}
							// Only triggers for non-folders, adds non-folders to list
							else out.push({id: entry, path: MiscUtil.copy(pos)});
						}

						// Get the directory structure and start traversal through it
						const root = {i: d20plus.ut.getJournalFolderObj()};
						recurse(root, [], true);
						return out.map(it => getItemFromId(it.id, it.path.join(" / ")));
					}

					function getRootJournalItems () {
						const rootItems = [];
						const journal = d20plus.ut.getJournalFolderObj();
						journal.forEach(it => {
							if (it.i) return; // skip folders
							rootItems.push(getItemFromId(it));
						});
						return rootItems;
					}

					function getItemFromId (itId, path = "") {
						// Get handout object, undefined if item is not a handout
						const handout = d20.Campaign.handouts.get(itId);
						if (handout && (handout.get("name") === CONFIG_HANDOUT || handout.get("name") === ART_HANDOUT)) return null; // skip 5etools handouts

						// Get character object, undefined if item is not a character
						const character = d20.Campaign.characters.get(itId);

						// Return based on which object isn't empty
						if (handout) return {type: "handouts", id: itId, name: handout.get("name"), path: path, archived: handout.attributes.archived};
						if (character) return {type: "characters", id: itId, name: character.get("name"), path: path, archived: character.attributes.archived};

						// If both are empty, check if item is a folder and return a folder type
						if (d20plus.journal.checkDirExistsByPath(path.split(" / "))) return {type: "folder", id: itId, name: "", path: path, archived: false, folder: true}
					}

					function getJournalItems () {
						// For the root only option
						if ($cbShallow.prop("checked")) return getRootJournalItems().filter(Boolean);

						// For the all files option
						if ($cbDeep.prop("checked")) return getAllJournalItems().filter(Boolean);

						// For the all files and folder option
						if ($cbFolder.prop("checked")) return getFolderJournalItems().filter(Boolean);

						// For the get rollable tables option
						if ($cbTables.prop("checked")) return getRollableTables().filter(Boolean);
					}

					// Allow for deleting tables as well
					function getRollableTables () {
						let tItems = [];
						if ($cbTables.prop("checked")) {
							// Get a tableobject from the d20 thing and loop through it
							const tableObject = d20.Campaign.rollabletables;
							for (i = 0; i < tableObject.length; i++) {
								// If it looks confusing, it is. Just trust that I got the objects properly
								const tAttr = tableObject.at(i).attributes;
								const tObj = {
									name: tAttr.name,
									id: tAttr.id,
									type: "rollabletables",
									table: true,
								};
								tItems.push(tObj);
							}
						}
						return tItems;
					}

					// Populate different lists based on which box is checked
					const journalItems = getJournalItems();

					// Display found items
					const $delList = $win.find(`.list`);
					$delList.empty();

					journalItems.forEach((it, i) => {
						$delList.append(`
							<label class="import-cb-label" data-listid="${i}">
								<input type="checkbox">
								<span class="name readable">${it.path ? `${it.path} / ` : ""}${it.name}</span>
								${it.archived ? `<span class="name readable">(archived)</span>` : ""}
								${it.table ? `<span class="name readable">(table)</span>` : ""}
								${it.folder ? `<span class="name readable">(folder)</span>` : ""}
							</label>
						`);
					});

					// init list library
					const delList = new List("delete-list-container", {
						valueNames: ["name"],
						listClass: "deletelist",
					});

					$cbAll.prop("checked", false);
					$cbAll.off("click").click(() => d20plus.importer._importToggleSelectAll(delList, $cbAll));

					$btnDel.off("click").on("click", () => {
						const sel = delList.items
							.filter(it => $(it.elm).find(`input`).prop("checked"))
							.map(it => journalItems[$(it.elm).attr("data-listid")])
							.reverse();

						if (!sel.length) {
							alert("No items selected!");
						} else if (confirm(`Are you sure you want to delete the ${sel.length} selected item${sel.length > 1 ? "s" : ""}?`)) {
							$win.dialog("close");
							$("a.ui-tabs-anchor[href='#journal']").trigger("click");
							sel.forEach(toDel => {
								// If the item is a folder, use the folder deletion functon
								if (toDel.folder) d20plus.journal.removeDirByPath(toDel.path.split(" / "));

								// Otherwise delete through d20 object
								else d20.Campaign[toDel.type].get(toDel.id).destroy();
							});
							$("#journalfolderroot").trigger("change");
						}
					});
				}
			},
		},
		{
			name: "SVG Draw",
			desc: "Paste SVG data as text to automatically draw the paths.",
			html: `
				<div id="d20plus-svgdraw" title="Better20 - SVG Drawing Tool">
				<p>Paste SVG data as text to automatically draw any included &lt;path&gt;s. Draws to the current layer, in the top-left corner, with no scaling. Takes colour information from &quot;stroke&quot; attributes.</p>
				<p>Line width (px; default values are 1, 3, 5, 8, 14): <input name="stroke-width" placeholder="5" value="5" type="number"></p>
				<textarea rows="10" cols="100" placeholder="Paste SVG data here"></textarea>
				<br>
				<button class="btn">Draw</button>
				</div>
				`,
			dialogFn: () => {
				$("#d20plus-svgdraw").dialog({
					autoOpen: false,
					resizable: true,
					width: 800,
					height: 650,
				});
			},
			openFn: () => {
				// adapted from `d20.engine.finishCurrentPolygon`
				function addShape (path, pathStroke, strokeWidth) {
					let i = d20.engine.convertAbsolutePathStringtoFabric(path);
					i = _.extend(i, {
						strokeWidth: strokeWidth,
						fill: "transparent",
						stroke: pathStroke,
						path: JSON.parse(i.path),
					});
					d20.Campaign.activePage().addPath(i);
					d20.engine.redrawScreenNextTick();
				}

				const $win = $("#d20plus-svgdraw");
				$win.dialog("open");

				$win.find(`button`).off("click").on("click", () => {
					d20plus.ut.log("Drawing paths");
					const input = $win.find(`textarea`).val();
					const svg = $.parseXML(input);

					const toDraw = $(svg).find("path").map((i, e) => {
						const $e = $(e);
						return {stroke: $e.attr("stroke") || "black", d: $e.attr("d")}
					}).get();

					const strokeWidth = Math.max(1, Number($win.find(`input[name="stroke-width"]`).val()));

					toDraw.forEach(it => {
						addShape(it.d, it.stroke, strokeWidth)
					});
				});
			},
		},
		{
			name: "Multi-Whisper",
			desc: "Send whispers to multiple players ",
			html: `
				<div id="d20plus-whispers" title="Better20 - Multi-Whisper Tool">
				<div>
					<button class="btn toggle-dc">Show Disconnected Players</button>
					<button class="btn send-all">Send All Messages</button>
					<button class="btn clear-all">Clear All Messages</button>
				</div>
				<hr>
				<div class="messages" style="max-height: 600px; overflow-y: auto; overflow-x: hidden; transform: translateZ(0)">
					<!-- populate with JS -->
				</div>
				</div>
				`,
			dialogFn: () => {
				$("#d20plus-whispers").dialog({
					autoOpen: false,
					resizable: true,
					width: 1000,
					height: 760,
				});
			},
			openFn: () => {
				$("a.ui-tabs-anchor[href='#textchat']").trigger("click");

				const $win = $("#d20plus-whispers");
				$win.dialog("open");

				const $btnToggleDc = $win.find(`.toggle-dc`).off("click").text("Show Disconnected Players");
				const $btnSendAll = $win.find(`.send-all`).off("click");
				const $btnClearAll = $win.find(`.clear-all`).off("click");

				const $pnlMessages = $win.find(`.messages`).empty();
				const players = d20.Campaign.players.toJSON();
				players.forEach((p, i) => {
					const $btnSend = $(`<button class="btn send" style="margin-right: 5px;">Send</button>`).on("click", function () {
						const $btn = $(this);
						const $wrp = $btn.closest(`.wrp-message`);
						const toMsg = $wrp.find(`input[data-player-id]:checked`).filter(":visible").map((ii, e) => $(e).attr("data-player-id")).get();
						const content = $wrp.find(`.message`).val().trim();
						toMsg.forEach(targetId => {
							d20.textchat.doChatInput(`/w ${d20.Campaign.players.get(targetId).get("displayname").split(" ")[0]} ${content}`);

							// This only posts to local player's chat, sadly
							// d20.textchat.incoming(
							// 	false,
							// 	{
							// 		avatar: `/users/avatar/${window.currentPlayer.get("d20userid")}/30`,
							// 		who: d20.textchat.$speakingas.find("option:first-child").text(),
							// 		type: "whisper",
							// 		content: content,
							// 		playerid: window.currentPlayer.id,
							// 		id: d20plus.ut.generateRowId(),
							// 		target: targetId,
							// 		target_name: d20.Campaign.players.get(targetId).get("displayname") || ""
							// 	}
							// );
						})
					});

					const $btnClear = $(`<button class="btn msg-clear">Clear</button>`).on("click", function () {
						$(this).closest(`.wrp-message`).find(`.message`).val("");
					});

					$pnlMessages.append($(`
							<div ${p.online || `style="display: none;"`} data-online="${p.online}" class="wrp-message">
								<div>
									${players.map((pp, ii) => `<label style="margin-right: 10px; ${pp.online || ` display: none;`}" data-online="${pp.online}" class="display-inline-block">${pp.displayname} <input data-player-id="${pp.id}" type="checkbox" ${i === ii ? `checked="true"` : ""}></label>`).join("")}
								</div>
								<textarea style="display: block; width: 95%;" placeholder="Enter whisper" class="message"></textarea>
							</div>
						`).append($btnSend).append($btnClear).append(`<hr>`));
				});

				$btnToggleDc.on("click", () => {
					$btnToggleDc.text($btnToggleDc.text().startsWith("Show") ? "Hide Disconnected Players" : "Show Disconnected Players");
					$pnlMessages.find(`[data-online="false"]`).toggle();
				});

				$btnSendAll.on("click", () => {
					$pnlMessages.find(`button.send`).click();
				});

				$btnClearAll.on("click", () => $pnlMessages.find(`button.msg-clear`).click());
			},
		},
		{
			name: "Token Avatar URL Fixer",
			desc: "Change the root URL for tokens en-masse.",
			html: `
				<div id="d20plus-avatar-fixer" title="Better20 - Avatar Fixer">
				<p><b>Warning:</b> this thing doesn't really work.</p>
				<p>Current URLs (view only): <select class="view-only"></select></p>
				<p><label>Replace:<br><input name="search" value="https://5e.tools/"></label></p>
				<p><label>With:<br><input name="replace" value="https://5etools-mirror-1.github.io/"></label></p>
				<p><button class="btn">Go!</button></p>
				</div>
				`,
			dialogFn: () => {
				$("#d20plus-avatar-fixer").dialog({
					autoOpen: false,
					resizable: true,
					width: 400,
					height: 400,
				});
			},
			openFn: () => {
				function replaceAll (str, search, replacement) {
					return str.split(search).join(replacement);
				}

				const $win = $("#d20plus-avatar-fixer");
				$win.dialog("open");

				const $selView = $win.find(`.view-only`);
				const toView = [];
				d20.Campaign.characters.toJSON().forEach(c => {
					if (c.avatar && c.avatar.trim()) {
						toView.push(c.avatar);
					}
				});
				toView.sort(SortUtil.ascSort).forEach(url => $selView.append(`<option disabled>${url}</option>`));

				const $btnGo = $win.find(`button`).off("click");
				$btnGo.on("click", () => {
					let count = 0;
					$("a.ui-tabs-anchor[href='#journal']").trigger("click");

					const search = $win.find(`[name="search"]`).val();
					const replace = $win.find(`[name="replace"]`).val();

					d20.Campaign.characters.toJSON().forEach(c => {
						const id = c.id;

						const realC = d20.Campaign.characters.get(id);

						const curr = realC.get("avatar");
						let toSave = false;
						if (curr.includes(search)) {
							count++;
							realC.set("avatar", replaceAll(curr, search, replace));
							toSave = true;
						}
						if (realC.get("defaulttoken")) {
							realC._getLatestBlob("defaulttoken", (bl) => {
								bl = bl && bl.trim() ? JSON.parse(bl) : {};
								if (bl && bl.imgsrc && bl.imgsrc.includes(search)) {
									count++;
									realC.updateBlobs({imgsrc: replaceAll(bl.imgsrc, search, replace)});
									toSave = true;
								}
							});
						}

						if (toSave) {
							realC.save();
						}

						for (const page of d20.Campaign.pages.models) {
							if (page.thegraphics && page.thegraphics.models) {
								for (const token of page.thegraphics.models) {
									const tokenImgsrc = token.get("imgsrc");
									if (tokenImgsrc.includes(search)) {
										token.set("imgsrc", tokenImgsrc.replace(search, replace));
										token.save();
										count++;
									}
								}
							}
						}
					});
					window.alert(`Replaced ${count} item${count === 0 || count > 1 ? "s" : ""}.`)
				});
			},
		},
		{
			name: "Mass-Delete Pages",
			desc: "Quickly delete multiple pages.",
			html: `
				<div id="d20plus-mass-page-delete" title="Better20 - Mass-Delete Pages">
					<div id="del-pages-list">
						<div class="list" style="transform: translateZ(0); max-height: 490px; overflow-y: scroll; overflow-x: hidden; margin-bottom: 10px;"><i>Loading...</i></div>
					</div>
					<hr>
					<p><label class="ib"><input type="checkbox" class="select-all"> Select All</label> | <button class="btn btn-danger deleter">Delete</button></p>
					<p><i>This tool will delete neither your active page, nor a page active for players.</i></p>
				</div>
				`,
			dialogFn: () => {
				$("#d20plus-mass-page-delete").dialog({
					autoOpen: false,
					resizable: true,
					width: 600,
					height: 800,
				});
			},
			openFn: () => {
				function deletePage (model, pageList) {
					if ($(`#page-toolbar .availablepage[data-pageid=${model.id}]`).remove()) {
						let n = d20.Campaign.getPageIndex(model.id);
						if (model.thegraphics) {
							model.thegraphics.massdelete = true;
							model.thegraphics.backboneFirebase.reference.set(null);
						}
						if (model.thetexts) {
							model.thetexts.massdelete = true;
							model.thetexts.backboneFirebase.reference.set(null);
						}
						if (model.thepaths) {
							model.thepaths.backboneFirebase.reference.set(null);
							model.thepaths.massdelete = true;
						}
						let i = d20.Campaign.get("playerspecificpages");
						let o = false;
						_.each(i, function (e, n) {
							if (e === model.id) {
								delete i[n];
								o = true;
							}
						});
						o && d20.Campaign.save({
							playerspecificpages: i,
						});
						model.destroy();
						d20.Campaign.activePageIndex > n && (d20.Campaign.activePageIndex -= 1);

						pageList.remove("page-id", model.id);
					}
				}

				const $win = $("#d20plus-mass-page-delete");
				$win.dialog("open");

				const $lst = $win.find(`.list`).empty();

				d20.Campaign.pages.models.forEach(m => {
					$lst.append(`
							<label class="import-cb-label import-cb-label--img" data-listid="${m.id}">
								<input type="checkbox">
								<img class="import-label__img" src="${m.attributes.thumbnail}">
								<span class="name col-9">${m.attributes.name}</span>
								<span style="display: none;" class="page-id">${m.id}</span>
							</label>
						`);
				});

				const pageList = new List("del-pages-list", {
					valueNames: ["name", "page-id"],
				});

				const $cbAll = $win.find(`.select-all`).off("click").click(() => {
					pageList.items.forEach(it => {
						$(it.elm).find(`input[type="checkbox"]`).prop("checked", $cbAll.prop("checked"));
					});
				});

				const $btnDel = $win.find(`.deleter`).off("click").click(() => {
					const sel = pageList.items
						.filter(it => $(it.elm).find(`input`).prop("checked"))
						.map(it => $(it.elm).attr("data-listid"))
						.map(pId => d20.Campaign.pages.models.find(it => it.id === pId))
						.filter(it => it);

					sel.forEach(m => {
						if (m.id !== d20.Campaign.get("playerpageid") && m.id !== d20.Campaign.activePage().id) {
							deletePage(m, pageList);
						}
					});
					$cbAll.prop("checked", false);
				});
			},
		},
		{
			name: "Quantum Token Entangler",
			desc: "Connect tokens between pages, linking their positions.",
			html: `
				<div id="d20plus-token-entangle" title="Better20 - Quantum Token Entangler">
					<p><i>Please note that this feature is highly experimental.
					<br>
					You can learn Token IDs by rightclicking a token -> "Advanced" -> "View Token ID."</i></p>
					<hr>
					<input id="token-entangle-id-1" placeholder="Master ID">
					Type:
					<select id="token-entangle-type-1">
						<option value="0">Token</option>
						<option value="1">Path</option>
					</select>
					<br>
					<input id="token-entangle-id-2" placeholder="Slave ID">
					Type:
					<select id="token-entangle-type-2">
						<option value="0">Token</option>
						<option value="1">Path</option>
					</select>
					<br>
					<button class="btn btn-default" id="token-entangle-go">Entangle</button>
					<hr>
					<input id="token-clear-entangles" placeholder="ID to Clear">
					Type:
					<select id="token-clear-type">
						<option value="0">Token</option>
						<option value="1">Path</option>
					</select>
					<button class="btn btn-default" id="token-entangle-clear">Clear Entangles</button>
				</div>
				`,
			dialogFn: () => {
				const $win = $("#d20plus-token-entangle");

				const entangleTracker = {};
				const ALLOWED_TYPES = ["path", "image"];
				const SYNCABLE_ATTRS_IMAGE = [
					"rotation",
					"width",
					"height",
					"top",
					"left",
					"scaleX",
					"scaleY",
					"fliph",
					"flipv",
				];
				const SYNCABLE_ATTRS_PATH = [
					"rotation",
					"top",
					"left",
					"scaleX",
					"scaleY",
				];

				$win.data("VE_DO_ENTANGLE", (master) => {
					if (!ALLOWED_TYPES.includes(master.attributes.type)) return;

					// prevent double-binding
					if (entangleTracker[master.id]) return;

					const TO_SYNC = master.attributes.type === "image" ? SYNCABLE_ATTRS_IMAGE : SYNCABLE_ATTRS_PATH;

					master.on("change", (it) => {
						let anyUpdates = false;

						if (master.attributes.entangledImages && master.attributes.entangledImages.length) {
							if (TO_SYNC.filter(attr => it.changed[attr] !== undefined).length) {
								master.attributes.entangledImages = master.attributes.entangledImages.filter(id => {
									const slave = d20plus.ut.getTokenById(id);
									const SLAVE_ATTRS = slave.attributes.type === "image" ? SYNCABLE_ATTRS_IMAGE : SYNCABLE_ATTRS_PATH;
									if (slave) {
										TO_SYNC
											.filter(attr => SLAVE_ATTRS.includes(attr))
											.filter(attr => master.attributes[attr] != null)
											.forEach(attr => slave.attributes[attr] = master.attributes[attr]);
										slave.save();
										return true;
									} else {
										// eslint-disable-next-line no-console
										console.warn(`Could not find entangled token with ID "${id}", removing...`);
										anyUpdates = true;
									}
								});
							}
						}

						if (master.attributes.entangledPaths && master.attributes.entangledPaths.length) {
							if (TO_SYNC.filter(attr => it.changed[attr] !== undefined).length) {
								master.attributes.entangledPaths = master.attributes.entangledPaths.filter(id => {
									const slave = d20plus.ut.getPathById(id);
									const SLAVE_ATTRS = slave.attributes.type === "image" ? SYNCABLE_ATTRS_IMAGE : SYNCABLE_ATTRS_PATH;
									if (slave) {
										TO_SYNC
											.filter(attr => SLAVE_ATTRS.includes(attr))
											.filter(attr => master.attributes[attr] != null)
											.forEach(attr => slave.attributes[attr] = master.attributes[attr]);
										slave.save();
										return true;
									} else {
										// eslint-disable-next-line no-console
										console.warn(`Could not find entangled path with ID "${id}", removing...`);
										anyUpdates = true;
									}
								});
							}
						}

						if (anyUpdates) master.save();
					})
				});

				// do initial entangles
				const runInitial = () => {
					const pages = d20.Campaign.pages;
					if (pages && pages.models) {
						d20plus.ut.log("Initialisng existing entangles...");
						d20.Campaign.pages.models
							.forEach(model => {
								const PROPS = {
									thegraphics: "entangledImages",
									thepaths: "entangledPaths",
								};
								Object.keys(PROPS).forEach(prop => {
									Object.values(PROPS).forEach(attrK => {
										if (model[prop] && model[prop].models) {
											model[prop].models.filter(it => it.attributes[attrK] && it.attributes[attrK].length).forEach(it => {
												$win.data("VE_DO_ENTANGLE")(it);
											})
										}
									});
								});
							});
					} else {
						// eslint-disable-next-line no-console
						console.log("Pages uninitialised, waiting...");
						setTimeout(runInitial, 1000);
					}
				};

				runInitial();

				$win.dialog({
					autoOpen: false,
					resizable: true,
					width: 800,
					height: 400,
				});
			},
			openFn: () => {
				const ATTR_PROPS = ["entangledImages", "entangledPaths"];

				const notFound = (id, type) => alert(`${type === "image" ? "Token" : "Path"} with ID ${id} didn't exist!`);

				const $win = $("#d20plus-token-entangle");
				$win.dialog("open");

				const $ipt1 = $(`#token-entangle-id-1`);
				const $ipt2 = $(`#token-entangle-id-2`);
				const $selType1 = $(`#token-entangle-type-1`);
				const $selType2 = $(`#token-entangle-type-2`);

				const $btnGo = $(`#token-entangle-go`)
					.off("click")
					.click(() => {
						const id1 = $ipt1.val();
						const id2 = $ipt2.val();
						const checkExisting = (a, b) => {
							const _check = (p, q) => ATTR_PROPS.some(prop => p.attributes[prop] && a.attributes[prop].includes(q.id));

							if (_check(a, b)) return `"${a.id}" is already entangled to "${b.id}"!`;
							if (_check(b, a)) return `"${b.id}" is already entangled to "${a.id}"!`;
							return false;
						};

						const entity1 = $selType1.val() === "0" ? d20plus.ut.getTokenById(id1) : d20plus.ut.getPathById(id1);
						const entity2 = $selType2.val() === "0" ? d20plus.ut.getTokenById(id2) : d20plus.ut.getPathById(id2);

						if (!entity1) return notFound(id1, $selType1.val() === "0" ? "image" : "path");
						if (!entity2) return notFound(id2, $selType2.val() === "0" ? "image" : "path");

						const existing = checkExisting(entity1, entity2);
						if (existing) return alert(existing);

						const prop1 = entity2.attributes.type === "image" ? "entangledImages" : "entangledPaths";
						const prop2 = entity1.attributes.type === "image" ? "entangledImages" : "entangledPaths";

						(entity1.attributes[prop1] = entity1.attributes[prop1] || []).push(id2);
						entity1.save();
						(entity2.attributes[prop2] = entity2.attributes[prop2] || []).push(id1);
						entity2.save();

						$win.data("VE_DO_ENTANGLE")(entity1);
						$win.data("VE_DO_ENTANGLE")(entity2);
						alert("Entangled!");
					});

				const $iptClear = $(`#token-clear-entangles`);

				const $selTypeClear = $(`#token-clear-type`);

				const $btnClear = $(`#token-entangle-clear`)
					.off("click")
					.click(() => {
						const id = $iptClear.val();
						const entity = $selTypeClear.val() === "0" ? d20plus.ut.getTokenById(id) : d20plus.ut.getPathById(id);
						if (!entity) return notFound(id, $selTypeClear.val() === "0" ? "image" : "path");

						const count = (entity.attributes.entangledImages ? entity.attributes.entangledImages.length : 0) + (entity.attributes.entangledPaths ? entity.attributes.entangledPaths.length : 0);

						(entity.attributes.entangledImages || []).forEach(eId => {
							const ent = d20plus.ut.getTokenById(eId);
							if (ent && ent.attributes.entangledImages && ent.attributes.entangledImages.includes(id)) {
								ent.attributes.entangledImages.splice(ent.attributes.entangledImages.indexOf(id), 1);
								ent.save();
							}
						});

						(entity.attributes.entangledPaths || []).forEach(eId => {
							const ent = d20plus.ut.getPathById(eId);
							if (ent && ent.attributes.entangledPaths && ent.attributes.entangledPaths.includes(id)) {
								ent.attributes.entangledPaths.splice(ent.attributes.entangledPaths.indexOf(id), 1);
								ent.save();
							}
						});

						entity.attributes.entangledImages = [];
						entity.attributes.entangledPaths = [];
						entity.save();
						alert(`${count} entangle${count === 1 ? "" : "s"} cleared.`);
					});
			},
		},
	];

	d20plus.tool.get = (toolId) => {
		return d20plus.tool.tools.find(it => it.toolId === toolId);
	};

	d20plus.tool.addTools = () => {
		const $body = $(`body`);
		const $tools = $(`#d20-tools-list`);
		const $toolsList = $tools.find(`.tools-list`);
		d20plus.tool.tools.sort((a, b) => SortUtil.ascSortLower(a.name || "", b.name || "")).forEach(t => {
			$body.append(t.html); // add HTML
			try {
				t.dialogFn(); // init window
				// add tool row
				const $wrp = $(`<div class="tool-row"/>`);
				$wrp.append(`<span style="width: 20%; padding: 4px;">${t.name}</span>`);
				$wrp.append(`<span style="width: calc(60% - 8px); padding: 4px;">${t.desc}</span>`);
				$(`<a style="width: 15%;" class="btn" href="#">Open</a>`).on(mousedowntype, () => {
					t.openFn.bind(t)();
					$tools.dialog("close");
				}).appendTo($wrp);
				$toolsList.append($wrp);
			} catch (e) {
				// eslint-disable-next-line no-console
				console.error(`Failed to initialise tool "${t.name}"`, e);
			}
		});

		$tools.dialog({
			autoOpen: false,
			resizable: true,
			width: 800,
			height: 660,
		});
		$(`#button-view-tools`).on(mousedowntype, () => {
			$tools.dialog("open");
		});
	};
}

SCRIPT_EXTENSIONS.push(baseTool);


function baseToolModule () {
	d20plus.tool.tools.push({
		toolId: "MODULES",
		name: "Module Importer/Exporter",
		desc: "Import full games (modules), or import/export custom games",
		html: `
				<div id="d20plus-module-importer" title="Better20 - Module Importer/Exporter">
				<p style="margin-bottom: 4px;"><b style="font-size: 110%;">Exporter: </b> <button class="btn" name="export">Export Game to File</button> <i>The exported file can later be used with the "Upload File" option, below.</i></p>
				<hr style="margin: 4px;">
				<p style="margin-bottom: 4px;">
					<b style="font-size: 110%;">Importer:</b>
					<button class="btn readme" style="float: right;">Help/README</button>
					<div style="clear: both;"></div>
				</p>
				<div style="border-bottom: 1px solid #ccc; margin-bottom: 3px; padding-bottom: 3px;">
					<button class="btn" name="load-Vetools">Load from 5etools</button>
					<button class="btn" name="load-dmsguild">Load from R20 Repo</button>
					<button class="btn" name="load-file">Upload File</button>
				</div>
				<div>
					<div name="data-loading-message"></div>
					<select name="data-type" disabled style="margin-bottom: 0;">
						<option value="characters">Characters</option>
						<option value="decks">Decks</option>
						<option value="handouts">Handouts</option>
						<option value="playlists">Jukebox Playlists</option>
						<option value="tracks">Jukebox Tracks</option>
						<option value="maps">Maps</option>
						<option value="rolltables">Rollable Tables</option>
					</select>
					<button class="btn" name="view-select-entries">View/Select Entries</button>
					<br>
					<button class="btn" name="select-all-entries">Select Everything</button>
					<div name="selection-summary" style="margin-top: 5px;"></div>
				</div>
				<hr>
				<p><button class="btn" style="float: right;" name="import">Import Selected</button></p>
				</div>

				<div id="d20plus-module-importer-list" title="Select Entries">
					<div id="module-importer-list">
						<input type="search" class="search" placeholder="Search..." disabled>
						<div class="list" style="transform: translateZ(0); max-height: 650px; overflow-y: auto; overflow-x: hidden; margin-bottom: 10px;">
						<i>Load a file to view the contents here</i>
						</div>
					</div>
					<div>
						<label class="ib"><input type="checkbox" class="select-all"> Select All</label>
						<button class="btn" style="float: right;" name="confirm-selection">Confirm Selection</button>
					</div>
				</div>

				<div id="d20plus-module-importer-progress" title="Import Progress">
					<h3 class="name"></h3>
					<span class="remaining"></span>
					<p>Errors: <span class="errors">0</span> <span class="error-names"></span></p>
					<p><button class="btn cancel">Cancel</button></p>
				</div>

				<div id="d20plus-module-importer-help" title="Readme">
					<p>First, either load a module from 5etools, or upload one from a file. Then, choose the category you wish to import, and "View/Select Entries." Once you've selected everything you wish to import from the module, hit "Import Selected." This ensures entries are imported in the correct order.</p>
					<p><b>Note:</b> The script-wide configurable "rest time" options affect how quickly each category of entries is imported (tables and decks use the "Handout" rest time).</p>
					<p><b>Note:</b> Configuration options (aside from "rest time" as detailed above) <i>do not</i> affect the module importer. It effectively "clones" the content as-exported from the original module, including any whisper/advantage/etc settings.</p>
				</div>

				<div id="d20plus-module-importer-5etools" title="Select Module">
					<div id="module-importer-list-5etools">
						<input type="search" class="search" placeholder="Search modules...">
						<div>
							<div style="display: inline-block; width: 13px; height: 1px;"></div>
							<div class="col-5 col">Name</div>
							<div class="col-1 col" style="text-align: center;">Version</div>
							<div class="col-2 col" style="text-align: center;">Last Modified</div>
							<div class="col-1 col" style="text-align: center;">Size</div>
							<div class="col-2 col" style="text-align: center;">Source</div>
						</div>
						<div class="list" style="transform: translateZ(0); max-height: 480px; overflow-y: auto; overflow-x: hidden; margin-bottom: 10px;">
						<i>Loading...</i>
						</div>
					</div>
					<p><button class="btn load">Load Module Data</button></p>
				</div>

				<div id="d20plus-module-importer-select-exports-p1" title="Select Categories to Export">
					<div>
						<label>Characters <input type="checkbox" class="float-right" name="cb-characters"></label>
						<label>Decks <input type="checkbox" class="float-right" name="cb-decks"></label>
						<label>Handouts <input type="checkbox" class="float-right" name="cb-handouts"></label>
						<label>Jukebox Playlists <input type="checkbox" class="float-right" name="cb-playlists"></label>
						<label>Jukebox Tracks <input type="checkbox" class="float-right" name="cb-tracks"></label>
						<label>Maps <input type="checkbox" class="float-right" name="cb-maps"></label>
						<label>Rollable Tables <input type="checkbox" class="float-right" name="cb-rolltables"></label>
					</div>
					<div class="clear" style="width: 100%; border-bottom: #ccc solid 1px;"></div>
					<p style="margin-top: 5px;"><label>Select All <input type="checkbox" class="float-right" name="cb-all"></label></p>
					<p><button class="btn">Export</button></p>
				</div>
				`,
		dialogFn: () => {
			$("#d20plus-module-importer").dialog({
				autoOpen: false,
				resizable: true,
				width: 750,
				height: 360,
			});
			$(`#d20plus-module-importer-progress`).dialog({
				autoOpen: false,
				resizable: false,
			});
			$("#d20plus-module-importer-5etools").dialog({
				autoOpen: false,
				resizable: true,
				width: 800,
				height: 600,
			});
			$("#d20plus-module-importer-help").dialog({
				autoOpen: false,
				resizable: true,
				width: 600,
				height: 400,
			});
			$("#d20plus-module-importer-select-exports-p1").dialog({
				autoOpen: false,
				resizable: true,
				width: 400,
				height: 275,
			});
			$("#d20plus-module-importer-list").dialog({
				autoOpen: false,
				resizable: true,
				width: 600,
				height: 800,
			});
		},
		openFn: () => {
			const DISPLAY_NAMES = {
				maps: "Maps",
				rolltables: "Rollable Tables",
				decks: "Decks",
				handouts: "Handouts",
				playlists: "Jukebox Playlists",
				tracks: "Jukebox Tracks",
				characters: "Characters",
			};

			const $win = $("#d20plus-module-importer");
			$win.dialog("open");

			const $winProgress = $(`#d20plus-module-importer-progress`);
			const $btnCancel = $winProgress.find(".cancel").off("click");

			const $win5etools = $(`#d20plus-module-importer-5etools`);

			const $winHelp = $(`#d20plus-module-importer-help`);
			const $btnHelp = $win.find(`.readme`).off("click").click(() => $winHelp.dialog("open"));

			const $winList = $(`#d20plus-module-importer-list`);
			const $wrpLst = $(`#module-importer-list`);
			const $lst = $winList.find(`.list`).empty();
			const $cbAll = $winList.find(`.select-all`).off("click").prop("disabled", true);
			const $iptSearch = $winList.find(`.search`).prop("disabled", true);
			const $btnConfirmSel = $winList.find(`[name="confirm-selection"]`).off("click");

			const $wrpSummary = $win.find(`[name="selection-summary"]`);
			const $wrpDataLoadingMessage = $win.find(`[name="data-loading-message"]`);

			const $btnImport = $win.find(`[name="import"]`).off("click").prop("disabled", true);
			const $btnViewCat = $win.find(`[name="view-select-entries"]`).off("click").prop("disabled", true);
			const $btnSelAllContent = $win.find(`[name="select-all-entries"]`).off("click").prop("disabled", true);

			const $selDataType = $win.find(`[name="data-type"]`).prop("disabled", true);
			let lastDataType = $selDataType.val();
			let genericFolder;
			let lastLoadedData = null;

			const getFreshSelected = () => ({
				characters: [],
				decks: [],
				handouts: [],
				maps: [],
				playlists: [],
				tracks: [],
				rolltables: [],
			});

			let selected = getFreshSelected();

			function handleLoadedData (data) {
				lastLoadedData = data;
				selected = getFreshSelected();
				$selDataType.prop("disabled", false);

				function updateSummary () {
					$wrpSummary.text(Object.entries(selected).filter(([prop, ents]) => ents && ents.length).map(([prop, ents]) => `${DISPLAY_NAMES[prop]}: ${ents.length} selected`).join("; "));
				}

				$btnViewCat.prop("disabled", false);
				$btnViewCat.off("click").click(() => {
					$winList.dialog("open");
					$iptSearch.prop("disabled", false);

					let prop = "";
					switch (lastDataType) {
						case "rolltables":
						case "decks":
						case "playlists":
						case "tracks":
						case "maps": {
							prop = lastDataType;
							break;
						}
						case "handouts": {
							prop = "handouts";
							genericFolder = d20plus.journal.makeDirTree(`Handouts`);
							break;
						}
						case "characters": {
							prop = "characters";
							genericFolder = d20plus.journal.makeDirTree(`Characters`);
							break;
						}
						default: throw new Error(`Unhandled data type: ${lastDataType}`);
					}

					const moduleData = data[prop] || [];
					moduleData.sort((a, b) => SortUtil.ascSortLower(
						(a.attributes && a.attributes.name) || a.name || a.title || "",
						(b.attributes && a.attributes.name) || a.name || b.title || "",
					));

					$lst.empty();
					moduleData.forEach((m, i) => {
						const img = lastDataType === "maps" ? m.attributes.thumbnail
							: (lastDataType === "characters" || lastDataType === "handouts" || lastDataType === "decks") ? m.attributes.avatar : "";

						$lst.append(`
									<label class="import-cb-label ${img ? `import-cb-label--img` : ""}" data-listid="${i}">
										<input type="checkbox">
										${img && img.trim() ? `<img class="import-label__img" src="${img}">` : ""}
										<span class="name col-9 readable">${(m.attributes && m.attributes.name) || m.name || m.title || ""}</span>
									</label>
								`);
					});

					const entryList = new List("module-importer-list", {
						valueNames: ["name"],
					});

					$cbAll.prop("disabled", false).off("click").click(() => {
						entryList.items.forEach(it => {
							$(it.elm).find(`input[type="checkbox"]`).prop("checked", $cbAll.prop("checked"));
						});
					});

					$btnConfirmSel.off("click").click(() => {
						const sel = entryList.items
							.filter(it => $(it.elm).find(`input`).prop("checked"))
							.map(it => moduleData[$(it.elm).attr("data-listid")]);

						$cbAll.prop("checked", false);
						$winList.dialog("close");
						selected[prop] = sel;
						updateSummary();
					});
				});

				$btnSelAllContent.prop("disabled", false);
				$btnSelAllContent.off("click").click(() => {
					Object.keys(selected).forEach(k => {
						selected[k] = data[k];
						updateSummary();
					});
				});

				$btnImport.prop("disabled", false).off("click").click(() => {
					const totalSelected = Object.values(selected).map(it => it ? it.length : 0).reduce((a, b) => a + b, 0);
					if (!totalSelected) return alert("No entries selected!");

					const $name = $winProgress.find(`.name`);
					const $remain = $winProgress.find(`.remaining`).text(`${totalSelected} remaining...`);
					const $errCount = $winProgress.find(`.errors`);
					const $errReasons = $winProgress.find(`.error-names`);
					let errCount = 0;

					$winProgress.dialog("open");

					const journal = data.journal ? MiscUtil.copy(data.journal).reverse() : null;

					let queue = [];
					let jukebox = {};
					Object.entries(selected).filter(([k, v]) => v && v.length).forEach(([prop, ents]) => {
						if (prop === "playlists") return jukebox.playlists = (jukebox.playlists || []).concat(ents);
						else if (prop === "tracks") return jukebox.tracks = (jukebox.tracks || []).concat(ents);

						ents = MiscUtil.copy(ents);

						// if importing journal items, make sure they get put back in the right order
						if (journal && (prop === "characters" || prop === "handouts")) {
							const nuQueue = [];

							journal.forEach(jIt => {
								const qIx = ents.findIndex(qIt => qIt.attributes.id === jIt.id);
								if (~qIx) nuQueue.push(ents.splice(qIx, 1)[0]);
							});
							ents.forEach(qIt => nuQueue.push(qIt)); // add anything that wasn't in the journal to the end of the queue
							ents = nuQueue;
						}

						const toAdd = ents.map(entry => ({entry, prop}));
						// do maps first
						if (prop === "maps") queue = toAdd.concat(queue);
						else queue = queue.concat(toAdd);
					});

					// reset the tool
					selected = getFreshSelected();
					$wrpSummary.text("");

					let isCancelled = false;
					let lastTimeout = null;
					$btnCancel.off("click").click(() => {
						isCancelled = true;
						if (lastTimeout != null) {
							clearTimeout(lastTimeout);
							doImport();
						}
					});
					const mapTimeout = d20plus.cfg.get("import", "importIntervalMap") || d20plus.cfg.getDefault("import", "importIntervalMap");
					const charTimeout = d20plus.cfg.get("import", "importIntervalCharacter") || d20plus.cfg.getDefault("import", "importIntervalCharacter");
					const handoutTimeout = d20plus.cfg.get("import", "importIntervalHandout") || d20plus.cfg.getDefault("import", "importIntervalHandout");
					const timeouts = {
						characters: charTimeout,
						decks: handoutTimeout,
						handouts: handoutTimeout,
						playlists: 0,
						tracks: 0,
						maps: mapTimeout,
						rolltables: handoutTimeout,
					};

					const addToJournal = (originalId, itId) => {
						let handled = false;
						if (journal) {
							const found = journal.find(it => it.id === originalId);
							if (found) {
								const rawPath = found.path;
								const cleanPath = rawPath.slice(1); // paths start with "Root"
								const folder = d20plus.journal.makeDirTree(...cleanPath);
								d20.journal.addItemToFolderStructure(itId, folder.id);
								handled = true;
							}
						}

						if (!handled) d20.journal.addItemToFolderStructure(itId, genericFolder.id);
					};

					const doImport = () => {
						if (isCancelled) {
							$name.text("Import cancelled.");
							$remain.text(`Cancelled with ${queue.length} remaining.`);
						} else if (queue.length && !isCancelled) {
							$remain.text(`${queue.length} remaining...`);
							const {entry, prop} = queue.shift();
							const timeout = timeouts[prop];
							const name = entry.attributes.name;
							try {
								$name.text(`Importing ${name}`);

								switch (prop) {
									case "maps": {
										const map = d20.Campaign.pages.create(entry.attributes);
										entry.graphics.forEach(it => map.thegraphics.create(it));
										entry.paths.forEach(it => map.thepaths.create(it));
										entry.text.forEach(it => map.thetexts.create(it));
										map.save();
										break;
									}
									case "rolltables": {
										const table = d20.Campaign.rollabletables.create(entry.attributes);
										table.tableitems.reset();
										const toSave = entry.tableitems.map(it => table.tableitems.push(it));
										toSave.forEach(s => s.save());
										table.save();
										break;
									}
									case "decks": {
										const deck = d20.Campaign.decks.create(entry.attributes);
										deck.cards.reset();
										const toSave = entry.cards.map(it => deck.cards.push(it));
										toSave.forEach(s => s.save());
										deck.save();
										break;
									}
									case "handouts": {
										d20.Campaign.handouts.create(entry.attributes,
											{
												success: function (handout) {
													handout.updateBlobs({
														notes: entry.blobNotes,
														gmnotes: entry.blobGmNotes,
													});

													addToJournal(entry.attributes.id, handout.id);
												},
											},
										);
										break;
									}
									case "characters": {
										d20.Campaign.characters.create(entry.attributes,
											{
												success: function (character) {
													character.attribs.reset();
													const toSave = entry.attribs.map(a => character.attribs.push(a));
													toSave.forEach(s => s.syncedSave());

													character.abilities.reset();
													if (entry.abilities) entry.abilities.map(a => character.abilities.push(a)).forEach(s => s.save());

													character.updateBlobs({
														bio: entry.blobBio,
														gmnotes: entry.blobGmNotes,
														defaulttoken: entry.blobDefaultToken,
													});

													addToJournal(entry.attributes.id, character.id);
												},
											},
										);
										break;
									}
									default: throw new Error(`Unhandled data type: ${prop}`);
								}
							} catch (e) {
								// eslint-disable-next-line no-console
								console.error(e);

								errCount++;
								$errCount.text(errCount);
								const prevReasons = $errReasons.text().trim();
								$errReasons.append(`${prevReasons.length ? ", " : ""}${name}: "${e.message}"`)
							}

							// queue up the next import
							lastTimeout = setTimeout(doImport, timeout);
						} else {
							$name.text("Import complete!");
							$remain.text(`${queue.length} remaining.`);
						}
					};

					if (Object.keys(jukebox).length) d20plus.jukebox.importWrappedData(jukebox);
					doImport();
				});
			}

			$selDataType.off("change").on("change", () => {
				lastDataType = $selDataType.val();
			});

			const $btnLoadVetools = $win.find(`[name="load-Vetools"]`);
			$btnLoadVetools.off("click").click(() => {
				$win5etools.dialog("open");
				const $btnLoad = $win5etools.find(`.load`).off("click");

				DataUtil.loadJSON(`${DATA_URL_MODULES}/roll20-module-index.json`).then(data => {
					const $lst = $win5etools.find(`.list`);
					const modules = data.map.sort((a, b) => SortUtil.ascSortLower(a.name, b.name));
					let tmp = "";
					modules.forEach((t, i) => {
						tmp += `
								<label class="import-cb-label" data-listid="${i}">
									<input type="radio" name="map-5etools">
									<span class="name col-5 readable">${t.name}</span>
									<span class="version col-1 readable" style="text-align: center;">${t.version || ""}</span>
									<span class="lat-modified col-2 readable" style="text-align: center;">${t.dateLastModified ? DatetimeUtil.getDateStr({date: new Date(t.dateLastModified * 1000), isShort: true}) : ""}</span>
									<span class="size col-1 readable" style="text-align: right;">${d20plus.ut.getReadableFileSizeString(t.size)}</span>
									<span title="${Parser.sourceJsonToFull(t.id)}" class="source readable" style="text-align: right;">SRC[${Parser.sourceJsonToAbv(t.id)}]</span>
								</label>
							`;
					});
					$lst.html(tmp);
					tmp = null;

					const list5etools = new List("module-importer-list-5etools", {
						valueNames: ["name"],
					});

					$btnLoad.on("click", () => {
						const sel = list5etools.items
							.filter(it => $(it.elm).find(`input`).prop("checked"))
							.map(it => modules[$(it.elm).attr("data-listid")])[0];

						$win5etools.dialog("close");
						$win.dialog("open");
						$wrpDataLoadingMessage.html("<i>Loading...</i>");
						DataUtil.loadJSON(`${DATA_URL_MODULES}/roll20-module-${sel.id.toLowerCase()}.json`)
							.then(moduleFile => {
								$wrpDataLoadingMessage.html("");
								return handleLoadedData(moduleFile);
							})
							.catch(e => {
								$wrpDataLoadingMessage.html("");
								// eslint-disable-next-line no-console
								console.error(e);
								alert(`Failed to load data! See the console for more information.`);
							});
					});
				}).catch(e => {
					// eslint-disable-next-line no-console
					console.error(e);
					alert(`Failed to load data! See the console for more information.`);
				});
			});

			// For content loaded from the R20 repo
			const $btnLoadDmsguild = $win.find(`[name="load-dmsguild"]`);
			$btnLoadDmsguild.off("click").click(() => {
				$win5etools.dialog("open");
				const $btnLoad = $win5etools.find(`.load`).off("click");
				// url for the repo
				const urlbase = "https://raw.githubusercontent.com/DMsGuild201/Roll20_resources/master/Module/";

				DataUtil.loadJSON(`${urlbase}index.json`).then(data => {
					const $lst = $win5etools.find(`.list`);
					const modules = data.map.sort((a, b) => SortUtil.ascSortLower(a.name, b.name));
					let tmp = "";
					// Display each module in the selector
					modules.forEach((t, i) => {
						tmp += `
								<label class="import-cb-label" data-listid="${i}">
									<input type="radio" name="map-5etools">
									<span class="name col-5 readable">${t.name}</span>
									<span class="version col-1 readable" style="text-align: center;">${t.version || ""}</span>
									<span class="lat-modified col-2 readable" style="text-align: center;">${t.dateLastModified ? DatetimeUtil.getDateStr({date: new Date(t.dateLastModified * 1000), isShort: true}) : ""}</span>
									<span class="size col-1 readable" style="text-align: right;">${t.size ? d20plus.ut.getReadableFileSizeString(t.size) : ""}</span>
									<span title="${Parser.sourceJsonToFull(t.id)}" class="source readable" style="text-align: right;">SRC[${Parser.sourceJsonToAbv(t.id)}]</span>
								</label>
							`;
					});
					$lst.html(tmp);
					tmp = null;

					const list5etools = new List("module-importer-list-5etools", {
						valueNames: ["name"],
					});

					$btnLoad.on("click", () => {
						const sel = list5etools.items
							.filter(it => $(it.elm).find(`input`).prop("checked"))
							.map(it => modules[$(it.elm).attr("data-listid")])[0];

						$win5etools.dialog("close");
						$win.dialog("open");
						$wrpDataLoadingMessage.html("<i>Loading...</i>");
						// Load the chosen module
						DataUtil.loadJSON(`${urlbase}${sel.filename}`)
							.then(moduleFile => {
								$wrpDataLoadingMessage.html("");
								return handleLoadedData(moduleFile);
							})
							.catch(e => {
								$wrpDataLoadingMessage.html("");
								// eslint-disable-next-line no-console
								console.error(e);
								alert(`Failed to load data! See the console for more information.`);
							});
					});
				}).catch(e => {
					// eslint-disable-next-line no-console
					console.error(e);
					alert(`Failed to load data! See the console for more information.`);
				});
			});

			// Load from file
			const $btnLoadFile = $win.find(`[name="load-file"]`);
			$btnLoadFile.off("click").click(async () => {
				const data = await DataUtil.pUserUpload();
				// Due to the new util functon, need to account for data being an array
				data.jsons.forEach(d => handleLoadedData(d));
			});

			const $winExportP1 = $("#d20plus-module-importer-select-exports-p1");
			const $cbAllExport = $winExportP1.find(`[name="cb-all"]`);

			const $btnExport = $win.find(`[name="export"]`);
			$btnExport.off("click").click(() => {
				const CATS = [
					"characters",
					"decks",
					"handouts",
					"playlists",
					"tracks",
					"maps",
					"rolltables",
				];

				$winExportP1.dialog("open");

				$cbAllExport.off("change").on("change", () => {
					CATS.forEach(cat => $winExportP1.find(`input[name="cb-${cat}"]`).prop("checked", $cbAllExport.prop("checked")))
				});

				$winExportP1.find("button").off("click").click(async () => {
					const isCatSelected = (name) => $winExportP1.find(`input[name="cb-${name}"]`).prop("checked");

					const catsToExport = new Set(CATS.filter(it => isCatSelected(it)));

					// eslint-disable-next-line no-console
					console.log("Exporting journal...");
					const journal = d20plus.journal.getExportableJournal();

					let maps;
					if (catsToExport.has("maps")) {
						// eslint-disable-next-line no-console
						console.log("Exporting maps..."); // shoutouts to Stormy
						maps = await Promise.all(d20.Campaign.pages.models.map(async map => {
							const getOut = () => {
								return {
									attributes: map.attributes,
									graphics: (map.thegraphics || []).map(g => g.attributes),
									text: (map.thetexts || []).map(t => t.attributes),
									paths: (map.thepaths || []).map(p => p.attributes),
								};
							};

							if (map.get("archived")) {
								map.set({archived: false});
								await d20plus.ut.promiseDelay(d20plus.cfg.getOrDefault("import", "importIntervalHandout") * 2);
								const out = getOut();
								map.set({archived: true});
								return out;
							} else {
								return getOut();
							}
						}));
					}

					let rolltables;
					if (catsToExport.has("rolltables")) {
						// eslint-disable-next-line no-console
						console.log("Exporting rolltables...");
						rolltables = d20.Campaign.rollabletables.models.map(rolltable => ({
							attributes: rolltable.attributes,
							tableitems: (rolltable.tableitems.models || []).map(tableitem => tableitem.attributes),
						}));
					}

					let decks;
					if (catsToExport.has("decks")) {
						// eslint-disable-next-line no-console
						console.log("Exporting decks...");
						decks = d20.Campaign.decks.models.map(deck => {
							if (deck.name && deck.name.toLowerCase() === "playing cards") return;
							return {
								attributes: deck.attributes,
								cards: (deck.cards.models || []).map(card => card.attributes),
							};
						}).filter(it => it);
					}

					let playlists;
					if (catsToExport.has("playlists")) {
						// eslint-disable-next-line no-console
						console.log("Exporting jukebox playlists...");
						playlists = d20plus.jukebox.getExportablePlaylists();
					}

					let tracks;
					if (catsToExport.has("tracks")) {
						// eslint-disable-next-line no-console
						console.log("Exporting jukebox tracks...");
						tracks = d20plus.jukebox.getExportableTracks();
					}

					let blobCount = 0;
					let onBlobsReady = null;
					let anyBlobs = false;

					const handleBlob = (addTo, asKey, data) => {
						addTo[asKey] = data;
						blobCount--;
						if (onBlobsReady && blobCount === 0) onBlobsReady();
					};

					let characters;
					if (catsToExport.has("characters")) {
						anyBlobs = true;
						// eslint-disable-next-line no-console
						console.log("Exporting characters...");
						characters = d20.Campaign.characters.models.map(character => {
							character.attribs.fetch(character.attribs);
							const out = {
								attributes: character.attributes,
								attribs: character.attribs,
							};
							const abilities = (character.abilities || {models: []}).models.map(ability => ability.attributes);
							if (abilities && abilities.length) out.abilities = abilities;
							blobCount += 3;
							character._getLatestBlob("bio", (data) => handleBlob(out, "blobBio", data));
							character._getLatestBlob("gmnotes", (data) => handleBlob(out, "blobGmNotes", data));
							character._getLatestBlob("defaulttoken", (data) => handleBlob(out, "blobDefaultToken", data));
							return out;
						});
					}

					let handouts;
					if (catsToExport.has("handouts")) {
						anyBlobs = true;
						// eslint-disable-next-line no-console
						console.log("Exporting handouts...");
						handouts = d20.Campaign.handouts.models.map(handout => {
							if (handout.attributes.name === ART_HANDOUT || handout.attributes.name === CONFIG_HANDOUT) return;

							const out = {
								attributes: handout.attributes,
							};
							blobCount += 2;
							handout._getLatestBlob("notes", (data) => handleBlob(out, "blobNotes", data));
							handout._getLatestBlob("gmnotes", (data) => handleBlob(out, "blobGmNotes", data));
							return out;
						}).filter(it => it);
					}

					// eslint-disable-next-line no-console
					if (anyBlobs) console.log("Waiting for blobs...");
					onBlobsReady = () => {
						// eslint-disable-next-line no-console
						if (anyBlobs) console.log("Blobs are ready!");

						// eslint-disable-next-line no-console
						console.log("Preparing payload");

						const payload = {
							schema_version: 1, // version number from r20es
						};
						if (maps) payload.maps = maps;
						if (rolltables) payload.rolltables = rolltables;
						if (decks) payload.decks = decks;
						if (journal) payload.journal = journal;
						if (handouts) payload.handouts = handouts;
						if (characters) payload.characters = characters;
						if (playlists) payload.playlists = playlists;
						if (tracks) payload.tracks = tracks;

						const filename = document.title.replace(/\|\s*Roll20$/i, "").trim().replace(/[^-\w]/g, "_");
						const data = JSON.stringify(payload, null, "\t");

						// eslint-disable-next-line no-console
						console.log("Saving");
						const blob = new Blob([data], {type: "application/json"});
						d20plus.ut.saveAs(blob, `${filename}.json`);
					};
					if (!anyBlobs || blobCount === 0) onBlobsReady();
				});

				// TODO
				/*
				macro
				 */
			});
		},
	})
}

SCRIPT_EXTENSIONS.push(baseToolModule);


function baseToolUnlock () {
	d20plus.tool.tools.push({
		toolId: "UNLOCKER",
		name: "Token Unlocker",
		desc: "Unlock previously-locked tokens",
		html: `
			<div id="d20plus-token-unlocker" title="Better20 - Token Unlocker">
				<p>
					<button class="btn" name="btn-refresh">Refresh</button>
				</p>
				<p class="split">
					<label><input type="checkbox" title="Select all" name="cb-all"> Select All</label> 
					<button class="btn" name="btn-unlock">Unlock Selected</button>
				</p>
				<div id="token-unlocker-list-container">
					<input class="search" autocomplete="off" placeholder="Search list..." style="width: 100%;">
					<br><br>
					<ul class="list unlock-list" style="max-height: 420px; overflow-y: scroll; display: block; margin: 0;"></ul>
				</div>
			</div>
		`,
		dialogFn: () => {
			const $win = $("#d20plus-token-unlocker").dialog({
				autoOpen: false,
				resizable: true,
				width: 800,
				height: 600,
			}).data("VE_HANDLE_UPDATE", () => {
				d20.engine.canvas._objects.forEach(ob => {
					if (ob.model) {
						const locked = ob.model.get("VeLocked");
						if (locked) {
							ob.lockMovementX = true;
							ob.lockMovementY = true;
							ob.lockScalingX = true;
							ob.lockScalingY = true;
							ob.lockRotation = true;
							ob.saveState();
						}
					}
				});
			});

			document.addEventListener("VePageChange", () => {
				$win.data("VE_HANDLE_UPDATE")();
			});

			document.addEventListener("VeLayerChange", () => {
				$win.data("VE_HANDLE_UPDATE")();
			});

			try {
				$win.data("VE_HANDLE_UPDATE")();
			} catch (e) {
				d20plus.ut.error("Failed to re-lock tokens!")
			}
		},
		openFn: () => {
			const $win = $("#d20plus-token-unlocker");
			$win.dialog("open");
			const $wrpCbs = $(`#token-unlocker-list-container`).find(`.unlock-list`);
			const $cbAll = $win.find(`[name="cb-all"]`);
			const $btnUnlock = $win.find(`[name="btn-unlock"]`);
			const $btnRefresh = $win.find(`[name="btn-refresh"]`).click(() => populateList());

			function populateList () {
				const objects = d20.engine.canvas._objects.filter(it => it.model && it.model.get("VeLocked"));
				$wrpCbs.empty();

				objects.forEach(it => {
					$wrpCbs.append(`
						<label class="import-cb-label" data-listid="${it.model.get("id")}">
							<input type="checkbox">
							<span class="name readable">${it.model.get("name") || `Unnamed${it.type ? ` ${it.type}` : ""}`}</span>
						</label>
					`);
				});

				// init list library
				const unlockList = new List("token-unlocker-list-container", {
					valueNames: ["name"],
					listClass: "unlock-list",
				});

				$cbAll.prop("checked", false);
				$cbAll.off("click").click(() => d20plus.importer._importToggleSelectAll(unlockList, $cbAll));

				$btnUnlock.off("click").on("click", () => {
					const sel = unlockList.items
						.filter(it => $(it.elm).find(`input`).prop("checked"))
						.map(it => $(it.elm).attr("data-listid"));

					if (!sel.length) {
						alert("No items selected!");
					} else {
						const currObjects = d20.engine.canvas._objects.filter(it => it.model);
						let counter = 0;
						sel.forEach(toUnlock => {
							const ob = currObjects.find(it => it.model && it.model.get("id") === toUnlock);
							if (ob) {
								counter++;
								ob.lockMovementX = false;
								ob.lockMovementY = false;
								ob.lockScalingX = false;
								ob.lockScalingY = false;
								ob.lockRotation = false;
								ob.saveState();

								ob.model.set("VeLocked", false);
								ob.model.save();
							}
						});
						alert(`${counter} item${counter === 1 ? "" : "s"} unlocked.`);
						populateList();
					}
				});
			}

			populateList();
		},
	})
}

SCRIPT_EXTENSIONS.push(baseToolUnlock);


function baseToolAnimator () {
	function cleanNulls (obj) {
		Object.entries(obj).filter(([k, v]) => v == null).forEach(([k]) => delete obj[k]);
		return obj;
	}

	d20plus.anim = {
		lineFromParsed (parsed) {
			const stack = [];
			const add = (...parts) => parts.forEach(p => stack.push(p == null ? "-" : p));

			stack.push(d20plus.anim.COMMAND_TO_SHORT[parsed._type]);
			stack.push(parsed.start || 0);

			switch (parsed._type) {
				case "Move":
				case "MoveExact": {
					stack.push(parsed.duration || 0);
					add(parsed.x, parsed.y, parsed.z);
					break;
				}
				case "Rotate":
				case "RotateExact": {
					stack.push(parsed.duration || 0);
					add(parsed.degrees);
					break;
				}
				case "Copy": {
					add(parsed.animation);
					break;
				}
				case "Flip":
				case "FlipExact": {
					add(parsed.flipH, parsed.flipV);
					break;
				}
				case "Scale":
				case "ScaleExact": {
					stack.push(parsed.duration || 0);
					add(parsed.scaleX, parsed.scaleY);
					break;
				}
				case "Layer": {
					add(parsed.layer);
					break;
				}
				case "Lighting":
				case "LightingExact": {
					stack.push(parsed.duration || 0);
					add(parsed.lightRadius, parsed.dimStart, parsed.degrees);
					break;
				}
				case "SetProperty":
				case "SumProperty": {
					add(parsed.prop, parsed.value);
					break;
				}
				case "TriggerMacro": {
					add(parsed.macro);
					break;
				}
				case "TriggerAnimation": {
					add(parsed.animation);
					break;
				}
				default: throw new Error(`Unhandled type "${parsed._type}"`);
			}

			return stack.join(" ");
		},

		deserialize: function (json) {
			let out;
			switch (json._type) {
				case "Nop": out = new d20plus.anim.Nop(); break;
				case "Move": out = new d20plus.anim.Move(json.startTime, json.duration, json.x, json.y, json.z); break;
				case "MoveExact": out = new d20plus.anim.MoveExact(json.startTime, json.duration, json.x, json.y, json.z); break;
				case "Copy": out = new d20plus.anim.Copy(json.startTime, json.childAnimation); break;
				case "Rotate": out = new d20plus.anim.Rotate(json.startTime, json.duration, json.degrees); break;
				case "RotateExact": out = new d20plus.anim.RotateExact(json.startTime, json.duration, json.degrees); break;
				case "Flip": out = new d20plus.anim.Flip(json.startTime, json.isHorizontal, json.isVertical); break;
				case "FlipExact": out = new d20plus.anim.FlipExact(json.startTime, json.isHorizontal, json.isVertical); break;
				case "Scale": out = new d20plus.anim.Scale(json.startTime, json.duration, json.scaleFactorX, json.scaleFactorY); break;
				case "ScaleExact": out = new d20plus.anim.ScaleExact(json.startTime, json.duration, json.scaleFactorX, json.scaleFactorY); break;
				case "Layer": out = new d20plus.anim.Layer(json.startTime, json.layer); break;
				case "SetProperty": out = new d20plus.anim.SetProperty(json.startTime, json.prop, json.value); break;
				case "SumProperty": out = new d20plus.anim.SumProperty(json.startTime, json.prop, json.value); break;
				case "Lighting": out = new d20plus.anim.Lighting(json.startTime, json.duration, json.lightRadius, json.dimStart, json.degrees); break;
				case "LightingExact": out = new d20plus.anim.LightingExact(json.startTime, json.duration, json.lightRadius, json.dimStart, json.degrees); break;
				case "TriggerMacro": out = new d20plus.anim.TriggerMacro(json.startTime, json.macroName); break;
				case "TriggerAnimation": out = new d20plus.anim.TriggerAnimation(json.startTime, json.animation); break;
				default: throw new Error(`Unhandled type "${json._type}"`);
			}
			out._hasRun = json._hasRun;
			out._offset = json._offset;
			out._progress = json._progress;
			out._snapshotDiff = json._snapshotDiff;
			return out;
		},

		// region animations
		// Each has `animate` which accepts up to four parameters:
		//   token: the token object being animated
		//   alpha: the absolute time since the start of the animation's life
		//   delta: the time delta from the last time the `animate` function was run
		//   queue: the queue this animation is part of
		// The `animate` function returns `true` if the token needs to be saved, `false` otherwise
		// Each should also have:
		//   `serialize` function
		//   `hasRun` function; returns `true` if the animation has been run, and can therefore be safely removed from any queues
		//   `setOffset` function; sets a start time offset for the animation. Used when triggering child animations
		_Base: function () {
			this._hasRun = false;
			this._offset = 0;
			this._progress = 0; // 0 - 1f
			this._snapshotDiff = null;

			this.hasRun = () => this._hasRun;
			this.setOffset = offset => this._offset = offset;
			this.isLastTick = () => !(this._progress < (1 - Number.EPSILON));
			this._serialize = () => {
				// remove any undefined properties
				const rawOut = {
					_type: this.constructor.name,
					_hasRun: this._hasRun,
					_offset: this._offset,
					_progress: this._progress,
					_snapshotDiff: this._snapshotDiff,
				};
				const out = {};
				Object.entries(rawOut).forEach(([k, v]) => {
					if (v != null) out[k] = v;
				});
				return out;
			};

			this._getTickProgress = (duration, delta) => {
				let mProgress = duration === 0 ? 1 : Math.min(1, delta / duration);
				// prevent progress from going past 100%
				if (this._progress + mProgress > 1) mProgress = 1 - this._progress;
				return mProgress;
			};
		},

		Nop: function () {
			d20plus.anim._Base.call(this);

			this.animate = function () {
				return false;
			};

			this.hasRun = () => true;
			this.serialize = () => {};
		},

		_BaseMove: function (startTime, duration, x, y, z) {
			d20plus.anim._Base.call(this);

			this.serialize = () => {
				return cleanNulls({
					...this._serialize(),
					startTime,
					duration,
					x,
					y,
					z,
				})
			};

			this._getCurrentZ = (token) => {
				const statuses = (token.attributes.statusmarkers || "").split(",");
				let total = 0;
				let pow = 1;
				let stack = "";

				// reverse loop through the fluffy wings, multiplying vals by 1/10/100...
				const len = statuses.length;
				for (let i = len - 1; i >= 0; --i) {
					const [name, val] = statuses[i].split("@");
					if (name === "fluffy-wing") {
						total += pow * Number(val);
						pow = pow * 10;
					} else {
						stack += `${statuses[i]},`;
					}
				}

				return {total, stack};
			};

			this._setCurrentZ = (token, stack, total) => {
				if (total) {
					const nums = String(Math.round(total)).split("");
					for (let i = 0; i < nums.length; ++i) {
						stack += `fluffy-wing@${nums[i]}${i < nums.length - 1 ? "," : ""}`;
					}
				} else stack = stack.replace(/,$/, "");

				token.attributes.statusmarkers = stack;
			};
		},

		Move: function (startTime, duration, x, y, z) {
			d20plus.anim._BaseMove.call(this, startTime, duration, x, y, z);

			this.animate = function (token, alpha, delta) {
				alpha = alpha - this._offset;

				if (alpha >= startTime) {
					if (this._progress < (1 - Number.EPSILON)) {
						const mProgress = this._getTickProgress(duration, delta);

						// handle movement
						if (x != null) token.attributes.left += mProgress * x;
						if (y != null) token.attributes.top -= mProgress * y;
						if (z != null) {
							let {total, stack} = this._getCurrentZ(token);
							total += mProgress * z;
							this._setCurrentZ(token, stack, total);
						}

						// update progress
						this._progress += mProgress;

						return true;
					} else this._hasRun = true;
				}
				return false;
			};
		},

		MoveExact: function (startTime, duration, x, y, z) {
			d20plus.anim._BaseMove.call(this, startTime, duration, x, y, z);

			this.animate = function (token, alpha, delta) {
				alpha = alpha - this._offset;

				if (alpha >= startTime) {
					if (this._snapshotDiff == null) {
						const {total} = this._getCurrentZ(token);
						this._snapshotDiff = {
							x: (x || 0) - (token.attributes.left || 0),
							y: (y || 0) - (token.attributes.top || 0),
							z: (z || 0) - (total),
						};
					}

					if (this._progress < (1 - Number.EPSILON)) {
						const mProgress = this._getTickProgress(duration, delta);

						// handle movement
						if (x != null) token.attributes.left += mProgress * this._snapshotDiff.x;
						if (y != null) token.attributes.top -= mProgress * this._snapshotDiff.y;
						if (z != null) {
							let {total, stack} = this._getCurrentZ(token);
							total += mProgress * this._snapshotDiff.z;
							this._setCurrentZ(token, stack, total);
						}

						// update progress
						this._progress += mProgress;

						// on the last tick, update to precise values
						if (this.isLastTick()) {
							if (x != null) token.attributes.left = x;
							if (y != null) token.attributes.top = -y;
							if (z != null) {
								let {stack} = this._getCurrentZ(token);
								this._setCurrentZ(token, stack, z);
							}
						}

						return true;
					} else this._hasRun = true;
				}
				return false;
			};
		},

		Copy: function (startTime, childAnimation = false) {
			d20plus.anim._Base.call(this);

			this.animate = function (token, alpha, delta, queue) {
				alpha = alpha - this._offset;

				if (!this._hasRun && alpha >= startTime) {
					this._hasRun = true;

					// based on "d20.clipboard.doCopy"
					const graphic = token.view.graphic;
					const attrs = {
						...MiscUtil.copy(graphic),
					};

					const modelattrs = {};
					const json = token.toJSON();
					d20.token_editor.tokenkeys.forEach(k => modelattrs[k] = json[k]);

					const cpy = {
						type: token.attributes.type,
						attrs,
						modelattrs,
						oldid: token.id,
						groupwith: "",
					};

					// based on "d20.clipboard.doPaste"
					let childToken;
					const page = d20.Campaign.pages.models.find(model => model.thegraphics.models.find(it => it.id === token.id));
					if (cpy.type === "image") {
						attrs.imgsrc = attrs.src;
						childToken = page.addImage(attrs, true, false, false, false, true);
						if (cpy.modelattrs && cpy.modelattrs.represents) {
							const char = d20.Campaign.characters.get(cpy.modelattrs.represents);

							if (char) {
								const updateBarN = (n) => {
									const prop = `bar${n}_link`;
									if (cpy.modelattrs[prop] !== "" && (cpy.modelattrs[prop].indexOf("sheetattr_") !== -1)) {
										const l = cpy.modelattrs[prop].split("sheetattr_")[1];
										setTimeout(() => char.updateTokensByName(l), 0.5);
									} else {
										const s = char.attribs.get(cpy.modelattrs[prop]);
										const l = s.get("name");
										setTimeout(() => char.updateTokensByName(l, cpy.modelattrs[prop]), 0.5);
									}
								};
								updateBarN(1);
								updateBarN(2);
								updateBarN(3);
							}
						}

						childToken && childToken.save(cpy.modelattrs);
					}

					if (childToken && childAnimation) {
						const nxt = new d20plus.anim.TriggerAnimation(startTime, childAnimation);
						nxt.animate(childToken, alpha, delta, queue);
					}
				}
				return false;
			};

			this.serialize = () => {
				return cleanNulls({
					...this._serialize(),
					startTime,
					childAnimation,
				})
			};
		},

		_BaseRotate: function (startTime, duration, degrees) {
			d20plus.anim._Base.call(this);

			this.serialize = () => {
				return cleanNulls({
					...this._serialize(),
					startTime,
					duration,
					degrees,
				})
			};
		},

		Rotate: function (startTime, duration, degrees) {
			d20plus.anim._BaseRotate.call(this, startTime, duration, degrees);

			this.animate = function (token, alpha, delta) {
				alpha = alpha - this._offset;

				if (alpha >= startTime) {
					if (this._progress < (1 - Number.EPSILON)) {
						const mProgress = this._getTickProgress(duration, delta);

						// handle rotation
						if (degrees != null) {
							const rot = mProgress * degrees;
							token.attributes.rotation += rot;
						}

						// update progress
						this._progress += mProgress;

						return true;
					} else this._hasRun = true;
				}
				return false;
			};
		},

		RotateExact: function (startTime, duration, degrees) {
			d20plus.anim._BaseRotate.call(this, startTime, duration, degrees);

			this.animate = function (token, alpha, delta) {
				alpha = alpha - this._offset;

				if (alpha >= startTime) {
					if (this._snapshotDiff == null) {
						this._snapshotDiff = {
							degrees: (degrees || 0) - Number(token.attributes.rotation || 0),
						};
					}

					if (this._progress < (1 - Number.EPSILON)) {
						const mProgress = this._getTickProgress(duration, delta);

						// handle rotation
						if (degrees != null) token.attributes.rotation += mProgress * this._snapshotDiff.degrees;

						// update progress
						this._progress += mProgress;

						// on the last tick, update to precise values
						if (this.isLastTick()) {
							if (degrees != null) token.attributes.rotation = degrees;
						}

						return true;
					} else this._hasRun = true;
				}
				return false;
			};
		},

		_BaseFlip: function (startTime, isHorizontal, isVertical) {
			d20plus.anim._Base.call(this);

			this.serialize = () => {
				return cleanNulls({
					...this._serialize(),
					startTime,
					isHorizontal,
					isVertical,
				})
			};
		},

		Flip: function (startTime, isHorizontal, isVertical) {
			d20plus.anim._BaseFlip.call(this, startTime, isHorizontal, isVertical);

			this.animate = function (token, alpha) {
				alpha = alpha - this._offset;

				if (!this._hasRun && alpha >= startTime) {
					this._hasRun = true;

					if (isHorizontal != null && isHorizontal) token.set("fliph", !(typeof token.get("fliph") === "string" ? token.get("fliph") === "true" : token.get("fliph")));
					if (isVertical != null && isVertical) token.set("flipv", !(typeof token.get("flipv") === "string" ? token.get("flipv") === "true" : token.get("flipv")));

					return true;
				}
				return false;
			};
		},

		FlipExact: function (startTime, isHorizontal, isVertical) {
			d20plus.anim._BaseFlip.call(this, startTime, isHorizontal, isVertical);

			this.animate = function (token, alpha) {
				alpha = alpha - this._offset;

				if (!this._hasRun && alpha >= startTime) {
					this._hasRun = true;

					if (isHorizontal != null) token.set("fliph", isHorizontal);
					if (isVertical != null) token.set("fliph", isVertical);

					return true;
				}
				return false;
			};
		},

		_BaseScale: function (startTime, duration, scaleFactorX, scaleFactorY) {
			d20plus.anim._Base.call(this);

			this.serialize = () => {
				return cleanNulls({
					...this._serialize(),
					startTime,
					duration,
					scaleFactorX,
					scaleFactorY,
				})
			};
		},

		Scale: function (startTime, duration, scaleFactorX, scaleFactorY) {
			d20plus.anim._BaseScale.call(this, startTime, duration, scaleFactorX, scaleFactorY);

			this.animate = function (token, alpha, delta) {
				alpha = alpha - this._offset;

				if (alpha >= startTime) {
					if (this._progress < (1 - Number.EPSILON)) {
						const mProgress = this._getTickProgress(duration, delta);

						// handle scaling
						if (scaleFactorX != null) {
							const mScaleX = mProgress * scaleFactorX;
							token.view.graphic.scaleX = Number(token.view.graphic.scaleX || 0) + mScaleX;
							token.attributes.scaleX = token.view.graphic.scaleX;
						}

						if (scaleFactorY != null) {
							const mScaleY = mProgress * scaleFactorY;
							token.view.graphic.scaleY = Number(token.view.graphic.scaleY || 0) + mScaleY;
							token.attributes.scaleY = token.view.graphic.scaleY;
						}

						// update progress
						this._progress += mProgress;

						return true;
					} else this._hasRun = true;
				}
				return false;
			};
		},

		ScaleExact: function (startTime, duration, scaleFactorX, scaleFactorY) {
			d20plus.anim._BaseScale.call(this, startTime, duration, scaleFactorX, scaleFactorY);

			this.animate = function (token, alpha, delta) {
				alpha = alpha - this._offset;

				if (alpha >= startTime) {
					if (this._snapshotDiff == null) {
						this._snapshotDiff = {
							scaleX: (scaleFactorX || 0) - (token.view.graphic.scaleX || 0),
							scaleY: (scaleFactorY || 0) - (token.view.graphic.scaleY || 0),
						};
					}

					if (this._progress < (1 - Number.EPSILON)) {
						const mProgress = this._getTickProgress(duration, delta);

						// handle scaling
						if (scaleFactorX != null) {
							token.view.graphic.scaleX += mProgress * this._snapshotDiff.scaleX;
							token.attributes.scaleX = token.view.graphic.scaleX;
						}

						if (scaleFactorY != null) {
							token.view.graphic.scaleY += mProgress * this._snapshotDiff.scaleY;
							token.attributes.scaleY = token.view.graphic.scaleY;
						}

						// update progress
						this._progress += mProgress;

						// on the last tick, update to precise values
						if (this.isLastTick()) {
							if (scaleFactorX != null) {
								token.view.graphic.scaleX = scaleFactorX;
								token.attributes.scaleX = token.view.graphic.scaleX;
							}

							if (scaleFactorY != null) {
								token.view.graphic.scaleY = scaleFactorY;
								token.attributes.scaleY = token.view.graphic.scaleY;
							}
						}

						return true;
					} else this._hasRun = true;
				}
				return false;
			};
		},

		Layer: function (startTime, layer) {
			d20plus.anim._Base.call(this);

			this.animate = function (token, alpha) {
				alpha = alpha - this._offset;

				if (!this._hasRun && alpha >= startTime) {
					this._hasRun = true;

					if (layer != null) {
						token.attributes.layer = layer;
					}

					return true;
				}
				return false;
			};

			this.serialize = () => {
				return cleanNulls({
					...this._serialize(),
					startTime,
					layer,
				})
			};
		},

		_BaseProperty: function (startTime, prop, value) {
			d20plus.anim._Base.call(this);

			this.serialize = () => {
				return cleanNulls({
					...this._serialize(),
					startTime,
					prop,
					value,
				})
			};
		},

		SumProperty: function (startTime, prop, value) {
			d20plus.anim._BaseProperty.call(this, startTime, prop, value);

			this.animate = function (token, alpha) {
				alpha = alpha - this._offset;

				if (!this._hasRun && alpha >= startTime) {
					this._hasRun = true;

					if (prop != null) {
						const curNum = Number(token.attributes[prop]);
						// eslint-disable-next-line no-eval
						token.attributes[prop] = (isNaN(curNum) ? 0 : curNum) + eval(value);
					}

					return true;
				}
				return false;
			};
		},

		// TODO consider making an alternate version which sets a property on the character
		// TODO consider the ability to set properties on _other_ tokens -- might not be performant enough?
		SetProperty: function (startTime, prop, value) {
			d20plus.anim._BaseProperty.call(this, startTime, prop, value);

			this.animate = function (token, alpha) {
				alpha = alpha - this._offset;

				if (!this._hasRun && alpha >= startTime) {
					this._hasRun = true;

					if (prop != null) {
						if (prop === "gmnotes") value = escape(value);
						else if (prop === "sides") value = value.split("|").map(it => escape(it)).join("|");
						token.attributes[prop] = value;
					}

					return true;
				}
				return false;
			};
		},

		_BaseLighting: function (startTime, duration, lightRadius, dimStart, degrees) {
			d20plus.anim._Base.call(this);

			this.serialize = () => {
				return cleanNulls({
					...this._serialize(),
					startTime,
					duration,
					lightRadius,
					dimStart,
					degrees,
				})
			};
		},

		Lighting: function (startTime, duration, lightRadius, dimStart, degrees) {
			d20plus.anim._BaseLighting.call(this, startTime, duration, lightRadius, dimStart, degrees);

			this.animate = function (token, alpha, delta) {
				alpha = alpha - this._offset;

				if (alpha >= startTime) {
					if (this._progress < (1 - Number.EPSILON)) {
						const mProgress = this._getTickProgress(duration, delta);

						// handle lighting changes
						if (lightRadius != null) token.attributes.light_radius = Number(token.attributes.light_radius || 0) + mProgress * lightRadius;
						if (dimStart != null) token.attributes.light_dimradius = Number(token.attributes.light_dimradius || 0) + mProgress * dimStart;
						if (degrees != null) {
							if (token.attributes.light_angle === "") token.attributes.light_angle = 360;
							token.attributes.light_angle = Number(token.attributes.light_angle || 0) + mProgress * degrees;
						}

						// update progress
						this._progress += mProgress;

						return true;
					} else this._hasRun = true;
				}
				return false;
			};
		},

		LightingExact: function (startTime, duration, lightRadius, dimStart, degrees) {
			d20plus.anim._BaseLighting.call(this, startTime, duration, lightRadius, dimStart, degrees);

			this.animate = function (token, alpha, delta) {
				alpha = alpha - this._offset;

				if (alpha >= startTime) {
					if (this._snapshotDiff == null) {
						this._snapshotDiff = {
							lightRadius: (lightRadius || 0) - Number(token.attributes.light_radius || 0),
							dimStart: (dimStart || 0) - Number(token.attributes.light_dimradius || 0),
							degrees: (degrees || 0) - Number(token.attributes.light_angle || 0),
						};
					}

					if (this._progress < (1 - Number.EPSILON)) {
						const mProgress = this._getTickProgress(duration, delta);

						// handle lighting changes
						if (lightRadius != null) token.attributes.light_radius = Number(token.attributes.light_radius) + mProgress * this._snapshotDiff.lightRadius;
						if (dimStart != null) token.attributes.light_dimradius = Number(token.attributes.light_dimradius) + mProgress * this._snapshotDiff.dimStart;
						if (degrees != null) token.attributes.light_angle = Number(token.attributes.light_angle) + mProgress * this._snapshotDiff.degrees;

						// update progress
						this._progress += mProgress;

						if (this.isLastTick()) {
							if (lightRadius != null) token.attributes.light_radius = lightRadius;
							if (dimStart != null) token.attributes.light_dimradius = dimStart;
							if (degrees != null) token.attributes.light_angle = degrees;
						}

						return true;
					} else this._hasRun = true;
				}
				return false;
			};
		},

		TriggerMacro: function (startTime, macroName) {
			d20plus.anim._Base.call(this);

			this.animate = function (token, alpha) {
				alpha = alpha - this._offset;

				if (!this._hasRun && alpha >= startTime) {
					this._hasRun = true;

					if (macroName != null) {
						d20.textchat.doChatInput(`#${macroName}`)
					}
				}
				return false;
			};

			this.serialize = () => {
				return cleanNulls({
					...this._serialize(),
					startTime,
					macroName,
				})
			};
		},

		TriggerAnimation: function (startTime, animation) {
			d20plus.anim._Base.call(this);

			this.animate = function (token, alpha, delta, queue) {
				alpha = alpha - this._offset;

				if (!this._hasRun && alpha >= startTime) {
					this._hasRun = true;

					if (animation != null) {
						const anim = d20plus.anim.animatorTool.getAnimationByName(animation);

						if (!anim) return false; // if it has been deleted/etc

						const nxtQueue = d20plus.anim.animatorTool.getAnimQueue(anim);
						nxtQueue.forEach(it => it.setOffset(alpha + this._offset));
						queue.push(...nxtQueue);
					}
				}
				return false;
			};

			this.serialize = () => {
				return cleanNulls({
					...this._serialize(),
					startTime,
					animation,
				})
			};
		},
		// endregion animations
	};

	function Command (line, error, Cons = null, parsed = null) {
		this.line = line;
		this.error = error;
		this.isRunnable = !!Cons;
		this.parsed = parsed;

		this.getInstance = function () {
			return new Cons();
		};
	}

	Command.errInvalidArgCount = function (line, ...counts) { return new Command(line, `Invalid argument count; expected ${counts.joinConjunct(", ", " or ")}`) };
	Command.errPropNum = function (line, prop, val) { return new Command(line, `${prop} "${val}" was not a number`) };
	Command.errPropBool = function (line, prop, val) { return new Command(line, `${prop} "${val}" was not a boolean`) };
	Command.errPropLayer = function (line, prop, val) { return new Command(line, `${prop} "${val}" was not a layer (valid layers are: ${d20plus.ut.LAYERS.joinConjunct(", ", " or ")})`) };
	Command.errPropToken = function (line, prop, val) { return new Command(line, `${prop} "${val}" was not a token property`) };
	Command.errValNeg = function (line, prop, val) { return new Command(line, `${prop} "${val}" was negative`) };

	Command.errStartNum = function (line, val) { return Command.errPropNum(line, "start time", val) };
	Command.errStartNeg = function (line, val) { return Command.errValNeg(line, "start time", val) };
	Command.errDurationNum = function (line, val) { return Command.errPropNum(line, "duration", val) };
	Command.errDurationNeg = function (line, val) { return Command.errValNeg(line, "duration", val) };

	Command.fromString = function (line) {
		const cleanLine = line
			.split(/\/\//g)[0] // handle comments
			.trim();
		const tokens = cleanLine.split(/ +/g).filter(Boolean);
		if (!tokens.length) return new Command(line);

		const op = tokens.shift();
		switch (op) {
			case "mv":
			case "mvx": {
				if (tokens.length !== 5) return Command.errInvalidArgCount(line, 5);
				const nStart = Number(tokens[0]);
				if (isNaN(nStart)) return Command.errStartNum(line, tokens[0]);
				if (nStart < 0) return Command.errStartNeg(line, tokens[0]);
				const nDuration = Number(tokens[1]);
				if (isNaN(nDuration)) return Command.errDurationNum(line, tokens[1]);
				if (nDuration < 0) return Command.errDurationNeg(line, tokens[1]);

				const nX = tokens[2] === "-" ? null : Number(tokens[2]);
				if (nX != null && isNaN(nX)) return Command.errPropNum(line, "x", tokens[2]);
				const nY = tokens[3] === "-" ? null : Number(tokens[3]);
				if (nY != null && isNaN(nY)) return Command.errPropNum(line, "y", tokens[3]);
				const nZ = tokens[4] === "-" ? null : Number(tokens[4]);
				if (nZ != null && isNaN(nY)) return Command.errPropNum(line, "z", tokens[4]);

				if (op === "mv") {
					return new Command(
						line,
						null,
						d20plus.anim.Move.bind(null, nStart, nDuration, nX, nY, nZ),
						{
							_type: "Move",
							start: nStart,
							duration: nDuration,
							x: nX,
							y: nY,
							z: nZ,
						},
					);
				} else {
					return new Command(
						line,
						null,
						d20plus.anim.MoveExact.bind(null, nStart, nDuration, nX, nY, nZ),
						{
							_type: "MoveExact",
							start: nStart,
							duration: nDuration,
							x: nX,
							y: nY,
							z: nZ,
						},
					);
				}
			}

			case "rot":
			case "rotx": {
				if (tokens.length !== 3) return Command.errInvalidArgCount(line, 3);
				const nStart = Number(tokens[0]);
				if (isNaN(nStart)) return Command.errStartNum(line, tokens[0]);
				if (nStart < 0) return Command.errStartNeg(line, tokens[0]);
				const nDuration = Number(tokens[1]);
				if (isNaN(nDuration)) return Command.errDurationNum(line, tokens[1]);
				if (nDuration < 0) return Command.errDurationNeg(line, tokens[1]);

				const nRot = tokens[2] === "-" ? null : Number(tokens[2]);
				if (nRot != null && isNaN(nRot)) return Command.errPropNum(line, "degrees", tokens[2]);

				if (op === "rot") {
					return new Command(
						line,
						null,
						d20plus.anim.Rotate.bind(null, nStart, nDuration, nRot),
						{
							_type: "Rotate",
							start: nStart,
							duration: nDuration,
							degrees: nRot,
						},
					);
				} else {
					return new Command(
						line,
						null,
						d20plus.anim.RotateExact.bind(null, nStart, nDuration, nRot),
						{
							_type: "RotateExact",
							start: nStart,
							duration: nDuration,
							degrees: nRot,
						},
					);
				}
			}

			case "cp": {
				if (tokens.length < 1 || tokens.length > 2) return Command.errInvalidArgCount(line, 1, 2);
				const nStart = Number(tokens[0]);
				if (isNaN(nStart)) return Command.errStartNum(line, tokens[0]);
				if (nStart < 0) return Command.errStartNeg(line, tokens[0]);

				const childAnim = tokens[1] === "-" ? null : tokens[1];

				return new Command(
					line,
					null,
					d20plus.anim.Copy.bind(null, nStart, childAnim),
					{
						_type: "Copy",
						start: nStart,
						animation: childAnim,
					},
				);
			}

			case "flip":
			case "flipx": {
				if (tokens.length !== 3) return Command.errInvalidArgCount(line, 3);
				const nStart = Number(tokens[0]);
				if (isNaN(nStart)) return Command.errStartNum(line, tokens[0]);
				if (nStart < 0) return Command.errStartNeg(line, tokens[0]);

				const flipH = tokens[1] === "-" ? null : tokens[1] === "true" ? true : tokens[1] === "false" ? false : undefined;
				if (flipH === undefined) return Command.errPropBool(line, "flipH", tokens[1]);
				const flipV = tokens[2] === "-" ? null : tokens[2] === "true" ? true : tokens[2] === "false" ? false : undefined;
				if (flipV === undefined) return Command.errPropBool(line, "flipV", tokens[2]);

				if (op === "flip") {
					return new Command(
						line,
						null,
						d20plus.anim.Flip.bind(null, nStart, flipH, flipV),
						{
							_type: "Flip",
							start: nStart,
							flipH: flipH,
							flipV: flipV,
						},
					);
				} else {
					return new Command(
						line,
						null,
						d20plus.anim.FlipExact.bind(null, nStart, flipH, flipV),
						{
							_type: "FlipExact",
							start: nStart,
							flipH: flipH,
							flipV: flipV,
						},
					);
				}
			}

			case "scale":
			case "scalex": {
				if (tokens.length !== 4) return Command.errInvalidArgCount(line, 4);
				const nStart = Number(tokens[0]);
				if (isNaN(nStart)) return Command.errStartNum(line, tokens[0]);
				if (nStart < 0) return Command.errStartNeg(line, tokens[0]);
				const nDuration = Number(tokens[1]);
				if (isNaN(nDuration)) return Command.errDurationNum(line, tokens[1]);
				if (nDuration < 0) return Command.errDurationNeg(line, tokens[1]);

				const nScaleX = tokens[2] === "-" ? null : Number(tokens[2]);
				if (nScaleX != null && isNaN(nScaleX)) return Command.errPropNum(line, "scaleX", tokens[2]);
				if (nScaleX != null && nScaleX < 0) return Command.errValNeg(line, "scaleX", tokens[2]);
				const nScaleY = tokens[3] === "-" ? null : Number(tokens[3]);
				if (nScaleY != null && isNaN(nScaleY)) return Command.errPropNum(line, "scaleY", tokens[3]);
				if (nScaleY != null && nScaleY < 0) return Command.errValNeg(line, "scaleY", tokens[3]);

				if (op === "scale") {
					return new Command(
						line,
						null,
						d20plus.anim.Scale.bind(null, nStart, nDuration, nScaleX, nScaleY),
						{
							_type: "Scale",
							start: nStart,
							duration: nDuration,
							scaleX: nScaleX,
							scaleY: nScaleY,
						},
					);
				} else {
					return new Command(
						line,
						null,
						d20plus.anim.ScaleExact.bind(null, nStart, nDuration, nScaleX, nScaleY),
						{
							_type: "ScaleExact",
							start: nStart,
							duration: nDuration,
							scaleX: nScaleX,
							scaleY: nScaleY,
						},
					);
				}
			}

			case "layer": {
				if (tokens.length !== 2) return Command.errInvalidArgCount(line, 2);
				const nStart = Number(tokens[0]);
				if (isNaN(nStart)) return Command.errStartNum(line, tokens[0]);
				if (nStart < 0) return Command.errStartNeg(line, tokens[0]);

				const layer = tokens[1] === "-" ? null : tokens[1];
				if (layer != null && !d20plus.anim.VALID_LAYER.has(layer)) return Command.errPropLayer(line, "layer", layer);

				return new Command(
					line,
					null,
					d20plus.anim.Layer.bind(null, nStart, layer),
					{
						_type: "Layer",
						start: nStart,
						layer: layer,
					},
				);
			}

			case "light":
			case "lightx": {
				if (tokens.length !== 5) return Command.errInvalidArgCount(line, 5);
				const nStart = Number(tokens[0]);
				if (isNaN(nStart)) return Command.errStartNum(line, tokens[0]);
				if (nStart < 0) return Command.errStartNeg(line, tokens[0]);
				const nDuration = Number(tokens[1]);
				if (isNaN(nDuration)) return Command.errDurationNum(line, tokens[1]);
				if (nDuration < 0) return Command.errDurationNeg(line, tokens[1]);

				const nLightRadius = tokens[2] === "-" ? null : Number(tokens[2]);
				if (nLightRadius != null && isNaN(nLightRadius)) return Command.errPropNum(line, "lightRadius", tokens[2]);
				const nDimStart = tokens[3] === "-" ? null : Number(tokens[3]);
				if (nDimStart != null && isNaN(nDimStart)) return Command.errPropNum(line, "dimStart", tokens[3]);
				const nDegrees = tokens[4] === "-" ? null : Number(tokens[4]);
				if (nDegrees != null && isNaN(nDegrees)) return Command.errPropNum(line, "degrees", tokens[4]);

				if (op === "light") {
					return new Command(
						line,
						null,
						d20plus.anim.Lighting.bind(null, nStart, nDuration, nLightRadius, nDimStart, nDegrees),
						{
							_type: "Lighting",
							start: nStart,
							duration: nDuration,
							lightRadius: nLightRadius,
							dimStart: nDimStart,
							degrees: nDegrees,
						},
					);
				} else {
					return new Command(
						line,
						null,
						d20plus.anim.LightingExact.bind(null, nStart, nDuration, nLightRadius, nDimStart, nDegrees),
						{
							_type: "LightingExact",
							start: nStart,
							duration: nDuration,
							lightRadius: nLightRadius,
							dimStart: nDimStart,
							degrees: nDegrees,
						},
					);
				}
			}

			case "prop":
			case "propSum": {
				if (tokens.length < 2) return Command.errInvalidArgCount(line, 3);
				const nStart = Number(tokens[0]);
				if (isNaN(nStart)) return Command.errStartNum(line, tokens[0]);
				if (nStart < 0) return Command.errStartNeg(line, tokens[0]);

				const prop = tokens[1] === "-" ? null : tokens[1];
				if (prop != null && !d20plus.anim.VALID_PROP_TOKEN.has(prop)) return Command.errPropToken(line, "prop", prop);
				let val = "";
				if (tokens.length > 2) val = tokens.slice(2, tokens.length).join(" "); // combine trailing tokens
				// eslint-disable-next-line no-console
				try { val = JSON.parse(val); } catch (ignored) { console.warn(`Failed to parse "${val}" as JSON, treating as raw string...`) }

				if (op === "propSum") {
					return new Command(
						line,
						null,
						d20plus.anim.SumProperty.bind(null, nStart, prop, val),
						{
							_type: "SumProperty",
							start: nStart,
							prop: prop,
							value: val,
						},
					);
				} else {
					return new Command(
						line,
						null,
						d20plus.anim.SetProperty.bind(null, nStart, prop, val),
						{
							_type: "SetProperty",
							start: nStart,
							prop: prop,
							value: val,
						},
					);
				}
			}

			case "macro": {
				if (tokens.length !== 2) return Command.errInvalidArgCount(line, 2);
				const nStart = Number(tokens[0]);
				if (isNaN(nStart)) return Command.errStartNum(line, tokens[0]);
				if (nStart < 0) return Command.errStartNeg(line, tokens[0]);

				// no validation for macro -- it might exist in the future if it doesn't now, or vice-versa
				const macro = tokens[1] === "-" ? null : tokens[1];

				return new Command(
					line,
					null,
					d20plus.anim.TriggerMacro.bind(null, nStart, macro),
					{
						_type: "TriggerMacro",
						start: nStart,
						macro: macro,
					},
				);
			}

			case "anim": {
				if (tokens.length !== 2) return Command.errInvalidArgCount(line, 2);
				const nStart = Number(tokens[0]);
				if (isNaN(nStart)) return Command.errStartNum(line, tokens[0]);
				if (nStart < 0) return Command.errStartNeg(line, tokens[0]);

				// no validation for animation -- it might exist in the future if it doesn't now, or vice-versa
				const animation = tokens[1] === "-" ? null : tokens[1];

				return new Command(
					line,
					null,
					d20plus.anim.TriggerAnimation.bind(null, nStart, animation),
					{
						_type: "TriggerAnimation",
						start: nStart,
						animation: animation,
					},
				);
			}
		}
	};

	d20plus.anim.animatorTool = {
		name: "Token Animator",
		desc: "Manage token animations",
		html: `
			<div id="d20plus-token-animator" title="Better20 - Token Animator" class="anm__win">
				<div class="split mb-2">
					<div>
						<button class="btn" name="btn-scenes">Edit Scenes</button>
						<button class="btn" name="btn-disable">Stop Animations</button>
						<button class="btn" name="btn-rescue">Rescue Tokens</button>
					</div>
					<div>
						<button class="btn" name="btn-saving" title="If enabled, can have a serious performance impact. If disabled, animations will not resume when reloading the game.">Save Active Animations</button>
					</div>
				</div>
				<div class="split mb-2">
					<button class="btn" name="btn-add">Add Animation</button>
					<button class="btn mr-2" name="btn-import">Import Animation</button>
				</div>

				<div class="anm__wrp-sel-all">
					<label class="flex-label"><input type="checkbox" title="Select all" name="cb-all" class="mr-2"> <span>Select All</span></label>
					<div>
						<button class="btn" name="btn-export">Export Selected</button>
						<button class="btn btn-danger" name="btn-delete">Delete Selected</button>
					</div>
				</div>

				<div id="token-animator-list-container">
					<input class="search" autocomplete="off" placeholder="Search list..." style="width: 100%;">
					<br><br>
					<ul class="list" style="max-height: 420px; overflow-y: auto; display: block; margin: 0;"></ul>
				</div>
			</div>

			<div id="d20plus-token-animator-disable" title="Stop Animation" class="anm__win">
				<p>
					<button class="btn" name="btn-refresh">Refresh</button>
				</p>

				<p class="anm__wrp-sel-all">
					<label class="flex-label"><input type="checkbox" title="Select all" name="cb-all" class="mr-2"> <span>Select All</span></label>
					<button class="btn" name="btn-stop">Stop Selected</button>
				</p>

				<div id="token-animator-disable-list-container">
					<input class="search" autocomplete="off" placeholder="Search list..." style="width: 100%;">
					<div class="bold flex-v-center mt-2">
						<div class="col-1"></div>
						<div class="col-3 text-center">Page</div>
						<div class="col-2 text-center">Image</div>
						<div class="col-3 text-center">Name</div>
						<div class="col-3 text-center">Animation</div>
					</div>
					<ul class="list" style="max-height: 420px; overflow-y: auto; display: block; margin: 0;"></ul>
				</div>
			</div>

			<div id="d20plus-token-animator-rescue" title="Token Rescue" class="anm__win">
				<p>
					<button class="btn mr-2" name="btn-refresh">Refresh</button>
				</p>

				<p class="anm__wrp-sel-all">
					<label class="flex-label"><input type="checkbox" title="Select all" name="cb-all" class="mr-2"> <span>Select All</span></label>
					<button class="btn" name="btn-rescue">Rescue Selected</button>
				</p>

				<div id="token-animator-rescue-list-container">
					<input class="search" autocomplete="off" placeholder="Search list..." style="width: 100%;">
					<div class="bold flex-v-center mt-2">
						<div class="col-1"></div>
						<div class="col-4 text-center">Page</div>
						<div class="col-2 text-center">Image</div>
						<div class="col-5 text-center">Name</div>
					</div>
					<ul class="list" style="max-height: 420px; overflow-y: auto; display: block; margin: 0;"></ul>
				</div>
			</div>

			<div id="d20plus-token-animator-scene" title="Scene List" class="anm__win">
				<div class="split mb-2">
					<button class="btn" name="btn-add">Add Scene</button>
					<button class="btn mr-2" name="btn-import">Import Scene</button>
				</div>

				<div class="anm__wrp-sel-all">
					<label class="flex-label"><input type="checkbox" title="Select all" name="cb-all" class="mr-2"> <span>Select All</span></label>
					<div>
						<button class="btn" name="btn-export">Export Selected</button>
						<button class="btn btn-danger" name="btn-delete">Delete Selected</button>
					</div>
				</div>

				<div id="token-animator-scene-list-container">
					<input class="search" autocomplete="off" placeholder="Search list..." style="width: 100%;">
					<br><br>
					<ul class="list" style="max-height: 420px; overflow-y: auto; display: block; margin: 0;"></ul>
				</div>
			</div>
		`,
		_html_template_editor: `
			<div title="Animation Editor" class="anm__win anm-edit__gui flex-col">
				<div class="mb-2 no-shrink split flex-vh-center">
					<input name="ipt-name" placeholder="Name">

					<div class="flex">
						<button class="btn mr-1" name="btn-save">Save</button>
						<button class="btn" name="btn-export-file">Export to File</button>

						<div class="anm-edit__gui-hidden flex">
							<button class="btn ml-2" name="btn-help">View Help</button>
							<button class="btn ml-1" name="btn-validate">Validate</button>
						</div>

						<div class="anm-edit__gui-visible flex">
							<button class="btn ml-2" name="btn-add-command">Add Command</button>
						</div>

						<button class="btn ml-2" name="btn-edit-text">Edit as Text</button>
					</div>
				</div>

				<div class="anm-edit__ipt-lines-wrp anm-edit__ipt-lines-wrp--gui anm-edit__gui-visible">

				</div>

				<div class="anm-edit__ipt-lines-wrp anm-edit__ipt-lines-wrp--text anm-edit__gui-hidden">
					<textarea name="ipt-lines" placeholder="mv 0 100 50 -50" class="anm-edit__ipt-lines"></textarea>
				</div>
			</div>
		`,
		_html_template_scene_editor: `
			<div title="Scene Editor" class="anm__win flex-col">
				<div class="mb-2 no-shrink split">
					<input name="ipt-name" placeholder="Name">

					<div>
						<button class="btn" name="btn-save">Save</button>
						<button class="btn" name="btn-export-file">Export to File</button>
					</div>
				</div>
				<div class="mb-2">
					<button class="btn" name="btn-add">Add Part</button>
				</div>
				<div class="bold flex-v-center mt-2">
					<div class="col-3 text-center">Token</div>
					<div class="col-2"></div>
					<div class="col-2 text-center">Animation</div>
					<div class="col-2"></div>
					<div class="col-2 text-center help" title="Delay period upon starting the scene before this animation is run (in milliseconds)">Start Time</div>
					<div class="col-1"></div>
				</div>
				<div class="anm-edit__ipt-rows-wrp">

				</div>
			</div>
		`,

		dialogFn () {
			$("#d20plus-token-animator").dialog({
				autoOpen: false,
				resizable: true,
				width: 800,
				height: 600,
			}).data("initialised", false);

			$("#d20plus-token-animator-disable").dialog({
				autoOpen: false,
				resizable: true,
				width: 800,
				height: 600,
			});

			$("#d20plus-token-animator-rescue").dialog({
				autoOpen: false,
				resizable: true,
				width: 800,
				height: 600,
			});

			$("#d20plus-token-animator-scene").dialog({
				autoOpen: false,
				resizable: true,
				width: 800,
				height: 600,
			});
		},

		openFn () {
			this.init();
			this.$win.dialog("open");
		},

		// region public
		init () {
			this.$win = this.$win || $("#d20plus-token-animator");
			if (!this.$win.data("initialised")) {
				this._meta_init();
				// init the runner after, as we need to first load the animations
				d20plus.anim.animator.init();
			}
		},

		getAnimation (uid) {
			return this._anims[uid];
		},

		getAnimationByName (name) {
			const fauxAnim = d20plus.anim.animatorTool.getAnimations().find(it => it.name === name);
			if (!fauxAnim) return null;
			return d20plus.anim.animatorTool.getAnimation(fauxAnim.uid);
		},

		getAnimQueue (anim, additionalOffset) {
			additionalOffset = additionalOffset || 0;
			this._edit_convertLines(anim);
			const queue = anim.lines.filter(it => it.isRunnable).map(it => it.getInstance());
			queue.forEach(it => it._offset += additionalOffset);
			return queue;
		},

		_getUidItems (fromObj) {
			return Object.entries(fromObj).map(([k, v]) => ({
				uid: k,
				name: v.name,
			}))
		},

		getAnimations () {
			return this._getUidItems(this._anims);
		},

		getScenes () {
			return this._getUidItems(this._scenes);
		},

		isSavingActive () {
			return !!this._isSaveActive;
		},

		_pSelectUid (fnGetAll, msgNoneFound, title, defaultSelUid) {
			// convert, as the UIDs are object keys
			if (defaultSelUid != null) defaultSelUid = String(defaultSelUid);

			const selFrom = fnGetAll();
			if (!selFrom.length) return d20plus.ut.chatLog(msgNoneFound);

			return new Promise(resolve => {
				const $selUid = $(`<select>
				<option disabled value="-1">${title}</option>
				${selFrom.map(it => `<option value="${it.uid}">${it.name}</option>`).join("")}
				</select>`);
				if (defaultSelUid != null && selFrom.find(it => it.uid === defaultSelUid)) $selUid.val(defaultSelUid);
				else $selUid[0].selectedIndex = 0;

				const $dialog = $$`
					<div title="${title}">
						${$selUid}
					</div>
				`.appendTo($("body"));

				$dialog.dialog({
					dialogClass: "no-close",
					buttons: [
						{
							text: "Cancel",
							click: function () {
								$(this).dialog("close");
								$dialog.remove();
							},
						},
						{
							text: "OK",
							click: function () {
								const selected = Number(d20plus.ut.get$SelValue($selUid));
								$(this).dialog("close");
								$dialog.remove();

								if (~selected) resolve(selected);
								else resolve(null);
							},
						},
					],
				});
			});
		},

		pSelectAnimation (defaultSelUid) {
			return this._pSelectUid(
				this.getAnimations.bind(this),
				`No animations available! Use the Token Animator tool to define some first. See <a href="${d20plus.ut.WIKI_URL}/index.php/Feature:_Animator" target="_blank">the Wiki for help.</a>`,
				"Select Animation",
				defaultSelUid,
			);
		},

		pSelectScene (defaultSelUid) {
			return this._pSelectUid(
				this.getScenes.bind(this),
				`No scenes available! Use Edit Scenes in the Token Animator tool to define some first. See <a href="${d20plus.ut.WIKI_URL}/index.php/Feature:_Animator" target="_blank">the Wiki for help.</a>`,
				"Select Scene",
				defaultSelUid,
			);
		},

		doStartScene (sceneUid) {
			const scene = this._scenes[sceneUid];
			if (!scene) return d20plus.ut.chatLog(`Could not find scene!`);

			(scene.anims || []).forEach(animMeta => {
				if (animMeta.tokenId && animMeta.animUid) {
					const token = d20plus.ut.getTokenById(animMeta.tokenId);
					if (!token) return;
					const anim = this.getAnimation(animMeta.animUid);
					if (!anim) return;
					d20plus.anim.animator.startAnimation(token, animMeta.animUid, {offset: animMeta.offset || 0});
				}
			});
		},
		// endregion public

		// region meta
		_meta_doSaveState () {
			// copy, and return any parsed commands to strings
			const saveableAnims = {};
			Object.entries(this._anims).forEach(([k, v]) => {
				saveableAnims[k] = {
					...v,
					lines: [...(v.lines || [])].map(it => typeof it === "string" ? it : it.line),
				}
			});

			Campaign.save({
				bR20tool__anim_id: this._anim_id,
				bR20tool__anim_animations: saveableAnims,
				bR20tool__anim_save: this._isSaveActive,
				bR20tool__anim_scene_id: this._scene_id,
				bR20tool__anim_scenes: this._scenes,
			});
		},

		_meta_doLoadState () {
			this._anim_id = Campaign.attributes.bR20tool__anim_id || 1;
			this._scene_id = Campaign.attributes.bR20tool__anim_scene_id || 1;

			// convert legacy "array" versions to objects
			this._anims = {};
			if (Campaign.attributes.bR20tool__anim_animations) {
				const loadedAnims = MiscUtil.copy(Campaign.attributes.bR20tool__anim_animations);
				Object.entries(loadedAnims).filter(([k, v]) => !!v).forEach(([k, v]) => this._anims[k] = v);
			}

			this._scenes = {};
			if (Campaign.attributes.bR20tool__anim_scenes) {
				const loadedScenes = MiscUtil.copy(Campaign.attributes.bR20tool__anim_scenes);
				Object.entries(loadedScenes).filter(([k, v]) => !!v).forEach(([k, v]) => this._scenes[k] = v);
			}

			this._isSaveActive = Campaign.attributes.bR20tool__anim_save || false;
		},

		_meta_init () {
			this._meta_doLoadState();
			this._doSaveStateDebounced = MiscUtil.debounce(this._meta_doSaveState, 100);

			this._$winScene = $(`#d20plus-token-animator-scene`);
			this._$winDisable = $(`#d20plus-token-animator-disable`);
			this._$winRescue = $(`#d20plus-token-animator-rescue`);

			this._main_init();
			this._scene_init();
			this._rescue_init();
			this._dis_init();
			this.$win.data("initialised", true);
		},
		// endregion meta

		// region shared
		async _shared_doImport (prop, name, fnNextId, fnNextName, fnGetValidMsg, fnAdd, ...requiredProps) {
			let data;
			try {
				data = await DataUtil.pUserUpload();
			} catch (e) {
				d20plus.ut.chatLog("File was not valid JSON!");
				// eslint-disable-next-line no-console
				console.error(e);
				return;
			}

			// Done as a quick fix to account for the pUserUpload lib function changing
			data = data[0];

			if (data[prop] && data[prop].length) {
				let messages = [];
				data[prop].forEach((it, i) => {
					const missingProp = requiredProps.find(rp => it[rp] == null);
					if (missingProp != null) messages.push(`${name.uppercaseFirst()} at index ${i} is missing required fields!`);
					else {
						const originalName = it.name;
						it.uid = fnNextId();
						it.name = fnNextName(it.name);
						const msg = fnGetValidMsg(it);
						if (msg) {
							messages.push(`${originalName} was invalid: ${msg}`);
						} else {
							fnAdd(it);
							messages.push(`Added ${originalName}${it.name !== originalName ? ` (renamed as ${it.name})` : ""}!`);
						}
					}
				});

				if (messages.length) {
					// eslint-disable-next-line no-console
					console.log(messages.join("\n"));
					return d20plus.ut.chatLog(messages.join("\n"))
				}
			} else {
				return d20plus.ut.chatLog(`File contained no ${name}s!`);
			}
		},

		_shared_getValidNameMsg (obj, peers) {
			if (!obj.name.length) return "Did not have a name!";
			const illegalNameChars = obj.name.split(/[_0-9a-zA-Z]/g).filter(Boolean);
			if (illegalNameChars.length) return `Illegal characters in name: ${illegalNameChars.map(it => `"${it}"`).join(", ")}`;
			const sameName = Object.values(peers).filter(it => it.uid !== obj.uid).find(it => it.name === obj.name);
			if (sameName) return "Name must be unique!";
		},

		_shared_getNextName (obj, baseName) {
			let nxtName = baseName;
			let suffix = 1;
			while (Object.values(obj).find(it => it.name === nxtName)) nxtName = `${baseName}_${suffix++}`;
			return nxtName;
		},
		// endregion

		// region main
		_main_init () {
			const $btnAdd = this.$win.find(`[name="btn-add"]`);
			const $btnImport = this.$win.find(`[name="btn-import"]`);
			const $btnDisable = this.$win.find(`[name="btn-disable"]`);
			const $btnScenes = this.$win.find(`[name="btn-scenes"]`);
			const $btnRescue = this.$win.find(`[name="btn-rescue"]`);
			const $btnToggleSave = this.$win.find(`[name="btn-saving"]`);

			const $btnSelExport = this.$win.find(`[name="btn-export"]`);
			const $btnSelDelete = this.$win.find(`[name="btn-delete"]`);

			const $cbAll = this.$win.find(`[name="cb-all"]`);
			this._$list = this.$win.find(`.list`);

			$btnAdd.click(() => this._main_addAnim(this._main_getNewAnim()));

			$btnImport.click(async () => {
				await this._shared_doImport(
					"animations",
					"animation",
					this._main_getNextId.bind(this),
					this._shared_getNextName.bind(this, this._anims),
					this._edit_getValidationMessage.bind(this),
					this._main_addAnim.bind(this),
					"uid", "name", "lines", // required properties
				);
			});

			$btnScenes.click(() => {
				this._scene_doPopulateList();
				this._$winScene.dialog("open");
			});

			$btnDisable.click(() => {
				this._dis_doPopulateList();
				this._$winDisable.dialog("open");
			});

			$btnRescue.click(() => {
				this._rescue_doPopulateList();
				this._$winRescue.dialog("open")
			});

			$btnToggleSave.toggleClass("active", this._isSaveActive);
			$btnToggleSave.click(() => {
				this._isSaveActive = !this._isSaveActive;
				$btnToggleSave.toggleClass("active", this._isSaveActive);
				this._doSaveStateDebounced();

				// on disable, clear existing running animations
				// prevents next load from re-loading old running state
				if (!this._isSaveActive) {
					setTimeout(() => Campaign.save({bR20tool__anim_running: {}}), 100);
				}
			});

			const getSelButtons = ofClass => {
				return this._anim_list.items
					.map(it => $(it.elm))
					.filter($it => $it.find(`input`).prop("checked"))
					.map($it => $it.find(`.${ofClass}`));
			};

			$btnSelExport.click(() => {
				const out = {
					animations: this._anim_list.items
						.filter(it => $(it.elm).find(`input`).prop("checked"))
						.map(it => this._main_getExportableAnim(this._anims[it.values().uid])),
				};
				d20plus.ut.saveAsJson("animations", out);
			});

			$cbAll.click(() => {
				const val = $cbAll.prop("checked");
				this._anim_list.items.forEach(it => {
					$(it.elm.children[0].children[0]).prop("checked", val);
				})
			});

			$btnSelDelete.click(() => {
				const $btns = getSelButtons(`.anm__btn-delete`);
				if (!$btns.length) return;
				if (!confirm("Are you sure?")) return;
				$btns.forEach($btn => $btn.click());
			});

			this._main_doPopulateList();
		},

		_main_getExportableAnim (anim) {
			const out = {...anim};
			out.lines = out.lines.map(it => typeof it === "string" ? it : it.line);
			return out;
		},

		_main_doPopulateList () {
			this._$list.empty();
			Object.values(this._anims).forEach(anim => this._$list.append(this._main_getListItem(anim)));

			this._anim_list = new List("token-animator-list-container", {
				valueNames: ["name", "uid"],
			});
		},

		_main_addAnim (anim) {
			const lastSearch = d20plus.ut.getSearchTermAndReset(this._anim_list);
			this._anims[anim.uid] = anim;
			this._$list.append(this._main_getListItem(anim));

			this._anim_list.reIndex();
			if (lastSearch) this._anim_list.search(lastSearch);
			this._anim_list.sort("name");

			this._doSaveStateDebounced();
		},

		_main_getNewAnim () {
			return {
				uid: this._main_getNextId(),
				name: this._shared_getNextName(this._anims, "new_animation"),
				lines: [],
			}
		},

		_main_getNextId () {
			return this._anim_id++;
		},

		_main_getListItem (anim) {
			const $name = $(`<div class="name readable col-9 clickable" title="Edit Animation">${anim.name}</div>`)
				.click(() => this._edit_openEditor(anim));

			const $btnDuplicate = $(`<div class="btn anm__row-btn pictos mr-2" title="Duplicate">F</div>`)
				.click(() => {
					const copy = MiscUtil.copy(anim);
					copy.name = `${copy.name}_copy`;
					copy.uid = this._anim_id++;
					this._main_addAnim(copy);
				});

			const $btnExport = $(`<div class="btn anm__row-btn pictos mr-2" title="Export to File">I</div>`)
				.click(() => {
					const out = {animations: [this._main_getExportableAnim(anim)]};
					d20plus.ut.saveAsJson(`${anim.name}`, out);
				});

			const $btnDelete = $(`<div class="btn anm__row-btn btn-danger pictos anm__btn-delete mr-2" title="Delete">#</div>`)
				.click(() => {
					delete this._anims[anim.uid];
					this._anim_list.remove("uid", anim.uid);
					this._doSaveStateDebounced();
				});

			return $$`<div class="anm__row">
				<label class="col-1 flex-vh-center full-height"><input type="checkbox"></label>
				${$name}
				<div class="anm__row-controls col-2 text-center">
					${$btnDuplicate}
					${$btnExport}
					${$btnDelete}
				</div>
				<div class="hidden uid">${anim.uid}</div>
			</div>`;
		},
		// endregion main

		// region scene
		_scene_getSelected () {
			return this._scene_list.items.filter(it => $(it.elm).find("input[type=checkbox]").prop("checked"));
		},

		_scene_addScene (scene) {
			// eslint-disable-next-line no-console
			if (scene == null) return console.error(`Scene was null!`);

			const lastSearch = d20plus.ut.getSearchTermAndReset(this._scene_list);
			this._scenes[scene.uid] = scene;
			this._scene_$wrpList.append(this._scene_$getListItem(scene));

			this._scene_list.reIndex();
			if (lastSearch) this._scene_list.search(lastSearch);
			this._scene_list.sort("name");

			this._doSaveStateDebounced();
		},

		_scene_$getListItem (scene) {
			const $name = $(`<div class="name readable col-9 clickable" title="Edit Animation">${scene.name}</div>`)
				.click(() => this._scene_openEditor(scene));

			const $btnDuplicate = $(`<div class="btn anm__row-btn pictos mr-2" title="Duplicate">F</div>`)
				.click(() => {
					const copy = MiscUtil.copy(scene);
					copy.name = `${copy.name}_copy`;
					copy.uid = this._scene_id++;
					this._scene_addScene(copy);
				});

			const $btnExport = $(`<div class="btn anm__row-btn pictos mr-2" title="Export to File">I</div>`)
				.click(() => {
					const out = {scenes: [scene]};
					d20plus.ut.saveAsJson(`${scene.name}`, out);
				});

			const $btnDelete = $(`<div class="btn anm__row-btn btn-danger pictos anm__btn-delete mr-2" title="Delete">#</div>`)
				.click(() => {
					delete this._scenes[scene.uid];
					this._scene_list.remove("uid", scene.uid);
					this._doSaveStateDebounced();
				});

			return $$`<div class="flex-v-center mb-2">
				<label class="col-1 flex-vh-center full-height"><input type="checkbox"></label>
				${$name}
				<div class="anm__row-controls col-2 text-center">
					${$btnDuplicate}
					${$btnExport}
					${$btnDelete}
				</div>
				<div class="uid hidden">${scene.uid}</div>
			</div>`
		},

		_scene_doPopulateList () {
			this._scene_$wrpList.empty();
			Object.values(this._scenes).forEach(scene => this._scene_$wrpList.append(this._scene_$getListItem(scene)));

			this._scene_list = new List("token-animator-scene-list-container", {
				valueNames: [
					"name",
					"uid",
				],
			});
		},

		_scene_init () {
			this._scene_$btnAdd = this._$winScene.find(`[name="btn-add"]`);
			this._scene_$btnImport = this._$winScene.find(`[name="btn-import"]`);
			this._scene_$btnExport = this._$winScene.find(`[name="btn-export"]`);
			this._scene_$btnDelete = this._$winScene.find(`[name="btn-delete"]`);
			this._scene_$cbAll = this._$winScene.find(`[name="cb-all"]`);
			this._scene_$wrpList = this._$winScene.find(`.list`);

			this._scene_list = null;

			this._scene_$cbAll.click(() => {
				const toVal = this._scene_$cbAll.prop("checked");
				this._scene_list.items.forEach(it => $(it.elm).find("input[type=checkbox]").prop("checked", toVal));
			});

			this._scene_$btnAdd.off("click").click(() => this._scene_addScene(this._scene_getNewScene()));

			this._scene_$btnImport.click(async () => {
				await this._shared_doImport(
					"scenes",
					"scene",
					this._scene_getNextId.bind(this),
					this._shared_getNextName.bind(this, this._scenes),
					this._scene_getValidationMessage.bind(this),
					this._scene_addScene.bind(this),
					"uid", "name", "anims", // required properties
				);
			});

			this._scene_$btnExport.click(() => {
				const out = {
					scenes: this._scene_getSelected()
						.map(it => this._scenes[it.values().uid]),
				};
				d20plus.ut.saveAsJson("scenes", out);
			});

			this._scene_$btnDelete.click(() => {
				const sel = this._scene_getSelected();
				if (!sel.length) return;
				if (!confirm("Are you sure?")) return;
				sel.forEach(it => {
					const uid = it.values()._scene_id;
					delete this._scenes[uid];
					this._scene_list.remove("uid", uid);
				});
				this._doSaveStateDebounced();
			});
		},

		_scene_getNextId () {
			return this._scene_id++;
		},

		_scene_getNewScene () {
			return {
				uid: this._scene_getNextId(),
				name: this._shared_getNextName(this._scenes, "new_scene"),
				anims: [],
				/*
				Anims array structure:
				[
					...,
					{
						tokenId: "",
						animUid: "",
						offset: 0
					},
					...
				]
				 */
			}
		},

		_scene_openEditor (scene) {
			scene = MiscUtil.copy(scene);
			scene.anims = scene.anims || []; // handle legacy data
			const editorOptions = {};

			const $winEditor = $(this._html_template_scene_editor)
				.attr("title", `Scene Editor - ${scene.name}`)
				.appendTo($("body"));

			const $iptName = $winEditor.find(`[name="ipt-name"]`).disableSpellcheck()
				.val(scene.name)
				.change(() => {
					scene.name = $iptName.val().trim();
					$winEditor.dialog("option", "title", `Scene Editor - ${$iptName.val()}`);
				});
			const $btnSave = $winEditor.find(`[name="btn-save"]`);
			const $btnExportFile = $winEditor.find(`[name="btn-export-file"]`);
			const $btnAdd = $winEditor.find(`[name="btn-add"]`);
			const $wrpRows = $winEditor.find(`.anm-edit__ipt-rows-wrp`);

			$btnSave.off("click").click(() => {
				const msg = this._scene_getValidationMessage(scene);
				if (msg) return d20plus.ut.chatLog(msg);

				// we passed validation
				this._scenes[scene.uid] = scene;

				this._doSaveStateDebounced();

				const matches = this._scene_list.get("uid", scene.uid);
				if (matches.length) {
					matches[0].values({name: scene.name})
				}

				d20plus.ut.chatLog("Saved!");
			});

			$btnExportFile.off("click").click(() => {
				const out = {scenes: [scene]};
				d20plus.ut.saveAsJson(`${scene.name}`, out);
			});

			$btnAdd.off("click").click(() => $wrpRows.append(this._scene_$getEditorRow(editorOptions, scene)));

			$wrpRows.empty();
			scene.anims.forEach(animMeta => $wrpRows.append(this._scene_$getEditorRow(editorOptions, scene, animMeta)));

			$winEditor.dialog({
				resizable: true,
				width: 800,
				height: 600,
				close: () => {
					setTimeout(() => $winEditor.remove())
				},
			});
		},

		_scene_$getEditorRow (editorOptions, scene, animMeta) {
			if (!animMeta) {
				animMeta = {
					offset: 0,
				};
				scene.anims.push(animMeta);
			}

			const $btnSelToken = $(`<button class="btn anm__row-btn">Select Token</button>`)
				.click(() => {
					let lastSelectedTokenId = null;
					const $wrpTokens = $$`<div class="anm-scene__wrp-tokens"></div>`;

					const $selPage = $(`<select><option disabled value="">Select Page</option></select>`)
						.change(() => {
							lastSelectedTokenId = null;
							$wrpTokens.empty();

							const page = d20.Campaign.pages.get(d20plus.ut.get$SelValue($selPage));
							editorOptions.lastPageId = d20plus.ut.get$SelValue($selPage);

							if (page.thegraphics && page.thegraphics.length) {
								const tokens = page.thegraphics.models
									.filter(it => it.attributes.type === "image")
									.map(it => ({
										id: it.id,
										name: it.attributes.name || "(Unnamed)",
										imgsrc: it.attributes.imgsrc,
									}))
									.sort((a, b) => SortUtil.ascSortLower(a.name, b.name));
								tokens.forEach(it => {
									const $wrpToken = $$`<div class="anm-scene__wrp-token">
											<div class="no-shrink flex-vh-center" style="width: 80px; height: 80px;">
												<img
													class="no-shrink"
													style="max-width: 80px; max-height: 80px;"
													src="${it.imgsrc}"
												>
											</div>
											<div class="no-shrink full-width flex-vh-center anm-scene__wrp-token-name">
												<span title="${it.name}" class="anm-scene__wrp-token-name-inner">${it.name}</span>
											</div>
										</div>`.click(() => {
		$wrpTokens.find(`.anm-scene__wrp-token`).removeClass(`anm-scene__wrp-token--active`);
		$wrpToken.addClass(`anm-scene__wrp-token--active`);
		lastSelectedTokenId = it.id;
	}).appendTo($wrpTokens);
								});
							} else $wrpTokens.append("There are no tokens on this page!");
						});
					// TODO alphabetise pages
					d20.Campaign.pages
						.forEach(it => $(`<option value="${it.id}"></option>`).text(it.attributes.name || "(Unnamed)").appendTo($selPage));
					// default re-display last page
					if (editorOptions.lastPageId && d20.Campaign.pages.get(editorOptions.lastPageId)) $selPage.val(editorOptions.lastPageId).change();
					else $selPage[0].selectedIndex = 0;

					const $dialog = $$`
							<div title="Select Token">
								<div class="flex-col full-width full-height">
									<div class="mb-2 no-shrink">${$selPage}</div>
									${$wrpTokens}
								</div>
							</div>
						`.appendTo($("body"));

					$dialog.dialog({
						dialogClass: "no-close",
						buttons: [
							{
								text: "Cancel",
								click: function () {
									$(this).dialog("close");
									$dialog.remove();
								},
							},
							{
								text: "OK",
								click: function () {
									$(this).dialog("close");
									$dialog.remove();

									if (lastSelectedTokenId != null) {
										animMeta.tokenId = lastSelectedTokenId;
										$wrpToken.html(getTokenPart());
										$wrpTokenName.html(getTokenNamePart());
									}
								},
							},
						],
						width: 640,
						height: 480,
					});
				});
			const getTokenPart = () => {
				const token = animMeta.tokenId ? d20plus.ut.getTokenById(animMeta.tokenId) : null;
				return token ? `<img src="${token.attributes.imgsrc}" style="max-width: 40px; max-height: 40px;">` : "";
			};
			const getTokenNamePart = () => {
				const token = animMeta.tokenId ? d20plus.ut.getTokenById(animMeta.tokenId) : null;
				return token ? token.attributes.name : "";
			};
			const $wrpToken = $(`<div>${getTokenPart()}</div>`);
			const $wrpTokenName = $(`<div>${getTokenNamePart()}</div>`);

			const $btnSelAnim = $(`<button class="btn anm__row-btn">Select Animation</button>`)
				.click(async () => {
					const anim = await this.pSelectAnimation(editorOptions.lastAnimUid);
					if (anim != null) {
						editorOptions.lastAnimUid = anim;
						animMeta.animUid = anim;
						$wrpAnim.html(getAnimPart())
					}
				});
			const getAnimPart = () => {
				const anim = animMeta.animUid ? this.getAnimation(animMeta.animUid) : null;
				return anim ? anim.name : "";
			};
			const $wrpAnim = $(`<div>${getAnimPart()}</div>`);

			const $iptOffset = $(`<input type="number" min="0" style="max-width: 100%;" class="text-right">`)
				.val(animMeta.offset || 0)
				.change(() => {
					const rawNum = Number($iptOffset.val());
					const num = isNaN(rawNum) ? 0 : rawNum;
					animMeta.offset = Math.max(0, num);
					$iptOffset.val(animMeta.offset);
				});

			const $btnDelete = $(`<button class="btn btn-danger anm__row-btn pictos">#</button>`)
				.click(() => {
					scene.anims.splice(scene.anims.indexOf(animMeta), 1);
					$out.remove();
				});

			const $out = $$`<div class="flex-vh-center mb-1">
					<div class="col-1 text-center">${$wrpToken}</div>
					<div class="col-2 text-center">${$wrpTokenName}</div>
					<div class="col-2 text-center">${$btnSelToken}</div>

					<div class="col-2 text-center">${$wrpAnim}</div>
					<div class="col-2 text-center">${$btnSelAnim}</div>

					<div class="col-2">${$iptOffset}</div>

					<div class="col-1 text-center">${$btnDelete}</div>
				</div>`;
			return $out;
		},

		_scene_getValidationMessage (scene) {
			// validate name
			return this._shared_getValidNameMsg(scene, this._scenes);
		},
		// endregion

		// region rescue
		_rescue_getSelected () {
			return this._rescue_list.items.filter(it => $(it.elm).find("input[type=checkbox]").prop("checked"));
		},

		_rescue_getListItem (page, imgUrl, tokenName, _tokenId) {
			return `<label class="flex-v-center">
				<div class="col-1 flex-vh-center full-height"><input type="checkbox"></div>
				<div class="page col-4">${page}</div>
				<div class="col-2">
					<a href="${imgUrl}" target="_blank"><img src="${imgUrl}" style="max-width: 40px; max-height: 40px;"></a>
				</div>
				<div class="col-5 tokenName">${tokenName || "(unnamed)"}</div>
				<div class="_tokenId hidden">${_tokenId}</div>
			</label>`
		},

		_rescue_doPopulateList () {
			let temp = "";

			const pageW = d20.Campaign.activePage().attributes.width * 70;
			const pageH = d20.Campaign.activePage().attributes.height * 70;

			const outOfBounds = d20.Campaign.activePage().thegraphics.models.filter(tokenModel => {
				return tokenModel.view.graphic.scaleX < 0.01
					|| tokenModel.view.graphic.scaleX > 50.0
					|| tokenModel.view.graphic.scaleY < 0.01
					|| tokenModel.view.graphic.scaleY > 50.0
					|| tokenModel.attributes.left < 0
					|| tokenModel.attributes.left > pageW
					|| tokenModel.attributes.top < 0
					|| tokenModel.attributes.top > pageH;
			});

			outOfBounds.forEach(token => {
				const pageId = token.attributes.page_id;
				const pageName = (d20.Campaign.pages.get(pageId) || {attributes: {name: "(unknown)"}}).attributes.name;

				temp += this._rescue_getListItem(
					pageName,
					token.attributes.imgsrc,
					token.attributes.name,
					token.attributes.id,
				)
			});

			this._rescue_$wrpList.empty().append(temp);

			this._rescue_list = new List("token-animator-rescue-list-container", {
				valueNames: [
					"page",
					"tokenName",
					"_tokenId",
				],
			});
		},

		_rescue_init () {
			this._rescue_$btnRefresh = this._$winRescue.find(`[name="btn-refresh"]`);
			this._rescue_$btnRescue = this._$winRescue.find(`[name="btn-rescue"]`);
			this._rescue_$cbAll = this._$winRescue.find(`[name="cb-all"]`);
			this._rescue_$wrpList = this._$winRescue.find(`.list`);

			this._rescue_list = null;

			this._rescue_$cbAll.click(() => {
				const toVal = this._rescue_$cbAll.prop("checked");
				this._rescue_list.items.forEach(it => $(it.elm).find("input[type=checkbox]").prop("checked", toVal));
			});

			this._rescue_$btnRefresh.click(() => this._rescue_doPopulateList());

			this._rescue_$btnRescue.off("click").click(() => {
				const sel = this._rescue_getSelected();
				if (!sel.length) return d20plus.ut.chatLog("Please select some items from the list!");

				sel.map(it => it.values()).forEach(it => {
					// disable animations for token
					delete d20plus.anim.animator._tracker[it._tokenId];

					// reset token properties; place in the top-left corner of the canvas on the GM layer
					const token = d20plus.ut.getTokenById(it._tokenId);
					token.attributes.scaleX = 1.0;
					token.view.graphic.scaleX = token.attributes.scaleX;
					token.attributes.scaleY = 1.0;
					token.view.graphic.scaleY = token.attributes.scaleY;
					token.attributes.flipv = false;
					token.attributes.fliph = false;
					token.attributes.left = 35;
					token.attributes.top = 35;
					token.attributes.width = 70;
					token.attributes.height = 70;
					token.attributes.rotation = 0;
					token.attributes.layer = "gmlayer";
					token.save();
				});

				d20plus.ut.chatLog("Rescued tokens will be placed on the GM layer, in the top-left corner of the map");
				this._rescue_doPopulateList();
			});
		},
		// endregion rescue

		// region disabler
		_dis_getSelected () {
			return this._dis_list.items.filter(it => $(it.elm).find("input[type=checkbox]").prop("checked"));
		},

		_dis_getListItem (page, imgUrl, tokenName, animName, _tokenId, _animUid) {
			return `<label class="flex-v-center">
				<div class="col-1 flex-vh-center full-height"><input type="checkbox"></div>
				<div class="page col-3">${page}</div>
				<div class="col-2">
					<a href="${imgUrl}" target="_blank"><img src="${imgUrl}" style="max-width: 40px; max-height: 40px;"></a>
				</div>
				<div class="col-3 tokenName">${tokenName || "(unnamed)"}</div>
				<div class="col-3 animName">${animName}</div>
				<div class="_tokenId hidden">${_tokenId}</div>
				<div class="_animUid hidden">${_animUid}</div>
			</label>`
		},

		_dis_doPopulateList () {
			let temp = "";

			Object.entries(d20plus.anim.animator._tracker).forEach(([tokenId, tokenMeta]) => {
				const imgUrl = tokenMeta.token.attributes.imgsrc;
				const pageId = tokenMeta.token.attributes.page_id;
				const pageName = (d20.Campaign.pages.get(pageId) || {attributes: {name: "(unknown)"}}).attributes.name;

				Object.entries(tokenMeta.active).forEach(([animUid, animMeta]) => {
					temp += this._dis_getListItem(
						pageName,
						imgUrl,
						tokenMeta.token.attributes.name,
						d20plus.anim.animatorTool.getAnimation(animUid).name,
						tokenId,
						animUid,
					)
				});
			});

			this._dis_$wrpList.empty().append(temp);

			this._dis_list = new List("token-animator-disable-list-container", {
				valueNames: [
					"page",
					"tokenName",
					"animName",
					"_tokenId",
					"_animUid",
				],
			});
		},

		_dis_init () {
			this._dis_$btnRefresh = this._$winDisable.find(`[name="btn-refresh"]`);
			this._dis_$btnStop = this._$winDisable.find(`[name="btn-stop"]`);
			this._dis_$cbAll = this._$winDisable.find(`[name="cb-all"]`);
			this._dis_$wrpList = this._$winDisable.find(`.list`);

			this._dis_list = null;

			this._dis_$cbAll.click(() => {
				const toVal = this._dis_$cbAll.prop("checked");
				this._dis_list.items.forEach(it => $(it.elm).find("input[type=checkbox]").prop("checked", toVal));
			});

			this._dis_$btnRefresh.click(() => this._dis_doPopulateList());

			this._dis_$btnStop.off("click").click(() => {
				const sel = this._dis_getSelected();
				if (!sel.length) return d20plus.ut.chatLog("Please select some items from the list!");
				if (!confirm("Are you sure?")) return;

				sel.map(it => it.values()).forEach(it => {
					delete d20plus.anim.animator._tracker[it._tokenId].active[it._animUid];

					if (!hasAnyKey(d20plus.anim.animator._tracker[it._tokenId].active)) {
						delete d20plus.anim.animator._tracker[it._tokenId];
					}
				});

				d20plus.anim.animator.saveState();
				this._dis_doPopulateList();
			});
		},
		// endregion disabler

		// region editor
		_edit_openEditor (anim) {
			const $winEditor = $(this._html_template_editor)
				.attr("title", `Animation Editor - ${anim.name}`)
				.appendTo($("body"));

			$winEditor.dialog({
				resizable: true,
				width: 800,
				height: 600,
				close: () => {
					setTimeout(() => $winEditor.remove())
				},
			});

			const $iptName = $winEditor.find(`[name="ipt-name"]`).disableSpellcheck();
			const $btnSave = $winEditor.find(`[name="btn-save"]`);
			const $btnHelp = $winEditor.find(`[name="btn-help"]`);
			const $btnAddCommand = $winEditor.find(`[name="btn-add-command"]`);
			const $btnExportFile = $winEditor.find(`[name="btn-export-file"]`);
			const $btnValidate = $winEditor.find(`[name="btn-validate"]`);
			const $btnEditText = $winEditor.find(`[name="btn-edit-text"]`);
			const $iptLines = $winEditor.find(`[name="ipt-lines"]`);
			const $wrpRows = $winEditor.find(`.anm-edit__ipt-lines-wrp--gui`);

			anim.lines = anim.lines || [];
			$iptName
				.val(anim.name)
				.change(() => {
					$winEditor.dialog("option", "title", `Animation Editor - ${$iptName.val()}`);
				});

			// map to strings to ensure fresh array
			let myLines = anim.lines.map(it => typeof it === "string" ? it : it.line);

			const doDisplayLines = () => {
				$iptLines.val(myLines.map(it => typeof it === "string" ? it : it.line).join("\n"));
			};

			const gui_getTitleFromType = (type, doRemoveExact) => {
				const clean = doRemoveExact ? type.replace(/exact/gi, "") : type;

				const splCaps = clean.split(/([A-Z])/g).filter(it => it.trim());
				const stack = [];
				for (let i = 0; i < splCaps.length; ++i) {
					const tok = splCaps[i];
					if (i % 2 === 0) stack.push(tok);
					else stack[stack.length - 1] = `${stack.last()}${tok}`;
				}
				return stack.join(" ");
			};

			const gui_getBasicRowMeta = (myLines, line, isDuration) => {
				const parsed = line.parsed;

				const _getTitleMeta = () => {
					const clean = parsed._type.replace(/exact/gi, "");

					const text = gui_getTitleFromType(parsed._type, true);

					return {
						text,
						className: `anm-edit__gui-row-name--${clean}`,
					}
				};

				const doUpdate = () => {
					parsed.start = Math.round(Number($iptStart.val()));
					if (isDuration) parsed.duration = Math.round(Number($iptDuration.val()));
					line.line = d20plus.anim.lineFromParsed(parsed);
				};

				const $btnRemove = $(`<button class="btn btn-danger mr-2">Delete</button>`).click(() => {
					myLines.splice(myLines.indexOf(line), 1);
					$row.remove();
				});

				const $iptStart = $(`<input type="number" min="0" class="full-width mr-2">`).change(() => doUpdate()).val(parsed.start);
				const $iptDuration = isDuration ? $(`<input type="number" min="0" class="full-width mr-2">`).change(() => doUpdate()).val(parsed.duration) : null;

				const $wrpHeaders = $$`<div class="flex-v-center mb-2">
						<div class="col-2 bold flex-vh-center">Start Time (ms)</div>
						${isDuration ? `<div class="col-2 bold flex-vh-center">Duration (ms)</div>` : ""}
					</div>`;

				const $wrpInputs = $$`<div class="flex-v-center">
						<div class="col-2 flex-vh-center">${$iptStart}</div>
						${isDuration ? $$`<div class="col-2 flex-vh-center">${$iptDuration}</div>` : ""}
					</div>`;

				const titleMeta = _getTitleMeta();
				const $dispName = $(`<div class="bold anm-edit__gui-row-name ${titleMeta.className}">${titleMeta.text}</div>`);
				const $row = $$`<div class="flex-col full-width anm-edit__gui-row">
						<div class="split flex-v-center mb-2">
							<div class="full-width flex-v-center full-height">${$dispName}</div>
							${$btnRemove}
						</div>
						${$wrpHeaders}
						${$wrpInputs}
					</div>`;

				return {$row, doUpdate, $wrpHeaders, $wrpInputs, $dispName};
			};

			const gui_$getBtnAnim = (fnUpdate, $iptAnim) => {
				return $(`<button class="btn btn-xs mr-2 pictos">s</button>`)
					.click(async () => {
						const name = await new Promise(resolve => {
							const $selAnim = $(`<select>
							<option value="-1">(None)</option>
							${d20plus.anim.animatorTool.getAnimations().map(it => `<option value="${it.uid}">${it.name}</option>`).join("")}
							</select>`);
							$selAnim[0].selectedIndex = 0;

							const $dialog = $$`<div title="Select Animation">${$selAnim}</div>`.appendTo($("body"));

							$dialog.dialog({
								dialogClass: "no-close",
								buttons: [
									{
										text: "Cancel",
										click: function () {
											$(this).dialog("close");
											$dialog.remove();
										},
									},
									{
										text: "OK",
										click: function () {
											const selected = Number(d20plus.ut.get$SelValue($selAnim));
											$(this).dialog("close");
											$dialog.remove();

											if (~selected) resolve((d20plus.anim.animatorTool.getAnimation(selected) || {}).name);
											else resolve(null);
										},
									},
								],
							});
						});

						if (name != null) {
							$iptAnim.val(name);
							fnUpdate();
						} else if (!allowNone) {
							$iptAnim.val("-");
							fnUpdate();
						}
					});
			};

			const gui_$getWrapped = (it, width, bold) => $$`<div class="col-${width} flex-vh-center ${bold ? "bold" : ""}">${it}</div>`;

			const gui_doAddRow = (myLines, line) => {
				const parsed = line.parsed;
				switch (parsed._type) {
					case "Move":
					case "MoveExact": {
						const baseMeta = gui_getBasicRowMeta(myLines, line, true);

						const doUpdate = () => {
							baseMeta.doUpdate();
							parsed.x = $iptX.val().trim() ? Math.round(Number($iptX.val())) : null;
							parsed.y = $iptY.val().trim() ? Math.round(Number($iptY.val())) : null;
							parsed.z = $iptZ.val().trim() ? Math.round(Number($iptZ.val())) : null;
							parsed._type = $cbExact.prop("checked") ? "MoveExact" : "Move";
							line.line = d20plus.anim.lineFromParsed(parsed);
							baseMeta.$dispName.text(parsed._type);
						};

						const $iptX = $(`<input type="number" min="0" class="full-width mr-2">`).change(() => doUpdate()).val(parsed.x);
						const $iptY = $(`<input type="number" min="0" class="full-width mr-2">`).change(() => doUpdate()).val(parsed.y);
						const $iptZ = $(`<input type="number" min="0" class="full-width mr-2">`).change(() => doUpdate()).val(parsed.z);
						const $cbExact = $(`<input type="checkbox">`).prop("checked", parsed._type === "MoveExact").change(() => doUpdate());

						gui_$getWrapped("X", 1, true).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("Y", 1, true).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("Z", 1, true).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("", 4).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("Is Exact", 1, true).appendTo(baseMeta.$wrpHeaders);

						gui_$getWrapped($iptX, 1).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped($iptY, 1).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped($iptZ, 1).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped("", 4).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped($cbExact, 1).appendTo(baseMeta.$wrpInputs);

						$wrpRows.append(baseMeta.$row);

						break;
					}
					case "Rotate":
					case "RotateExact": {
						const baseMeta = gui_getBasicRowMeta(myLines, line, true);

						const doUpdate = () => {
							baseMeta.doUpdate();
							parsed.degrees = $iptDegrees.val().trim() ? Math.round(Number($iptDegrees.val().trim())) : null;
							parsed._type = $cbExact.prop("checked") ? "RotateExact" : "Rotate";
							line.line = d20plus.anim.lineFromParsed(parsed);
							baseMeta.$dispName.text(parsed._type);
						};

						const $iptDegrees = $(`<input type="number" min="0" class="full-width mr-2">`).change(() => doUpdate()).val(parsed.degrees);
						const $cbExact = $(`<input type="checkbox">`).prop("checked", parsed._type === "RotateExact").change(() => doUpdate());

						gui_$getWrapped("Degrees", 2, true).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("", 6).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("Is Exact", 1, true).appendTo(baseMeta.$wrpHeaders);

						gui_$getWrapped($iptDegrees, 2).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped("", 6).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped($cbExact, 1).appendTo(baseMeta.$wrpInputs);

						$wrpRows.append(baseMeta.$row);

						break;
					}
					case "Copy": {
						const baseMeta = gui_getBasicRowMeta(myLines, line, false);

						const doUpdate = () => {
							baseMeta.doUpdate();
							parsed.animation = $iptAnim.val().trim() || null;
							line.line = d20plus.anim.lineFromParsed(parsed);
						};

						const $iptAnim = $(`<input class="full-width mr-1">`).change(() => doUpdate()).val(parsed.animation);
						const $btnSelAnim = gui_$getBtnAnim(doUpdate, $iptAnim);

						gui_$getWrapped("Animation", 3, true).appendTo(baseMeta.$wrpHeaders);

						gui_$getWrapped($iptAnim, 3).append($btnSelAnim).appendTo(baseMeta.$wrpInputs);

						$wrpRows.append(baseMeta.$row);

						break;
					}
					case "Flip":
					case "FlipExact": {
						const baseMeta = gui_getBasicRowMeta(myLines, line, false);

						const doUpdate = () => {
							baseMeta.doUpdate();
							parsed.flipH = $selFlipH.val() === "0" ? null : $selFlipH.val() !== "1";
							parsed.flipV = $selFlipV.val() === "0" ? null : $selFlipV.val() !== "1";
							parsed._type = $cbExact.prop("checked") ? "FlipExact" : "Flip";
							line.line = d20plus.anim.lineFromParsed(parsed);
							baseMeta.$dispName.text(parsed._type);
						};

						const $getSelFlip = () => {
							const VALS = ["(None)", "No", "Yes"];
							return $(`<select class="sel-xs mr-2">${VALS.map((it, i) => `<option value="${i}">${it}</option>`).join("")}</select>`);
						};

						const $selFlipH = $getSelFlip().val(parsed.flipH == null ? "0" : parsed.flipH ? "2" : "1").change(() => doUpdate());
						const $selFlipV = $getSelFlip().val(parsed.flipV == null ? "0" : parsed.flipV ? "2" : "1").change(() => doUpdate());
						const $cbExact = $(`<input type="checkbox">`).prop("checked", parsed._type === "FlipExact").change(() => doUpdate());

						gui_$getWrapped("Flip Horizontally", 3, true).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("Flip Vertically", 3, true).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("", 3).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("Is Exact", 1, true).appendTo(baseMeta.$wrpHeaders);

						gui_$getWrapped($selFlipH, 3).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped($selFlipV, 3).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped("", 3).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped($cbExact, 1).appendTo(baseMeta.$wrpInputs);

						$wrpRows.append(baseMeta.$row);

						break;
					}
					case "Scale":
					case "ScaleExact": {
						const baseMeta = gui_getBasicRowMeta(myLines, line, true);

						const doUpdate = () => {
							baseMeta.doUpdate();
							parsed.scaleX = $iptScaleX.val().trim() ? Number($iptScaleX.val()) : null;
							parsed.scaleY = $iptScaleY.val().trim() ? Number($iptScaleY.val()) : null;
							parsed._type = $cbExact.prop("checked") ? "ScaleExact" : "Scale";
							line.line = d20plus.anim.lineFromParsed(parsed);
							baseMeta.$dispName.text(parsed._type);
						};

						const $iptScaleX = $(`<input type="number" min="0" class="full-width mr-2">`).change(() => doUpdate()).val(parsed.scaleX);
						const $iptScaleY = $(`<input type="number" min="0" class="full-width mr-2">`).change(() => doUpdate()).val(parsed.scaleY);
						const $cbExact = $(`<input type="checkbox">`).prop("checked", parsed._type === "ScaleExact").change(() => doUpdate());

						gui_$getWrapped("Horizontal Scale", 3, true).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("Vertical Scale", 3, true).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("", 1).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("Is Exact", 1, true).appendTo(baseMeta.$wrpHeaders);

						gui_$getWrapped($iptScaleX, 3).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped($iptScaleY, 3).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped("", 1).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped($cbExact, 1).appendTo(baseMeta.$wrpInputs);

						$wrpRows.append(baseMeta.$row);

						break;
					}
					case "Layer": {
						const baseMeta = gui_getBasicRowMeta(myLines, line, false);

						const doUpdate = () => {
							baseMeta.doUpdate();
							parsed.layer = $selLayer.val().trim() ? $selLayer.val() : null;
							line.line = d20plus.anim.lineFromParsed(parsed);
						};

						const $selLayer = $(`<select class="mr-2 sel-xs">
							<option value="">Select a layer...</option>
							${d20plus.ut.LAYERS.map(l => `<option value="${l}">${d20plus.ut.layerToName(l)}</option>`).join("")}
							</select>`)
							.change(() => doUpdate()).val(parsed.layer);

						gui_$getWrapped("Layer", 3, true).appendTo(baseMeta.$wrpHeaders);

						gui_$getWrapped($selLayer, 3).appendTo(baseMeta.$wrpInputs);

						$wrpRows.append(baseMeta.$row);

						break;
					}
					case "Lighting":
					case "LightingExact": {
						const baseMeta = gui_getBasicRowMeta(myLines, line, true);

						const doUpdate = () => {
							baseMeta.doUpdate();
							parsed.lightRadius = $iptLightRadius.val().trim() ? Math.round(Number($iptLightRadius.val())) : null;
							parsed.dimStart = $iptDimStart.val().trim() ? Math.round(Number($iptDimStart.val())) : null;
							parsed.degrees = $iptDegrees.val().trim() ? Math.round(Number($iptDegrees.val())) : null;
							parsed._type = $cbExact.prop("checked") ? "LightingExact" : "Lighting";
							line.line = d20plus.anim.lineFromParsed(parsed);
							baseMeta.$dispName.text(parsed._type);
						};

						const $iptLightRadius = $(`<input type="number" class="full-width mr-2">`).change(() => doUpdate()).val(parsed.lightRadius);
						const $iptDimStart = $(`<input type="number" class="full-width mr-2">`).change(() => doUpdate()).val(parsed.dimStart);
						const $iptDegrees = $(`<input type="number" min="0" class="full-width mr-2">`).change(() => doUpdate()).val(parsed.degrees);
						const $cbExact = $(`<input type="checkbox">`).prop("checked", parsed._type === "MoveExact").change(() => doUpdate());

						gui_$getWrapped("Light Radius", 2, true).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("Dim Start", 2, true).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("Angle", 2, true).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("", 1).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("Is Exact", 1, true).appendTo(baseMeta.$wrpHeaders);

						gui_$getWrapped($iptLightRadius, 2).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped($iptDimStart, 2).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped($iptDegrees, 2).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped("", 1).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped($cbExact, 1).appendTo(baseMeta.$wrpInputs);

						$wrpRows.append(baseMeta.$row);

						break;
					}
					case "SetProperty":
					case "SumProperty": {
						const baseMeta = gui_getBasicRowMeta(myLines, line, false);

						const doUpdate = () => {
							baseMeta.doUpdate();
							parsed.prop = $selProp.val();
							try { parsed.value = JSON.parse($iptVal().trim()); } catch (ignored) { parsed.value = $iptVal.val(); }
							line.line = d20plus.anim.lineFromParsed(parsed);
							parsed._type = $selMode.val();
							baseMeta.$dispName.text(parsed._type);
						};

						const $selProp = $(`<select class="mr-2 sel-xs">${d20plus.anim._PROP_TOKEN.sort(SortUtil.ascSortLower).map(it => `<option>${it}</option>`).join("")}</select>`)
							.change(() => doUpdate()).val(parsed.prop);
						const $iptVal = $(`<textarea class="full-width my-0" style="resize: vertical;"></textarea>`).change(() => doUpdate()).val(parsed.value);
						const $selMode = $(`<select class="mr-2 sel-xs">
							<option value="SetProperty">Set</option>
							<option value="SumProperty">Sum</option>
						</select>`)
							.val(parsed._type)
							.change(() => doUpdate());

						gui_$getWrapped("Property", 4, true).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("Value", 3, true).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("", 1).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("Mode", 2, true).appendTo(baseMeta.$wrpHeaders);

						gui_$getWrapped($selProp, 4).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped($iptVal, 3).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped("", 1).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped($selMode, 2).appendTo(baseMeta.$wrpInputs);

						$wrpRows.append(baseMeta.$row);

						break;
					}
					case "TriggerMacro": {
						const baseMeta = gui_getBasicRowMeta(myLines, line, false);

						const doUpdate = () => {
							baseMeta.doUpdate();
							parsed.macro = $iptMacro.val().trim() ? $iptMacro.val().trim() : null;
							line.line = d20plus.anim.lineFromParsed(parsed);
						};

						const $iptMacro = $(`<input class="full-width mr-2">`).change(() => doUpdate()).val(parsed.macro);
						// TODO add macro search button?

						gui_$getWrapped("Macro Name", 4, true).appendTo(baseMeta.$wrpHeaders);

						gui_$getWrapped($iptMacro, 4).appendTo(baseMeta.$wrpInputs);

						$wrpRows.append(baseMeta.$row);

						break;
					}
					case "TriggerAnimation": {
						const baseMeta = gui_getBasicRowMeta(myLines, line, false);

						const doUpdate = () => {
							baseMeta.doUpdate();
							parsed.animation = $iptAnim.val().trim() ? $iptAnim.val().trim() : null;
							line.line = d20plus.anim.lineFromParsed(parsed);
						};

						const $iptAnim = $(`<input class="full-width mr-1">`).change(() => doUpdate()).val(parsed.animation);
						const $btnSelAnim = gui_$getBtnAnim(doUpdate, $iptAnim);

						gui_$getWrapped("Animation", 3, true).appendTo(baseMeta.$wrpHeaders);

						gui_$getWrapped($iptAnim, 3).append($btnSelAnim).appendTo(baseMeta.$wrpInputs);

						$wrpRows.append(baseMeta.$row);

						break;
					}
					default: throw new Error(`Unhandled type "${parsed._type}"`);
				}
			};

			const doDisplayRows = () => {
				$wrpRows.empty();
				const wrpMyLines = {lines: myLines};
				this._edit_convertLines(wrpMyLines);

				myLines.forEach(line => {
					if (line.error) {
						// eslint-disable-next-line no-console
						console.error(`Failed to create GUI row from line "${line.line}"!`, line.error);
					} else gui_doAddRow(myLines, line);
				});
			};

			const getValidationMessage = () => {
				if ($btnEditText.hasClass("active")) {
					// create a fake animation object, and check it for errors
					const toValidate = {
						uid: anim.uid, // pass out UID, so the validator can ignore our old data when checking duplicate names
						name: $iptName.val(),
						lines: $iptLines.val().split("\n"),
					};
					return this._edit_getValidationMessage(toValidate);
				}
				// (assume the GUI version passes validation)
				return null;
			};

			$btnSave.off("click").click(() => {
				if ($btnEditText.hasClass("active")) {
					const msg = getValidationMessage();
					if (msg) return d20plus.ut.chatLog(msg);

					// we passed validation
					anim.name = $iptName.val();
					anim.lines = $iptLines.val().split("\n");
				} else {
					const nameMsg = this._shared_getValidNameMsg({name: $iptName.val(), uid: anim.uid}, this._anims);
					if (nameMsg) return d20plus.ut.chatLog(nameMsg);

					anim.name = $iptName.val();
					anim.lines = myLines.map(it => typeof it === "string" ? it : it.line);
				}
				this._doSaveStateDebounced();

				const matches = this._anim_list.get("uid", anim.uid);
				if (matches.length) matches[0].values({name: anim.name});

				d20plus.ut.chatLog("Saved!");
			});

			$btnExportFile.off("click").click(() => {
				const out = {animations: [this._main_getExportableAnim(anim)]};
				d20plus.ut.saveAsJson(`${anim.name}`, out);
			});

			$btnValidate.off("click").click(() => {
				const msg = getValidationMessage();
				d20plus.ut.chatLog(msg || "Valid!");
			});

			$btnHelp.click(() => {
				d20plus.ut.chatLog(`<a href="${d20plus.ut.WIKI_URL}/index.php/Feature:_Animator" target="_blank">View the Wiki page for help!</a>`);
				window.open(`${d20plus.ut.WIKI_URL}/index.php/Feature:_Animator`);
			});

			let lastSelCommand = null;
			$btnAddCommand.click(async () => {
				const _KEYS = [...new Set(Object.keys(d20plus.anim.COMMAND_TO_SHORT).map(it => it.replace(/exact/gi, "")))];

				const type = await new Promise(resolve => {
					const $selCommand = $(`<select>
					<option disabled value="-1">Select Command...</option>
					${_KEYS.map((it, i) => `<option value="${i}">${gui_getTitleFromType(it, false)}</option>`).join("")}
					</select>`);

					if (lastSelCommand != null) $selCommand.val(lastSelCommand);
					else $selCommand[0].selectedIndex = 0;

					const $dialog = $$`<div title="Select Command">${$selCommand}</div>`.appendTo($("body"));

					$dialog.dialog({
						dialogClass: "no-close",
						buttons: [
							{
								text: "Cancel",
								click: function () {
									$(this).dialog("close");
									$dialog.remove();
								},
							},
							{
								text: "OK",
								click: function () {
									const ix = Number(d20plus.ut.get$SelValue($selCommand));
									$(this).dialog("close");
									$dialog.remove();

									if (~ix) {
										resolve(_KEYS[ix]);
										lastSelCommand = String(ix);
									} else resolve(null);
								},
							},
						],
					});
				});

				if (type == null) return;

				const nuLine = (() => {
					const short = d20plus.anim.COMMAND_TO_SHORT[type];
					if (!short) throw new Error(`No short form found for "${short}"`);
					const args = d20plus.anim.SHORT_TO_DEFAULT_ARGS[short];
					if (!args) throw new Error(`No default args found for "${short}"`);
					return `${short} ${args}`;
				})();

				myLines.push(nuLine);
				const wrpMyLines = {lines: myLines};
				this._edit_convertLines(wrpMyLines);
				gui_doAddRow(myLines, myLines.last());
			});

			$btnEditText.click(() => {
				const isTextModeNxt = !$btnEditText.hasClass("active");
				if (isTextModeNxt) {
					// myLines will already be up-to-date due to UI state changes; simply switch to text display
					doDisplayLines();
				} else {
					// validate + update state
					const msg = getValidationMessage();
					if (msg) return d20plus.ut.chatLog(msg);

					myLines = $iptLines.val().split("\n").map(it => it.trim()).filter(Boolean);
					doDisplayRows();
				}

				$btnEditText.toggleClass("active");
				$winEditor.toggleClass("anm-edit__text", isTextModeNxt);
				$winEditor.toggleClass("anm-edit__gui", !isTextModeNxt);
			});

			doDisplayRows();
		},

		/**
		 * Returns `null` if valid, or an error message if invalid.
		 * @private
		 */
		_edit_getValidationMessage (anim) {
			// validate name
			const nameMsg = this._shared_getValidNameMsg(anim, this._anims);
			if (nameMsg) return nameMsg;

			// validate lines
			this._edit_convertLines(anim);

			const badLines = anim.lines.filter(c => c.error);
			if (badLines.length) {
				return `Invalid, the following lines could not be parsed:\n${badLines.map(c => `${c.error} at line "${c.line}"`).join("\n")}`;
			}

			return null;
		},

		_edit_convertLines (anim) {
			for (let i = 0; i < anim.lines.length; ++i) {
				const line = anim.lines[i];
				if (typeof line === "string") anim.lines[i] = Command.fromString(line);
			}
		},
		// endregion editor
	};

	d20plus.tool.tools.push(d20plus.anim.animatorTool);

	function hasAnyKey (object) {
		for (const k in object) {
			if (!object.hasOwnProperty(k)) continue;
			return true;
		}
		return false;
	}

	d20plus.anim.animator = {
		/*
		_tracker: {
			tokenId: {
				token: {...}, // Roll20 token
				active: {
					// only one instance of an animation can be active on a token at a time
					animUid: {
						queue: [...], // returned by getAnimQueue
						start, // start time
						lastTick, // last tick time
						lastAlpha // last alpha value passed -- used for deserialization
					},
					... // other animations
				}
			}
		}
		*/
		_tracker: {},
		_restTicks: 1,

		__tickCount: 0,

		startAnimation (token, animUid, options) {
			options = options || {};

			const anim = d20plus.anim.animatorTool.getAnimation(animUid);
			const queue = d20plus.anim.animatorTool.getAnimQueue(anim, options.offset || 0);

			this._tracker[token.id] = this._tracker[token.id] || {token, active: {}};
			const time = (new Date()).getTime();
			this._tracker[token.id].active[animUid] = {
				queue,
				start: time,
				lastTick: time,
			};
		},

		endAnimation (token, animUid) {
			if (this._tracker[token.id] && this._tracker[token.id].active[animUid]) {
				delete this._tracker[token.id].active[animUid];

				if (hasAnyKey(this._tracker[token.id].active)) delete this._tracker[token.id];
			}
		},

		setRestTicks (tickRate) {
			this._restTicks = tickRate;
		},

		_lastTickActive: false,
		_tickTimeout: null,
		doTick () {
			if (this._tickTimeout) clearTimeout(this._tickTimeout);

			if (this._hasAnyActive()) {
				// if we've been sleeping, reset start times
				// prevents an initial "jolt" as anims suddenly have catch up on 1.5s of lag
				if (!this._lastTickActive) {
					this._lastTickActive = true;
					const time = (new Date()).getTime();

					for (const tokenId in this._tracker) {
						if (!this._tracker.hasOwnProperty(tokenId)) continue;
						const tokenMeta = this._tracker[tokenId];

						for (const animUid in tokenMeta.active) {
							if (!tokenMeta.active.hasOwnProperty(animUid)) continue;
							const instance = tokenMeta.active[animUid];
							instance.start = time;
							instance.lastTick = time;
						}
					}
				}

				this._doTick();
			} else {
				this._lastTickActive = false;
				// if none are active, sleep for 1.5 seconds
				this._tickTimeout = setTimeout(() => this.doTick(), 1500);
			}
		},

		_saveState () {
			const toSave = {};
			Object.entries(this._tracker).forEach(([tokenId, tokenMeta]) => {
				const saveableTokenMeta = {active: {}};

				Object.entries(tokenMeta.active).forEach(([animUid, state]) => {
					saveableTokenMeta.active[animUid] = {
						queue: state.queue.map(it => it.serialize()),
						lastAlpha: state.lastAlpha,
					};
				});

				toSave[tokenId] = saveableTokenMeta;
			});

			Campaign.save({
				bR20tool__anim_running: toSave,
			});
		},

		saveState () {
			if (d20plus.anim.animatorTool.isSavingActive()) this._doSaveStateThrottled();
		},

		loadState () {
			const time = (new Date()).getTime();
			const saved = Campaign.attributes.bR20tool__anim_running ? MiscUtil.copy(Campaign.attributes.bR20tool__anim_running) : {};
			const toLoad = {};
			Object.entries(saved).forEach(([tokenId, savedTokenMeta]) => {
				// load real token
				const token = d20plus.ut.getTokenById(tokenId);
				// eslint-disable-next-line no-console
				if (!token) return console.log(`Token ${tokenId} not found!`);
				const tokenMeta = {};
				tokenMeta.token = token;

				const active = {};
				Object.entries(savedTokenMeta.active).forEach(([animUid, savedState]) => {
					const anim = d20plus.anim.animatorTool.getAnimation(animUid);
					// eslint-disable-next-line no-console
					if (!anim) return console.log(`Animation ${animUid} not found!`);

					active[animUid] = {
						queue: savedState.queue.map(it => d20plus.anim.deserialize(it)),
						start: time - savedState.lastAlpha,
						lastTick: time,
					}
				});

				tokenMeta.active = active;

				toLoad[tokenId] = tokenMeta;
			});

			this._tracker = toLoad;
		},

		_hasAnyActive () {
			return hasAnyKey(this._tracker);
		},

		_doTick () {
			// higher tick rate = slower
			if (++this.__tickCount >= this._restTicks) {
				this.__tickCount = 0;
				let anyGlobalModifications = false;

				const time = (new Date()).getTime();

				for (const tokenId in this._tracker) {
					if (!this._tracker.hasOwnProperty(tokenId)) continue;
					const tokenMeta = this._tracker[tokenId];

					let anyModification = false;
					for (const animUid in tokenMeta.active) {
						if (!tokenMeta.active.hasOwnProperty(animUid)) continue;
						const instance = tokenMeta.active[animUid];

						const alpha = time - instance.start;
						const delta = time - instance.lastTick;

						// avoid using fast-loop length optimization, as we'll splice out completed animations
						for (let i = 0; i < instance.queue.length; ++i) {
							anyModification = instance.queue[i].animate(
								tokenMeta.token,
								alpha,
								delta,
								instance.queue,
							) || anyModification;

							if (instance.queue[i].hasRun()) {
								instance.queue.splice(i, 1);
								--i;
							}
						}

						// queue empty -> this animation is no longer active
						if (!instance.queue.length) delete tokenMeta.active[animUid];
						else {
							instance.lastTick = time;
							instance.lastAlpha = alpha;
						}
					}

					// no active animations -> stop tracking this token
					if (!hasAnyKey(tokenMeta.active)) delete this._tracker[tokenId];

					// save after applying animations
					if (anyModification) tokenMeta.token.save();
					anyGlobalModifications = anyGlobalModifications || anyModification;
				}

				this.saveState();
				if (anyGlobalModifications) d20.engine.canvas.renderAll();
			}

			requestAnimationFrame(this.doTick.bind(this))
		},

		init () {
			this._doSaveStateThrottled = _.throttle(this._saveState, 100);
			setTimeout(() => {
				this.loadState();
				this._lastTickActive = true;
				this.doTick();
			}, 5000);
		},
	};

	// all properties that can be set via the 'prop' command
	d20plus.anim._PROP_TOKEN = [
		"left",
		"top",
		"width",
		"height",
		"z_index",
		"imgsrc",
		"rotation",
		"type",
		"layer",
		"locked",
		"flipv",
		"fliph",
		"anim_loop",
		"anim_paused_at",
		"anim_autoplay",
		"name",
		"gmnotes", // `escape`d HTML
		"controlledby",
		"represents",
		"bar1_value",
		"bar1_max",
		"bar1_link",
		"bar2_value",
		"bar2_max",
		"bar2_link",
		"bar3_value",
		"bar3_max",
		"bar3_link",
		"aura1_radius",
		"aura1_color",
		"aura1_square",
		"aura2_radius",
		"aura2_color",
		"aura2_square",
		"tint_color",
		"status_dead",
		"statusmarkers",
		"showname",
		"showplayers_name",
		"showplayers_bar1",
		"showplayers_bar2",
		"showplayers_bar3",
		"showplayers_aura1",
		"showplayers_aura2",
		"playersedit_name",
		"playersedit_bar1",
		"playersedit_bar2",
		"playersedit_bar3",
		"playersedit_aura1",
		"playersedit_aura2",
		"light_radius",
		"light_dimradius",
		"light_otherplayers",
		"light_hassight",
		"light_angle",
		"light_losangle",
		"light_multiplier",
		"adv_fow_view_distance",
		"groupwith",
		"sides", // pipe-separated list of `escape`d image URLs
		"currentSide",
	];
	d20plus.anim.VALID_PROP_TOKEN = new Set(d20plus.anim._PROP_TOKEN);

	d20plus.anim.VALID_LAYER = new Set(d20plus.ut.LAYERS);

	d20plus.anim.COMMAND_TO_SHORT = {
		"Move": "mv",
		"MoveExact": "mvx",
		"Rotate": "rot",
		"RotateExact": "rotx",
		"Copy": "cp",
		"Flip": "flip",
		"FlipExact": "flipx",
		"Scale": "scale",
		"ScaleExact": "scalex",
		"Layer": "layer",
		"Lighting": "light",
		"LightingExact": "lightx",
		"SetProperty": "prop",
		"SumProperty": "propSum",
		"TriggerMacro": "macro",
		"TriggerAnimation": "anim",
	};

	d20plus.anim.SHORT_TO_DEFAULT_ARGS = {
		"mv": "0 0 - - -",
		"mvx": "0 0 - - -",
		"rot": "0 0 -",
		"rotx": "0 0 -",
		"cp": "0",
		"flip": "0 - -",
		"flipx": "0 - -",
		"scale": "0 0 - -",
		"scalex": "0 0 - -",
		"layer": "0 -",
		"light": "0 0 - - -",
		"lightx": "0 0 - - -",
		"prop": "0 -",
		"propSum": "0 -",
		"macro": "0 -",
		"anim": "0 -",
	};
}

SCRIPT_EXTENSIONS.push(baseToolAnimator);


function d20plusArt () {
	d20plus.art = {
		button: () => {
			// add external art button was clicked
			const $art = $("#d20plus-artfolder");
			$art.dialog("open");
			const $artList = $art.find(`.list`);
			$artList.empty();

			if (d20plus.art.custom) {
				d20plus.art.custom.forEach(a => {
					const $liArt = getArtLi(a.name, a.url);
					$artList.append($liArt);
				});
			}

			// init list library
			const artList = new List("art-list-container", {
				valueNames: ["name"],
				listClass: "artlist",
			});

			const $btnAdd = $(`#art-list-add-btn`);
			const $iptAddName = $(`#art-list-add-name`);
			const $iptAddUrl = $(`#art-list-add-url`);
			$btnAdd.off("click");
			$btnAdd.on("click", () => {
				const name = $iptAddName.val().trim();
				const url = $iptAddUrl.val().trim();
				if (!name || !url) {
					alert("Missing required fields!")
				} else {
					artList.search();
					artList.filter();
					const $liArt = getArtLi(name, url);
					$artList.append($liArt);
					refreshCustomArtList();
				}
			});

			const $btnMassAdd = $(`#art-list-multi-add-btn`);
			$btnMassAdd.off("click");
			$btnMassAdd.on("click", () => {
				$("#d20plus-artmassadd").dialog("open");
				const $btnMassAddSubmit = $(`#art-list-multi-add-btn-submit`);
				$btnMassAddSubmit.off("click");
				$btnMassAddSubmit.on("click", () => {
					artList.search();
					artList.filter();
					const $iptUrls = $(`#art-list-multi-add-area`);
					const massUrls = $iptUrls.val();
					const spl = massUrls.split("\n").map(s => s.trim()).filter(s => s);
					if (!spl.length) return;
					const delim = "---";
					const toAdd = [];
					for (const s of spl) {
						if (!s.includes(delim)) {
							alert(`Badly formatted line: ${s}`);
							return;
						} else {
							const parts = s.split(delim);
							if (parts.length !== 2) {
								alert(`Badly formatted line: ${s}`);
								return;
							} else {
								toAdd.push({
									name: parts[0],
									url: parts[1],
								});
							}
						}
					}
					toAdd.forEach(a => {
						$artList.append(getArtLi(a.name, a.url));
					});
					refreshCustomArtList();
					$("#d20plus-artmassadd").dialog("close");
				});
			});

			const $btnDelAll = $(`#art-list-delete-all-btn`);
			$btnDelAll.off("click").on("click", () => {
				$artList.empty();
				refreshCustomArtList();
			});

			makeDraggables();
			d20plus.art.refreshList = refreshCustomArtList;

			function getArtLi (name, url) {
				const showImage = d20plus.cfg.get("interface", "showCustomArtPreview");
				const $liArt = $(`
						<li class="dd-item library-item draggableresult Vetools-draggable-art ui-draggable" data-fullsizeurl="${url}">
							${showImage ? `<img src="${url}" style="width: 30px; max-height: 30px; display: inline-block" draggable="false">` : ""}
							<div class="dd-content name" style="display: inline-block; width: 35%;" data-url="${url}">${name}</div>
							<a href="${url}"><span class="url" style="display: inline-block; width: ${showImage ? "40%" : "55%"};">${url}</span></a>
						</li>
					`);
				if (!showImage) {
					$liArt.on("mousedown", () => {
						const $loader = $(`<div class="temp-warning">Loading image - don't drop yet!</div>`);
						const $img = $(`<img src="${url}" style="width: 30px; max-height: 30px; display: none">`);
						if (!$img.prop("complete")) {
							$(`body`).append($loader);
							$img.on("load", () => {
								$loader.remove();
							});
							$loader.append($img);
						}
					});
				}

				const $btnDel = $(`<span class="delete btn btn-danger"><span class="pictos">#</span></span>`).on("click", () => {
					$liArt.remove();
					deleteCustomArt(name);
				});
				$liArt.append($btnDel);
				return $liArt;
			}

			function deleteCustomArt (name) {
				artList.remove("name", name)
				d20plus.art.custom.splice(d20plus.art.custom.findIndex(i => i.name === name), 1);
				makeDraggables();
				d20plus.art.saveToHandout();
			}

			function refreshCustomArtList () {
				artList.reIndex();
				const custom = [];
				artList.items.forEach(i => {
					const $ele = $(i.elm);
					custom.push({
						name: $ele.find(`.name`).text(),
						url: $ele.find(`.url`).text(),
					});
				});
				d20plus.art.custom = custom;
				makeDraggables();
				d20plus.art.saveToHandout();
			}

			function makeDraggables () {
				$(`.Vetools-draggable-art`).draggable({
					handle: ".dd-content",
					revert: true,
					revertDuration: 0,
					helper: "clone",
					appendTo: "body",
				})
			}
		},

		saveToHandout () {
			const handout = d20plus.art.getArtHandout();
			if (!handout) {
				d20.Campaign.handouts.create({
					name: ART_HANDOUT,
					archived: true,
				}, {
					success: function (handout) {
						notecontents = "This handout is used to store custom art URLs.";

						const gmnotes = JSON.stringify(d20plus.art.custom);
						handout.updateBlobs({notes: notecontents, gmnotes: gmnotes});
						handout.save({notes: (new Date()).getTime(), inplayerjournals: ""});
					},
				});
			} else {
				const gmnotes = JSON.stringify(d20plus.art.custom);
				handout.updateBlobs({gmnotes: gmnotes});
				handout.save({notes: (new Date()).getTime()});
			}
		},

		/**
		 * @param items Array of Objects with "name" and "url" properties.
		 * @private
		 */
		addToHandout (items) {
			const invalid = items.find(it => !it.name || !it.url);
			if (invalid) throw new Error(`Invalid item ${JSON.stringify(invalid)} did not contain required name and URL properties!`);
			d20plus.art.custom = (d20plus.art.custom || []).concat(items);
			d20plus.art.saveToHandout();
		},

		// TODO load a decent default art library from somewhere
		default: [
			// {
			// 	name: "Phoenix",
			// 	url: "http://www.discgolfbirmingham.com/wordpress/wp-content/uploads/2014/04/phoenix-rising.jpg"
			// }
		],
	};

	d20plus.art.getArtHandout = () => {
		return d20.Campaign.handouts.models.find((handout) => {
			return handout.attributes.name === ART_HANDOUT;
		});
	};

	d20plus.art.pLoadArt = async () => {
		d20plus.ut.log("Loading custom art");
		const handout = d20plus.art.getArtHandout();
		if (handout) {
			handout.view.render();
			return new Promise(resolve => {
				handout._getLatestBlob("gmnotes", function (gmnotes) {
					const decoded = decodeURIComponent(gmnotes);
					try {
						d20plus.art.custom = JSON.parse(decoded);
						resolve();
					} catch (e) {
						// eslint-disable-next-line no-console
						console.error(e);
						resolve();
					}
				});
			});
		}
	};

	d20plus.art.addCustomArtSearch = () => {
		d20plus.ut.log("Add custom art search");
		const $afterTo = $(`#libraryresults`);
		$afterTo.after(d20plus.html.artListHTML);

		const $olNone = $(`#image-search-none`);
		const $olHasResults = $(`#image-search-has-results`);

		const $olArt = $(`#custom-art-results`);
		const $srchImages = $(`#imagedialog .searchbox input.keywords`);
		$srchImages.on("keyup", () => {
			$olArt.empty();
			const searched = $srchImages.val().trim().toLowerCase();
			if (searched.length < 2) {
				$olNone.show();
				$olHasResults.hide();
				return;
			}

			let toShow = d20plus.art.default.filter(a => a.name.toLowerCase().includes(searched));
			if (d20plus.art.custom) toShow = toShow.concat(d20plus.art.custom.filter(a => a.name.toLowerCase().includes(searched)));

			if (!toShow.length) {
				$olNone.show();
				$olHasResults.hide();
			} else {
				$olNone.hide();
				$olHasResults.show();

				toShow.forEach(a => {
					$olArt.append(`
						<li class="dd-item library-item draggableresult Vetoolsresult ui-draggable" data-fullsizeurl="${a.url}">
							<div class="dd-content">
								<div class="token"><img src="${a.url}" draggable="false"></div>
								<div class="name">
									<div class="namecontainer"><a href="${a.url}" rel="external">${a.name}</a></div>
								</div>
							</div>
						</li>
					`);
				});
			}

			$("#imagedialog #Vetoolsresults .draggableresult").draggable({
				handle: ".dd-content",
				revert: true,
				revertDuration: 0,
				helper: "clone",
				appendTo: "body",
			}).addTouch();
		});
	};

	d20plus.art.initArtFromUrlButtons = () => {
		d20plus.ut.log("Add direct URL art buttons");
		// requires templates to be swapped, which happens ASAP during Init

		$(`.character-image-by-url`).live("click", function () {
			const cId = $(this).closest(`[data-characterid]`).attr(`data-characterid`);
			const url = window.prompt("Enter a URL", d20plus.art.getLastImageUrl());
			if (url) {
				d20plus.art.setLastImageUrl(url);
				d20.Campaign.characters.get(cId).set("avatar", url);
			}
		});

		$(`.handout-image-by-url`).live("click", function () {
			const hId = $(this).closest(`[data-handoutid]`).attr(`data-handoutid`);
			const url = window.prompt("Enter a URL", d20plus.art.getLastImageUrl());
			if (url) {
				d20plus.art.setLastImageUrl(url);
				d20.Campaign.handouts.get(hId).set("avatar", url);
			}
		});

		$(`.token-image-by-url`).live("click", function () {
			const cId = $(this).closest(`[data-characterid]`).attr(`data-characterid`);
			const url = window.prompt("Enter a URL", d20plus.art.getLastImageUrl());
			if (url) {
				d20plus.art.setLastImageUrl(url);
				const char = d20.Campaign.characters.get(cId);
				char._getLatestBlob("defaulttoken", (blob) => {
					blob = blob && blob.trim() ? JSON.parse(blob) : {};
					blob.imgsrc = url;
					char.updateBlobs({defaulttoken: JSON.stringify(blob)});
				});
			}
		});

		$(`.deck-image-by-url`).live("click", function () {
			const dId = $(this).attr("data-deck-id");
			const url = window.prompt("Enter a URL", d20plus.art.getLastImageUrl());
			if (url) {
				d20plus.art.setLastImageUrl(url);
				d20.Campaign.decks.get(dId).set("avatar", url)
			}
		});

		$(`.card-image-by-url`).live("click", function () {
			const cId = $(this).attr("data-card-id");
			const url = window.prompt("Enter a URL", d20plus.art.getLastImageUrl());
			if (url) {
				d20plus.art.setLastImageUrl(url);
				const card = d20.Campaign.decks.find(it => it.cards.find(c => c.id === cId)).cards.find(c => c.id === cId);
				card.set("avatar", url);
			}
		});

		$(`.deck-mass-cards-by-url`).live("click", function () {
			const dId = $(this).attr("data-deck-id");

			const deck = d20.Campaign.decks.get(dId);

			const cleanTemplate = d20plus.html.addArtMassAdderHTML.replace(/id="[^"]+"/gi, "");
			const $dialog = $(cleanTemplate).appendTo($("body"));
			const $iptTxt = $dialog.find(`textarea`);
			const $btnAdd = $dialog.find(`button`).click(() => {
				const lines = ($iptTxt.val() || "").split("\n");
				const toSaveAll = [];
				lines.filter(it => it && it.trim()).forEach(l => {
					const split = l.split("---").map(it => it.trim()).filter(Boolean);
					if (split.length >= 2) {
						const [name, url] = split;
						const toSave = deck.cards.push({
							avatar: url,
							id: d20plus.ut.generateRowId(),
							name,
							placement: 99,
						});
						toSaveAll.push(toSave);
					}
				});
				$dialog.dialog("close");

				toSaveAll.forEach(s => s.save());
				deck.save();
			});

			$dialog.dialog({
				width: 800,
				height: 650,
			});
		});
	};

	d20plus.art._lastImageUrl = "https://example.com/pic.png";
	d20plus.art.getLastImageUrl = () => {
		return d20plus.art._lastImageUrl;
	};
	d20plus.art.setLastImageUrl = (url) => {
		d20plus.art._lastImageUrl = url || d20plus.art._lastImageUrl;
	};
}

SCRIPT_EXTENSIONS.push(d20plusArt);


function d20plusArtBrowser () {
	d20plus.artBrowse = {};

	// ART IMPORTER 2.0
	d20plus.artBrowse.initRepoBrowser = () => {
		const TIME = (new Date()).getTime();
		const STATES = ["0", "1", "2"]; // off, blue, red

		function pGetJson (url) { // avoid using the main site method's caching
			return new Promise(resolve => $.getJSON(url, data => resolve(data)));
		}

		const $win = $(`<div title="BetteR20 - Art Repository" class="artr__win"/>`)
			.appendTo($(`body`))
			.dialog({
				autoOpen: false,
				resizable: true,
				width: 1,
				height: 1,
			})
			// bind droppable, so that elements dropped back onto the browser don't get caught by the canvas behind
			.droppable({
				accept: ".draggableresult",
				tolerance: "pointer",
				drop: (event, ui) => {
					event.preventDefault();
					event.stopPropagation();
					event.originalEvent.dropHandled = true;
					d20plus.ut.log(`Dropped back onto art browser!`);
				},
			});

		async function doInit () {
			const $sidebar = $(`<div class="artr__side"/>`).appendTo($win);
			const $mainPane = $(`<div class="artr__main"/>`).appendTo($win);
			const $loadings = [
				$(`<div class="artr__side__loading" title="Caching repository data, this may take some time">Loading...</div>`).appendTo($sidebar),
				$(`<div class="artr__main__loading" title="Caching repository data, this may take some time">Loading...</div>`).appendTo($mainPane),
			];

			const start = (new Date()).getTime();
			const GH_PATH = `https://raw.githubusercontent.com/DMsGuild201/Roll20_resources/master/ExternalArt/dist/`;
			const [enums, index] = await Promise.all([pGetJson(`${GH_PATH}_meta_enums.json`), pGetJson(`${GH_PATH}_meta_index.json`)]);
			d20plus.ut.log(`Loaded metadata in ${((new Date()).getTime() - start) / 1000} secs.`);

			Object.keys(index).forEach(k => index[k]._key = k);

			let filters = {};
			let search = "";
			let currentItem = null;
			let currentIndexKey = null;

			function _searchFeatures (item, doLowercase) {
				// features are lowercase in index
				return !!(item.features || []).find(x => (doLowercase ? x.toLowerCase() : x).includes(search));
			}

			function _filterProps (item) {
				if (Object.keys(filters).length) {
					const missingOrUnwanted = Object.keys(filters).find(prop => {
						if (!item[prop]) return true;
						const requiredVals = Object.keys(filters[prop]).filter(k => filters[prop][k]);
						const missingEnum = !!requiredVals.find(x => !item[prop].includes(x));
						const excludedVals = Object.keys(filters[prop]).filter(k => !filters[prop][k]);
						const unwantedEnum = !!excludedVals.find(x => item[prop].includes(x));
						return missingEnum || unwantedEnum;
					});
					if (missingOrUnwanted) return false;
				}
				return true;
			}

			function applyFilterAndSearchToIndex () {
				search = search.toLowerCase();

				// require the user to search or apply a filter before displaying any results
				if (Object.keys(filters).length === 0 && search.length < 2) return [];

				return Object.values(index).filter(it => {
					if (search) {
						const searchVisible = it._set.toLowerCase().includes(search)
							|| it._artist.toLowerCase().includes(search)
							|| _searchFeatures(it);
						if (!searchVisible) return false;
					}
					return _filterProps(it, 1);
				});
			}

			function applyFilterAndSearchToItem () {
				const cpy = MiscUtil.copy(currentItem);
				const filterItem = $cbMirrorFilters.prop("checked");
				cpy.data = cpy.data.filter(it => {
					if (search) if (!_searchFeatures(it, true)) return false;
					if (filterItem) return _filterProps(it);
					return true;
				});
				return cpy;
			}

			$loadings.forEach($l => $l.remove());

			// SIDEBAR /////////////////////////////////////////////////////////////////////////////////////////
			const $sideHead = $(`<div class="p-2 artr__side__head"><div class="artr__side__head__title">Filters</div></div>`).appendTo($sidebar);
			// This functionality is contained in the filter buttons, but might need to be done here to improve performance in the future
			// $(`<button class="btn">Apply</button>`).click(() => {
			// 	if (currentItem) doRenderItem(applyFilterAndSearchToItem());
			// 	else doRenderIndex(applyFilterAndSearchToIndex())
			// }).appendTo($sideHead);
			const $lbMirrorFilters = $(`<label class="split" title="Apply filters to results inside folders (as well as the index)"><span>Filter within folders</span></label>`).appendTo($sideHead);
			const $cbMirrorFilters = $(`<input type="checkbox" checked>`).appendTo($lbMirrorFilters).change(() => {
				if (currentItem) {
					doRenderItem(applyFilterAndSearchToItem());
				}
			});

			const $sideBody = $(`<div class="artr__side__body"/>`).appendTo($sidebar);
			const addSidebarSection = (prop, ix) => {
				const fullName = (() => {
					switch (prop) {
						case "imageType": return "Image Type";
						case "grid": return "Grid Type";
						case "monster": return "Monster Type";
						case "audience": return "Intended Audience";
						default:
							return prop.uppercaseFirst();
					}
				})();

				const $tagHead = $(`<div class="artr__side__tag_header"><div>${fullName}</div><div>[\u2013]</div></div>`).appendTo($sideBody).click(() => {
					$tagGrid.toggle();
					$tagHead.html($tagHead.html().replace(/\[.]/, (...m) => m[0] === "[+]" ? "[\u2013]" : "[+]"));
				});

				const $tagGrid = $(`<div class="artr__side__tag_grid"/>`).appendTo($sideBody);
				const getNextState = (state, dir) => {
					const ix = STATES.indexOf(state) + dir;
					if (ix > STATES.length - 1) return STATES[0];
					if (ix < 0) return STATES.last();
					return STATES[ix];
				};

				if (ix) $tagHead.click(); // hide by default

				enums[prop].sort((a, b) => SortUtil.ascSort(b.c, a.c)).forEach(enm => {
					const cycleState = dir => {
						const nxtState = getNextState($btn.attr("data-state"), dir);
						$btn.attr("data-state", nxtState);

						if (nxtState === "0") {
							delete filters[prop][enm.v];
							if (!Object.keys(filters[prop]).length) delete filters[prop];
						} else (filters[prop] = filters[prop] || {})[enm.v] = nxtState === "1";

						if (currentItem) doRenderItem(applyFilterAndSearchToItem());
						else doRenderIndex(applyFilterAndSearchToIndex());
					};

					const $btn = $(`<button class="btn artr__side__tag" data-state="0">${enm.v} (${enm.c})</button>`)
						.click(() => cycleState(1))
						.contextmenu((evt) => {
							if (!evt.ctrlKey) {
								evt.preventDefault();
								cycleState(-1);
							}
						})
						.appendTo($tagGrid);
				});
			};
			Object.keys(enums).forEach((k, i) => addSidebarSection(k, i));

			// MAIN PAGE ///////////////////////////////////////////////////////////////////////////////////////
			const $mainHead = $(`<div class="p-2 artr__search"/>`).appendTo($mainPane);

			const $wrpBread = $(`<div class="artr__bread"/>`).appendTo($mainHead);
			const updateCrumbs = () => {
				$wrpBread.empty();
				const $txtIndex = $(`<span class="artr__crumb btn">Index</span>`)
					.appendTo($wrpBread)
					.click(() => doRenderIndex(applyFilterAndSearchToIndex()));

				if (currentItem) {
					const $txtSlash = $(`<span class="artr__crumb artr__crumb--sep">/</span>`).appendTo($wrpBread);
					const $txtItem = $(`<span class="artr__crumb btn">${currentItem.set} \u2013 ${currentItem.artist}</span>`)
						.appendTo($wrpBread)
						.click(() => {
							$iptSearch.val("");
							search = "";
							doRenderItem(applyFilterAndSearchToItem(), true);
						});
				}
			};
			updateCrumbs();

			let searchTimeout;
			const doSearch = () => {
				search = ($iptSearch.val() || "").trim();
				if (currentItem) doRenderItem(applyFilterAndSearchToItem());
				else doRenderIndex(applyFilterAndSearchToIndex())
			};
			const $iptSearch = $(`<input placeholder="Search..." class="artr__search__field">`).on("keydown", (e) => {
				clearTimeout(searchTimeout);
				if (e.which === 13) {
					doSearch();
				} else {
					searchTimeout = setTimeout(() => {
						doSearch();
					}, 100);
				}
			}).appendTo($mainHead);

			const $mainBody = $(`<div class="artr__view"/>`).appendTo($mainPane);
			const $mainBodyInner = $(`<div class="artr__view_inner"/>`).appendTo($mainBody);

			const $itemBody = $(`<div class="artr__view"/>`).hide().appendTo($mainPane);
			const $itemBodyInner = $(`<div class="artr__view_inner"/>`).appendTo($itemBody);

			function doRenderIndex (indexSlice) {
				currentItem = false;
				currentIndexKey = false;
				$mainBody.show();
				$itemBody.hide();
				$mainBodyInner.empty();
				updateCrumbs();

				if (!indexSlice.length) {
					$(`<div class="artr__no_results_wrp"><div class="artr__no_results"><div class="text-center"><span class="artr__no_results_headline">No results found</span><br>Please adjust the filters (on the left) or refine your search (above).</div></div></div>`).appendTo($mainBodyInner)
				} else {
					indexSlice.forEach(it => {
						const $item = $(`<div class="artr__item artr__item--index"/>`).appendTo($mainBodyInner).click(() => doLoadAndRenderItem(it));

						const $itemTop = $(`
							<div class="artr__item__top artr__item__top--quart">
								${[...new Array(4)].map((_, i) => `<div class="atr__item__quart">${it._sample[i] ? `<img class="artr__item__thumbnail" src="${GH_PATH}${it._key}--thumb-${it._sample[i]}.jpg">` : ""}</div>`).join("")}
							</div>
						`).appendTo($item);

						const $itemStats = $(`<div class="artr__item__stats"/>`).appendTo($itemTop);
						const $statsImages = $(`<div class="artr__item__stats_item help--subtle" title="Number of images">×${it._size.toLocaleString()}</div>`).appendTo($itemStats);

						const $itemMenu = $(`<div class="artr__item__menu"/>`).appendTo($itemTop);
						const $btnExternalArt = $(`<div class="artr__item__menu_item pictos btn" title="Add to External Art list (${it._size} image${it._size === 1 ? "" : "s"})">P</div>`)
							.appendTo($itemMenu)
							.click(async (evt) => {
								evt.stopPropagation();
								const file = await pGetJson(`${GH_PATH}${it._key}.json`);
								const toAdd = file.data.map((it, i) => ({
									name: `${file.set} \u2014 ${file.artist} (${i})`,
									url: it.uri,
								}));
								d20plus.art.addToHandout(toAdd);
								alert(`Added ${file.data.length} image${file.data.length === 1 ? "" : "s"} to the External Art list.`);
							});
						const $btnDownload = $(`<div class="artr__item__menu_item pictos btn" title="Download ZIP (SHIFT to download a text file of URLs)">}</div>`)
							.appendTo($itemMenu)
							.click(async (evt) => {
								evt.stopPropagation();
								const file = await pGetJson(`${GH_PATH}${it._key}.json`);
								if (evt.shiftKey) {
									d20plus.artBrowse._downloadUrls(file);
								} else {
									d20plus.artBrowse._downloadZip(file);
								}
							});

						const $itemBottom = $(`
							<div class="artr__item__bottom">
								<div class="artr__item__bottom__row" style="padding-bottom: 2px;" title="${it._set}">${it._set}</div>
								<div class="artr__item__bottom__row" style="padding-top: 2px;" title="${it._artist}"><i>By</i> ${it._artist}</div>
							</div>
						`).appendTo($item);
					});
				}
			}

			function doLoadAndRenderItem (indexItem) {
				pGetJson(`${GH_PATH}${indexItem._key}.json`).then(file => {
					currentItem = file;
					currentIndexKey = indexItem._key;
					doRenderItem(applyFilterAndSearchToItem(), true);
				});
			}

			function doRenderItem (file, resetScroll) {
				$mainBody.hide();
				$itemBody.show();
				$itemBodyInner.empty();
				updateCrumbs();
				if (resetScroll) $itemBodyInner.scrollTop(0);
				const $itmUp = $(`<div class="artr__item artr__item--item artr__item--back"><div class="pictos">[</div></div>`)
					.click(() => doRenderIndex(applyFilterAndSearchToIndex()))
					.appendTo($itemBodyInner);

				file.data.sort((a, b) => SortUtil.ascSort(a.hash, b.hash)).forEach((it, i) => {
					// "library-item" and "draggableresult" classes required for drag/drop
					const $item = $(`<div class="artr__item artr__item--item library-item draggableresult" data-fullsizeurl="${it.uri}"/>`)
						.appendTo($itemBodyInner)
						.click(() => {
							const $wrpBigImg = $(`<div class="artr__wrp_big_img"><img class="artr__big_img" src="${it.uri}"></div>`)
								.click(() => $wrpBigImg.remove()).appendTo($(`body`));
						});
					const $wrpImg = $(`<div class="artr__item__full"/>`).appendTo($item);
					const $img = $(`<img class="artr__item__thumbnail" src="${GH_PATH}${currentIndexKey}--thumb-${it.hash}.jpg">`).appendTo($wrpImg);

					const $itemMenu = $(`<div class="artr__item__menu"/>`).appendTo($item);
					const $btnExternalArt = $(`<div class="artr__item__menu_item pictos" title="Add to External Art list">P</div>`)
						.appendTo($itemMenu)
						.click((evt) => {
							evt.stopPropagation();
							d20plus.art.addToHandout([{name: `${file.set} \u2014 ${file.artist} (${i})`, url: it.uri}]);
							alert(`Added image to the External Art list.`);
						});
					const $btnDownload = $(`<div class="artr__item__menu_item pictos" title="Download">}</div>`)
						.appendTo($itemMenu)
						.click((evt) => {
							evt.stopPropagation();
							window.open(it.uri, "_blank");
						});
					const $btnCopyUrl = $(`<div class="artr__item__menu_item pictos" title="Copy URL">A</div>`)
						.appendTo($itemMenu)
						.click(async (evt) => {
							evt.stopPropagation();
							await MiscUtil.pCopyTextToClipboard(it.uri);
							JqueryUtil.showCopiedEffect($btnDownload, "Copied URL!");
						});
					if (it.support) {
						const $btnSupport = $(`<div class="artr__item__menu_item pictos" title="Support Artist">$</div>`)
							.appendTo($itemMenu)
							.click((evt) => {
								evt.stopPropagation();
								window.open(it.support, "_blank");
							});
					}

					$item.draggable({
						handle: ".artr__item",
						revert: true,
						revertDuration: 0,
						helper: "clone",
						appendTo: "body",
					});
				});
			}

			doRenderIndex(applyFilterAndSearchToIndex());
		}

		let firstClick = true;
		const calcWidth = () => {
			const base = d20.engine.canvasWidth * 0.66;
			return (Math.ceil((base - 300) / 190) * 190) + 320;
		};
		const $btnBrowse = $(`#button-browse-external-art`).click(() => {
			$win.dialog(
				"option",
				{
					width: calcWidth(),
					height: d20.engine.canvasHeight - 100,
					position: {
						my: "left top",
						at: "left+75 top+15",
						collision: "none",
					},
				},
			).dialog("open");

			if (firstClick) {
				doInit();
				firstClick = false;
			}
		});
	};

	d20plus.artBrowse._downloadZip = async item => {
		function doCreateIdChat (str, isError) {
			const uid = d20plus.ut.generateRowId();
			d20.textchat.incoming(false, ({
				who: "system",
				type: "system",
				content: `<span id="${uid}" class="hacker-chat inline-block ${isError ? "is-error" : ""}">${str}</span>`,
			}));
			return uid;
		}

		function doUpdateIdChat (id, str, isError = false) {
			$(`#userscript-${id}`).toggleClass("is-error", isError).html(str);
		}

		let isHandled = false;
		function handleCancel (id) {
			if (isHandled) return;
			isHandled = true;
			doUpdateIdChat(id, "Download cancelled.");
		}

		function pAjaxLoad (url) {
			const oReq = new XMLHttpRequest();
			const p = new Promise((resolve, reject) => {
				// FIXME cors-anywhere has a usage limit, which is pretty easy to hit when downloading many files
				oReq.open("GET", `https://cors-anywhere.herokuapp.com/${url}`, true);
				oReq.responseType = "arraybuffer";
				let lastContentType = null;
				oReq.onreadystatechange = () => {
					const h = oReq.getResponseHeader("content-type");
					if (h) {
						lastContentType = h;
					}
				};
				oReq.onload = function () {
					const arrayBuffer = oReq.response;
					resolve({buff: arrayBuffer, contentType: lastContentType});
				};
				oReq.onerror = (e) => reject(new Error(`Error during request: ${e}`));
				oReq.send();
			});
			p.abort = () => oReq.abort();
			return p;
		}

		$(`#rightsidebar a[href="#textchat"]`).click();
		const chatId = doCreateIdChat(`Download starting...`);
		let isCancelled = false;
		let downloadTasks = [];
		const $btnStop = $(`<button class="btn btn-danger Ve-btn-chat" id="button-${chatId}">Stop</button>`)
			.insertAfter($(`#userscript-${chatId}`))
			.click(() => {
				isCancelled = true;
				downloadTasks.forEach(p => p.abort());
				handleCancel(chatId);
				$btnStop.remove();
			});
		// eslint-disable-next-line no-console
		try { $btnStop[0].scrollIntoView() } catch (e) { console.error(e) }

		if (isCancelled) return handleCancel(chatId);

		try {
			const toSave = [];
			let downloaded = 0;
			let errorCount = 0;

			const getWrappedPromise = dataItem => {
				const pAjax = pAjaxLoad(dataItem.uri);
				// eslint-disable-next-line no-async-promise-executor
				const p = new Promise(async resolve => {
					try {
						const data = await pAjax;
						toSave.push(data);
					} catch (e) {
						d20plus.ut.error(`Error downloading "${dataItem.uri}":`, e);
						++errorCount;
					}
					++downloaded;
					doUpdateIdChat(chatId, `Downloading ${downloaded}/${item.data.length}... (${Math.floor(100 * downloaded / item.data.length)}%)${errorCount ? ` (${errorCount} error${errorCount === 1 ? "" : "s"})` : ""}`);
					resolve();
				});
				p.abort = () => pAjax.abort();
				return p;
			};

			downloadTasks = item.data.map(dataItem => getWrappedPromise(dataItem));
			await Promise.all(downloadTasks);

			if (isCancelled) return handleCancel(chatId);

			doUpdateIdChat(chatId, `Building ZIP...`);

			const zip = new JSZip();
			toSave.forEach((data, i) => {
				const extension = (data.contentType || "unknown").split("/").last();
				zip.file(`${`${i}`.padStart(3, "0")}.${extension}`, data.buff, {binary: true});
			});

			if (isCancelled) return handleCancel(chatId);

			zip.generateAsync({type: "blob"})
				.then((content) => {
					if (isCancelled) return handleCancel(chatId);

					doUpdateIdChat(chatId, `Downloading ZIP...`);
					d20plus.ut.saveAs(content, d20plus.ut.sanitizeFilename(`${item.set}__${item.artist}`));
					doUpdateIdChat(chatId, `Download complete.`);
					$btnStop.remove();
				});
		} catch (e) {
			doUpdateIdChat(chatId, `Download failed! Error was: ${e.message}<br>Check the log for more information.`, true);
			// eslint-disable-next-line no-console
			console.error(e);
		}
	};

	d20plus.artBrowse._downloadUrls = async item => {
		const contents = item.data.map(it => it.uri).join("\n");
		const blob = new Blob([contents], {type: "text/plain"});
		d20plus.ut.saveAs(blob, d20plus.ut.sanitizeFilename(`${item.set}__${item.artist}`));
	};
}

SCRIPT_EXTENSIONS.push(d20plusArtBrowser);


function initOverwrites () {
	d20plus.overwrites = {};
}

SCRIPT_EXTENSIONS.push(initOverwrites);


function initCanvasHandlerOverwrite () {
	/**
	 * Dumb variable names copy-pasted from uglified code
	 * @param c x co-ord
	 * @param u y c-ord
	 * @returns {*[]} 2-len array; [0] = x and [1] = y
	 */
	function getClosestHexPoint (c, u) {
		function getEuclidDist (x1, y1, x2, y2) {
			return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
		}

		const hx = d20.canvas_overlay.activeHexGrid.GetHexAt({
			X: c,
			Y: u,
		});

		let minDist = 1000000;
		let minPoint = [c, u];

		function checkDist (x1, y1) {
			const dist = getEuclidDist(x1, y1, c, u);
			if (dist < minDist) {
				minDist = dist;
				minPoint = [x1, y1];
			}
		}
		hx.Points.forEach(pt => {
			checkDist(pt.X, pt.Y);
		});
		checkDist(hx.MidPoint.X, hx.MidPoint.Y);

		return minPoint;
	}

	const canvasHandlerDown = function (e) {
		/* eslint-disable */

		// BEGIN MOD
		var cnv = d20.engine.canvas;
		var wrp = $("#editor-wrapper");
		const $finalCanvas = $(d20.engine.final_canvas);
		// END MOD
		var i, n;
		if (d20.tddice && d20.tddice.handleInteraction && d20.tddice.handleInteraction(),
			e.touches) {
			if ("pan" == d20.engine.mode)
				return;
			e.touches.length > 1 && (A = d20.engine.mode,
				d20.engine.mode = "pan",
				d20.engine.leftMouseIsDown = !0),
				d20.engine.lastTouchStarted = (new Date).getTime(),
				i = e.touches[0].pageX,
				n = e.touches[0].pageY,
				e.preventDefault()
		} else
			i = e.pageX,
				n = e.pageY;
		for (var o = d20.engine.showLastPaths.length; o--;)
			"selected" == d20.engine.showLastPaths[o].type && d20.engine.showLastPaths.splice(o, 1);
		d20.engine.handleMetaKeys(e),
		"select" != d20.engine.mode && "path" != d20.engine.mode || cnv.__onMouseDown(e),
		(0 === e.button || e.touches && 1 == e.touches.length) && (d20.engine.leftMouseIsDown = !0),
		2 === e.button && (d20.engine.rightMouseIsDown = !0);
		var r = Math.floor(i / d20.engine.canvasZoom + d20.engine.currentCanvasOffset[0] - d20.engine.paddingOffset[0] / d20.engine.canvasZoom)
			,
			a = Math.floor(n / d20.engine.canvasZoom + d20.engine.currentCanvasOffset[1] - d20.engine.paddingOffset[1] / d20.engine.canvasZoom);
		if (d20.engine.lastMousePos = [r, a],
			d20.engine.mousePos = [r, a],
		!d20.engine.leftMouseIsDown || "fog-reveal" != d20.engine.mode && "fog-hide" != d20.engine.mode && "gridalign" != d20.engine.mode) {
			if (d20.engine.leftMouseIsDown && "fog-polygonreveal" == d20.engine.mode) {
				// BEGIN MOD
				var s = r
					, c = a;

				if (0 != d20.engine.snapTo && (e.shiftKey && !d20.Campaign.activePage().get("adv_fow_enabled") || !e.shiftKey && d20.Campaign.activePage().get("adv_fow_enabled"))) {
					if ("square" == d20.Campaign.activePage().get("grid_type")) {
						s = d20.engine.snapToIncrement(s, d20.engine.snapTo)
						c = d20.engine.snapToIncrement(c, d20.engine.snapTo)
					} else {
						const minPoint = getClosestHexPoint(s, c);
						s = minPoint[0];
						c = minPoint[1];
					}
				}

				d20.engine.fog.points.length > 0 && Math.abs(d20.engine.fog.points[0][0] - s) + Math.abs(d20.engine.fog.points[0][1] - c) < 15 ? (d20.engine.fog.points.push([d20.engine.fog.points[0][0], d20.engine.fog.points[0][1]]),
					d20.engine.finishPolygonReveal()) : d20.engine.fog.points.push([s, c]),
					d20.engine.redrawScreenNextTick(!0)
				// END MOD
			} else if (d20.engine.leftMouseIsDown && "measure" == d20.engine.mode)
				if (2 === e.button)
					d20.engine.addWaypoint(e);
				else {
					d20.engine.measure.sticky && d20.engine.endMeasure(),
						d20.engine.measure.down[0] = r,
						d20.engine.measure.down[1] = a,
						d20.engine.measure.sticky = e.shiftKey;
					const t = d20.Campaign.activePage().get("grid_type");
					let i = "snap_center" === d20.engine.ruler_snapping && !e.altKey;
					if (i |= "no_snap" === d20.engine.ruler_snapping && e.altKey,
						i &= 0 !== d20.engine.snapTo)
						if ("square" === t)
							d20.engine.measure.down[1] = d20.engine.snapToIncrement(d20.engine.measure.down[1] + Math.floor(d20.engine.snapTo / 2), d20.engine.snapTo) - Math.floor(d20.engine.snapTo / 2),
								d20.engine.measure.down[0] = d20.engine.snapToIncrement(d20.engine.measure.down[0] + Math.floor(d20.engine.snapTo / 2), d20.engine.snapTo) - Math.floor(d20.engine.snapTo / 2);
						else {
							const e = d20.canvas_overlay.activeHexGrid.GetHexAt({
								X: d20.engine.measure.down[0],
								Y: d20.engine.measure.down[1]
							});
							e && (d20.engine.measure.down[1] = e.MidPoint.Y,
								d20.engine.measure.down[0] = e.MidPoint.X)
						}
					else if (0 === d20.engine.snapTo || "snap_corner" !== d20.engine.ruler_snapping || e.altKey)
						d20.engine.measure.flags |= 1;
					else {
						if ("square" === t)
							d20.engine.measure.down[0] = d20.engine.snapToIncrement(d20.engine.measure.down[0], d20.engine.snapTo),
								d20.engine.measure.down[1] = d20.engine.snapToIncrement(d20.engine.measure.down[1], d20.engine.snapTo);
						else {
							const e = d20.engine.snapToHexCorner([d20.engine.measure.down[0], d20.engine.measure.down[1]]);
							e && (d20.engine.measure.down[0] = e[0],
								d20.engine.measure.down[1] = e[1])
						}
						d20.engine.measure.flags |= 1
					}
				}
			else if (d20.engine.leftMouseIsDown && "fxtools" == d20.engine.mode)
				d20.engine.fx.current || (d20.engine.fx.current = d20.fx.handleClick(r, a));
			else if (d20.engine.leftMouseIsDown && "text" == d20.engine.mode) {
				const e = {
					fontFamily: $("#font-family").val(),
					fontSize: $("#font-size").val(),
					fill: $("#font-color").val(),
					text: "",
					left: r,
					top: a,
					stroke: $('#font-stroke').val()
				}
					, t = d20.Campaign.activePage().addText(e);
				$("body").on("mouseup.create_text_editor", () => {
						$("body").off("mouseup.create_text_editor"),
							d20.engine.editText(t.view.graphic, e.top, e.left),
							$(".texteditor").focus()
					}
				)
			} else if (d20.engine.leftMouseIsDown && "rect" == d20.engine.mode) {
				var u = parseInt($("#path_width").val(), 10)
					, h = d20.engine.drawshape.shape = {
					strokewidth: u,
					x: 0,
					y: 0,
					width: 10,
					height: 10,
					type: e.altKey ? "circle" : "rect"
				};
				s = r,
					c = a;
				0 != d20.engine.snapTo && e.shiftKey && (s = d20.engine.snapToIncrement(s, d20.engine.snapTo),
					c = d20.engine.snapToIncrement(c, d20.engine.snapTo)),
					h.x = s,
					h.y = c,
					h.fill = $("#path_fillcolor").val(),
					h.stroke = $("#path_strokecolor").val(),
					d20.engine.drawshape.start = [i + d20.engine.currentCanvasOffset[0] - d20.engine.paddingOffset[0], n + d20.engine.currentCanvasOffset[1] - d20.engine.paddingOffset[1]],
					d20.engine.redrawScreenNextTick()
			} else if (d20.engine.leftMouseIsDown && "ellipse" == d20.engine.mode) {
				var u = parseInt($("#path_width").val(), 10)
					, h = d20.engine.drawshape.shape = {
					strokewidth: u,
					x: 0,
					y: 0,
					width: 10,
					height: 10,
					type: "circle"
				};
				s = r,
					c = a;
				0 != d20.engine.snapTo && e.shiftKey && (s = d20.engine.snapToIncrement(s, d20.engine.snapTo),
					c = d20.engine.snapToIncrement(c, d20.engine.snapTo)),
					h.x = s,
					h.y = c,
					h.fill = $("#path_fillcolor").val(),
					h.stroke = $("#path_strokecolor").val(),
					d20.engine.drawshape.start = [i + d20.engine.currentCanvasOffset[0] - d20.engine.paddingOffset[0], n + d20.engine.currentCanvasOffset[1] - d20.engine.paddingOffset[1]],
					d20.engine.redrawScreenNextTick()
			} else if (d20.engine.leftMouseIsDown && "polygon" == d20.engine.mode) {
				if (d20.engine.drawshape.shape) h = d20.engine.drawshape.shape;
				else {
					u = parseInt($("#path_width").val(), 10);
					(h = d20.engine.drawshape.shape = {
						strokewidth: u,
						points: [],
						type: "polygon"
					}).fill = $("#path_fillcolor").val(),
						h.stroke = $("#path_strokecolor").val()
				}

				// BEGIN MOD
				s = r, c = a;

				if (0 != d20.engine.snapTo && e.shiftKey) {
					if ("square" == d20.Campaign.activePage().get("grid_type")) {
						s = d20.engine.snapToIncrement(s, d20.engine.snapTo);
						c = d20.engine.snapToIncrement(c, d20.engine.snapTo);
					} else {
						const minPoint = getClosestHexPoint(s, c);
						s = minPoint[0];
						c = minPoint[1];
					}
				}

				h.points.length > 0 && Math.abs(h.points[0][0] - s) + Math.abs(h.points[0][1] - c) < 15 ? (h.points.push([h.points[0][0], h.points[0][1]]),
						d20.engine.finishCurrentPolygon()) : h.points.push([s, c]),
					d20.engine.redrawScreenNextTick()
				// END MOD
			} else if (d20.engine.leftMouseIsDown && "targeting" === d20.engine.mode) {
				var p = d20.engine.canvas.findTarget(e, !0, !0);
				return void (p !== undefined && "image" === p.type && p.model && d20.engine.nextTargetCallback(p))
			}
			// BEGIN MOD
			else if (d20.engine.leftMouseIsDown && "line_splitter" === d20.engine.mode) {
				const lastPoint = {
					x: d20.engine.lastMousePos[0],
					y: d20.engine.lastMousePos[1]
				};
				(d20.engine.canvas._objects || []).forEach(o => {
					if (o.type === "path" && o.containsPoint(lastPoint)) {
						const asObj = o.toObject();
						const anyCurves = asObj.path.filter(it => it instanceof Array && it.length > 0 && it[0] === "C");
						if (!anyCurves.length) {
							// PathMath expects these
							o.model.set("_pageid", d20.Campaign.activePage().get("id"));
							o.model.set("_path", JSON.stringify(o.path));

							console.log("SPLITTING PATH: ", o.model.toJSON());
							const mainPath = o.model;

							// BEGIN PathSplitter CODE
							let mainSegments = PathMath.toSegments(mainPath);
							// BEGIN MOD
							const SLICE_LEN = 10;
							const slicePoint1 = [lastPoint.x + (SLICE_LEN / 2), lastPoint.y + (SLICE_LEN / 2), 1];
							const slicePoint2 = [lastPoint.x - (SLICE_LEN / 2), lastPoint.y - (SLICE_LEN / 2), 1];
							setTimeout(() => {
								d20.engine.redrawScreenNextTick();
							}, 1);

							let splitSegments = [
								[slicePoint1, slicePoint2]
							];
							// END MOD
							let segmentPaths = _getSplitSegmentPaths(mainSegments, splitSegments);

							// (function moved into this scope)
							function _getSplitSegmentPaths(mainSegments, splitSegments) {
								let resultSegPaths = [];
								let curPathSegs = [];

								_.each(mainSegments, seg1 => {

									// Find the points of intersection and their parametric coefficients.
									let intersections = [];
									_.each(splitSegments, seg2 => {
										let i = PathMath.segmentIntersection(seg1, seg2);
										if (i) intersections.push(i);
									});

									if (intersections.length > 0) {
										// Sort the intersections in the order that they appear along seg1.
										intersections.sort((a, b) => {
											return a[1] - b[1];
										});

										let lastPt = seg1[0];
										_.each(intersections, i => {
											// Complete the current segment path.
											curPathSegs.push([lastPt, i[0]]);
											resultSegPaths.push(curPathSegs);

											// Start a new segment path.
											curPathSegs = [];
											lastPt = i[0];
										});
										curPathSegs.push([lastPt, seg1[1]]);
									} else {
										curPathSegs.push(seg1);
									}
								});
								resultSegPaths.push(curPathSegs);

								return resultSegPaths;
							};
							// (end function moved into this scope)

							// Convert the list of segment paths into paths.
							let _pageid = mainPath.get('_pageid');
							let controlledby = mainPath.get('controlledby');
							let fill = mainPath.get('fill');
							let layer = mainPath.get('layer');
							let stroke = mainPath.get('stroke');
							let stroke_width = mainPath.get('stroke_width');

							let results = [];
							_.each(segmentPaths, segments => {
								// BEGIN MOD
								if (!segments) {
									d20plus.chatLog(`A path had no segments! This is probably a bug. Please report it.`);
									return;
								}
								// END MOD

								let pathData = PathMath.segmentsToPath(segments);
								_.extend(pathData, {
									_pageid,
									controlledby,
									fill,
									layer,
									stroke,
									stroke_width
								});
								let path = createObj('path', pathData);
								results.push(path);
							});

							// Remove the original path and the splitPath.
							// BEGIN MOD
							mainPath.destroy();
							// END MOD
							// END PathSplitter CODE
						}
					}
				});
			}
			// END MOD
		} else
			d20.engine.fog.down[0] = r,
				d20.engine.fog.down[1] = a,
			0 != d20.engine.snapTo && "square" == d20.Campaign.activePage().get("grid_type") && ("gridalign" == d20.engine.mode ? e.shiftKey && (d20.engine.fog.down[0] = d20.engine.snapToIncrement(d20.engine.fog.down[0], d20.engine.snapTo),
				d20.engine.fog.down[1] = d20.engine.snapToIncrement(d20.engine.fog.down[1], d20.engine.snapTo)) : (e.shiftKey && !d20.Campaign.activePage().get("adv_fow_enabled") || !e.shiftKey && d20.Campaign.activePage().get("adv_fow_enabled")) && (d20.engine.fog.down[0] = d20.engine.snapToIncrement(d20.engine.fog.down[0], d20.engine.snapTo),
				d20.engine.fog.down[1] = d20.engine.snapToIncrement(d20.engine.fog.down[1], d20.engine.snapTo)));
		if (window.currentPlayer && d20.engine.leftMouseIsDown && "select" == d20.engine.mode) {
			if (2 === e.button && d20.engine.addWaypoint(e),
			d20.engine.pings[window.currentPlayer.id] && d20.engine.pings[window.currentPlayer.id].radius > 20)
				return;
			var f = {
				left: r,
				top: a,
				radius: -5,
				player: window.currentPlayer.id,
				pageid: d20.Campaign.activePage().id,
				currentLayer: window.currentEditingLayer
			};
			window.is_gm && e.shiftKey && (f.scrollto = !0),
				d20.engine.pings[window.currentPlayer.id] = f,
				d20.engine.pinging = {
					downx: i,
					downy: n
				},
				d20.engine.redrawScreenNextTick(!0)
		}

		const g = ["select", "path", "text", "fxtools", "measure", "rect", "ellipse"];
		d20.engine.rightMouseIsDown && g.includes(d20.engine.mode) || d20.engine.leftMouseIsDown && "pan" === d20.engine.mode ? (d20.engine.pan.beginPos = [wrp.scrollLeft(), wrp.scrollTop()],
			d20.engine.pan.panXY = [i, n],
			d20.engine.pan.panning = !0,
			// BEGIN MOD
			$finalCanvas.css("cursor", "grabbing")) : d20.engine.pan.panning = !1,
			// END MOD
		2 === e.button && !d20.engine.leftMouseIsDown && d20.engine.measurements[window.currentPlayer.id] && d20.engine.measurements[window.currentPlayer.id].sticky && (d20.engine.endMeasure(),
			d20.engine.announceEndMeasure({
				player: window.currentPlayer.id
			}));

		// BEGIN MOD
		$finalCanvas.hasClass("hasfocus") || $finalCanvas.focus();
		// END MOD

		/* eslint-enable */
	}

	const canvasHandlerMove = function (e) {
		/* eslint-disable */

		// BEGIN MOD
		var cnv = d20.engine.canvas;
		var wrp = $("#editor-wrapper");
		const $selMeasureMode = $(`#measure_mode`);
		const $selRadMode = $(`#measure_mode_sel_2`);
		const $iptConeWidth = $(`#measure_mode_ipt_3`);
		const $selConeMode = $(`#measure_mode_sel_3`);
		const $selBoxMode = $(`#measure_mode_sel_4`);
		const $selLineMode = $(`#measure_mode_sel_5`);
		const $iptLineWidth = $(`#measure_mode_ipt_5`);
		// END MOD

		var t, i;
		if (e.changedTouches ? ((e.changedTouches.length > 1 || "pan" == d20.engine.mode) && (delete d20.engine.pings[window.currentPlayer.id],
			d20.engine.pinging = !1),
			e.preventDefault(),
			t = e.changedTouches[0].pageX,
			i = e.changedTouches[0].pageY) : (t = e.pageX,
			i = e.pageY),
		"select" != d20.engine.mode && "path" != d20.engine.mode && "targeting" != d20.engine.mode || cnv.__onMouseMove(e),
		d20.engine.leftMouseIsDown || d20.engine.rightMouseIsDown) {
			var n = Math.floor(t / d20.engine.canvasZoom + d20.engine.currentCanvasOffset[0] - d20.engine.paddingOffset[0] / d20.engine.canvasZoom)
				, o = Math.floor(i / d20.engine.canvasZoom + d20.engine.currentCanvasOffset[1] - d20.engine.paddingOffset[1] / d20.engine.canvasZoom);
			if (d20.engine.mousePos = [n, o],
			!d20.engine.leftMouseIsDown || "fog-reveal" !== d20.engine.mode && "fog-hide" !== d20.engine.mode && "gridalign" !== d20.engine.mode) {
				if (d20.engine.leftMouseIsDown && "measure" == d20.engine.mode && d20.engine.measure.down[0] !== undefined && d20.engine.measure.down[1] !== undefined) {
					d20.engine.measure.down[2] = n,
						d20.engine.measure.down[3] = o,
						d20.engine.measure.sticky |= e.shiftKey;
					const t = d20.Campaign.activePage().get("grid_type")
						, i = "snap_corner" === d20.engine.ruler_snapping && !e.altKey && 0 !== d20.engine.snapTo;
					let a = "snap_center" === d20.engine.ruler_snapping && !e.altKey;
					if (a |= "no_snap" === d20.engine.ruler_snapping && e.altKey,
						a &= 0 !== d20.engine.snapTo) {
						if ("square" === t)
							d20.engine.measure.down[2] = d20.engine.snapToIncrement(d20.engine.measure.down[2] + Math.floor(d20.engine.snapTo / 2), d20.engine.snapTo) - Math.floor(d20.engine.snapTo / 2),
								d20.engine.measure.down[3] = d20.engine.snapToIncrement(d20.engine.measure.down[3] + Math.floor(d20.engine.snapTo / 2), d20.engine.snapTo) - Math.floor(d20.engine.snapTo / 2);
						else {
							const e = d20.canvas_overlay.activeHexGrid.GetHexAt({
								X: d20.engine.measure.down[2],
								Y: d20.engine.measure.down[3]
							});
							e && (d20.engine.measure.down[3] = e.MidPoint.Y,
								d20.engine.measure.down[2] = e.MidPoint.X)
						}
						d20.engine.measure.flags &= -3
					} else if (i) {
						if ("square" === t)
							d20.engine.measure.down[2] = d20.engine.snapToIncrement(d20.engine.measure.down[2], d20.engine.snapTo),
								d20.engine.measure.down[3] = d20.engine.snapToIncrement(d20.engine.measure.down[3], d20.engine.snapTo);
						else {
							const e = d20.engine.snapToHexCorner([d20.engine.measure.down[2], d20.engine.measure.down[3]]);
							e && (d20.engine.measure.down[2] = e[0],
								d20.engine.measure.down[3] = e[1])
						}
						d20.engine.measure.flags |= 2
					} else
						d20.engine.measure.flags |= 2;
					var r = {
						x: d20.engine.measure.down[0],
						y: d20.engine.measure.down[1],
						to_x: d20.engine.measure.down[2],
						to_y: d20.engine.measure.down[3],
						player: window.currentPlayer.id,
						pageid: d20.Campaign.activePage().id,
						currentLayer: window.currentEditingLayer,
						waypoints: d20.engine.measure.waypoints,
						sticky: d20.engine.measure.sticky,
						flags: d20.engine.measure.flags,
						hide: d20.engine.measure.hide

						// BEGIN MOD
						,
						Ve: {
							mode: $selMeasureMode.val(),
							radius: {
								mode: $selRadMode.val()
							},
							cone: {
								arc: $iptConeWidth.val(),
								mode: $selConeMode.val()
							},
							box: {
								mode: $selBoxMode.val(),
							},
							line: {
								mode: $selLineMode.val(),
								width: $iptLineWidth.val()
							}
						}
						// END MOD
					};
					d20.engine.announceMeasure(r)
				} else if (d20.engine.leftMouseIsDown && "fxtools" == d20.engine.mode) {
					if (d20.engine.fx.current) {
						var a = (new Date).getTime();
						a - d20.engine.fx.lastMoveBroadcast > d20.engine.fx.MOVE_BROADCAST_FREQ ? (d20.fx.moveFx(d20.engine.fx.current, n, o),
							d20.engine.fx.lastMoveBroadcast = a) : d20.fx.moveFx(d20.engine.fx.current, n, o, !0)
					}
				} else if (d20.engine.leftMouseIsDown && "rect" == d20.engine.mode) {
					var s = (t + d20.engine.currentCanvasOffset[0] - d20.engine.paddingOffset[0] - d20.engine.drawshape.start[0]) / d20.engine.canvasZoom
						, c = (i + d20.engine.currentCanvasOffset[1] - d20.engine.paddingOffset[1] - d20.engine.drawshape.start[1]) / d20.engine.canvasZoom;
					0 != d20.engine.snapTo && e.shiftKey && (s = d20.engine.snapToIncrement(s, d20.engine.snapTo),
						c = d20.engine.snapToIncrement(c, d20.engine.snapTo));
					var u = d20.engine.drawshape.shape;
					u.width = s,
						u.height = c,
						d20.engine.redrawScreenNextTick()
				} else if (d20.engine.leftMouseIsDown && "ellipse" == d20.engine.mode) {
					var s = (t + d20.engine.currentCanvasOffset[0] - d20.engine.paddingOffset[0] - d20.engine.drawshape.start[0]) / d20.engine.canvasZoom
						, c = (i + d20.engine.currentCanvasOffset[1] - d20.engine.paddingOffset[1] - d20.engine.drawshape.start[1]) / d20.engine.canvasZoom;
					0 != d20.engine.snapTo && e.shiftKey && (s = d20.engine.snapToIncrement(s, d20.engine.snapTo),
						c = d20.engine.snapToIncrement(c, d20.engine.snapTo));
					var u = d20.engine.drawshape.shape;
					u.width = s,
						u.height = c,
						d20.engine.redrawScreenNextTick()
				}
			} else
				d20.engine.fog.down[2] = n,
					d20.engine.fog.down[3] = o,
				0 !== d20.engine.snapTo && "square" === d20.Campaign.activePage().get("grid_type") && ("gridalign" === d20.engine.mode ? e.shiftKey && (d20.engine.fog.down[2] = d20.engine.snapToIncrement(d20.engine.fog.down[2], d20.engine.snapTo),
					d20.engine.fog.down[3] = d20.engine.snapToIncrement(d20.engine.fog.down[3], d20.engine.snapTo)) : (e.shiftKey && !d20.Campaign.activePage().get("adv_fow_enabled") || !e.shiftKey && d20.Campaign.activePage().get("adv_fow_enabled")) && (d20.engine.fog.down[2] = d20.engine.snapToIncrement(d20.engine.fog.down[2], d20.engine.snapTo),
					d20.engine.fog.down[3] = d20.engine.snapToIncrement(d20.engine.fog.down[3], d20.engine.snapTo))),
					d20.engine.redrawScreenNextTick(!0);
			if (d20.engine.pinging)
				(s = Math.abs(d20.engine.pinging.downx - t)) + (c = Math.abs(d20.engine.pinging.downy - i)) > 10 && (delete d20.engine.pings[window.currentPlayer.id],
					d20.engine.pinging = !1);
			if (d20.engine.pan.panning) {
				s = 2 * (t - d20.engine.pan.panXY[0]),
					c = 2 * (i - d20.engine.pan.panXY[1]);
				if (d20.engine.pan.lastPanDist += Math.abs(s) + Math.abs(c),
				d20.engine.pan.lastPanDist < 10)
					return;
				var h = d20.engine.pan.beginPos[0] - s
					, p = d20.engine.pan.beginPos[1] - c;
				wrp.stop().animate({
					scrollLeft: h,
					scrollTop: p
				}, {
					duration: 1,
					easing: "linear",
					queue: !1
				})
			}
		}

		/* eslint-enable */
	}

	d20plus.overwrites.canvasHandlerDown = canvasHandlerDown
	d20plus.overwrites.canvasHandlerMove = canvasHandlerMove
}
SCRIPT_EXTENSIONS.push(initCanvasHandlerOverwrite);


function initHTMLTokenEditor () {
	d20plus.html = d20plus.html || {};

	// no mods; just switched in to grant full features to non-pro
	document.addEventListener("b20initTemplates", function initHTML () {
		d20plus.html.tokenEditor = `
		<script id="tmpl_tokeneditor" type="text/html">
		<div class='dialog largedialog tokeneditor' style='display: block;'>
		<ul class='nav nav-tabs tokeneditor_navigation'>
		<li class='active'>
		<a data-tab='basic' href='javascript:void(0);'>
		<h2>Details</h2>
		</a>
		</li>
		<li>
		<a data-tab='notes' href='javascript:void(0);'>
		<h2>GM Notes</h2>
		</a>
		</li>
		<li class='nav-tabs--beta'>
		<a data-tab='prototype' href='javascript:void(0);'>
		<h2>Dynamic Lighting</h2>
		</a>
		</li>
		</ul>
		<div class='tab-content'>
		<div class='basic tab-pane tokeneditor__details'>
		<div class='w-100 d-inline-flex flex-wrap'>
		<!-- General -->
		<div class='tokeneditor__col general'>
		<div class='tokeneditor__row--general d-grid'>
		<div class='tokeneditor__header'>
		<h3 class='page_title text-capitalize'>general</h3>
		</div>
		<div class='tokeneditor__dropdown d-grid'>
		<div class='dropdown keep-open'>
		<button aria-expanded='false' aria-haspopup='true' class='btn btn-default btn--circle' data-toggle='dropdown' type='button'>
		<span class='sr-only'>nameplate player permissions menu</span>
		<svg aria-hidden='true' class='svg-inline--fa' data-icon='ellipsis-v' data-prefix='fas' height='12' viewBox='0 0 192 512' width='12' xmlns='http://www.w3.org/2000/svg'>
		<path d='M96 184c39.8 0 72 32.2 72 72s-32.2 72-72 72-72-32.2-72-72 32.2-72 72-72zM24 80c0 39.8 32.2 72 72 72s72-32.2 72-72S135.8 8 96 8 24 40.2 24 80zm0 352c0 39.8 32.2 72 72 72s72-32.2 72-72-32.2-72-72-72-72 32.2-72 72z' fill='000000'></path>
		</svg>
		</button>
		<ul aria-labelledby='dLabel' class='dropdown-menu dropdown-menu--right'>
		<h4>Player Permissions</h4>
		<li class='dropdown-item'>
		<div class='checkbox'>
		<label title='allow players to see name plate'>
		<input class='showplayers_name' type='checkbox'>
		See
		</label>
		</div>
		</li>
		<li class='dropdown-item'>
		<div class='checkbox'>
		<label title='allow players to edit name plate'>
		<input class='playersedit_name' type='checkbox'>
		Edit
		</label>
		</div>
		</li>
		</ul>
		</div>
		</div>
		</div>
		<!-- Represents Character -->
		<div class='tokeneditor__row'>
		<div class='tokeneditor__subheader help-icon'>
		<h4>Represents Character</h4>
		<a class='showtip pictos' title='You can choose to have the token represent a Character from the Journal. If you do, the token&#39;s name, controlling players, and bar values will be based on the Character. Most times you&#39;ll just leave this set to None/Generic.'>?</a>
		</div>
		<div class='tokeneditor__container'>
		<label title='select which token this character represents'>
		<span class='sr-only'>select which token this character represents</span>
		<select class='represents'>
		<option value=''>None/Generic Token</option>
		<$ _.each(window.Campaign.activeCharacters(), function(char) { $>
		<option value="<$!char.id$>"><$!char.get("name")$></option>
		<$ }); $>
		</select>
		</label>
		</div>
		</div>
		<!-- Name -->
		<div class='tokeneditor__row'>
		<div class='tokeneditor__subheader'>
		<h4>Name</h4>
		</div>
		<div class='tokeneditor__container tokeneditor__container-name tokeneditor__border d-inline-grid'>
		<div class='d-flex'>
		<label class='sr-only' for='token-general-character-name'>character name</label>
		<input class='name' id='token-general-character-name' type='text'>
		</div>
		<div class='tokeneditor__container-nameplate disable_box'>
		<div class='d-flex justify-content-center align-items-center'>
		<label class='sr-only' for='token-general-nameplate'>show nameplate on token</label>
		<input class='showname' id='token-general-nameplate' type='checkbox' value='1'>
		</div>
		<h4 class='text-capitalize'>nameplate</h4>
		</div>
		</div>
		</div>
		<!-- Controlled By -->
		<div class='tokeneditor__row'>
		<div class='tokeneditor__subheader'>
		<h4>Controlled By</h4>
		</div>
		<div class='tokeneditor__container'>
		<$ if(this.character) { $>
		<p>(Determined by Character settings)</p>
		<$ } else { $>
		<select class='controlledby selectize' multiple='true'>
		<option value='all'>All Players</option>
		<$ window.Campaign.players.each(function(player) { $>
		<option value="<$!player.id$>"><$!player.get("displayname")$></option>
		<$ }); $>
		</select>
		<$ } $>
		</div>
		</div>
		<!-- Update default token button -->
		<$ if(!this.isDefaultToken) { $>
		<div class='tokeneditor__row'>
		<button class='btn btn-primary update_default_token'>Update Default Token</button>
		<a class='showtip pictos' title='Copy a snapshot of this token’s image and settings as the default token for this character.'>?</a>
		</div>
		<$ } $>
		<!-- Tint Color -->
		<div class='tokeneditor__row'>
		<div class='tokeneditor__subheader'>
		<h4>Tint Color</h4>
		</div>
		<div class='tokeneditor__container'>
		<label class='sr-only' for='token-general-tint-color'>choose a tint color of the token</label>
		<input class='tint_color colorpicker' id='token-general-tint-color' type='text'>
		</div>
		</div>
		</div>
		<!-- Token Settings -->
		<div class='tokeneditor__col token-settings'>
		<div class='tokeneditor__header'>
		<h3 class='page_title text-capitalize'>token bars</h3>
		</div>
		<div class='tokeneditor__row tokeneditor__row--bar d-grid'>
		<div class='col tokeneditor__bar-inputs d-grid'>
		<div class='tokeneditor__subheader align-items-center d-grid'>
		<span class='bar_color_indicator' style='background-color: <$!window.Campaign.get('bar1_color')$>'></span>
		<h4>Bar 1</h4>
		</div>
		<div class='tokeneditor__container align-items-center d-grid'>
		<div class='tokeneditor__border'>
		<label title='enter bar 1 value'>
		<input class='bar1_value' placeholder='Value' type='text'>
		</label>
		</div>
		<span>/</span>
		<div class='tokeneditor__border'>
		<label title='enter bar 1 maximum value'>
		<input class='bar1_max' placeholder='Max' type='text'>
		</label>
		</div>
		</div>
		</div>
		<div class='col tokeneditor__bar-select align-items-center'>
		<div class='tokeneditor__subheader help-icon'>
		<h4 class='text-capitalize'>attribute</h4>
		<a class='pictos showtip' title='You can choose to have the bar represent an attribute from the character sheet like health, mana, or an expendable resource.'>?</a>
		</div>
		<div class='tokeneditor__container'>
		<label title='select a character sheet attribute to link to bar 1'>
		<span class='sr-only'>select a character sheet attribute to link to bar 1</span>
		<select class='bar1_link'>
		<option value=''>None</option>
		<$ _.each(this.availAttribs(), function(attrib) { $>
		<option value="<$!attrib.id$>"><$!attrib.name$>
		<$ }); $>
		</select>
		</label>
		</div>
		</div>
		<div class='col tokeneditor__dropdown d-grid'>
		<div class='dropdown keep-open'>
		<button aria-expanded='false' aria-haspopup='true' class='btn btn-default btn--circle' data-toggle='dropdown' type='button'>
		<span class='sr-only'>bar 1 player permissions menu</span>
		<svg aria-hidden='true' class='svg-inline--fa' data-icon='ellipsis-v' data-prefix='fas' height='12' viewBox='0 0 192 512' width='12' xmlns='http://www.w3.org/2000/svg'>
		<path d='M96 184c39.8 0 72 32.2 72 72s-32.2 72-72 72-72-32.2-72-72 32.2-72 72-72zM24 80c0 39.8 32.2 72 72 72s72-32.2 72-72S135.8 8 96 8 24 40.2 24 80zm0 352c0 39.8 32.2 72 72 72s72-32.2 72-72-32.2-72-72-72-72 32.2-72 72z' fill='000000'></path>
		</svg>
		</button>
		<ul aria-labelledby='dLabel' class='dropdown-menu dropdown-menu--right permission_section bar1' id='myDropdown'>
		<h4>Player Permissions</h4>
		<li class='dropdown-item'>
		<div class='checkbox'>
		<label title='show players bar 1'>
		<input class='showplayers_bar1' type='checkbox' value=''>
		See
		</label>
		</div>
		</li>
		<li class='dropdown-item'>
		<div class='checkbox'>
		<label title='allow players to edit bar 1'>
		<input class='playersedit_bar1' type='checkbox' value=''>
		Edit
		</label>
		</div>
		</li>
		<li class='dropdown-item'>
		<label class='bar_val_permission'>
		Text Overlay:
		<select class='bar1options'>
		<option value='hidden'>
		Hidden
		</option>
		<option selected value='editors'>
		Visible to Editors
		</option>
		<option value='everyone'>
		Visible to Everyone
		</option>
		</select>
		</label>
		</li>
		</ul>
		</div>
		</div>
		</div>
		<div class='tokeneditor__row tokeneditor__row--bar d-grid'>
		<div class='col tokeneditor__bar-inputs d-grid'>
		<div class='tokeneditor__subheader align-items-center d-grid'>
		<span class='bar_color_indicator' style='background-color: <$!window.Campaign.get('bar2_color')$>'></span>
		<h4>Bar 2</h4>
		</div>
		<div class='tokeneditor__container align-items-center d-grid'>
		<div class='tokeneditor__border'>
		<label title='enter bar 2 value'>
		<input class='bar2_value' placeholder='Value' type='text'>
		</label>
		</div>
		<span>/</span>
		<div class='tokeneditor__border'>
		<label title='enter bar 2 maximum value'>
		<input class='bar2_max' placeholder='Max' type='text'>
		</label>
		</div>
		</div>
		</div>
		<div class='col tokeneditor__bar-select align-items-center'>
		<div class='tokeneditor__subheader help-icon'>
		<h4 class='text-capitalize'>attribute</h4>
		</div>
		<div class='tokeneditor__container'>
		<label title='select a character sheet attribute to link to bar 2'>
		<span class='sr-only'>select a character sheet attribute to link to bar 2</span>
		<select class='bar2_link'>
		<option value=''>None</option>
		<$ _.each(this.availAttribs(), function(attrib) { $>
		<option value="<$!attrib.id$>"><$!attrib.name$>
		<$ }); $>
		</select>
		</label>
		</div>
		</div>
		<div class='col tokeneditor__dropdown d-grid'>
		<div class='dropdown keep-open'>
		<button aria-expanded='false' aria-haspopup='true' class='btn btn-default btn--circle' data-toggle='dropdown' type='button'>
		<span class='sr-only'>bar 2 player permissions menu</span>
		<svg aria-hidden='true' class='svg-inline--fa' data-icon='ellipsis-v' data-prefix='fas' height='12' viewBox='0 0 192 512' width='12' xmlns='http://www.w3.org/2000/svg'>
		<path d='M96 184c39.8 0 72 32.2 72 72s-32.2 72-72 72-72-32.2-72-72 32.2-72 72-72zM24 80c0 39.8 32.2 72 72 72s72-32.2 72-72S135.8 8 96 8 24 40.2 24 80zm0 352c0 39.8 32.2 72 72 72s72-32.2 72-72-32.2-72-72-72-72 32.2-72 72z' fill='000000'></path>
		</svg>
		</button>
		<ul aria-labelledby='dLabel' class='dropdown-menu dropdown-menu--right permission_section bar2' id='myDropdown'>
		<h4>Player Permissions</h4>
		<li class='dropdown-item'>
		<div class='checkbox'>
		<label title='show players bar 2'>
		<input class='showplayers_bar2' type='checkbox' value=''>
		See
		</label>
		</div>
		</li>
		<li class='dropdown-item'>
		<div class='checkbox'>
		<label title='allow players to edit bar 2'>
		<input class='playersedit_bar2' type='checkbox' value=''>
		Edit
		</label>
		</div>
		</li>
		<li class='dropdown-item'>
		<label class='bar_val_permission'>
		Text Overlay:
		<select class='bar2options'>
		<option value='hidden'>
		Hidden
		</option>
		<option selected value='editors'>
		Visible to Editors
		</option>
		<option value='everyone'>
		Visible to Everyone
		</option>
		</select>
		</label>
		</li>
		</ul>
		</div>
		</div>
		</div>
		<div class='tokeneditor__row tokeneditor__row--bar d-grid'>
		<div class='col tokeneditor__bar-inputs d-grid'>
		<div class='tokeneditor__subheader align-items-center d-grid'>
		<span class='bar_color_indicator' style='background-color: <$!window.Campaign.get('bar3_color')$>'></span>
		<h4>Bar 3</h4>
		</div>
		<div class='tokeneditor__container align-items-center d-grid'>
		<div class='tokeneditor__border'>
		<label title='enter bar 3 value'>
		<input class='bar3_value' placeholder='Value' type='text'>
		</label>
		</div>
		<span>/</span>
		<div class='tokeneditor__border'>
		<label title='enter bar 3 maximum value'>
		<input class='bar3_max' placeholder='Max' type='text'>
		</label>
		</div>
		</div>
		</div>
		<div class='col tokeneditor__bar-select align-items-center'>
		<div class='tokeneditor__subheader help-icon'>
		<h4 class='text-capitalize'>attribute</h4>
		</div>
		<div class='tokeneditor__container'>
		<label title='select a character sheet attribute to link to bar 3'>
		<span class='sr-only'>select a character sheet attribute to link to bar 3</span>
		<select class='bar3_link'>
		<option value=''>None</option>
		<$ _.each(this.availAttribs(), function(attrib) { $>
		<option value="<$!attrib.id$>"><$!attrib.name$>
		<$ }); $>
		</select>
		</label>
		</div>
		</div>
		<div class='col tokeneditor__dropdown d-grid'>
		<div class='dropdown keep-open'>
		<button aria-expanded='false' aria-haspopup='true' class='btn btn-default btn--circle' data-toggle='dropdown' type='button'>
		<span class='sr-only'>bar 3 player permissions menu</span>
		<svg aria-hidden='true' class='svg-inline--fa' data-icon='ellipsis-v' data-prefix='fas' height='12' viewBox='0 0 192 512' width='12' xmlns='http://www.w3.org/2000/svg'>
		<path d='M96 184c39.8 0 72 32.2 72 72s-32.2 72-72 72-72-32.2-72-72 32.2-72 72-72zM24 80c0 39.8 32.2 72 72 72s72-32.2 72-72S135.8 8 96 8 24 40.2 24 80zm0 352c0 39.8 32.2 72 72 72s72-32.2 72-72-32.2-72-72-72-72 32.2-72 72z' fill='000000'></path>
		</svg>
		</button>
		<ul aria-labelledby='dLabel' class='dropdown-menu dropdown-menu--right permission_section bar3' id='myDropdown'>
		<h4>Player Permissions</h4>
		<li class='dropdown-item'>
		<div class='checkbox'>
		<label title='show players bar 3'>
		<input class='showplayers_bar3' type='checkbox' value=''>
		See
		</label>
		</div>
		</li>
		<li class='dropdown-item'>
		<div class='checkbox'>
		<label title='allow players to edit bar 3'>
		<input class='playersedit_bar3' type='checkbox' value=''>
		Edit
		</label>
		</div>
		</li>
		<li class='dropdown-item'>
		<label class='bar_val_permission'>
		Text Overlay:
		<select class='bar3options'>
		<option value='hidden'>
		Hidden
		</option>
		<option selected value='editors'>
		Visible to Editors
		</option>
		<option value='everyone'>
		Visible to Everyone
		</option>
		</select>
		</label>
		</li>
		</ul>
		</div>
		</div>
		</div>
		</div>
		</div>
		<hr>
		<!-- Token Tooltip -->
		<div class='tokendescription w-100'>
		<div class='w-100 d-inline-flex flex-wrap tokeneditor__container tokeneditor__tooltip-title'>
		<div class='flex-col'>
		<div class='tokeneditor__header w-100'>
		<h3 class='page_title text-capitalize'>Tooltip</h3>
		</div>
		</div>
		<div class='tokeneditor__container-tooltip tooltip_disable_box'>
		<div class='d-flex justify-content-center align-items-center'>
		<label class='sr-only' for='token-general-description-toggle'>show tooltip on token</label>
		<input class='show_tooltip' id='token-general-tooltip-toggle' type='checkbox' value='1'>
		</div>
		<h4 class='text-capitalize'>Show</h4>
		</div>
		</div>
		</div>
		<div class='tokeneditor__row'>
		<div class='tokeneditor__container'>
		<div class='d-flex'>
		<textarea class='token-tooltip' id='token-general-description' maxlength='150' type='text'></textarea>
		</div>
		</div>
		</div>
		<br>
		<small>
		<span class='tooltip-count'>0</span>
		/150
		</small>
		<hr>
		<!-- Token Bar Options -->
		<div class='tokenbaroptions w-100'>
		<div class='tokeneditor__header w-100'>
		<h3 class='page_title text-capitalize'>token bar options</h3>
		</div>
		<div class='w-100 d-inline-flex flex-wrap'>
		<div class='tokeneditor__col'>
		<div class='tokeneditor__subheader help-icon'>
		<h4 class='text-capitalize'>location</h4>
		<a class='showtip pictos' title='&lt;b&gt;Above:&lt;/b&gt; &lt;br&gt; All bars are above the token. (Default for new games) &lt;br&gt; &lt;b&gt;Top Overlapping:&lt;/b&gt; &lt;br&gt; The bottom-most bar overlaps the top of the token. Other bars float above it. &lt;br&gt; &lt;b&gt;Bottom Overlapping:&lt;/b&gt; &lt;br&gt; Bars fill the token from the bottom up. &lt;br&gt; &lt;b&gt;Below:&lt;/b&gt; &lt;br&gt; All bars are below the token.'>?</a>
		</div>
		<div class='tokeneditor__container player-permissions'>
		<div class='permission_section barLocation'>
		<label class='movable_token_bar' title='select the token bar location'>
		<span class='sr-only'>select the token bar location</span>
		<select class='token_bar_location'>
		<option selected value='above'>
		Above
		</option>
		<option value='overlap_top'>
		Top Overlapping
		</option>
		<option value='overlap_bottom'>
		Bottom Overlapping
		</option>
		<option value='below'>
		Below
		</option>
		</select>
		</label>
		</div>
		</div>
		</div>
		<div class='tokeneditor__col'>
		<div class='tokeneditor__subheader help-icon'>
		<h4 class='text-capitalize'>style</h4>
		<a class='showtip pictos' title='&lt;b&gt;Standard:&lt;/b&gt;&lt;br&gt; Full sized token bar, displays text overlays. &lt;br&gt; &lt;b&gt;Compact:&lt;/b&gt; &lt;br&gt;Narrow token bars. No text overlay.'>?</a>
		</div>
		<div class='tokeneditor__container player-permissions'>
		<div class='permission_section barLocation tokenbaroptions__style d-grid'>
		<label class='compact_bar align-items-center' title='Standard token bar style'>
		<input checked name='barStyle' type='radio' value='standard'>
		<span class='sr-only'>choose token bar style</span>
		Standard
		</label>
		<label class='compact_bar align-items-center' title='Compact token bar style'>
		<span class='sr-only'>choose token bar style</span>
		<input name='barStyle' type='radio' value='compact'>
		Compact
		</label>
		</div>
		</div>
		</div>
		</div>
		</div>
		<hr>
		<!-- Token Aura -->
		<div class='tokenaura w-100'>
		<div class='tokeneditor__header w-100'>
		<h3 class='page_title text-capitalize'>token aura</h3>
		</div>
		<div class='w-100 d-inline-flex flex-wrap'>
		<div class='tokeneditor__col'>
		<div class='tokenaura__header d-grid'>
		<div class='tokeneditor__subheader'>
		<h4 class='text-capitalize'>Aura 1</h4>
		</div>
		<div class='tokeneditor__dropdown d-grid'>
		<div class='dropdown keep-open dropup'>
		<button aria-expanded='false' aria-haspopup='true' class='btn btn-default btn--circle' data-toggle='dropdown' type='button'>
		<span class='sr-only'>aura 1 player permissions menu</span>
		<svg aria-hidden='true' class='svg-inline--fa' data-icon='ellipsis-v' data-prefix='fas' height='12' viewBox='0 0 192 512' width='12' xmlns='http://www.w3.org/2000/svg'>
		<path d='M96 184c39.8 0 72 32.2 72 72s-32.2 72-72 72-72-32.2-72-72 32.2-72 72-72zM24 80c0 39.8 32.2 72 72 72s72-32.2 72-72S135.8 8 96 8 24 40.2 24 80zm0 352c0 39.8 32.2 72 72 72s72-32.2 72-72-32.2-72-72-72-72 32.2-72 72z' fill='000000'></path>
		</svg>
		</button>
		<ul aria-labelledby='dLabel' class='dropdown-menu dropdown-menu--right' id='myDropdown'>
		<h4>Player Permissions</h4>
		<li class='dropdown-item'>
		<div class='checkbox'>
		<label title='show players aura 1'>
		<input class='showplayers_aura1' type='checkbox' value=''>
		See
		</label>
		</div>
		</li>
		<li class='dropdown-item'>
		<div class='checkbox'>
		<label title='allow players to edit aura 1'>
		<input class='playersedit_aura1' type='checkbox' value=''>
		Edit
		</label>
		</div>
		</li>
		</ul>
		</div>
		</div>
		</div>
		<div class='tokenaura__container d-grid'>
		<!-- Token Aura Diameter -->
		<div class='tokenaura__diameter'>
		<div class='tokeneditor__subheader'>
		<h4 class='text-capitalize'>radius</h4>
		</div>
		<div class='tokeneditor__container tokeneditor__border'>
		<label title='input aura 1 radius'>
		<input class='aura1_radius' type='text'>
		</label>
		<div class='disable_box d-block'>
		<$!window.Campaign.activePage().get("scale_units")$>
		</div>
		</div>
		</div>
		<!-- Token Aura Shape -->
		<div class='tokenaura__shape'>
		<div class='tokeneditor__subheader'>
		<h4 class='text-capitalize'>shape</h4>
		</div>
		<div class='tokeneditor__container'>
		<label title='select aura 1 shape'>
		<select class='text-capitalize aura1_options'>
		<option selected value='circle'>circle</option>
		<option value='square'>square</option>
		</select>
		</label>
		</div>
		</div>
		<!-- Token Aura Tint Color -->
		<div class='tokeneditor__tint'>
		<div class='tokeneditor__subheader'>
		<h4 class='text-capitalize'>tint color</h4>
		</div>
		<div class='tokeneditor__container'>
		<input class='colorpicker aura1_color' type='text'>
		</div>
		</div>
		</div>
		</div>
		<div class='tokeneditor__col'>
		<div class='tokenaura__header d-grid'>
		<div class='tokeneditor__subheader'>
		<h4 class='text-capitalize'>Aura 2</h4>
		</div>
		<div class='tokeneditor__dropdown d-grid'>
		<div class='dropdown keep-open dropup'>
		<button aria-expanded='false' aria-haspopup='true' class='btn btn-default btn--circle' data-toggle='dropdown' type='button'>
		<span class='sr-only'>aura 2 player permissions menu</span>
		<svg aria-hidden='true' class='svg-inline--fa' data-icon='ellipsis-v' data-prefix='fas' height='12' viewBox='0 0 192 512' width='12' xmlns='http://www.w3.org/2000/svg'>
		<path d='M96 184c39.8 0 72 32.2 72 72s-32.2 72-72 72-72-32.2-72-72 32.2-72 72-72zM24 80c0 39.8 32.2 72 72 72s72-32.2 72-72S135.8 8 96 8 24 40.2 24 80zm0 352c0 39.8 32.2 72 72 72s72-32.2 72-72-32.2-72-72-72-72 32.2-72 72z' fill='000000'></path>
		</svg>
		</button>
		<ul aria-labelledby='dLabel' class='dropdown-menu dropdown-menu--right' id='myDropdown'>
		<h4>Player Permissions</h4>
		<li class='dropdown-item'>
		<div class='checkbox'>
		<label title='show players aura 2'>
		<input class='showplayers_aura2' type='checkbox' value=''>
		See
		</label>
		</div>
		</li>
		<li class='dropdown-item'>
		<div class='checkbox'>
		<label title='allow players to edit aura 2'>
		<input class='playersedit_aura2' type='checkbox' value=''>
		Edit
		</label>
		</div>
		</li>
		</ul>
		</div>
		</div>
		</div>
		<div class='tokenaura__container d-grid'>
		<!-- Token Aura Diameter -->
		<div class='tokenaura__diameter'>
		<div class='tokeneditor__subheader'>
		<h4 class='text-capitalize'>radius</h4>
		</div>
		<div class='tokeneditor__container tokeneditor__border'>
		<label title='input aura 2 radius'>
		<input class='aura2_radius' type='text'>
		</label>
		<div class='disable_box d-block'>
		<$!window.Campaign.activePage().get("scale_units")$>
		</div>
		</div>
		</div>
		<!-- Token Aura Shape -->
		<div class='tokenaura__shape'>
		<div class='tokeneditor__subheader'>
		<h4 class='text-capitalize'>shape</h4>
		</div>
		<div class='tokeneditor__container'>
		<label title='select aura 2 shape'>
		<select class='text-capitalize aura2_options'>
		<option selected value='circle'>circle</option>
		<option value='square'>square</option>
		</select>
		</label>
		</div>
		</div>
		<!-- Token Aura Tint Color -->
		<div class='tokeneditor__tint'>
		<div class='tokeneditor__subheader'>
		<h4 class='text-capitalize'>tint color</h4>
		</div>
		<div class='tokeneditor__container'>
		<input class='colorpicker aura2_color' type='text'>
		</div>
		</div>
		</div>
		</div>
		</div>
		</div>
		</div>
		<!-- GM Notes -->
		<div class='notes tab-pane'>
		<div class='tokeneditor__header'>
		<h3 class='d-inline'>GM Notes</h3>
		<span>(Only visible to GMs)</span>
		</div>
		<div>
		<textarea class='gmnotes summernote'></textarea>
		</div>
		</div>
		<!-- Dynamic Lighting -- Legacy lighting is under Advanced within this. -->
		<div class='prototype tab-pane'>
		<div class='alert alert-info' role='alert'>
		<p><a href="https://help.roll20.net/hc/en-us/articles/360051754954-Token-Settings" target=''_blank''>Easily convert your legacy settings with the Convert Lighting tool </a></p>
		</div>
		<div class='token_vision'>
		<p class='token_vision_title'>Token Vision</p>
		<div class='dyn_fog_vision' style='padding-top: 10px;'>
		<div class='row-fluid clearfix'>
		<div class='span8'>
		<p class='vision_title'>Vision</p>
		</div>
		<div class='span4 dyn_fog_switch'>
		<label class='switch'>
		<input class='dyn_fog_emits_vision feature_toggle' type='checkbox'>
		<span class='slider round'></span>
		</input>
		</label>
		</div>
		</div>
		<div class='row-fluid clearfix'>
		<div class='span8'>
		<p class='description'>Gives the ability to see, if there is light or if Night Vision is enabled. Tokens with vision can see to the edge of the available light.</p>
		</div>
		<div class='span4 dyn_fog_switch'>
		<div class='hidden'>
		<input class='dyn_fog_vision_range' type='number'>
		<input class='dyn_fog_dim_vision_range' type='number'>
		</div>
		</div>
		</div>
		</div>
		<hr>
		<div class='dyn_fog_dark_vision' style='padding-top: 10px;'>
		<div class='row-fluid clearfix'>
		<div class='span8'>
		<p class='vision_title'>Night Vision</p>
		</div>
		<div class='span4 dyn_fog_switch'>
		<label class='switch'>
		<input class='dyn_fog_emits_dark_vision feature_toggle' data-target='.dark_vision_input' data-toggle='toggle' type='checkbox'>
		<span class='slider round'></span>
		</input>
		</label>
		</div>
		</div>
		<div class='row-fluid clearfix'>
		<div class='span12'>
		<p class='description'>Give this token the ability to see without any light.</p>
		</div>
		</div>
		<div class='row-fluid clearfix toggle-element dark_vision_input'>
		<div class='span8'>
		<label class='distance'>Night Vision Distance</label>
		</div>
		<div class='span4 dyn_fog_switch'>
		<div class='form-group'>
		<div class='input-group'>
		<input class='dyn_fog_dark_vision_range' min='0' type='number'>
		<span class='input-group-addon'><$!window.Campaign.activePage().get("scale_units")$></span>
		</div>
		</div>
		</div>
		</div>
		<div class='row-fluid clearfix'>
		<div class='alert alert-danger negative_number_alert_night_vision hidden' role='alert'>
		<p>Please enter a positive number.</p>
		</div>
		</div>
		<div class='row-fluid clearfix toggle-element dark_vision_input'>
		<div class='span8'>
		<label class='vision-color'>Tint Color</label>
		</div>
		<div class='span4 dyn_fog_switch'>
		<input class='dyn_fog_dark_vision_color colorpicker' type='text' value='transparent'>
		</div>
		</div>
		<div class='row-fluid clearfix toggle-element dark_vision_input' style='padding-top: 10px'>
		<div class='span8'>
		<label>Night Vision Effect</label>
		</div>
		<div class='span4 dyn_fog_switch'>
		<div class='form-group' style='float:right;'>
		<div class='input-group'>
		<label class='dyn_fog_dropdown'>
		<select class='dyn_fog_dark_vision_effect form-control'>
		<option value=''>None</option>
		<option value='Nocturnal'>Nocturnal</option>
		<option value='Dimming'>Dimming</option>
		</select>
		</label>
		</div>
		</div>
		</div>
		</div>
		<div class='row-fluid clearfix toggle-element dark_vision_input dyn_fog_dark_fx_dimming_row hidden' style='padding-top: 10px'>
		<div class='span8'>
		<label class='dyn_fog_dark_vision_color'>Dimming Start</label>
		</div>
		<div class='span4 dyn_fog_switch'>
		<div class='form-group'>
		<div class='input-group'>
		<input class='dyn_fog_dark_vision_effect_dimming' max='100' min='0' step='0.01' type='number' value='5'>
		<span class='input-group-addon'><$!window.Campaign.activePage().get("scale_units")$></span>
		</div>
		</div>
		</div>
		</div>
		<div class='row-fluid clearfix'>
		<div class='alert alert-danger negative_number_alert_night_vision_dimming hidden' role='alert'>
		<p>Please enter a positive number.</p>
		</div>
		</div>
		</div>
		<hr>
		<div class='limit_field_of_vision hidden' style='padding-top: 10px;'>
		<div class='row-fluid clearfix'>
		<div class='span8'>
		<p class='vision_title'>Limit Field of Vision</p>
		</div>
		<div class='span4 dyn_fog_switch'>
		<label class='switch'>
		<input class='field_of_vision feature_toggle' data-target='.field_of_vision_inputs' data-toggle='toggle' type='checkbox'>
		<span class='slider round'></span>
		</input>
		</label>
		</div>
		</div>
		<div class='row-fluid clearfix'>
		<div class='span12'>
		<p class='description'>Limit the field revealed for the token.</p>
		</div>
		</div>
		<div class='row-fluid clearfix toggle-element field_of_vision_inputs'>
		<div class='span3'>
		<label class='distance'>Total</label>
		</div>
		<div class='span3 dyn_fog_switch'>
		<div class='form-group'>
		<div class='input-group'>
		<input class='field_of_vision_total' max='360' min='0' type='number'>
		<span class='input-group-addon'>&deg;</span>
		</div>
		</div>
		</div>
		<div class='span3'>
		<label class='distance'>Center</label>
		</div>
		<div class='span3 dyn_fog_switch'>
		<div class='form-group'>
		<div class='input-group'>
		<input class='field_of_vision_center' max='360' min='0' type='number'>
		<span class='input-group-addon'>&deg;</span>
		</div>
		</div>
		</div>
		<div class='row-fluid clearfix'></div>
		<div class='row-fluid clearfix'>
		<div class='alert alert-danger wrong_number_alert_vision hidden' role='alert'>
		<p>Please enter a number between 0-360.</p>
		</div>
		</div>
		<div class='row-fluid clearfix'>
		<div class='span6'>
		<p class='description'>Total size of the Field of Vision.</p>
		</div>
		<div class='span6'>
		<p class='description'>50% of Vision is before the Center, 50% is after.</p>
		</div>
		</div>
		</div>
		<hr>
		</div>
		</div>
		<div class='token_light'>
		<p class='token_light_title'>Token Emits Light</p>
		<div class='dyn_fog_light' style='padding-top: 10px;'>
		<div class='row-fluid clearfix'>
		<div class='span8'>
		<p class='light_title'>Bright Light</p>
		</div>
		<div class='span4 dyn_fog_switch'>
		<label class='switch'>
		<input class='dyn_fog_emits_light feature_toggle' data-target='.bright_light_input' data-toggle='toggle' type='checkbox'>
		<span class='slider round'></span>
		</input>
		</label>
		</div>
		</div>
		<div class='row-fluid clearfix'>
		<div class='span8'>
		<p class='description'>Makes the token emit Bright Light. Enable this to set its Distance.</p>
		</div>
		</div>
		<div class='row-fluid clearfix toggle-element bright_light_input'>
		<div class='span8'>
		<label class='distance'>Bright Light Distance</label>
		</div>
		<div class='span4 dyn_fog_switch'>
		<div class='form-group'>
		<div class='input-group'>
		<input class='dyn_fog_light_range' min='0' type='number'>
		<span class='input-group-addon'><$!window.Campaign.activePage().get("scale_units")$></span>
		</div>
		</div>
		</div>
		</div>
		<div class='row-fluid clearfix'>
		<div class='alert alert-danger negative_number_alert_bright_light hidden' role='alert'>
		<p>Please enter a positive number.</p>
		</div>
		</div>
		</div>
		<hr>
		<div class='dyn_fog_dim_light' style='padding-top: 10px;'>
		<div class='row-fluid clearfix'>
		<div class='span8'>
		<p class='light_title'>Low Light</p>
		</div>
		<div class='span4 dyn_fog_switch'>
		<label class='switch'>
		<input class='dyn_fog_emits_dim_light feature_toggle' data-target='.low_light_input' data-toggle='toggle' type='checkbox'>
		<span class='slider round'></span>
		</input>
		</label>
		</div>
		</div>
		<div class='row-fluid clearfix'>
		<div class='span8'>
		<p class='description'>Makes the token emit Low Light, in addition to any Bright Light set above. Enable this to set its Distance.</p>
		</div>
		</div>
		<div class='row-fluid clearfix toggle-element low_light_input'>
		<div class='span8'>
		<label class='distance'>Low Light Distance</label>
		</div>
		<div class='span4 dyn_fog_switch'>
		<div class='form-group'>
		<div class='input-group'>
		<input class='dyn_fog_dim_light_range' min='0' type='number'>
		<span class='input-group-addon'><$!window.Campaign.activePage().get("scale_units")$></span>
		</div>
		</div>
		</div>
		</div>
		<div class='row-fluid clearfix toggle-element low_light_input'>
		<div class='span8'>
		<label class='distance'>Brightness</label>
		</div>
		<div class='span4 dyn_fog_switch'>
		<div class='form-group'>
		<div class='input-group flex-group'>
		<img class='dyn_fog_img_left flex-item' src='/images/editor/lightbulb_low.svg'>
		<input class='dyn_fog_dim_light_opacity flex-item' max='1' min='0.2' step='0.05' type='range'>
		<img class='dyn_fog_img_right flex-item' src='/images/editor/lightbulb_high.svg'>
		</div>
		</div>
		</div>
		</div>
		<div class='row-fluid clearfix'>
		<div class='alert alert-danger negative_number_alert_dim_light hidden' role='alert'>
		<p>Please enter a positive number.</p>
		</div>
		</div>
		</div>
		<hr>
		<div class='directional_bright_light hidden' style='padding-top: 10px;'>
		<div class='row-fluid clearfix'>
		<div class='span8'>
		<p class='light_title'>Directional Light</p>
		</div>
		<div class='span4 dyn_fog_switch'>
		<label class='switch'>
		<input class='directional_bright_light_toggle feature_toggle' data-target='.directional_bright_light_inputs' data-toggle='toggle' type='checkbox'>
		<span class='slider round'></span>
		</input>
		</label>
		</div>
		</div>
		<div class='row-fluid clearfix'>
		<div class='span12'>
		<p class='description'>Set the direction of the Light emitting from this token.</p>
		</div>
		</div>
		<div class='row-fluid clearfix toggle-element directional_bright_light_inputs'>
		<div class='span3'>
		<label class='distance'>Total</label>
		</div>
		<div class='span3 dyn_fog_switch'>
		<div class='form-group'>
		<div class='input-group'>
		<input class='directional_bright_light_total' max='360' min='0' type='number'>
		<span class='input-group-addon'>&deg;</span>
		</div>
		</div>
		</div>
		<div class='span3'>
		<label class='distance'>Center</label>
		</div>
		<div class='span3 dyn_fog_switch'>
		<div class='form-group'>
		<div class='input-group'>
		<input class='directional_bright_light_center' max='360' min='0' type='number'>
		<span class='input-group-addon'>&deg;</span>
		</div>
		</div>
		</div>
		<div class='row-fluid clearfix'></div>
		<div class='row-fluid clearfix'>
		<div class='alert alert-danger wrong_number_alert_bright hidden' role='alert'>
		<p>Please enter a number between 0-360.</p>
		</div>
		</div>
		<div class='row-fluid clearfix'>
		<div class='span6'>
		<p class='description'>Total size of the Field of Light.</p>
		</div>
		<div class='span6'>
		<p class='description'>50% of Light is before the Center, 50% is after.</p>
		</div>
		</div>
		</div>
		<hr>
		<div class='row-fluid clearfix'>
		<div class='span8'>
		<label class='light_title'>Light Color</label>
		</div>
		<div class='span4 dyn_fog_switch'>
		<input class='dyn_fog_light_color colorpicker' type='text' value='transparent'>
		</div>
		</div>
		<hr>
		</div>
		<div class='total_light'>
		<div class='row-fluid clearfix'>
		<div class='span8'>
		<p class='light_title'>Total Light</p>
		</div>
		<div class='span4 dyn_fog_switch'>
		<div class='form-group'>
		<div class='input-group'>
		<input class='total_light_input' disabled type='number' value='0'>
		<span class='input-group-addon'><$!window.Campaign.activePage().get("scale_units")$></span>
		</div>
		</div>
		</div>
		</div>
		<div class='row-fluid clearfix'>
		<div class='span8'>
		<p class='description'>Amount of light emitting from this token.</p>
		</div>
		</div>
		</div>
		<hr>
		<div class='token_light'>
		<div aria-expanded='false' class='span8' data-target='.collapse_dyn_fog_advance' data-toggle='collapse' style='display:flex'>
		<p class='token_light_title' style='flex:1'>Advanced & Legacy Settings</p>
		<i aria-expanded='false' class='fa fa-chevron-up collapse_dyn_fog_advance' style='font-size:20px;cursor: pointer;'></i>
		<i aria-expanded='false' class='fa fa-chevron-down collapse_dyn_fog_advance' style='font-size:20px;cursor: pointer;'></i>
		</div>
		<div class='dyn_fog_light' style='padding-top: 10px;'></div>
		<div class='total_light collapse collapse_dyn_fog_advance'>
		<div class='row-fluid clearfix'>
		<div class='span8'>
		<p class='light_title'>Light Multiplier</p>
		</div>
		<div class='span4 dyn_fog_switch'>
		<div class='form-group'>
		<div class='input-group'>
		<input class='light_multi_input' min='1' type='number' value='100'>
		<span class='input-group-addon'>%</span>
		</div>
		</div>
		</div>
		</div>
		<div class='row-fluid clearfix'>
		<div class='span8'>
		<p class='description'>This changes the effective radius of light for this player. A setting of 200% will let this player see light from twice it’s set radius.</p>
		</div>
		</div>
		<hr>
		<div class='row-fluid clearfix'>
		<div class='span8'>
		<p class='light_title'>Legacy Lighting</p>
		</div>
		<div class='span4 dyn_fog_switch'>
		<label class='switch'>
		<input class='dyn_fog_enable_legacy_lighting feature_toggle' data-target='.toggle_legacy_light_section' data-toggle='toggle' type='checkbox'>
		<span class='slider round'></span>
		</input>
		</label>
		</div>
		</div>
		<div class='row-fluid toggle-element toggle_legacy_light_section'>
		<div class='emits-light'>
		<div class='clear'></div>
		<h4>Emits Light</h4>
		<div class='inlineinputs' style='margin-top: 5px; margin-bottom: 5px;'>
		<input class='light_radius' type='text'>
		<$!window.Campaign.activePage().get("scale_units")$>.
		<input class='light_dimradius' type='text'>
		<$!window.Campaign.activePage().get("scale_units")$>.
		<input class='light_angle' placeholder='360' type='text'>
		<span style='font-size: 2.0em;'>&deg;</span>
		</div>
		<span style='color: #888; padding-left: 5px;'>Light Radius / (optional) Start of Dim / Angle</span>
		<div class='inlineinputs' style='margin-top: 5px;'>
		<label style='margin-left: 7px;'>
		<input class='light_otherplayers' type='checkbox'>
		All Players See Light
		</label>
		</div>
		<div class='inlineinputs' style='margin-top: 2px;'>
		<label style='margin-left: 7px;'>
		<input class='light_hassight' type='checkbox'>
		Has Sight
		</label>
		<span style="margin-left: 9px; margin-right: 28px;">/</span>
		Angle:
		<input class='light_losangle' placeholder='360' type='text'>
		<span style='font-size: 2.0em;'>&deg;</span>
		<span style="margin-left: 8px; margin-right: 12px;">/</span>
		Multiplier:
		<input class='light_multiplier' placeholder='1.0' style='margin-right: 10px;' type='text'>x</input>
		</div>
		<h4>Advanced Fog of War</h4>
		<div class='inlineinputs' style='margin-top: 5px; margin-bottom: 5px;'>
		<input class='advfow_viewdistance' type='text'>
		<$!window.Campaign.activePage().get("scale_units")$>.
		</div>
		<span style='color: #888; padding-left: 5px;'>Reveal Distance</span>
		</div>
		<div class='alert alert-info' role='alert' style='margin-top: 5%'>
		<p><a href=" https://blog.roll20.net/posts/retiring-legacy-dynamic-lighting-what-you-need-to-know/" target=''_blank''>The sunset has started for Legacy Dynamic Lighting. Convert to Dynamic Lighting now; click to learn more.</a></p>
		</div>
		</div>
		</div>
		</div>
		</div>
		</div>
		</div>
		</div>
		</script>
		`;
		document.removeEventListener("b20initTemplates", initHTML, false);
	});
}

SCRIPT_EXTENSIONS.push(initHTMLTokenEditor);


function initHTMLPageSettings () {
	d20plus.html = d20plus.html || {};

	// no mods; just switched in to grant full features to non-pro
	document.addEventListener("b20initTemplates", function initHTML () {
		d20plus.html.pageSettings = `
		<div class='pagedetails tab-pane' style='display:block;'>
		<!-- * SIZE */ -->
		<div class='size_settings' id='size_settings'>
		<div class='pagedetails__header'>
		<h3 class='page_title'>Size</h3>
		</div>
		<div class='pagedetails__subheader'>
		<h4>Width</h4>
		</div>
		<div class='pagedetails__container grid_settings-input--list input-group'>
		<div class='pagedetails-input size_settings-input'>
		<div>
		<label class='sr-only' for='page-size-width-input'>enter a custom page width in pixels</label>
		<input id="page-size-width-input" type="number" class="width units page_setting_item" value="<$!this.model.get("width")$>" />
		</div>
		<div class='disable_box'>cells</div>
		</div>
		<div class='col pagedetails-symbol'>
		<span class='page_setting_item'>X</span>
		</div>
		<div class='pagedetails-input size_settings-input'>
		<div>
		<label class='sr-only' for='page-size-width-multiplier'>custom page width will be multiplied by 70</label>
		<input id='page-size-width-multiplier' type="text" value="70" class="page_setting_item" disabled>
		</div>
		<div class='disable_box'>px</div>
		</div>
		<div class='col pagedetails-symbol'>
		<span class='page_setting_item'>=</span>
		</div>
		<div class='pagedetails-input size_settings-input'>
		<div>
		<label class='sr-only' for='page-size-width-total'>total page width in pixels after being multiplied by 70</label>
		<input id='page-size-width-total' type="number" class="px_width pixels page_setting_item" value="<$!this.model.get("width")*70$>" />
		</div>
		<div class='disable_box'>px</div>
		</div>
		</div>
		<div class='pagedetails__subheader'>
		<h4>Height</h4>
		</div>
		<div class='pagedetails__container grid_settings-input--list input-group'>
		<div class='pagedetails-input size_settings-input'>
		<div>
		<label class='sr-only' for='page-size-height-input'>enter a custom page height in pixels</label>
		<input id="page-size-height-input" type="number" class="height units page_setting_item" value="<$!this.model.get("height")$>" />
		</div>
		<div class='disable_box'>cells</div>
		</div>
		<div class='col pagedetails-symbol'>
		<span class='page_setting_item'>X</span>
		</div>
		<div class='pagedetails-input size_settings-input'>
		<div>
		<label class='sr-only' for='page-size-height-multiplier'>custom page height will be multiplied by 70</label>
		<input id='page-size-height-multiplier' type="text" value="70" class="page_setting_item" disabled>
		</div>
		<div class='disable_box'>px</div>
		</div>
		<div class='col pagedetails-symbol'>
		<span class='page_setting_item'>=</span>
		</div>
		<div class='pagedetails-input size_settings-input'>
		<div>
		<label class='sr-only' for='page-size-height-total'>total page height in pixels after being multiplied by 70</label>
		<input id='page-size-height-total' type="number" class="px_height pixels page_setting_item" value="<$!this.model.get("height")*70$>" />
		</div>
		<div class='disable_box'>px</div>
		</div>
		</div>
		<div class='fine-print text-muted'>
		<p>The height and width are true to size when zoom is set to 100%.</p>
		</div>
		</div>
		<hr>
		<!-- * BACKGROUND */ -->
		<div class='background_settings'>
		<div class='pagedetails__header'>
		<h3 class='page_title'>Background</h3>
		</div>
		<div class='pagedetails__subheader'>
		<div class='row'>
		<div class='col-xs-5' style='display: flex; flex-direction: column; align-items: center; gap: 4px;'>
		<div class='pagedetails__container'>
		<h4>Board Color</h4>
		</div>
		<div class='pagedetails__container'>
		<div>
		<input class='pagebackground' type='text'>
		</div>
		</div>
		</div>
		<div class='col-xs-5' style='display: flex; flex-direction: column; align-items: center; gap: 4px;'>
		<div class='pagedetails__container'>
		<h4>Backdrop Color</h4>
		</div>
		<div class='pagedetails__container'>
		<div>
		<input class='wrappercolor' type='text'>
		</div>
		</div>
		</div>
		</div>
		</div>
		<div class='pagedetails__subheader'>
		<div class='row'>
		<div class='col-xs-7 pagedetails__subheader'>
		<h4 class='text-capitalize'>Apply dominant color from map layer</h4>
		</div>
		<div class='col-xs-3 grid_switch'>
		<label class='switch'>
		<label class='sr-only' for='page-wrapper-color-from-map-toggle'>apply dominant color from map layer</label>
		<input class='useautowrapper showtip' id='page-wrapper-color-from-map-toggle' title='Automatically update the backdrop to match the map layer' type='checkbox' value='1'>
		<span class='slider round'></span>
		</input>
		</label>
		</div>
		</div>
		</div>
		</div>
		<hr>
		<!-- * SCALE */ -->
		<div class='scale_settings'>
		<div class='pagedetails__header'>
		<h3 class='page_title'>Scale</h3>
		</div>
		<div class='pagedetails__subheader'>
		<h4 class='text-capitalize'>grid cell distance</h4>
		</div>
		<div class='pagedetails__container'>
		<div class='pagedetails-input scale_settings-input'>
		<div>
		<label class='sr-only' for='page-scale-grid-cell-distance'>enter a custom distance for each grid cell</label>
		<input id='page-scale-grid-cell-distance' type="number" class="scale_number" value="<$!this.model.get("scale_number")$>" />
		</div>
		<div class='scale_settings-select'>
		<label class='sr-only' for='page-scale-grid-cell-label-select'>choose a label for your grid cells</label>
		<select class='scale_units' id='page-scale-grid-cell-label-select'>
		<option value='ft'>ft.</option>
		<option value='m'>m.</option>
		<option value='km'>km.</option>
		<option value='mi'>mi.</option>
		<option value='in'>in.</option>
		<option value='cm'>cm.</option>
		<option value='un'>un.</option>
		<option value='hex'>hex</option>
		<option value='sq'>sq.</option>
		<option value='custom'>Custom</option>
		</select>
		</div>
		</div>
		</div>
		<div class='hidden' id='custom_scale_units'>
		<div class='pagedetails__subheader'>
		<h4>custom label</h4>
		</div>
		<div class='pagedetails__container'>
		<div class='pagedetails-input custom_scale_units-input'>
		<label class='sr-only' for='page-scale-grid-cell-custom-label'>enter a custom label for your grid cells</label>
		<input id="page-scale-grid-cell-custom-label" type="text" value="<$!this.model.get("scale_units")$>" />
		</div>
		</div>
		</div>
		</div>
		<hr>
		<!-- * GRID */ -->
		<div class='grid_settings' data-feature_enabled='showgrid' id='grid_settings'>
		<div class='row'>
		<div class='col-xs-7 pagedetails__header'>
		<h3 class='page_title'>Grid</h3>
		</div>
		<div class='col-xs-3 grid_switch'>
		<label class='switch'>
		<label class='sr-only' for='page-grid-display-toggle'>toggle the page grid</label>
		<input class='gridenabled feature_enabled' id='page-grid-display-toggle' type='checkbox' value='1'>
		<span class='slider round'></span>
		</input>
		</label>
		</div>
		</div>
		<div class='grid_subsettings' id='grid_subsettings'>
		<div class='pagedetails__container'>
		<div class='pagedetails__subheader'>
		<h4>Type</h4>
		</div>
		<div class='grid_settings-select'>
		<label class='sr-only' for='gridtype'>select the grid type</label>
		<select id='gridtype'>
		<option selected value='square'>Square</option>
		<option value='hex'>Hex (V)</option>
		<option value='hexr'>Hex (H)</option>
		<option value='dimetric'>Dimetric</option>
		<option value='isometric'>Isometric</option>
		</select>
		</div>
		</div>
		<div class='pagedetails__container grid_settings-row--hex flex-wrap align-items-center' id='hexlabels'>
		<div class='col-xs-7 pagedetails__subheader'>
		<h4>show hex labels</h4>
		</div>
		<div class='col-xs-3 grid_switch'>
		<label class='switch'>
		<label class='sr-only' for='page-grid-hex-label-toggle'>toggle display labels inside of hexes</label>
		<input class='gridlabels' id='page-grid-hex-label-toggle' type='checkbox' value='1'>
		<span class='slider round'></span>
		</input>
		</label>
		</div>
		</div>
		<div class='pagedetails__subheader help-icon'>
		<h4>Measurement</h4>
		<a class='tipsy-w showtip pictos' href='https://roll20.zendesk.com/hc/en-us/articles/360039674913-Ruler' target='_blank' title='Controls how diagonal cells are measured.'>?</a>
		</div>
		<div class='pagedetails__container'>
		<div class='grid_settings-select'>
		<select id='diagonaltype'>
		<option class='squareonly' selected value='foure'>D&D 5E/4E Compatible</option>
		<option class='squareonly' value='threefive'>Pathfinder/3.5E Compatible</option>
		<option class='squareonly' value='manhattan'>Manhattan</option>
		<option class='hexonly' value='hex'>Hex Path</option>
		<option value='pythagorean'>Euclidean</option>
		</select>
		</div>
		</div>
		<div class='pagedetails__subheader help-icon'>
		<h4>Cell Width</h4>
		<a class='tipsy-w showtip pictos' href='https://roll20.zendesk.com/hc/en-us/articles/360039675373-Page-Settings' target='_blank' title='The number of cells per 70 pixels in your grid. Ex .5 = 35 pixels per cell.'>?</a>
		</div>
		<div class='pagedetails__container grid_settings-input--list'>
		<div class='pagedetails-input grid_settings-input'>
		<label class='sr-only' for='page-grid-cell-width-input'>enter a custom cell width</label>
		<input id="page-grid-cell-width-input" type="number" class="grid-cell-width snappingincrement units" value="<$!this.model.get("snapping_increment")$>" />
		</div>
		<div class='col pagedetails-symbol'>
		<span class='page_setting_item'>X</span>
		</div>
		<div class='pagedetails-input grid_settings-input'>
		<div>
		<label class='sr-only' for='page-grid-cell-width-multiplier'>custom cell width will be multiplied by 70</label>
		<input id='page-grid-cell-width-multiplier' type="text" value="70" class="page_setting_item" disabled>
		</div>
		<div class='disable_box'>px</div>
		</div>
		<div class='col pagedetails-symbol'>
		<span class='page_setting_item'>=</span>
		</div>
		<div class='pagedetails-input grid_settings-input'>
		<div>
		<label class='sr-only' for='page-grid-cell-width-total'>total cell width in pixels after being multiplied by 70</label>
		<input id="page-grid-cell-width-total" type="number" class="px_snappingincrement pixels" value="<$!this.model.get("snapping_increment")*70$>" />
		</div>
		<div class='disable_box'>px</div>
		</div>
		</div>
		<div class='col' style='display: flex; flex-direction: column; gap: 4px;'>
		<div class='pagedetails__subheader'>
		<h4>Color</h4>
		</div>
		<div class='pagedetails__container'>
		<div>
		<input class='gridcolor' type='text'>
		</div>
		</div>
		</div>
		<div class='pagedetails__subheader'>
		<h4>Opacity</h4>
		</div>
		<div class='pagedetails__container'>
		<div>
		<div class='gridopacity'></div>
		</div>
		</div>
		</div>
		</div>
		<!-- * Movement */ -->
		<hr>
		<div class='restrict_movement lighting_feature' id='restict_movement'>
		<div class='pagedetails__header w-100'>
		<h3 class='page_title text-capitalize'>movement</h3>
		</div>
		<div class='pagedetails__container d-flex'>
		<div class='row'>
		<div class='col-xs-7 pagedetails__subheader'>
		<h4 class='text-capitalize'>dynamic lighting barriers restrict movement</h4>
		</div>
		<div class='col-xs-3 grid_switch'>
		<label class='switch'>
		<label class='sr-only' for='page-dynamic-lighting-line-restrict-movement-toggle'>dynamic lighting lines restrict movement toggle</label>
		<input class='lightrestrictmove showtip' id='page-dynamic-lighting-line-restrict-movement-toggle' title='Don&#39;t allow player tokens to move through Dynamic Lighting walls. Can be enabled even if lighting is not used.' type='checkbox' value='1'>
		<span class='slider round'></span>
		</input>
		</label>
		</div>
		</div>
		</div>
		</div>
		<hr>
		<div class='standard_fog lighting_feature' id='standard_fog'>
		<div class='pagedetails__header w-100'>
		<h3 class='page_title text-capitalize'>Fog of War</h3>
		</div>
		<div class='pagedetails__container d-flex'>
		<div class='row'>
		<div class='col-xs-7 pagedetails__subheader'>
		<h4 class='text-capitalize'>Standard Fog of War</h4>
		<a class='tipsy-w showtip pictos' href='https://roll20.zendesk.com/hc/en-us/articles/360039674913-Ruler' target='_blank' title='Enabling Fog of War will disable Updated Dynamic Lighting'>?</a>
		</div>
		<div class='col-xs-3 grid_switch'>
		<label class='switch'>
		<label class='sr-only' for='page-standard-fog-basic-toggle'>fog</label>
		<input class='darknessenabled feature_enabled showtip' id='page-standard-fog-basic-toggle' title='Simplest method of adding fog of war to your games. Use in conjunction with the hide/reveal tool' type='checkbox' value='1'>
		<span class='slider round'></span>
		</input>
		</label>
		</div>
		</div>
		</div>
		</div>
		</hr>
		<hr>
		<div class='gm_darkness_opacity'>
		<div class='row'>
		<div class='col-xs-12'>
		<p class='opacity_title'>GM Darkness Opacity</p>
		</div>
		</div>
		</div>
		<div class='row'>
		<div class='col-xs-8'>
		<div class='fogopacity'></div>
		</div>
		<div class='col-xs-1'>
		<input class='opacity_percentage' disabled type='text'>
		</div>
		</div>
		</hr>
		<!-- * Audio */ -->
		<hr>
		<div class='audio_settings'>
		<div class='pagedetails__header'>
		<h3 class='page_title'>Audio</h3>
		</div>
		<div class='pagedetails__subheader'>
		<h4>Play on Load</h4>
		</div>
		<div class='pagedetails__container'>
		<label class='sr-only' for='page-audio-play-on-load'>play an audio track on page load</label>
		<select class='pagejukeboxtrigger' id='page-audio-play-on-load'></select>
		</div>
		</div>
		<!-- * Archive & Delete Buttons */ -->
		<hr>
		<div class='page-buttons d-flex flex-wrap justify-content-between'>
		<button class='archive btn'>Archive Page</button>
		<button class='delete btn btn-danger'>Delete Page</button>
		</div>
		</div>
		
		<div class='lighting tab-pane' style='display:none;'>
		<!-- BEGIN MOD -->
		<strong style="display: block; margin-bottom: 10px;">
		<a class="tipsy-w showtip pictos" title="Requires subscription or players to use a betteR20 script">!</a>
		Requires a paid Roll20 subscription or all players to use a betteR20 script
		</strong>
		<!-- END MOD -->
		<div class='border_box lighting_feature' data-feature_enabled='dyn_fog_prototype_enabled' id='dyn_fog_prototype_settings'>
		<div class='alert alert-info' role='alert'>
		<p><a href="https://help.roll20.net/hc/en-us/articles/360052521913" target=''_blank''>Easily convert your legacy settings with the Convert Lighting tool </a></p>
		</div>
		<div class='dyn_fog_settings'>
		<div class='row'>
		<div class='col-xs-6'>
		<p class='dynamic_lighting_title'>Dynamic Lighting</p>
		</div>
		<div class='col-xs-3 dyn_fog_switch'>
		<label class='switch'>
		<input class='dyn_fog_enabled feature_enabled' type='checkbox'>
		<span class='slider round'></span>
		</input>
		</label>
		</div>
		</div>
		</div>
		<hr>
		<div class='explorer_mode'>
		<div class='row'>
		<div class='col-xs-6'>
		<p class='explorer_mode_title'>Explorer Mode</p>
		</div>
		<div class='col-xs-3 dyn_fog_switch'>
		<label class='switch'>
		<input class='dyn_fog_autofog_mode' type='checkbox'>
		<span class='slider round'></span>
		</input>
		</label>
		</div>
		</div>
		<div class='row'>
		<div class='col-xs-11'>
		<p class='description'>Reveals areas of the Map Layer that Players have already explored. Does not reveal areas that were revealed when Explorer Mode is disabled. Previously called "Advanced Fog of War".</p>
		</div>
		</div>
		</div>
		<hr>
		<div class='daylight_mode'>
		<div class='row'>
		<div class='col-xs-6'>
		<p class='explorer_mode_title'>Daylight Mode</p>
		</div>
		<div class='col-xs-3 dyn_fog_switch'>
		<label class='switch'>
		<input class='dyn_fog_global_illum' type='checkbox'>
		<span class='slider round'></span>
		</input>
		</label>
		</div>
		</div>
		<div class='row'>
		<div class='col-xs-11'>
		<p class='description'>Adds Light to the whole Page, good for a sunny day or well lit room or GMs who don't want to place a bunch of torches. Previously called "Global Illumination".</p>
		</div>
		</div>
		<div class='row-fluid clearfix daylight_slider_row' style='display: none;'>
		<div class='span2' style='float:left'>
		<label class='distance'>Brightness</label>
		</div>
		<div class='span8 dyn_fog_switch' style='float:right'>
		<div class='form-group'>
		<div class='input-group flex-group'>
		<img class='dyn_fog_img_left flex-item' src='/images/editor/lightbulb_low.svg'>
		<input class='dyn_fog_daylight_slider flex-item' max='1' min='0.05' step='0.05' type='range' value='1'>
		<img class='dyn_fog_img_right flex-item' src='/images/editor/lightbulb_high.svg'>
		</div>
		</div>
		</div>
		</div>
		</div>
		<hr>
		<div class='update_on_drop_mode'>
		<div class='row'>
		<div class='col-xs-6'>
		<p class='update_on_drop_title'>Update when Token Drop</p>
		</div>
		<div class='col-xs-3 dyn_fog_switch'>
		<label class='switch'>
		<input class='dyn_fog_update_on_drop' type='checkbox'>
		<span class='slider round'></span>
		</input>
		</label>
		</div>
		</div>
		<div class='row'>
		<div class='col-xs-11'>
		<p class='description'>When dragging and dropping a token, the lighting will only change after a player has dropped, not while dragging.</p>
		</div>
		</div>
		</div>
		<hr>
		<div class='gm_darkness_opacity'>
		<div class='row'>
		<div class='col-xs-12'>
		<p class='opacity_title'>GM Darkness Opacity</p>
		</div>
		</div>
		<div class='row'>
		<div class='col-xs-11'>
		<p class='description'>The GM can see through dark areas hidden from the Players when using Dynamic Lighting. This setting adjusts the opacity of those dark areas for the GM only.</p>
		</div>
		</div>
		<div class='row'>
		<div class='col-xs-8'>
		<div class='fogopacity'></div>
		</div>
		<div class='col-xs-1'>
		<input class='opacity_percentage' disabled type='text'>
		</div>
		</div>
		</div>
		<hr>
		</div>
		<div id='legacy_section'>
		<div aria-expanded='false' class='span8' data-target='.collapse_legacy_lighting' data-toggle='collapse' style='display:flex'>
		<p class='token_light_title' style='flex:1'>Advanced & Legacy Settings</p>
		<i aria-expanded='false' class='fa fa-chevron-up collapse_legacy_lighting' style='font-size:20px;cursor: pointer;'></i>
		<i aria-expanded='false' class='fa fa-chevron-down collapse_legacy_lighting' style='font-size:20px;cursor: pointer;'></i>
		</div>
		<div class='collapse collapse_legacy_lighting'>
		<div class='clearfix'>
		<div class='col-xs-7'>
		<p class='light_title'>Legacy Lighting</p>
		</div>
		<div class='col-xs-2 dyn_fog_switch'>
		<label class='switch'>
		<input class='page_settings_enable_legacy_lighting lighting_feature feature_toggle' data-feature_enabled='showlighting' data-target='.legacy_only_section' data-toggle='toggle' type='checkbox'>
		<span class='slider round'></span>
		</input>
		</label>
		</div>
		</div>
		<div class='toggle-element legacy_only_section'>
		<hr>
		<div class='lighting_feature' data-feature_enabled='adv_fow_enabled' id='afow_settings'>
		<label class='feature_name'>
		<strong>Advanced Fog of War</strong>
		</label>
		<div class='feature_options'>
		<input class='advancedfowenabled feature_enabled showtip' type='checkbox' value='1'>
		<label class='checkbox'>&nbsp; Enabled</label>
		<div class='subsettings'>
		<div>
		<input class='advancedfowshowgrid showtip' title='By default the Advanced Fog of War hides the map grid anywhere revealed but the player can no longer see because of Dynamic Lighting. This option makes the grid always visible.' type='checkbox' value='1'>
		<label class='checkbox'>&nbsp; Show Grid</label>
		</div>
		<div>
		<input class='dimlightreveals showtip' title='By default the Advanced Fog of War will not be permanently revealed by Dynamic Lighting that is not bright. This option allows dim lighting to also reveal the fog.' type='checkbox' value='1'>
		<label class='checkbox'>&nbsp; Dim Light Reveals</label>
		</div>
		<div>
		<input class='showtip' id='afow_gm_see_all' title='By default, Advanced Fog of War is only revealed by tokens with sight that are controlled by at least one player.&lt;br&gt;This option allows tokens with sight which are not controlled by anyone to reveal Advanced Fog of War for the GM only.' type='checkbox' value='0'>
		<label class='checkbox'>&nbsp; All Tokens Reveal (GM)</label>
		</div>
		<div id='afow_grid_size' style='width: 180px; line-height: 30px;'>
		<span id='cell_measurement'>Cell Width:</span>
		<input type="number" class="advancedfowgridsize units" value="<$!this.model.get("adv_fow_grid_size")$>" />
		<br>
		<span>x 70 px =</span>
		<input type="number" class="px_advancedfowgridsize pixels" value="<$!this.model.get("adv_fow_grid_size")*70$>" />
		<span>px<sup>*</sup></span>
		</div>
		</div>
		</div>
		</div>
		<div class='lighting_feature' data-feature_enabled='showlighting' id='dynamic_lighting_settings'>
		<label class='feature_name'>
		<strong>Dynamic Lighting</strong>
		</label>
		<div class='feature_options'>
		<input class='lightingenabled feature_enabled showtip' type='checkbox' value='1'>
		<label class='checkbox'>&nbsp; Enabled</label>
		<div class='subsettings'>
		<div>
		<input class='lightenforcelos showtip' title='Player&#39;s line of sight set by what tokens they can control.' type='checkbox' value='1'>
		<label class='checkbox'>&nbsp; Enforce Line of Sight</label>
		</div>
		<div>
		<input class='lightingupdate' type='checkbox' value='1'>
		<label class='checkbox'>&nbsp; Only Update on Drop</label>
		</div>
		<div>
		<input class='lightglobalillum showtip' title='Instead of darkness show light in all places players can see.' type='checkbox' value='1'>
		<label class='checkbox'>&nbsp; Global Illumination</label>
		</div>
		</div>
		</div>
		</div>
		<hr>
		<div class='alert alert-info' role='alert'>
		<p><a href=" https://blog.roll20.net/posts/retiring-legacy-dynamic-lighting-what-you-need-to-know/" target=''_blank''>The sunset has started for Legacy Dynamic Lighting. Convert to Dynamic Lighting now; click to learn more.</a></p>
		</div>
		<hr>
		<div id='gm_darkness_opacity'>
		<label class='feature_name'>
		<strong>Darkness Opacity (GM)</strong>
		</label>
		<div class='fogopacity showtip' title='The GM can see through dark areas hidden from the players when using Fog of War, Advanced Fog of War, and/or Dynamic Lighting. This setting adjusts the opacity of those dark areas for the GM only.'></div>
		</div>
		</div>
		</div>
		</div>
		</div>		
		`;
		document.removeEventListener("b20initTemplates", initHTML, false);
	});
}

SCRIPT_EXTENSIONS.push(initHTMLPageSettings);


function initHTMLroll20actionsMenu () {
	d20plus.html = d20plus.html || {};

	document.addEventListener("b20initTemplates", function initHTML () {
		d20plus.html.actionsMenu = `
		<script id='tmpl_actions_menu' type='text/html'>
			<div class='actions_menu d20contextmenu'>
				<ul>
					<$ if (Object.keys(this).length === 0) { $>
						<li data-action-type='unlock-tokens'>Unlock...</li>
					<$ } $>
					<$ if(this.view && this.view.graphic.type == "image" && this.get("cardid") !== "") { $>
						<li class='head hasSub' data-action-type='takecard'>Take Card</li>
						<li class='head hasSub' data-action-type='flipcard'>Flip Card</li>
					<$ } $>
					<$ if(window.is_gm) { $>
						<$ if(this.view && this.get("isdrawing") === false && window.currentEditingLayer != "map") { $>
							<!-- BEGIN MOD -->
							<li class='head hasSub' data-menuname='massroll'>
								Mass Roll &raquo;
								<ul class='submenu' data-menuname='massroll'>
									<li class='head hasSub' data-action-type='rollinit'>Initiative</li>
									<li class='head hasSub' data-action-type='rollsaves'>Save</li>
									<li class='head hasSub' data-action-type='rollskills'>Skill</li>
								</ul>
							</li>
							<!-- END MOD -->
							<li class='head hasSub' data-action-type='addturn'>Add Turn</li>
						<$ } $>
						<!-- BEGIN MOD -->
						<!-- <li class='head'>Edit</li> -->
						<!-- END MOD -->
						<$ if(this.view) { $>
							<li data-action-type='delete'>Delete</li>
							<li data-action-type='copy'>Copy</li>
						<$ } $>
						<li data-action-type='paste'>Paste</li>
						<!-- BEGIN MOD -->
						<$ if(!this.view) { $>
							<li data-action-type='undo'>Undo</li>
						<$ } $>
						<!-- END MOD -->

						<!-- BEGIN MOD -->
						<$ if(this.view) { $>
							<li class='head hasSub' data-menuname='move'>
							Move &raquo;
								<ul class='submenu' data-menuname='move'>
									<li data-action-type='tofront'>To Front</li>
									<li data-action-type='forward-one'>Forward One<!-- (B-F)--></li>
									<li data-action-type='back-one'>Back One<!-- (B-B)--></li>
									<li data-action-type='toback'>To Back</li>
								</ul>
							</li>
						<$ } $>

						<li class='head hasSub' data-menuname='VeUtil'>
							Utilities &raquo;
							<ul class='submenu' data-menuname='VeUtil'>
								<li data-action-type='util-scenes'>Start Scene</li>
								<$ if(this.get && this.get("type") == "image") { $>
									<div class="ctx__divider"></div>
									<li data-action-type='token-animate'>Animate</li>
									<li data-action-type='token-fly'>Set&nbsp;Flight&nbsp;Height</li>
									<li data-action-type='token-light'>Set&nbsp;Light</li>
								<$ } $>
							</ul>
						</li>
						<!-- END MOD -->

						<li class='head hasSub' data-menuname='advanced'>
							Advanced &raquo;
							<ul class='submenu' data-menuname='advanced'>
								<li data-action-type='group'>Group</li>
								<li data-action-type='ungroup'>Ungroup</li>
								<$ if(this.get && this.get("type") == "image") { $>
									<li class="<$ if (this && this.get("isdrawing")) { $>active<$ } $>" data-action-type="toggledrawing">Is Drawing</li>
									<li class="<$ if (this && this.get("fliph")) { $>active<$ } $>" data-action-type="togglefliph">Flip Horizontal</li>
									<li class="<$ if (this && this.get("flipv")) { $>active<$ } $>" data-action-type="toggleflipv">Flip Vertical</li>
									<li data-action-type='setdimensions'>Set Dimensions</li>
									<$ if(window.currentEditingLayer == "map") { $>
										<li data-action-type='aligntogrid'>Align to Grid</li>
									<$ } $>
								<$ } $>

								<$ if(this.view) { $>
									<li data-action-type='lock-token'>Lock/Unlock Position</li>
								<$ } $>

								<$ if(this.get && this.get("type") == "image") { $>
									<li data-action-type='copy-tokenid'>View Token ID</li>
								<$ } $>
								<$ if(this.get && this.get("type") == "path") { $>
									<li data-action-type='copy-pathid'>View Path ID</li>
								<$ } $>
							</ul>
						</li>

						<li class='head hasSub' data-menuname='positioning'>
							Layer &raquo;
							<ul class='submenu' data-menuname='positioning'>
								<li data-action-type="tolayer_map" class='<$ if(this && this.get && this.get("layer") == "map") { $>active<$ } $>'><span class="pictos ctx__layer-icon">@</span> Map Layer</li>
								<!-- BEGIN MOD -->
								<$ if(this?.get && this.get("layer") == "floors" || d20plus.cfg.getOrDefault("canvas", "showFloors")) { $>
								<li data-action-type="tolayer_floors" class='<$ if(this && this.get && this.get("layer") == "floors") { $>active<$ } $>'><span class="pictos ctx__layer-icon">I</span> Floors Layer</li>
								<$ } $>
								<$ if(this?.get && this.get("layer") == "background" || d20plus.cfg.getOrDefault("canvas", "showBackground")) { $>
								<li data-action-type="tolayer_background" class='<$ if(this && this.get && this.get("layer") == "background") { $>active<$ } $>'><span class="pictos ctx__layer-icon">a</span> Background Layer</li>
								<$ } $>
								<!-- END MOD -->
								<li data-action-type="tolayer_objects" class='<$ if(this && this.get && this.get("layer") == "objects") { $>active<$ } $>'><span class="pictos ctx__layer-icon">b</span> Token Layer</li>
								<!-- BEGIN MOD -->
								<$ if(this?.get && this.get("layer") == "roofs" || d20plus.cfg.getOrDefault("canvas", "showRoofs")) { $>
								<li data-action-type="tolayer_roofs" class='<$ if(this && this.get && this.get("layer") == "roofs") { $>active<$ } $>'><span class="pictos ctx__layer-icon">H</span> Roofs Layer</li>
								<$ } $>
								<$ if(this?.get && this.get("layer") == "foreground" || d20plus.cfg.getOrDefault("canvas", "showForeground")) { $>
								<li data-action-type="tolayer_foreground" class='<$ if(this && this.get && this.get("layer") == "foreground") { $>active<$ } $>'><span class="pictos ctx__layer-icon">B</span> Foreground Layer</li>
								<$ } $>
								<!-- END MOD -->
								<li data-action-type="tolayer_gmlayer" class='<$ if(this && this.get && this.get("layer") == "gmlayer") { $>active<$ } $>'><span class="pictos ctx__layer-icon">E</span> GM Layer</li>
								<li data-action-type="tolayer_walls" class='<$ if(this && this.get && this.get("layer") == "walls") { $>active<$ } $>'><span class="pictostwo ctx__layer-icon">r</span> Lighting Layer</li>
								<!-- BEGIN MOD -->
								<li data-action-type="tolayer_weather" class='<$ if(this && this.get && this.get("layer") == "weather") { $>active<$ } $>'><span class="pictos ctx__layer-icon">C</span> Weather Layer</li>
								<!-- END MOD -->
							</ul>
						</li>
					<$ } $>

					<!-- BEGIN MOD -->
					<$ if(this.view && this.get && !d20plus.engine.tokenRepresentsPc(this) && d20.Campaign.activePage().get && d20.Campaign.activePage().get('bR20cfg_viewsEnable')) { $>
						<li class='head hasSub' data-menuname='view'>
							Assign view &raquo;
							<ul class='submenu' data-menuname='view'>
								<$ if(this.view && d20.Campaign.activePage().get('bR20cfg_viewsEnable')) { $>
								<li data-action-type="assignview0" class='<$ if(this && this.get && this && this.get("bR20_view0")) { $>active<$ } $>'><span class="pictos ctx__layer-icon">P</span><$ if (d20.Campaign.activePage().get('bR20cfg_views0Name')) { $> <$!d20.Campaign.activePage().get('bR20cfg_views0Name')$> <$ } else { $> Default <$ } $></li>
								<$ } $>
								<$ if(this.view && d20.Campaign.activePage().get('bR20cfg_views1Enable')) { $>
								<li data-action-type="assignview1" class='<$ if(this && this.get && this && this.get("bR20_view1")) { $>active<$ } $>'><span class="pictos ctx__layer-icon">P</span><$ if (d20.Campaign.activePage().get('bR20cfg_views1Name')) { $> <$!d20.Campaign.activePage().get('bR20cfg_views1Name')$> <$ } else { $> View 1 <$ } $></li>
								<$ } $>
								<$ if(this.view && d20.Campaign.activePage().get('bR20cfg_views2Enable')) { $>
								<li data-action-type="assignview2" class='<$ if(this && this.get && this && this.get("bR20_view2")) { $>active<$ } $>'><span class="pictos ctx__layer-icon">P</span><$ if (d20.Campaign.activePage().get('bR20cfg_views2Name')) { $> <$!d20.Campaign.activePage().get('bR20cfg_views2Name')$> <$ } else { $> View 2 <$ } $></li>
								<$ } $>
								<$ if(this.view && d20.Campaign.activePage().get('bR20cfg_views3Enable')) { $>
								<li data-action-type="assignview3" class='<$ if(this && this.get && this && this.get("bR20_view3")) { $>active<$ } $>'><span class="pictos ctx__layer-icon">P</span><$ if (d20.Campaign.activePage().get('bR20cfg_views3Name')) { $> <$!d20.Campaign.activePage().get('bR20cfg_views3Name')$> <$ } else { $> View 3 <$ } $></li>
								<$ } $>
							</ul>
						</li>
					<$ } $>
					<!-- END MOD -->

					<$ if(this.view && this.get && this.get("sides") !== "" && this.get("cardid") === "") { $>
						<li class='head hasSub' data-menuname='mutliside'>
							Multi-Sided &raquo;
							<ul class='submenu' data-menuname='multiside'>
								<li data-action-type='side_random'>Random Side</li>
								<li data-action-type='side_choose'>Choose Side</li>
								<li data-action-type='rollertokenresize'>Set Side Size</li>
							</ul>
						</li>
					<$ } $>
				</ul>
			</div>
		</script>
		`;
		document.removeEventListener("b20initTemplates", initHTML, false);
	});
}

SCRIPT_EXTENSIONS.push(initHTMLroll20actionsMenu);


function initHTMLroll20EditorsMisc () {
	d20plus.html = d20plus.html || {};

	document.addEventListener("b20initTemplates", function initHTML () {
		d20plus.html.characterEditor = `
		<script id="tmpl_charactereditor" type="text/html">
		<div class='dialog largedialog charactereditor' style='display: block;'>
		<div class='tab-content'>
		<div class='bioinfo tab-pane'>
		<div class='row-fluid'>
		<div class='span5'>
		<label>
		<strong>Avatar</strong>
		</label>
		<$ if(true) { $>
		<div class="avatar dropbox <$! this.get("avatar") != "" ? "filled" : "" $>" style="width: 95%;">
		<div class="status"></div>
		<div class="inner">
		<$ if(this.get("avatar") == "") { $>
		<h4 style="padding-bottom: 0px; marigin-bottom: 0px; color: #777;">Drop a file from your <br>Art Library or computer<small>(JPG, GIF, PNG, WEBM, WP4)</small></h4>
		<br /> or
		<button class="btn">Click to Upload</button>
		<input class="manual" type="file" />
		<$ } else { $>
		<$ if(/.+\\.webm(\\?.*)?$/i.test(this.get("avatar"))) { $>
		<video src="<$!this.get("avatar")$>" draggable="false" muted autoplay loop />
		<$ } else { $>
		<img src="<$!this.get("avatar")$>" draggable="false" />
		<$ } $>
		<div class='remove'><a href='#'>Remove</a></div>
		<$ } $>
		</div>
		</div>
		<$ } else { $>
		<div class='avatar'>
		<$ if(this.get("avatar") != "") { $>
		<img src="<$!this.get("avatar")$>" draggable="false" />
		<$ } $>
		</div>
		<$ } $>
		<div class='clear'></div>
		<!-- BEGIN MOD -->
		<button class="btn character-image-by-url">Set Image from URL</button>
		<div class='clear'></div>
		<!-- END MOD -->
		<label>
		<strong>Default Token (Optional)</strong>
		<a class='showtip pictos' title='The default token will be used when this character is dragged from the Journal Tab to the Virtual Tabletop. For regular 1x1 tokens representing this character, you may use images from your Art Library or computer. For larger tokens, create a token on the Virtual Tabletop and use &quot;Use Selected Token.&quot;'>?</a>
		</label>
		<div class="defaultToken dropbox <$! this.defaultTokenImage != "" ? "filled" : "" $>">
		<div class="status"></div>
		<div class="inner">
		<$ if(this.defaultTokenImage == "") { $>
		<h4 style="padding-bottom: 0px; marigin-bottom: 0px; color: #777;">Drop a file from your <br>Art Library or computer<small>(JPG, GIF, PNG, WEBM, WP4)</small></h4>
		<br /> or
		<button class="btn">Click to Upload</button>
		<input class="manual" type="file" />
		<$ } else { $>
		<$ if(/.+\\.webm(\\?.*)?$/i.test(this.defaultTokenImage)) { $>
		<video src="<$!this.defaultTokenImage$>" draggable="false" muted autoplay loop />
		<$ } else { $>
		<img src="<$!this.defaultTokenImage$>" draggable="false" />
		<$ } $>
		<div class='remove'><a href='#'>Remove</a></div>
		<$ } $>
		</div>
		</div>
		<div class="default-token-buttons">
		<$ if(window.is_gm) { $>
		<button class='btn btn-primary edit-default-token'>Edit Token Properties</button>
		<a class='showtip pictos' title='Edit the Token Settings for this character’s default token. Use &quot;Apply Token Defaults&quot; to apply these settings to any existing tokens on the Virtual Tabletop.'>?</a>
		<$ } $>
		<button class='btn use-selected-token'>Use Selected Token</button>
		<a class='showtip pictos' title='Copy a snapshot of the selected token&#39;s image and settings as this character’s default token.'>?</a>
		<$ if(window.is_gm) { $>
		<button class='btn apply-token-defaults'>Apply Token Defaults</button>
		<a class='showtip pictos' title='Update tokens where Represents Character is set to this character. All tokens representing this character across all pages will be overwritten.'>?</a>
        <!-- BEGIN MOD -->
        <button class="btn token-image-by-url">Set Token Image from URL</button>
		<a class='showtip pictos' title='Update will only be visible upon re-opening the sheet.'>?</a>
        <!-- END MOD -->
		<$ } $>
		</div>
		</div>
		<div class='span7'>
		<label>
		<strong>Name</strong>
		</label>
		<input class='name' data-test='character-edit-name' type='text'>
		<div class='clear'></div>
		<$ if(window.is_gm) { $>
		<label>
		<strong>In Player's Journals</strong>
		</label>
		<select class='inplayerjournals selectize' data-test='character-edit-in-journal' multiple='true' style='width: 100%;'>
		<option value="all">All Players</option>
		<$ window.Campaign.players.each(function(player) { $>
		<option value="<$!player.id$>"><$!player.get("displayname")$></option>
		<$ }); $>
		</select>
		<div class='clear'></div>
		<label>
		<strong>Can Be Edited &amp; Controlled By</strong>
		</label>
		<select class='controlledby selectize' data-test='character-edit-controlledby' multiple='true' style='width: 100%;'>
		<option value="all">All Players</option>
		<$ window.Campaign.players.each(function(player) { $>
		<option value="<$!player.id$>"><$!player.get("displayname")$></option>
		<$ }); $>
		</select>
		<div class='clear'></div>
		<label>
		<strong>Tags</strong>
		</label>
		<input class='tags'>
		<div class='clear'></div>
		<hr>
		<button class='delete btn btn-danger' data-test='character-delete' style='float: right;'>
		Delete
		</button>
		<button class='duplicate btn' data-test='character-duplicate' style='margin-right: 10px;'>
		Duplicate
		</button>
		<button class='archive btn' data-test='character-archive'>
		<$ if(this.get("archived")) { $>Restore from Archive<$ } else { $>Archive<$ } $>
		</button>
		<div class='clear'></div>
		<$ } $>
		<div class='clear'></div>
		</div>
		</div>
		<$ if(!window.ADVANCED_SHEET) { $>
		<div class='row-fluid'>
		<div class='span12'>
		<hr>
		<label>
		<strong>Bio & Info</strong>
		</label>
		<textarea class='bio'></textarea>
		<div class='clear'></div>
		<$ if(window.is_gm) { $>
		<label>
		<strong>GM Notes (Only visible to GM)</strong>
		</label>
		<textarea class='gmnotes'></textarea>
		<div class='clear'></div>
		<$ } $>
		</div>
		</div>
		<$ } $>
		</div>
		</div>
		</div>
		</script>
		`;
		document.removeEventListener("b20initTemplates", initHTML, false);
	});

	document.addEventListener("b20initTemplates", function initHTML () {
		d20plus.html.handoutEditor = `
		<script id="tmpl_handouteditor" type="text/html">
		<div class='dialog largedialog handouteditor' style='display: block;'>
		<div class='row-fluid'>
		<div class='span12'>
		<label>
		<strong>Name</strong>
		</label>
		<input class='name' type='text'>
		<div class='clear'></div>
		<$ if (window.is_gm) { $>
		<label>
		<strong>In Player's Journals</strong>
		</label>
		<select class='inplayerjournals chosen' multiple='true' style='width: 100%;'>
		<option value="all">All Players</option>
		<$ window.Campaign.players.each(function(player) { $>
		<option value="<$!player.id$>"><$!player.get("displayname")$></option>
		<$ }); $>
		</select>
		<div class='clear'></div>
		<label>
		<strong>Can Be Edited By</strong>
		</label>
		<select class='controlledby chosen' multiple='true' style='width: 100%;'>
		<option value="all">All Players</option>
		<$ window.Campaign.players.each(function(player) { $>
		<option value="<$!player.id$>"><$!player.get("displayname")$></option>
		<$ }); $>
		</select>
		<div class='clear'></div>
		<label>
		<strong>Tags</strong>
		</label>
		<input class='tags'>
		<div class='clear'></div>
		<$ } $>
		</div>
		</div>
		<div class='row-fluid'>
		<div class='span12'>
		<div class="avatar dropbox <$! this.get("avatar") != "" ? "filled" : "" $>">
		<div class="status"></div>
		<div class="inner">
		<$ if(this.get("avatar") == "") { $>
		<h4 style="padding-bottom: 0px; marigin-bottom: 0px; color: #777;">Drop a file</h4>
		<br /> or
		<button class="btn">Choose a file...</button>
		<input class="manual" type="file" />
		<$ } else { $>
		<$ if(/.+\\.webm(\\?.*)?$/i.test(this.get("avatar"))) { $>
		<video src="<$!this.get("avatar")$>" draggable="false" muted autoplay loop />
		<$ } else { $>
		<img src="<$!this.get("avatar")$>" />
		<$ } $>
		<div class='remove'><a href='#'>Remove</a></div>
		<$ } $>
		</div>
		</div>
		<div class='clear'></div>
		</div>
		</div>
		<!-- BEGIN MOD -->
		<div class='row-fluid'>
			<button class="btn handout-image-by-url">Set Image from URL</button>
			<div class='clear'></div>
		</div>
		<!-- END MOD -->
		<div class='row-fluid'>
		<div class='span12'>
		<label>
		<strong>Description & Notes</strong>
		</label>
		<textarea class='notes'></textarea>
		<div class='clear'></div>
		<$ if(window.is_gm) { $>
		<label>
		<strong>GM Notes (Only visible to GM)</strong>
		</label>
		<textarea class='gmnotes'></textarea>
		<div class='clear'></div>
		<hr>
		<button class='delete btn btn-danger' style='float: right;'>
		Delete Handout
		</button>
		<button class='duplicate btn' style='margin-right: 10px;'>
		Duplicate
		</button>
		<button class='archive btn'>
		<$ if(this.get("archived")) { $>Restore Handout from Archive<$ } else { $>Archive<$ } $>
		</button>
		<div class='clear'></div>
		<$ } $>
		</div>
		</div>
		</div>
		</script>
		`;
		document.removeEventListener("b20initTemplates", initHTML, false);
	});

	document.addEventListener("b20initTemplates", function initHTML () {
		d20plus.html.deckEditor = `
    <script id='tmpl_deckeditor' type='text/html'>
      <div class='dialog largedialog deckeditor' style='display: block;'>
        <label>Name</label>
        <input class='name' type='text'>
        <div class='clear' style='height: 14px;'></div>
        <label>
          <input class='showplayers' type='checkbox'>
          Show deck to players?
        </label>
        <div class='clear' style='height: 7px;'></div>
        <label>
          <input class='playerscandraw' type='checkbox'>
          Players can draw cards?
        </label>
        <div class='clear' style='height: 7px;'></div>
        <label>
          <input class='infinitecards' type='checkbox'>
          Cards in deck are infinite?
        </label>
        <p class='infinitecardstype'>
          <label>
            <input name='infinitecardstype' type='radio' value='random'>
            Always a random card
          </label>
          <label>
            <input name='infinitecardstype' type='radio' value='cycle'>
            Draw through deck, shuffle, repeat
          </label>
        </p>
        <div class='clear' style='height: 7px;'></div>
        <label>
          Allow choosing specific cards from deck:
          <select class='deckpilemode'>
            <option value='none'>Disabled</option>
            <option value='choosebacks_gm'>GM Choose: Show Backs</option>
            <option value='choosefronts_gm'>GM Choose: Show Fronts</option>
            <option value='choosebacks'>GM + Players Choose: Show Backs</option>
            <option value='choosefronts'>GM + Players Choose: Show Fronts</option>
          </select>
        </label>
        <div class='clear' style='height: 7px;'></div>
        <label>
          Discard Pile:
          <select class='discardpilemode'>
            <option value='none'>No discard pile</option>
            <option value='choosebacks'>Choose: Show Backs</option>
            <option value='choosefronts'>Choose: Show Fronts</option>
            <option value='drawtop'>Draw most recent/top card</option>
            <option value='drawbottom'>Draw oldest/bottom card</option>
          </select>
        </label>
        <div class='clear' style='height: 7px;'></div>
        <hr>
        <strong>When played to the tabletop...</strong>
        <div class='clear' style='height: 5px;'></div>
        <label>
          Played Facing:
          <select class='cardsplayed' style='display: inline-block; width: auto; position: relative; top: 3px;'>
            <option value='facedown'>Face Down</option>
            <option value='faceup'>Face Up</option>
          </select>
        </label>
        <div class='clear' style='height: 7px;'></div>
        <label>
          Considered:
          <select class='treatasdrawing' style='display: inline-block; width: auto; position: relative; top: 3px;'>
            <option value='true'>Drawings (No Bubbles/Stats)</option>
            <option value='false'>Tokens (Including Bubbles and Stats)</option>
          </select>
        </label>
        <div class='clear' style='height: 7px;'></div>
        <div class='inlineinputs'>
          Card Size:
          <input class='defaultwidth' type='text'>
          x
          <input class='defaultheight' type='text'>
          px
        </div>
        <small style='text-align: left; padding-left: 135px; width: auto;'>Leave blank for default auto-sizing</small>
        <div class='clear' style='height: 7px;'></div>
        <!-- %label -->
        <!-- %input.showalldrawn(type="checkbox") -->
        <!-- Everyone sees what card is drawn onto top of deck? -->
        <!-- .clear(style="height: 7px;") -->
        <hr>
        <strong>In other's hands...</strong>
        <div class='clear' style='height: 5px;'></div>
        <div class='inlineinputs'>
          <label style='width: 75px;'>Players see:</label>
          <label>
            <input class='players_seenumcards' type='checkbox'>
            Number of Cards
          </label>
          <label>
            <input class='players_seefrontofcards' type='checkbox'>
            Front of Cards
          </label>
        </div>
        <div class='clear' style='height: 5px;'></div>
        <div class='inlineinputs'>
          <label style='width: 75px;'>GM sees:</label>
          <label>
            <input class='gm_seenumcards' type='checkbox'>
            Number of Cards
          </label>
          <label>
            <input class='gm_seefrontofcards' type='checkbox'>
            Front of Cards
          </label>
        </div>
        <div class='clear' style='height: 5px;'></div>
        <hr>
        <!-- BEGIN MOD -->
        <button class='btn deck-mass-cards-by-url' style='float: right; margin-left: 5px;' data-deck-id="<$!this.id$>">
          Add Cards from URLs
        </button>
        <!-- END MOD -->
        <button class='addcard btn' style='float: right;'>
          <span class='pictos'>&</span>
          Add Card
        </button>
        <h3>Cards</h3>
        <div class='clear' style='height: 7px;'></div>
        <table class='table table-striped'>
          <tbody></tbody>
        </table>
        <div class='clear' style='height: 15px;'></div>
        <label>
          <strong>Card Backing (Required)</strong>
        </label>
        <div class='clear' style='height: 7px;'></div>
        <!-- BEGIN MOD -->
        <button class='btn deck-image-by-url' style="margin-bottom: 10px" data-deck-id="<$!this.id$>">Set image from URL...</button>
        <!-- END MOD -->
        <div class="avatar dropbox <$! this.get("avatar") != "" ? "filled" : "" $>">
        <div class='status'></div>
        <div class='inner'></div>
        <$ if(this.get("avatar") == "") { $>
        <h4 style='padding-bottom: 0px; marigin-bottom: 0px; color: #777;'>Drop a file</h4>
        <br>or</br>
        <button class='btn'>Choose a file...</button>
        <input class='manual' type='file'>
        <$ } else { $>
        <img src="<$!this.get("avatar")$>" />
        <div class='remove'>
          <a href='javascript:void(0);'>Remove</a>
        </div>
        <$ } $>
        </div>
        </div>
        <div class='clear' style='height: 20px;'></div>
        <p style='float: left;'>
          <button class='btn dupedeck'>Duplicate Deck</button>
        </p>
        <$ if(this.id != "A778E120-672D-49D0-BAF8-8646DA3D3FAC") { $>
        <p style='text-align: right;'>
          <button class='btn btn-danger deletedeck'>Delete Deck</button>
        </p>
        <$ } $>
      </div>
    </script>
		`;
		document.removeEventListener("b20initTemplates", initHTML, false);
	});

	document.addEventListener("b20initTemplates", function initHTML () {
		d20plus.html.cardEditor = `
    <script id='tmpl_cardeditor' type='text/html'>
      <div class='dialog largedialog cardeditor' style='display: block;'>
        <label>Name</label>
        <input class='name' type='text'>
        <div class='clear'></div>
        <!-- BEGIN MOD -->
        <button class='btn card-image-by-url' style="margin-bottom: 10px" data-card-id="<$!this.id$>">Set image from URL...</button>
        <!-- END MOD -->
        <div class="avatar dropbox <$! this.get("avatar") != "" ? "filled" : "" $>">
        <div class="status"></div>
        <div class="inner">
        <$ if(this.get("avatar") == "") { $>
        <h4 style='padding-bottom: 0px; marigin-bottom: 0px; color: #777;'>Drop a file</h4>
        <br>or</br>
        <button class='btn'>Choose a file...</button>
        <input class='manual' type='file'>
        <$ } else { $>
        <img src="<$!this.get("avatar")$>" />
        <div class='remove'>
          <a href='javascript:void(0);'>Remove</a>
        </div>
        <$ } $>
        </div>
        </div>
        <div class='clear'></div>
        <label>&nbsp;</label>
        <button class='deletecard btn btn-danger'>Delete Card</button>
      </div>
    </script>
		`;
		document.removeEventListener("b20initTemplates", initHTML, false);
	});

	document.addEventListener("b20initTemplates", function initHTML () {
		d20plus.html.macroEditor = `
		<script id="tmpl_macroeditor" type="text/html">
		<div>
		<label>
		Name
		<span style='color: #777;'> (Don't include the <code>#</code> or spaces in the name)</span>
		</label>
		<input class='name' type='text'>
		<div class='clear'></div>
		<!-- BEGIN MOD -->
		<label>
		Actions
		<span class='actionhelp r20' style='color: #777;'>&nbsp;(One command/roll per line)</span>
		<span class='actionhelp js' style='color: #777;'>
			&nbsp;(Regular javascript commands)
			&nbsp;<a class="tipsy-n-right showtip pictos" original-title="<div style='background:black;width:300px;margin:-5px;padding:5px;text-align:left'>
				<strong>Notes on JS code usage:</strong><br>
				<code>use&nbsp;strict</code> directive enabled<br>
				<code>this</code> refers to this r20 macro object<br>
				<code>d20</code> object can be used to access game data:<br>
				<code>.textchat.doChatInput()</code> sends text to chat<br>
				<code>.engine.selected()</code> gets selected tokens<br>
				<code>.Campaign.activePage()</code> gets current map<br>
			</div>">?</a>
		</span>
		</label>
		<textarea class='macro tokenizer' style='display:none'></textarea>
		<textarea class='tokenizer b20' style='width: 100%; min-height: 75px; margin-top: 5px'></textarea>
		<div class='clear'></div>
		<div class='btn testmacro' style='float: right;'>Test Macro</div>
		<p class='commandhelp r20' style='color: #777;'>
		Type <code>@</code> to insert variables from Characters
		<br>
		Type <code>#</code> to insert other macros
		</p>
		<p class='commandhelp js' style='color: #777;'>
		This <code>#macro</code> can't be nested in macros or actions
		<br>
		Type <code>return</code> to output results to chat
		</p>
		<div class='clear'></div>
		<label>
		<input class='isjs' style='margin-right: 10px;' type='checkbox' value='1'>Execute as JS userscript</input>
		</label>
		<!-- END MOD -->
		<label>
		<input class='istokenaction' style='margin-right: 10px;' type='checkbox' value='1'>Show as Token Action?</input>
		</label>
		<div class='clear' style='height: 15px;'></div>
		<$ if(window.is_gm) { $>
		<label>
		Visible To Players
		<span style='color: #777;'>(Optional)</span>
		</label>
		<select class='visibleto chosen' multiple='true' style='width: 100%;'>
		<option value='all'>All Players</option>
		<$ window.Campaign.players.each(function(player) { $>
		<option value="<$!player.id$>"><$!player.get("displayname")$></option>
		<$ }); $>
		</select>
		<div class='clear'></div>
		<$ } $>
		<button class='btn btn-danger delete'>Delete Macro</button>
		</div>
		</script>
		`;
		document.removeEventListener("b20initTemplates", initHTML, false);
	});
}

SCRIPT_EXTENSIONS.push(initHTMLroll20EditorsMisc);


function initHTMLbaseMisc () {
	d20plus.html = d20plus.html || {};

	document.addEventListener("b20initTemplates", function initHTML () {
		d20plus.html.settingsHtmlPtFooter = `
		<p>
			<a class="btn " href="#" id="button-edit-config" style="margin-top: 3px; width: calc(100% - 22px);">Edit Config</a>
		</p>
		<p>
			<a class="btn btn player-hidden" href="#" id="button-view-tools" style="margin-top: 3px; width: calc(100% - 22px);">Open Tools List</a>
		</p>
		<p>
			For help, advice, and updates, <a href="https://discord.gg/nGvRCDs" target="_blank" style="color: #08c;">join our Discord!</a>
		</p>
		<style id="dynamicStyle"></style>
		`;
		document.removeEventListener("b20initTemplates", initHTML, false);
	});

	document.addEventListener("b20initTemplates", function initHTML () {
		d20plus.html.artTabHtml = `
		<div>
			<h3 style="margin-bottom: 4px;">BetteR20</h3>
			<p style="display: flex; width: 100%; justify-content: space-between;">
				<button class="btn" id="button-add-external-art" style="margin-right: 5px;">Manage External Art</button>
				<button class="btn" id="button-browse-external-art">Browse Repo</button>
			</p>
		</div>
		`;
		document.removeEventListener("b20initTemplates", initHTML, false);
	});

	document.addEventListener("b20initTemplates", function initHTML () {
		d20plus.html.addArtHTML = `
		<div id="d20plus-artfolder" title="BetteR20 - External Art" style="position: relative; background: inherit;">
			<p>Add external images by URL. Any direct link to an image should work.</p>
			<p>
			<input placeholder="Name*" id="art-list-add-name">
			<input placeholder="URL*" id="art-list-add-url">
			<a class="btn" href="#" id="art-list-add-btn">Add URL</a>
			<a class="btn" href="#" id="art-list-multi-add-btn">Add Multiple URLs...</a>
			<a class="btn btn-danger" href="#" id="art-list-delete-all-btn" style="margin-left: 12px;">Delete All</a>
			<p/>
			<hr>
			<div id="art-list-container" style="background: inherit;">
				<p style="position: sticky; top: -10px; background: inherit; z-index: 100;">
					<span style="display: inline-block; width: calc( 35% + 35px ); font-weight: bold;">
						Name
						<input class="search" autocomplete="off" placeholder="Search list..." style="width: 60%; margin: 10px;">
					</span>
					<span style="display: inline-block; font-weight: bold;">URL</span>
				</p>
				<ul class="list artlist" style="display: block; margin: 0; transform: translateZ(0);"></ul>
			</div>
		</div>
		<br>
		`;
		document.removeEventListener("b20initTemplates", initHTML, false);
	});

	document.addEventListener("b20initTemplates", function initHTML () {
		d20plus.html.addArtMassAdderHTML = `
		<div id="d20plus-artmassadd" title="Mass Add Art URLs">
			<p>One entry per line; entry format: <b>[name]---[URL (direct link to image)]</b> <button class="btn" id="art-list-multi-add-btn-submit">Add URLs</button></p>
			<p><textarea id="art-list-multi-add-area" style="width: 100%; height: 100%; min-height: 500px;" placeholder="My Image---http://example.com/img1.png"></textarea></p>
		</div>
		`;
		document.removeEventListener("b20initTemplates", initHTML, false);
	});

	document.addEventListener("b20initTemplates", function initHTML () {
		d20plus.html.artListHTML = `
		<div id="Vetoolsresults">
		<ol class="dd-list" id="image-search-none">
			<div class="alert white">No results found in 5etools for those keywords.</div>
		</ol>
		<ol class="dd-list" id="image-search-has-results">
			<li class="dd-item dd-folder Vetoolsresult">
				<div class="dd-content">
					<div class="folder-title">From 5etools</div>
				</div>
				<ol class="dd-list Vetoolsresultfolder" id="custom-art-results"></ol>
			</li>
		</ol>
		</div>
		`;
		document.removeEventListener("b20initTemplates", initHTML, false);
	});

	document.addEventListener("b20initTemplates", function initHTML () {
		d20plus.html.configEditorHTML = `
		<div id="d20plus-configeditor" title="Better20 - Config Editor" style="position: relative">
			<!-- populate with js -->
		</div>
		`;
		document.removeEventListener("b20initTemplates", initHTML, false);
	});

	document.addEventListener("b20initTemplates", function initHTML () {
		d20plus.html.configEditorButtonBarHTML = `
		<div class="ui-dialog-buttonpane ui-widget-content ui-helper-clearfix">
			<div class="ui-dialog-buttonset">
				<button type="button" id="configsave" alt="Save" title="Save Config" class="btn" role="button" aria-disabled="false">
					<span>${__("ui_cfg_save")}</span>
				</button>
			</div>
		</div>
		`;
		document.removeEventListener("b20initTemplates", initHTML, false);
	});

	document.addEventListener("b20initTemplates", function initHTML () {
		d20plus.html.toolsListHtml = `
		<div id="d20-tools-list" title="BetteR20 - Tools List" style="position: relative">
			<div class="tools-list">
			<!-- populate with js -->
			</div>
		</div>
		`;
		document.removeEventListener("b20initTemplates", initHTML, false);
	});

	document.addEventListener("b20initTemplates", function initHTML () {
		d20plus.html.pageSettingsNavTabs = `
		<li class="nav-tabs active">
			<a data-tab="pagedetails" href="javascript:void(0);">
				<h2>General</h2>
			</a>
		</li>
		<li class="nav-tabs">
			<a data-tab="lighting" href="javascript:void(0);">
				<h2>Lighting</h2>
			</a>
		</li>
		<li class="nav-tabs--beta">
			<span class="label label-info">bR20</span>
			<a data-tab="weather" href="javascript:void(0);">
				<h2>Weather</h2>
			</a>
		</li>
		<li class="nav-tabs--beta">
			<span class="label label-info">bR20</span>
			<a data-tab="views" href="javascript:void(0);">
				<h2>Views</h2>
			</a>
		</li>
		`;
		document.removeEventListener("b20initTemplates", initHTML, false);
	});

	document.addEventListener("b20initTemplates", function initHTML () {
		d20plus.html.chatSocial = `
		<div class="btn" id="socialswitch">
			<span class="pictos">w</span>
		</div>
		<div style="float: left;" class="social">
			<label for="speakingto">To:</label>
			<select id="speakingto" class="selectize social">
				<option value="">All</option>
			</select>
			<span id="langpanel">
				<label for="speakingin">In:</label>
				<select class="selectize social" id="speakingin">
					<option value=""></option>
				</select>
			</span>
		</div>
		<style type="text/css">
			#textchat-input .social {
				display: none;
			}
			#textchat-input.social-resized .social, #textchat-input.social-default .social {
				display: inline-block;
			}
			#textchat-input.social-default textarea {
				height: 19px;
				flex: auto;
			}
			.selectize.social {
				width: 100px;
			}
			select#speakingto, select#speakingin {
				height: 22px;
				padding: 0px 5px;
			}
			#socialswitch {
				height: 18px;
				margin-left: 5px;
			}
			#textchat-input.talkingtoself textarea {
				border: 2px solid rgba(255,0,0,0.4) !important;
				background-color: rgba(255,0,0,0.2) !important;
			}
		</style>
		`;
		document.removeEventListener("b20initTemplates", initHTML, false);
	});

	document.addEventListener("b20initTemplates", function initHTML () {
		d20plus.html.chatSocialNotifier = `
		<div id="textchat-note-container">
			<div id="textchat-social-notifier" title="Click to reset">
				<span id="textchat-social-notifier-to"></span>
				<span id="textchat-social-notifier-in"></span>
			</div>
		</div>
		<style type="text/css">
			#textchat-note-container {
				position: absolute;
				right: 0px;
				top: -5px;
			}
			#textchat-social-notifier {
				background-color: rgba(70, 50, 70, 0.8);
				color: white;
				opacity: 0.6;
				font-size: 0.9em;
				font-weight: bold;
				height: 17px;
				padding: 5px;
				float: right;
				cursor: pointer;
				display: none;
			}
			#textchat-social-notifier.b20-in, #textchat-social-notifier.b20-to {
				display: block;
			}
			#textchat-social-notifier span {
				padding-left: 5px;
				display: none;
				max-width: 70px;
				text-overflow: ellipsis;
				white-space: nowrap;
				overflow: hidden;
				vertical-align: baseline;
			}
			#textchat-social-notifier.b20-in #textchat-social-notifier-in, #textchat-social-notifier.b20-to #textchat-social-notifier-to {
				display: inline-block;
			}
			#textchat-social-notifier-to::before {
				content: "TO: ";
			}
			#textchat-social-notifier-in::before {
				content: "IN: ";
			}
			#textchat-social-notifier::after, #textchat-notifier::after {
				content: "*";
				font-family: pictos;
				padding-left: 3px;
				vertical-align: top;
			}
			#textchat-notifier {
				float: right;
				position: unset;
				cursor: pointer;
			}
		</style>
		`;
		document.removeEventListener("b20initTemplates", initHTML, false);
	});
}

SCRIPT_EXTENSIONS.push(initHTMLbaseMisc);


function initHTMLpageViews () {
	d20plus.html = d20plus.html || {};

	document.addEventListener("b20initTemplates", function initHTML () {
		d20plus.html.pageSettingsViews = `
		<div class='views tab-pane'>
			<div class="pagedetails">
				<div class="alert alert-info" role="alert">
					<p>Views are just another way to manage groups of items on your map
					. Each View can include different items - tokens (except PCs), paths & images, regardless of their layer.
					</p><p>Assign desired items to Views via the Context menu
					. Then you can easily hide or show those items using controls at the bottom of "Editing layer" dropdown
					. This may be useful to store and quickly switch between different states of your location - day/night, rooftops/interiors etc.
					</p><p>Players do not need betteR20 to see the effect of switching Views.</p>
				</div>
				<div class="row pagedetails__subheader">
					<div class="col-xs-7 pagedetails__header">
						<h4 class="page_title">Enable Views</h4>
					</div>
					<div class="col-xs-3">
						<label class="switch">
							<label class="sr-only" for="viewsEnable">toggle view one</label>
							<input name="viewsEnable" id="viewsEnable" type="checkbox">
							<span class="slider round"></span>
						</label>
					</div>
				</div>
				<div class="pagedetails__header">
					<h3 class="page_title">Default view</h3>
				</div>
				<div class="pagedetails__subheader">
					<h4>Custom name</h4>
					<a class="tipsy-w showtip pictos" original-title="Input your custom name for this view">?</a>
				</div>
				<div>
					<label class="sr-only">input custom name</label>
					<input class="page-input" name="views0Name" placeholder="Default">
				</div>
				<hr>
				<div class="pagedetails__header">
					<h3 class="page_title">View 1</h3>
				</div>
				<div class="row pagedetails__subheader">
					<div class="col-xs-7 pagedetails__header">
						<h4 class="page_title">Enable View 1</h4>
					</div>
					<div class="col-xs-3">
						<label class="switch">
							<label class="sr-only" for="views1Enable">toggle view one</label>
							<input name="views1Enable" id="views1Enable" type="checkbox">
							<span class="slider round"></span>
						</label>
					</div>
				</div>
				<div class="row pagedetails__subheader">
					<div class="col-xs-7 pagedetails__header">
						<h4 class="page_title">Mutually exclusive with previous</h4>
						<a class="tipsy-w showtip pictos" original-title="Check this, if enabling this or PREVIOUS view should disable another one of them">?</a>
					</div>
					<div class="col-xs-3">
						<label class="switch">
							<label class="sr-only" for="views1Exclusive">toggle view one</label>
							<input name="views1Exclusive" id="views1Exclusive" type="checkbox">
							<span class="slider round"></span>
						</label>
					</div>
				</div>
				<div class="pagedetails__subheader">
					<h4>Custom name</h4>
					<a class="tipsy-w showtip pictos" original-title="Input your custom name for this view">?</a>
				</div>
				<div>
					<label class="sr-only">input custom name</label>
					<input class="page-input" name="views1Name" placeholder="View 1">
				</div>
				<hr>
				<div class="pagedetails__header">
					<h3 class="page_title">View 2</h3>
				</div>
				<div class="row pagedetails__subheader">
					<div class="col-xs-7 pagedetails__header">
						<h4 class="page_title">Enable View 2</h4>
					</div>
					<div class="col-xs-3">
						<label class="switch">
							<label class="sr-only" for="views2Enable">toggle view one</label>
							<input name="views2Enable" id="views2Enable" type="checkbox">
							<span class="slider round"></span>
						</label>
					</div>
				</div>
				<div class="row pagedetails__subheader">
					<div class="col-xs-7 pagedetails__header">
						<h4 class="page_title">Mutually exclusive with previous</h4>
						<a class="tipsy-w showtip pictos" original-title="Check this, if enabling this or PREVIOUS view should disable another one of them">?</a>
					</div>
					<div class="col-xs-3">
						<label class="switch">
							<label class="sr-only" for="views2Exclusive">toggle view two</label>
							<input name="views2Exclusive" id="views2Exclusive" type="checkbox">
							<span class="slider round"></span>
						</label>
					</div>
				</div>
				<div class="pagedetails__subheader">
					<h4>Custom name</h4>
					<a class="tipsy-w showtip pictos" original-title="Input your custom name for this view">?</a>
				</div>
				<div>
					<label class="sr-only">input custom name</label>
					<input class="page-input" name="views2Name" placeholder="View 2">
				</div>
				<hr>
				<div class="pagedetails__header">
					<h3 class="page_title">View 3</h3>
				</div>
				<div class="row pagedetails__subheader">
					<div class="col-xs-7 pagedetails__header">
						<h4 class="page_title">Enable View 3</h4>
					</div>
					<div class="col-xs-3">
						<label class="switch">
							<label class="sr-only" for="views3Enable">toggle view three</label>
							<input name="views3Enable" id="views3Enable" type="checkbox" value="0">
							<span class="slider round"></span>
						</label>
					</div>
				</div>
				<div class="row pagedetails__subheader">
					<div class="col-xs-7 pagedetails__header">
						<h4 class="page_title">Mutually exclusive with previous</h4>
						<a class="tipsy-w showtip pictos" original-title="Check this, if enabling this or PREVIOUS view should disable another one of them">?</a>
					</div>
					<div class="col-xs-3">
						<label class="switch">
							<label class="sr-only" for="views3Exclusive">toggle view one</label>
							<input name="views3Exclusive" id="views3Exclusive" type="checkbox" value="0">
							<span class="slider round"></span>
						</label>
					</div>
				</div>
				<div class="pagedetails__subheader">
					<h4>Custom name</h4>
					<a class="tipsy-w showtip pictos" original-title="Input your custom name for this view">?</a>
				</div>
				<div>
					<label class="sr-only">input custom name</label>
					<input class="page-input" name="views3Name" placeholder="View 3">
				</div>
			</div>
		</div>
		`;
		document.removeEventListener("b20initTemplates", initHTML, false);
	});
}

SCRIPT_EXTENSIONS.push(initHTMLpageViews);


function initHTMLpageWeather () {
	d20plus.html = d20plus.html || {};

	document.addEventListener("b20initTemplates", function initHTML () {
		d20plus.html.pageSettingsWeather = `
		<div class='weather tab-pane'>
			<div class="pagedetails">
				<strong style="display: block; margin-bottom: 10px;">
					<a class="tipsy-w showtip pictos" title="Requires all players to use a betteR20 script">!</a>
					Requires all players to use a betteR20 script
				</strong>
				<hr>
				<div class="pagedetails__header">
					<h3 class="page_title">Weather Type</h3>
				</div>
				<div class="pagedetails__subheader">
					<h4>Select type</h4>
				</div>
				<div>
					<label class="sr-only">select the weather type</label>
					<select name="weatherType1">
						<option>None</option>
						<option>Fog</option>
						<option>Rain</option>
						<option>Ripples</option>
						<option>Snow</option>
						<option>Waves</option>
						<option>Blood Rain</option>
						<option>Custom (see below)</option>
					</select>
				</div>
				<div class="pagedetails__subheader">
					<h4>Custom type</h4>
					<a class="tipsy-w showtip pictos" original-title="Input URL to your PNG when &quot;Custom&quot; is selected above">?</a>
				</div>
				<div>
					<label class="sr-only">input custom image</label>
					<input class="page-input" name="weatherTypeCustom1" placeholder="https://example.com/pic.png">
				</div>
				<hr>
				<div class="pagedetails__header">
					<h3 class="page_title">Amimation</h3>
				</div>
				<div class="pagedetails__subheader">
					<h4>Weather Direction</h4>
				</div>
				<div>
					<label class="sr-only">select the weather direction</label>
					<select name="weatherDir1">
						<option value="Northerly">Northerly</option>
						<option value="North-Easterly">North-Easterly</option>
						<option value="Easterly">Easterly</option>
						<option value="South-Easterly">South-Easterly</option>
						<option value="Southerly">Southerly</option>
						<option value="South-Westerly">South-Westerly</option>
						<option value="Westerly">Westerly</option>
						<option value="North-Westerly">North-Westerly</option>
						<option value="Custom (see below)">Custom (see below)</option>
					</select>
				</div>
				<div class="pagedetails__subheader">
					<h4>Custom Direction</h4>
					<a class="tipsy-w showtip pictos" original-title="Set direction when &quot;Custom&quot; is selected above">?</a>
				</div>
				<div class="row">
					<div class="col-xs-9">
						<input type="range" name="weatherDirCustom1" min="0" max="360" step="1">
					</div>
					<div class="col-xs-1">
						<input class="page-input page-hint weatherDirCustom1" disabled="" type="text">
					</div>
				</div>
				<div class="pagedetails__subheader">
					<h4>Weather Speed</h4>
				</div>
				<div class="row">
					<div class="col-xs-9">
						<input type="range" name="weatherSpeed1" min="0.01" max="1" step="0.01">
					</div>
					<div class="col-xs-1">
						<input class="page-input page-hint weatherSpeed1" disabled="" type="text">
					</div>
				</div>
				<div class="row pagedetails__subheader">
					<div class="col-xs-7 pagedetails__header">
						<h4 class="page_title">Oscillate</h4>
					</div>
					<div class="col-xs-7 pagedetails__header">
						<span>Periodically revert Weather direction, with frequency based on Threshold</span>
					</div>
					<div class="col-xs-3">
						<label class="switch">
							<label class="sr-only" for="page-oscillate-toggle">toggle oscillate</label>
							<input name="weatherOscillate1" id="page-oscillate-toggle" type="checkbox">
							<span class="slider round">
						</span></label>
					</div>
				</div>
				<div class="pagedetails__subheader">
					<h4>Oscillation Threshold</h4>
				</div>
				<div class="row">
					<div class="col-xs-9">
						<input type="range" name="weatherOscillateThreshold1" min="0.05" max="1" step="0.01"/>
					</div>
					<div class="col-xs-1">
						<input class="page-input page-hint weatherOscillateThreshold1" disabled="" type="text"/>
					</div>
				</div>
				<hr>
				<div class="pagedetails__header">
					<h3 class="page_title">Appearance</h3>
				</div>
				<div class="pagedetails__subheader">
					<h4>Weather Opacity</h4>
				</div>
				<div class="row">
					<div class="col-xs-9">
						<input type="range" name="weatherOpacity1" min="0.05" max="1" step="0.01"/>
					</div>
					<div class="col-xs-1">
						<input class="page-input page-hint weatherOpacity1" disabled="" type="text"/>
					</div>
				</div>
				<div class="pagedetails__subheader">
					<h4>Weather Intensity</h4>
				</div>
				<div>
					<label class="sr-only">select the weather intensity</label>
					<select name="weatherIntensity1">
						<option>Normal</option>
						<option>Heavy</option>
					</select>
				</div>
				<div class="row pagedetails__subheader">
					<div class="col-xs-7 pagedetails__header">
						<h4 class="page_title">Enable Tint</h4>
					</div>
					<div class="col-xs-7 pagedetails__header">
						<span>Adds semi-transparent color overlay to the whole page</span>
					</div>
					<div class="col-xs-3">
						<label class="switch">
							<label class="sr-only" for="page-oscillate-toggle">toggle tint</label>
							<input name="weatherTint1" id="page-oscillate-toggle" type="checkbox">
							<span class="slider round">
						</span></label>
					</div>
				</div>
				<div class="row pagedetails__subheader">
					<div class="col-xs-7 pagedetails__header">
						<h4>Tint Color</h4>
					</div>
					<div class="col-xs-3">
						<input type="color" name="weatherTintColor1">
					</div>
				</div>
				<div class="pagedetails__subheader">
					<h4>Tint Opacity</h4>
				</div>
				<div class="row">
					<div class="col-xs-9">
						<input type="range" name="weatherTintOpacity1" min="0.1" max="1" step="0.01"/>
					</div>
					<div class="col-xs-1">
						<input class="page-input page-hint weatherTintOpacity1" disabled="" type="text"/>
					</div>
				</div>
				<div class="pagedetails__subheader">
					<h4 class="page_title">Special Effects</h4>
				</div>
				<div>
					<label class="sr-only">select effects</label>
					<select name="weatherEffect1">
					<option>None</option>
					<option>Lightning</option>
					</select>
				</div>
			</div>
		</div>
		`;
		document.removeEventListener("b20initTemplates", initHTML, false);
	});
}

SCRIPT_EXTENSIONS.push(initHTMLpageWeather);


function d20plusEngine () {
	d20plus.engine = {};

	d20plus.engine.addProFeatures = () => {
		d20plus.ut.log("Add Pro features");

		d20plus.setMode = d20plus.mod.setMode;
		window.setMode = d20plus.mod.setMode;

		// rebind buttons with new setMode
		const $drawTools = $("#drawingtools");
		const $rect = $drawTools.find(".chooserect");
		const $ellipse = $drawTools.find(".choosecircle");
		const $path = $drawTools.find(".choosepath");
		const $poly = $drawTools.find(".choosepolygon");
		$drawTools.unbind(clicktype).bind(clicktype, function () {
			$(this).hasClass("rect") ? setMode("rect") : $(this).hasClass("ellipse") ? setMode("ellipse") : $(this).hasClass("text") ? setMode("text") : $(this).hasClass("path") ? setMode("path") : $(this).hasClass("drawselect") ? setMode("drawselect") : $(this).hasClass("polygon") && setMode("polygon")
		});
		$rect.unbind(clicktype).bind(clicktype, () => {
			setMode("rect");
			return false;
		});
		$ellipse.unbind(clicktype).bind(clicktype, () => {
			setMode("ellipse");
			return false;
		});
		$path.unbind(clicktype).bind(clicktype, () => {
			setMode("path");
			return false;
		});
		$poly.unbind(clicktype).bind(clicktype, () => {
			setMode("polygon");
			return false;
		});
		$("#rect").unbind(clicktype).bind(clicktype, () => setMode("rect"));
		$("#ellipse").unbind(clicktype).bind(clicktype, () => setMode("ellipse"));
		$("#path").unbind(clicktype).bind(clicktype, () => setMode("path"));
		$("#select").unbind(clicktype).bind(clicktype, () => setMode("select"));
		$("#select .chooseselect").unbind(clicktype).bind(clicktype, () => setMode("select"));

		if (!$(`#fxtools`).length) {
			const $fxMode = $(`<li id="fxtools"/>`).append(`<span class="pictos">e</span>`);
			$fxMode.on("click", () => {
				d20plus.setMode("fxtools");
			});
			$(`#drawingtools`).after($fxMode);
		}

		if (window.is_gm) {
			// add lighting layer tool
			if (!$(`#editinglayer .choosewalls`).length) {
				$(`#editinglayer .choosegmlayer`).after(`
					<li class="choosewalls">
						<span class="pictostwo">r</span> 
						${__("ui_bar_barriers")}
					</li>
				`);
			}

			// add DL objects tool
			if (!$(`#placelight`).length) {
				const $placeControl = $(`<li id="placeObject">
					<svg fill="currentColor" height="24" width="24" xmlns="http://www.w3.org/2000/svg">
					<use href="#place-object-icon"></use>
					</svg>
					<div class="submenu"><ul>
						<li id="placelight" tip="Place Light">
							<svg fill="currentColor" height="24" width="24" xmlns="http://www.w3.org/2000/svg">
							<use href="#torch-icon"></use>
							</svg>
							Place Light
						</li>
						<li id="placeWindow">
							<svg fill="currentColor" height="24" width="24" xmlns="http://www.w3.org/2000/svg">
							<use href="#window-icon"></use>
							</svg>
							Place Window
						</li>
						<li id="placeDoor">
							<svg fill="currentColor" height="24" width="24" xmlns="http://www.w3.org/2000/svg">
							<use href="#door-icon"></use>
							</svg>
							Place Door
						</li>
					</ul></div>
				</li>`);
				$placeControl.find(`#placelight`).on("click", () => {
					d20plus.setMode("placelight");
					$placeControl.addClass("activebutton");
				});
				$placeControl.find(`#placeWindow`).on("click", () => {
					d20plus.setMode("placeWindow");
					$placeControl.addClass("activebutton");
				});
				$placeControl.find(`#placeDoor`).on("click", () => {
					d20plus.setMode("placeDoor");
					$placeControl.addClass("activebutton");
				});
				$(`#measure`).after($placeControl);
			}

			$("#page-toolbar").on("mousedown", ".js__settings-page", function () {
				let e = d20.Campaign.pages.get($(this).parents(".availablepage").attr("data-pageid"));
				e.view._template = $.jqotec("#tmpl_pagesettings");
			});
		}
	};

	d20plus.engine._removeStatusEffectEntries = () => {
		$(`#5etools-status-css`).html("");
		Object.keys(d20.token_editor.statusmarkers).filter(k => k.startsWith("5etools_")).forEach(k => delete d20.token_editor.statusmarkers[k]);
	};

	d20plus.engine.enhanceStatusEffects = () => {
		d20plus.ut.log("Enhance status effects");
		$(`head`).append(`<style id="5etools-status-css"/>`);

		d20plus.mod.overwriteStatusEffects();

		d20.engine.canvas.off("object:added");
		d20.engine.canvas.on("object:added", d20plus.mod.overwriteStatusEffects);

		// the holy trinity
		// d20.engine.canvas.on("object:removed", () => console.log("added"));
		// d20.engine.canvas.on("object:removed", () => console.log("removed"));
		// d20.engine.canvas.on("object:modified", () => console.log("modified"));

		$(document).off("mouseenter", ".markermenu");
		$(document).on("mouseenter", ".markermenu", d20plus.mod.mouseEnterMarkerMenu)
	};

	d20plus.engine.swapTemplates = () => {
		document.dispatchEvent(new Event(`b20initTemplates`));
		d20plus.ut.log("Swapping templates...");
		$("#tmpl_charactereditor").html($(d20plus.html.characterEditor).html());
		$("#tmpl_handouteditor").html($(d20plus.html.handoutEditor).html());
		$("#tmpl_deckeditor").html($(d20plus.html.deckEditor).html());
		$("#tmpl_cardeditor").html($(d20plus.html.cardEditor).html());
		$("#tmpl_macroeditor").html($(d20plus.html.macroEditor).html());
		// ensure tokens have editable sight
		$("#tmpl_tokeneditor").replaceWith(d20plus.html.tokenEditor);
		// show dynamic lighting/etc page settings
		$("#tmpl_pagesettings").replaceWith(d20plus.engine._makePageSettings());
		// swap templates stashed in page.view.template for each page
		d20.Campaign.pages.models.forEach(page => page.view.template = $.jqotec("#tmpl_pagesettings"));
	};

	d20plus.engine._makePageSettings = () => {
		return `<script id='tmpl_pagesettings' type='text/html'>
			<ul class='nav nav-tabs pagedetails_navigation'>
				${d20plus.html.pageSettingsNavTabs}
			</ul>
			<div class='tab-content'>
				${d20plus.html.pageSettings}
				${d20plus.html.pageSettingsWeather}
				${d20plus.html.pageSettingsViews}
			</div>
		</script>`;
	};

	d20plus.engine.enhancePageSelector = () => {
		d20plus.ut.log("Enhancing page selector");

		let updatePageOrder = function () {
			d20plus.ut.log("Saving page order...");
			let pos = 0;
			$("#page-toolbar .pages .chooseablepage").each(function () {
				let page = d20.Campaign.pages.get($(this).attr("data-pageid"));
				page && page.save({
					placement: pos,
				});
				pos++;
			});
			d20.pagetoolbar.noReload = false;
			d20.pagetoolbar.refreshPageListing();
		};

		function overwriteDraggables () {
			// make them draggable on both axes
			$("#page-toolbar .pages").sortable("destroy");
			$("#page-toolbar .pages").sortable({
				items: "> .chooseablepage",
				start: function () {
					d20.pagetoolbar.noReload = true;
				},
				stop: function () {
					updatePageOrder()
				},
				distance: 15,
			}).addTouch();
			$("#page-toolbar .playerbookmark").draggable("destroy");
			$("#page-toolbar .playerbookmark").draggable({
				revert: "invalid",
				appendTo: "#page-toolbar",
				helper: "original",
			}).addTouch();
			$("#page-toolbar .playerspecificbookmark").draggable("destroy");
			$("#page-toolbar .playerspecificbookmark").draggable({
				revert: "invalid",
				appendTo: "#page-toolbar",
				helper: "original",
			}).addTouch();
		}

		overwriteDraggables();
		$(`#page-toolbar`).css("top", "calc(-90vh + 40px)");

		const originalFn = d20.pagetoolbar.refreshPageListing;
		// original function is debounced at 100ms, so debounce this at 110ms and hope for the best
		const debouncedOverwrite = _.debounce(() => {
			overwriteDraggables();
			// fire an event for other parts of the script to listen for
			const pageChangeEvt = new Event(`VePageChange`);
			d20plus.ut.log("Firing page-change event");
			document.dispatchEvent(pageChangeEvt);
		}, 110);
		d20.pagetoolbar.refreshPageListing = () => {
			originalFn();
			debouncedOverwrite();
		}

		$(`body`).on("mouseup", "li.dl", (evt) => {
			// process Dynamic Lighting tabs
			const $dynLightTab = $(evt.target).closest("li.dl");
			const $isTabAnchor = $(evt.target).closest("a");
			if (!$dynLightTab.hasClass("active")) {
				setTimeout(() => {
					if (!$dynLightTab.hasClass("legacy")) $(`[data-tab=lighting]:visible`).click();
					else $(`[data-tab=legacy-lighting]:visible`).click();
				}, 10);
			}
			if ($isTabAnchor.data("tab") === "lighting") $dynLightTab.removeClass("legacy");
			if ($isTabAnchor.data("tab") === "legacy-lighting") $dynLightTab.addClass("legacy");
		}).on("mousedown", ".chooseablepage .js__settings-page", (evt) => {
			const {currentTarget: target} = evt;
			d20plus.engine._lastSettingsPageId = $(target).closest(`[data-pageid]`).data("pageid");
		}).on("click", ".weather input[type=range]", (evt) => {
			const {currentTarget: target} = evt;
			if (target.name) $(`.${target.name}`).val(target.value);
		}).on("click", ".chooseablepage .js__settings-page", () => {
			setTimeout(() => d20plus.engine.enhancePageSettings(), 50);
		}).on("click", ".nav-tabs--beta", () => {
			d20plus.engine._populateCustomOptions();
		}).on("click keyup", ".weather input, .weather .slider, .views input, .views .slider", () => {
			d20plus.engine._updateCustomOptions();
		});
	};

	d20plus.engine.enhanceMacros = (openedMacroId) => {
		const $dialog = $(`.dialog[data-macroid=${openedMacroId}]`);
		if (!openedMacroId || !$dialog[0]) return;
		const $macro = $dialog.find(`.macro.tokenizer`);
		const $b20macro = $dialog.find(`.tokenizer.b20`);
		const $name = $dialog.find("input.name");
		const $checkbox = $dialog.find(".isjs")
			.on("change", () => {
				if ($checkbox.prop("checked")) $macro.parent().addClass("jsdialog");
				else $macro.parent().removeClass("jsdialog");
			});
		const macro = currentPlayer.macros._byId[openedMacroId];
		const script = d20plus.engine.decodeScript($macro.val());
		if (script) {
			$macro.parent().addClass("jsdialog");
			$b20macro.val(script);
			$checkbox.prop("checked", true);
		} else {
			$b20macro.val($macro.val());
		}
		$dialog.find(".btn.testmacro").on("click", () => {
			if (!$checkbox.prop("checked")) {
				$macro.val($b20macro.val());
			} else {
				$macro.val(d20plus.engine.runScript($b20macro.val(), macro));
			}
		});
		const $buttons = $dialog.parent()
			.find(".ui-dialog-buttonpane button:not(.active)")
			.addClass("active");
		$buttons.on("mouseup", () => {
			let name = $name.val() || "Untitled";
			const existing = new Set(d20.Campaign.players.map(p => p.macros
				.filter(m => m.id !== openedMacroId && (p.id === d20_player_id || m.visibleToCurrentPlayer()))
				.map(m => m.get("name"))).flat());
			while (existing.has(name)) name = name.replace(/(\d*?)$/, id => Number(id) + 1);
			if ($name.val() !== name) $name.val(name);
			if (!$checkbox.prop("checked")) $macro.val($b20macro.val());
			else $macro.val(d20plus.engine.encodeScript($b20macro.val()));
		});
	}

	d20plus.engine.decodeScript = (macro) => {
		const parts = macro.split("...");
		if (parts.length !== 3
			|| parts[0] !== "bs``<``"
			|| parts[2] !== "``>``") return;
		const script = decodeURIComponent(atob(parts[1]));
		return script;
	}

	d20plus.engine.encodeScript = (script) => {
		const saved = btoa(encodeURIComponent(script));
		return `bs\`\`<\`\`...${saved}...\`\`>\`\``;
	}

	d20plus.engine.runScript = (script, macro) => {
		// b20 fails to load if it has words use and strict separated by space ANYWHERE (right, even in comments)
		const fnBody = `"use\u0020strict";\n${script}`;
		try {
			// eslint-disable-next-line no-new-func
			const fn = new Function(fnBody);
			return fn.call(macro) || "";
		} catch (e) {
			d20plus.ut.sendHackerChat(`Script executed with errors`, true);
			d20plus.ut.error(e);
			return "";
		}
	}

	d20plus.engine.enhancePageSettings = () => {
		if (!d20plus.engine._lastSettingsPageId) return;
		const page = d20.Campaign.pages.get(d20plus.engine._lastSettingsPageId);
		if (page && page.get) {
			const $dialog = $(`.pagedetails_navigation:visible`).closest(`.ui-dialog`);
			const $saveBtn = $dialog.find(`.btn-primary:visible`);
			// if editing active page then close pages list and add Apply button
			if (d20.Campaign.activePage().id === d20plus.engine._lastSettingsPageId) {
				const $barPage = $(`#page-toolbar`);
				const $overlay = $(`.ui-widget-overlay`);
				const templateApply = `<button type="button" class="btn btn-apply" title="Apply settings for current page">Apply</button>`;
				if (!$barPage.hasClass("closed")) {
					$barPage.find(`.handle`).click();
					$overlay.remove();
				}
				$saveBtn.before(templateApply);
				$(`.btn-apply`).on("click", d20plus.engine.applySettings);
			}
			// process options within open dialog
			if ($dialog[0]) {
				const $pageTitle = $dialog.find(`.ui-dialog-title:visible`);
				d20plus.engine._preserveCustomOptions(page);
				d20plus.engine._populateCustomOptions(page, $dialog.find(`.dialog .tab-content`));
				if ($pageTitle[0] && !$(".ui-dialog-pagename:visible")[0]) {
					$pageTitle.after(`<span class="ui-dialog-pagename">${page.get("name")}</span>`);
					$saveBtn.off("click");
					$saveBtn.on("click", d20plus.engine.applySettings);
					// closed editors behave strangely, so replace Close with Cancel
					$dialog.find(`.ui-dialog-titlebar-close:visible`).on("mousedown", () => {
						$dialog.find(`.ui-dialog-buttonpane .btn:not(.btn-apply):not(.btn-primary)`).click();
					}).off("click");
					// one property for two checkboxes, make sure they're synced
					const $dynlgtCheckbox = $(`.tab-content:visible .dyn_fog_update_on_drop`).parent().parent();
					const $legacyCheckbox = $(`.tab-content:visible .lightingupdate`);
					$dynlgtCheckbox.on("click", (evt) => {
						const $checkTarget = $(evt.target).parent().find(`input`);
						if ($checkTarget.length) {
							$legacyCheckbox.prop("checked", $checkTarget.prop("checked"));
						}
					});
				}
			}
		}
	}

	d20plus.engine.applySettings = (evt) => {
		evt.stopPropagation();
		evt.preventDefault();
		const page = d20.Campaign.pages.get(d20plus.engine._lastSettingsPageId);
		if (!page?.get) return;

		const $dialog = $(`.pagedetails_navigation:visible`).closest(".ui-dialog");
		if (!$dialog[0]) return;

		const activeTab = $(`li.active:visible:not(.dl) > a`).data("tab");
		const activeTabScroll = $dialog.find(`.ui-dialog-content`).scrollTop();
		const $settings = $dialog.find(`.dialog .tab-content`);

		d20plus.engine._saveCustomOptions(page);
		d20plus.engine._saveNativeOptions(page, $settings);

		page.save();

		if (!$(evt.currentTarget).hasClass("btn-apply")) {
			// now we should close the dialog (effectively press Cancel)
			$(`.ui-dialog-buttonpane:visible .btn:not(.btn-apply):not(.btn-primary)`).click();
		} else {
			// page.save resets current dialog, so we need to restore status quo
			$(`.nav-tabs:visible [data-tab=${activeTab}]`).click();
			$(`.ui-dialog-content:visible`).scrollTop(activeTabScroll);
			d20plus.engine._populateCustomOptions();
		}
	}

	d20plus.engine._ROLL20_PAGE_OPTIONS = {
		width: {id: "page-size-width-input", class: ".width.units.page_setting_item"},
		height: {id: "page-size-height-input", class: ".height.units.page_setting_item"},
		background_color: {class: ".pagebackground"},
		wrapperColor: {class: ".wrappercolor"},
		useAutoWrapper: {id: "page-wrapper-color-from-map-toggle", class: ".useautowrapper"},

		scale_number: {id: "page-size-height-input", class: ".scale_number"},
		scale_units: {id: "page-scale-grid-cell-label-select", class: ".scale_units"},
		gridlabels: {id: "page-grid-hex-label-toggle", class: ".gridlabels"},
		snapping_increment: {id: "page-grid-cell-width-input", class: ".grid-cell-width.snappingincrement.units"},
		gridcolor: {class: ".gridcolor"},
		grid_opacity: {class: ".gridopacity a.ui-slider-handle"},
		lightrestrictmove: {id: "page-dynamic-lighting-line-restrict-movement-toggle", class: ".lightrestrictmove"},
		jukeboxtrigger: {id: "page-audio-play-on-load", class: ".pagejukeboxtrigger"},

		dynamic_lighting_enabled: {class: ".dyn_fog_enabled"},
		explorer_mode: {class: ".dyn_fog_autofog_mode"},
		daylight_mode_enabled: {class: ".dyn_fog_global_illum"},
		daylightModeOpacity: {class: ".dyn_fog_daylight_slider"},
		// lightupdatedrop: {class: ".dyn_fog_update_on_drop"}, // same property
		fog_opacity: {class: ".fogopacity a.ui-slider-handle"},

		showdarkness: {class: ".darknessenabled"},

		adv_fow_enabled: {class: ".advancedfowenabled"},
		adv_fow_show_grid: {class: ".advancedfowshowgrid"},
		adv_fow_dim_reveals: {class: ".dimlightreveals"},
		adv_fow_gm_see_all: {id: "#afow_gm_see_all"},
		adv_fow_grid_size: {class: ".advancedfowgridsize"},
		showlighting: {class: ".lightingenabled"},
		lightenforcelos: {class: ".lightenforcelos"},
		lightupdatedrop: {class: ".lightingupdate"},
		lightglobalillum: {class: ".lightglobalillum"},
	};

	d20plus.engine._saveNativeOptions = (page, dialog) => {
		if (!page || !page.get) return;
		const getSlider = (el) => {
			if (el.style.left?.search("%") > 0) return el.style.left.slice(0, -1) / 100;
			else {
				// eslint-disable-next-line no-console
				console.warn("%cD20Plus > ", "color: #b93032; font-size: large", "Can't process slider value");
				return undefined;
			}
		}
		const getVal = (el) => {
			if (el.hasClass("dyn_fog_autofog_mode")) return el.prop("checked") ? "basic" : "off";
			else if (el.is(":checkbox")) return !!el.prop("checked");
			else if (el.hasClass("ui-slider-handle")) return getSlider(el.get(0));
			else return el.val();
		}
		Object.entries(d20plus.engine._ROLL20_PAGE_OPTIONS).forEach(([name, option]) => {
			const $e = dialog.find(option.class || option.id);
			const val = getVal($e);
			if (val !== undefined) page.attributes[name] = val;
		});
	}

	d20plus.engine._preserveCustomOptions = (page) => {
		if (!page || !page.get) return;
		d20plus.engine._customOptions = d20plus.engine._customOptions || {};
		d20plus.engine._customOptions[page.id] = { _defaults: {} };
		[
			"weather",
			"views",
		].forEach(category => Object.entries(d20plus[category].props).forEach(([name, deflt]) => {
			d20plus.engine._customOptions[page.id][name] = page.get(`bR20cfg_${name}`) || deflt;
			d20plus.engine._customOptions[page.id]._defaults[name] = deflt;
		}));
	}

	d20plus.engine._populateCustomOptions = (page, dialog) => {
		dialog = dialog || $(`.pagedetails_navigation:visible`).closest(".ui-dialog");
		page = page || d20.Campaign.pages.get(d20plus.engine._lastSettingsPageId);
		if (!d20plus.engine._customOptions[page.id]) return;
		Object.entries(d20plus.engine._customOptions[page.id]).forEach(([name, val]) => {
			dialog.find(`[name="${name}"]`).each((i, e) => {
				const $e = $(e);
				if ($e.is(":checkbox")) {
					$e.prop("checked", !!val);
				} else if ($e.is("input[type=range]")) {
					dialog.find(`.${name}`).val(val);
					$e.val(val);
				} else {
					$e.val(val);
				}
			});
		});
		// ensure all Select elements will update options on change
		$(".weather select").each((a, b) => { b.onchange = () => d20plus.engine._updateCustomOptions() });
	}

	d20plus.engine._updateCustomOptions = (page, dialog) => {
		dialog = dialog || $(`.pagedetails_navigation:visible`).closest(".ui-dialog");
		page = page || d20.Campaign.pages.get(d20plus.engine._lastSettingsPageId);
		if (!d20plus.engine._customOptions[page.id]) return;
		Object.entries(d20plus.engine._customOptions[page.id]).forEach(([name, val]) => {
			dialog.find(`[name="${name}"]`).each((i, e) => {
				const $e = $(e);
				const val = $e.is(":checkbox") ? !!$e.prop("checked") : $e.val();
				d20plus.engine._customOptions[page.id][name] = val;
			});
		});
	}

	d20plus.engine._saveCustomOptions = (page) => {
		const values = d20plus.engine._customOptions[page.id];
		Object.entries(values).forEach(([name, val]) => {
			if (name === "_defaults") return;
			if (val && val !== values._defaults[name]) {
				page.attributes[`bR20cfg_${name}`] = val;
			} else {
				if (page.attributes.hasOwnProperty(`bR20cfg_${name}`)) {
					page.attributes[`bR20cfg_${name}`] = null;
				}
			}
		});
	}

	d20plus.engine.initQuickSearch = ($iptSearch, $outSearch) => {
		$iptSearch.on("keyup", () => {
			const searchVal = ($iptSearch.val() || "").trim();
			$outSearch.empty();
			if (searchVal.length <= 2) return; // ignore 2 characters or less, for performance reasons
			const found = $(`#journal .content`).find(`li[data-itemid]`).filter((i, ele) => {
				const $ele = $(ele);
				return $ele.find(`.name`).text().trim().toLowerCase().includes(searchVal.toLowerCase());
			});
			if (found.length) {
				$outSearch.append(`<p><b>Search results:</b></p>`);
				const $outList = $(`<ol class="dd-list Vetools-search-results"/>`);
				$outSearch.append($outList);
				found.clone().addClass("Vetools-draggable").appendTo($outList);
				$outSearch.append(`<hr>`);
				$(`.Vetools-search-results .Vetools-draggable`).draggable({
					revert: true,
					distance: 10,
					revertDuration: 0,
					helper: "clone",
					handle: ".namecontainer",
					appendTo: "body",
					scroll: true,
					start: function () {
						$("#journalfolderroot").addClass("externaldrag")
					},
					stop: function () {
						$("#journalfolderroot").removeClass("externaldrag")
					},
				});
			}
		});
	};

	/* eslint-disable */

	d20plus.engine.getSelectedToMove = () => {
		const n = [];
		for (var l = d20.engine.selected(), c = 0; c < l.length; c++)
			n.push(l[c]);
	};

	d20plus.engine.forwardOneLayer = (n) => {
		d20.engine.canvas.getActiveGroup() && d20.engine.unselect(),
			_.each(n, function (e) {
				d20.engine.canvas.bringForward(e)
			}),
			d20.Campaign.activePage().debounced_recordZIndexes()
	};

	d20plus.engine.backwardOneLayer = (n) => {
		d20.engine.canvas.getActiveGroup() && d20.engine.unselect(),
			_.each(n, function (e) {
				d20.engine.canvas.sendBackwards(e)
			}),
			d20.Campaign.activePage().debounced_recordZIndexes()
	};

	// previously "enhanceSnap"
	d20plus.engine.enhanceMouseDown = () => {
		const R = d20plus.overwrites.canvasHandlerDown

		if (FINAL_CANVAS_MOUSEDOWN_LIST.length) {
			FINAL_CANVAS_MOUSEDOWN = (FINAL_CANVAS_MOUSEDOWN_LIST.find(it => it.on === d20.engine.final_canvas) || {}).listener;
		}

		if (FINAL_CANVAS_MOUSEDOWN) {
			d20plus.ut.log("Enhancing hex snap");
			d20.engine.final_canvas.removeEventListener("mousedown", FINAL_CANVAS_MOUSEDOWN);
			d20.engine.final_canvas.addEventListener("mousedown", R);
		}

		// add sub-grid snap
		d20.engine.snapToIncrement = function(e, t) {
			t *= Number(d20plus.cfg.getOrDefault("canvas", "gridSnap"));
			return t * Math.round(e / t);
		}
	};

	d20plus.engine.enhanceMouseUp = () => { // P

	};

	// needs to be called after `enhanceMeasureTool()`
	d20plus.engine.enhanceMouseMove = () => {
		// add missing vars
		var i = d20.engine.canvas;

		// Roll20 bug (present as of 2019-5-25) workaround
		//   when box-selecting + moving tokens, the "object:moving" event throws an exception
		//   try-catch-ignore this, because it's extremely annoying
		const cachedFire = i.fire.bind(i);
		i.fire = function (namespace, opts) {
			if (namespace === "object:moving") {
				try {
					cachedFire(namespace, opts);
				} catch (e) {}
			} else {
				cachedFire(namespace, opts);
			}
		};

		const I = d20plus.overwrites.canvasHandlerMove

		if (FINAL_CANVAS_MOUSEMOVE_LIST.length) {
			FINAL_CANVAS_MOUSEMOVE = (FINAL_CANVAS_MOUSEMOVE_LIST.find(it => it.on === d20.engine.final_canvas) || {}).listener;
		}

		if (FINAL_CANVAS_MOUSEMOVE) {
			d20plus.ut.log("Enhancing mouse move");
			d20.engine.final_canvas.removeEventListener("mousemove", FINAL_CANVAS_MOUSEMOVE);
			d20.engine.final_canvas.addEventListener("mousemove", I);
		}
	};

	/* eslint-enable */

	d20plus.engine.tokenRepresentsPc = (token) => {
		if (!token || !token.get) return undefined;
		if (token.get("type") !== "image") return false;
		if (!token.character) return false;
		if (!token.character.attribs.length && !token.character.attribs.fetching) {
			token.character.attribs.fetch(token.character.attribs);
			token.character.attribs.fetching = true;
		} else if (token.character.attribs.length) {
			if (token.character.attribs.fetching) delete token.character.attribs.fetching;
			const attrib = token.character.attribs.models.find(atrib => atrib.attributes.name === "npc");
			if (attrib) {
				if (attrib.attributes.current === "0") return true;
				else return false;
			}
		}
	}// RB20 EXCLUDE START

	/* d20plus.engine.updateTokenBars = async (charID, barID) => {
		d20.Campaign.pages.models.forEach(page => {
			page.thegraphics.forEach(item => {
				if (item.model.get("represents") === charID) {
					item.model.pullLinkedBar(barID);
				}
			})
		})
	} */

	d20plus.engine.expendResources = async (expend) => {
		const character = d20.Campaign.characters._byId[expend.charID];
		if (!character || !character?.currentPlayerControls()) return;
		const fetched = await d20plus.ut.fetchCharAttribs(character);
		if (!fetched) return;
		const getAttribVal = () => {
			const vals = {
				spell: {cur: "expended", id: `lvl${expend.lvl}_slots`},
				resource: {cur: "current", link: "itemid", id: `${expend.res}_resource`},
				repeated: {cur: "current", link: "itemid", exp: /repeating_resource_(.*?)_resource_(?<pos>right|left)_name/},
				item: {cur: "itemcount", link: "itemresourceid", exp: /repeating_inventory_(.*?)_itemname/},
			}[expend.type];
			vals.id = vals.id || character.attribs?.models
				?.find(prop => prop?.attributes?.current === expend.name && prop?.attributes?.name.match(vals.exp))
				?.attributes.name.replace(/_(name|itemname)$/, "");
			return vals;
		};
		d20plus.ut.log(expend);
		const playerName = d20plus.ut.getPlayerNameById(d20_player_id);
		const characterName = character.get("name");
		const refs = getAttribVal();
		const attrib = d20plus.ut.getCharMetaAttribByName(character, refs.id);
		if (!attrib) return;
		const syncWeight = (ref) => {
			const ignNonequipped = !!d20plus.ut.getCharAttribByName(character, "ingore_non_equipped_weight")?.attributes.current;
			const isAccounted = (!ignNonequipped || ref.equipped !== "0") && ref.itemweight > 0;
			if (!isAccounted) return;
			const totalWeight = d20plus.ut.getCharAttribByName(character, "weighttotal");
			if (!totalWeight?.attributes.current) return;
			const weightDelta = ((expend.restore || attrib._new) - attrib._cur) * ref.itemweight;
			const weightResult = totalWeight.attributes.current + weightDelta;
			totalWeight.save({current: weightResult});
		}
		const syncSheet = () => {
			if (attrib.itemweight) syncWeight(attrib);
			if (!refs.link || !attrib[refs.link]) return;
			const toSync = d20plus.ut.getCharMetaAttribByName(character, attrib[refs.link], true);
			const toSyncRef = toSync?._ref?.current || toSync?._ref?.itemcount;
			toSyncRef?.save({current: expend.restore || attrib._new});
			if (toSync?.itemweight) syncWeight(toSync);
		}
		const getMsgText = () => {
			if (expend.type === "spell") return `lvl${expend.lvl} slots`;
			else if (expend.name) return `of ${expend.name}`;
			else if (attrib.name) return `of ${attrib.name}`;
			else return `class resource`;
		};
		expend.amt = expend.amt || 1;
		attrib._cur = attrib[refs.cur];
		d20plus.ut.log(attrib);
		if (isNaN(attrib._cur)) return;
		if (expend.restore !== undefined) {
			attrib._ref[refs.cur].save({current: expend.restore});
			attrib._msg = `/w "${characterName}" ${characterName} has ${expend.restore} ${getMsgText()} again`;
			syncSheet();
		} else if (attrib._cur - expend.amt >= 0) {
			attrib._new = attrib._cur - expend.amt;
			attrib._ref[refs.cur].save({current: attrib._new});
			attrib._undo = {...expend}; attrib._undo.restore = attrib._cur;
			attrib._msg = `/w "${characterName}" ${characterName} now has ${attrib._new} ${getMsgText()} left`;
			syncSheet();
		} else {
			attrib._msg = `/w "${characterName}" ${characterName} already had zero ${getMsgText()}`;
		}
		const transport = {type: "automation"};
		if (expend.restore) transport.author = `${playerName} restored some ${getMsgText()}`;
		else transport.author = `${playerName} tried using ${expend.amt} ${getMsgText()}`;
		if (attrib._undo) transport.undo = attrib._undo;
		d20.textchat.doChatInput(attrib._msg, undefined, transport);
	}

	d20plus.engine.alterTokensHP = (alter) => {
		const barID = Number(d20plus.cfg.getOrDefault("chat", "dmgTokenBar"));
		const bar = {
			val: `bar${barID}_value`,
			link: `bar${barID}_link`,
			max: `bar${barID}_max`,
		};
		const calcHP = (token) => {
			if (!token?.get) return false;
			const current = token.get(bar.val);
			const max = token.get(bar.max);
			if (isNaN(max) || isNaN(current) || current === "") return false;
			const hp = {old: current, new: current - alter.dmg};
			if (hp.new < 0) hp.new = 0;
			if (max !== "") {
				if (hp.new > max) hp.new = max;
				if (hp.new <= -max) hp.dead = true;
				if (hp.old <= 0 && hp.new > 0) hp.alive = true;
			}
			return hp;
		}
		const playerName = d20plus.ut.getPlayerNameById(d20_player_id);
		const author = `${playerName} applied ${alter.dmg} damage`;
		const transport = {type: "automation", author};
		const targets = alter.targets || d20.engine.selected();
		d20.engine.unselect();
		targets.forEach(async token => {
			if (typeof token === "string") token = d20plus.ut.getTokenById(token);
			else if (token.model) token = token.model;
			const hp = calcHP(token);
			if (!hp) return d20plus.ut.sendHackerChat("You have to select proper token bar in the settings", true);
			if (!token.currentPlayerControls()) return;
			if (alter.restore !== undefined) hp.new = alter.restore;
			const barLinked = token.get(bar.link);
			const tokenName = token.get("name");
			if (barLinked) {
				if (!token.character?.currentPlayerControls()) return;
				const charID = token.character?.id;
				const fetched = await d20plus.ut.fetchCharAttribs(token.character);
				if (fetched && charID) {
					const attrib = token.character.attribs.get(barLinked);
					const charName = token.character.get("name");
					attrib.save({current: hp.new});
					attrib.syncTokenBars();
					hp.msg = `/w "${charName}" ${tokenName} from ${hp.old} to ${hp.new} HP`;
					if (alter.restore !== undefined) hp.msg = `/w "${charName}" ${tokenName} HP back to ${hp.new}`;
				}
			} else {
				token.save({[bar.val]: hp.new});
				hp.msg = `/w gm ${tokenName} from ${hp.old} to ${hp.new} HP`;
				if (alter.restore !== undefined) hp.msg = `/w gm ${tokenName} HP back to ${hp.new}`;
			}
			if (hp.msg) {
				hp.undo = {type: "hp", dmg: alter.dmg, restore: hp.old, targets: [token.id]};
				if (alter.restore === undefined) hp.transport = Object.assign({undo: hp.undo}, transport);
				else transport.author = `${playerName} restored HP to ${alter.restore}`;
				d20.textchat.doChatInput(hp.msg, undefined, hp.transport || transport);
				if (hp.dead) d20.textchat.doChatInput(`${tokenName} is instantly dead`, undefined, transport);
				else if (hp.alive) d20.textchat.doChatInput(`${tokenName} is conscious again`, undefined, transport);
				else if (hp.new === 0) d20.textchat.doChatInput(`${tokenName} falls unconscious`, undefined, transport);
			}
		})
	}// RB20 EXCLUDE END

	d20plus.engine.addLineCutterTool = () => {
		// The code in /overwrites/canvas-handler.js doesn't work
		const $btnTextTool = $(`.choosetext`);

		const $btnSplitTool = $(`<li class="choosesplitter">✂️ Line Splitter</li>`).click(() => {
			d20plus.setMode("line_splitter");
		});

		$btnTextTool.after($btnSplitTool);
	};

	d20plus.engine._tokenHover = null;
	d20plus.engine._drawTokenHover = () => {
		$(`.Vetools-token-hover`).remove();
		if (!d20plus.engine._tokenHover || !d20plus.engine._tokenHover.text) return;

		const pt = d20plus.engine._tokenHover.pt;
		const txt = unescape(d20plus.engine._tokenHover.text);

		$(`body`).append(`<div class="Vetools-token-hover" style="top: ${pt.y * d20.engine.canvasZoom}px; left: ${pt.x * d20.engine.canvasZoom}px">${txt}</div>`);
	};
	d20plus.engine.addTokenHover = () => {
		// gm notes on shift-hover
		const cacheRenderLoop = d20.engine.renderLoop;
		d20.engine.renderLoop = () => {
			d20plus.engine._drawTokenHover();
			cacheRenderLoop();
		};

		// store data for the rendering function to access
		d20.engine.canvas.on("mouse:move", (data, ...others) => {
			// enable hover from GM layer -> token layer
			let hoverTarget = data.target;
			if (data.e && window.currentEditingLayer === "gmlayer") {
				const cache = window.currentEditingLayer;
				window.currentEditingLayer = "objects";
				hoverTarget = d20.engine.canvas.findTarget(data.e, null, true);
				window.currentEditingLayer = cache;
			}

			if (data.e.shiftKey && hoverTarget && hoverTarget.model) {
				d20.engine.redrawScreenNextTick();
				const gmNotes = hoverTarget.model.get("gmnotes");
				const pt = d20.engine.canvas.getPointer(data.e);
				pt.x -= d20.engine.currentCanvasOffset[0];
				pt.y -= d20.engine.currentCanvasOffset[1];
				d20plus.engine._tokenHover = {
					pt: pt,
					text: gmNotes,
					id: hoverTarget.model.id,
				};
			} else {
				if (d20plus.engine._tokenHover) d20.engine.redrawScreenNextTick();
				d20plus.engine._tokenHover = null;
			}
		})
	};

	d20plus.engine.enhanceMarkdown = () => {
		const OUT_STRIKE = "<span style='text-decoration: line-through'>$1</span>";

		/* eslint-disable */

		// BEGIN ROLL20 CODE
		window.Markdown.parse = function(e) {
			{
				var t = e
					, n = []
					, i = [];
				-1 != t.indexOf("\r\n") ? "\r\n" : -1 != t.indexOf("\n") ? "\n" : ""
			}
			return t = t.replace(/{{{([\s\S]*?)}}}/g, function(e) {
				return n.push(e.substring(3, e.length - 3)),
					"{{{}}}"
			}),
				t = t.replace(new RegExp("<pre>([\\s\\S]*?)</pre>","gi"), function(e) {
					return i.push(e.substring(5, e.length - 6)),
						"<pre></pre>"
				}),
				// BEGIN MOD
				t = t.replace(/~~(.*?)~~/g, OUT_STRIKE),
				// END MOD
				t = t.replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>"),
				t = t.replace(/\*(.*?)\*/g, "<em>$1</em>"),
				t = t.replace(/``(.*?)``/g, "<code>$1</code>"),
				t = t.replace(/\[([^\]]+)\]\(([^)]+(\.png|\.gif|\.jpg|\.jpeg))\)/g, '<a href="$2"><img src="$2" alt="$1" /></a>'),
				t = t.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>'),
				t = t.replace(new RegExp("<pre></pre>","g"), function() {
					return "<pre>" + i.shift() + "</pre>"
				}),
				t = t.replace(/{{{}}}/g, function() {
					return n.shift()
				})
		};
		// END ROLL20 CODE

		/* eslint-enable */

		// after a short delay, replace any old content in the chat
		setTimeout(() => {
			$(`.message`).each(function () {
				$(this).html($(this).html().replace(/~~(.*?)~~/g, OUT_STRIKE))
			})
		}, 2500);
	};

	d20plus.engine.enhancePathWidths = () => {
		const $selThicc = $(`#path_width`).css("width", "150px");
		$selThicc.append(`
				<option value="5">Custom 1 (5 px.)</option>
				<option value="5">Custom 2 (5 px.)</option>
				<option value="5">Custom 3 (5 px.)</option>
			`);
		const $iptThicc = $(`<input type="number" style="max-width: 50px;">`).hide();
		const $lblPixels = $(`<label style="display: inline-flex;"> pixels</label>`).hide();
		$selThicc.after($lblPixels).after($iptThicc);

		let $selOpt = null;
		$selThicc.on("change", () => {
			$selOpt = $selThicc.find(`option:selected`);
			const txt = $selOpt.text();
			if (txt.startsWith("Custom")) {
				const thicc = /\((.*?) px\.\)/.exec(txt)[1];
				$lblPixels.show();
				$iptThicc.show().val(Number(thicc));
			} else {
				$lblPixels.hide();
				$iptThicc.hide();
			}
		});

		$iptThicc.on("keyup", () => {
			if (!$selOpt) $selOpt = $selThicc.find(`option:selected`);
			if ($selOpt) {
				const clean = Math.round(Math.max(1, Number($iptThicc.val())));
				$selOpt.val(`${clean}`);
				$selOpt.text($selOpt.text().replace(/\(\d+ px\.\)/, `(${clean} px.)`));
				d20.engine.canvas.freeDrawingBrush.width = clean;
			}
		});
	};

	d20plus.engine.enhanceTransmogrifier = () => {
		JqueryUtil.addSelectors();

		$("#transmogrifier").on("click", () => {
			setTimeout(() => {
				const $btnAlpha = $(`#vetools-transmog-alpha`);
				if (!$btnAlpha.length) {
					const $prependTarget = $(`.ui-dialog-title:textEquals(transmogrifier)`).first().parent().parent().find(`.ui-dialog-content`);
					$(`<button id="#vetools-transmog-alpha" class="btn btn default" style="margin-bottom: 5px;">Sort Items Alphabetically</button>`).on("click", () => {
						// coped from a bookmarklet
						$("iframe").contents().find(".objects").each((c, e) => { let $e = $(e); $e.children().sort((a, b) => { let name1 = $(a).find(".name").text().toLowerCase(); let name2 = $(b).find(".name").text().toLowerCase(); let comp = name1.localeCompare(name2); return comp; }).each((i, c) => $e.append(c)); });
					}).prependTo($prependTarget);
				}
			}, 35);
		})
	};

	d20plus.engine.layersIsMarkedAsHidden = (layer) => {
		const page = d20.Campaign.activePage();
		if (page && page.get && page.get(`bR20cfg_hidden`)) return page.get(`bR20cfg_hidden`).search(layer) > -1;
	}

	d20plus.engine.layersVisibilityCheck = () => {
		const layers = ["floors", "background", "foreground", "roofs"];
		layers.forEach((layer) => {
			const isHidden = d20.engine.canvas._objects.some((o) => {
				if (o.model) return o.model.get("layer") === `hidden_${layer}`;
			}) || d20plus.engine.layersIsMarkedAsHidden(layer);
			d20plus.engine.layerVisibilityOff(layer, isHidden, true);
		});
		if (!$(`#floatinglayerbar`).hasClass("objects")
			&& window.currentEditingLayer === "objects") $(`#floatinglayerbar`).addClass("objects");
	}

	d20plus.engine.layersToggle = (event) => {
		event.stopPropagation();
		const target = event.target;
		const page = d20.Campaign.activePage();
		const layer = target.parentElement.className.replace(/.*choose(\w+?)\b.*/, "$1");
		if (!page.get(`bR20cfg_hidden`)) page.set(`bR20cfg_hidden`, "");
		if (d20plus.engine.layersIsMarkedAsHidden(layer)) {
			d20plus.engine.layerVisibilityOff(layer, false);
		} else {
			d20plus.engine.layerVisibilityOff(layer, true);
		}
	};

	d20plus.engine.layerVisibilityOff = (layer, off, force) => {
		const menuButton = $(`#editinglayer .choose${layer}`);
		const secondaryButton = $(`#floatinglayerbar li.choose${layer}`);
		const page = d20.Campaign.activePage();
		if (off) {
			if (d20plus.engine.objectsHideUnhide("layer", layer, "layeroff", false) || force) {
				if (window.currentEditingLayer === layer) $(`#editinglayer li.chooseobjects`).click();
				menuButton.addClass("stashed");
				secondaryButton.addClass("off");
				if (!d20plus.engine.layersIsMarkedAsHidden(layer)) {
					page.set(`bR20cfg_hidden`, `${page.get(`bR20cfg_hidden`)} ${layer}`);
					page.save();
				}
			}
		} else {
			d20plus.engine.objectsHideUnhide("layer", layer, "layeroff", true);
			menuButton.removeClass("stashed");
			secondaryButton.removeClass("off");
			if (d20plus.engine.layersIsMarkedAsHidden(layer)) {
				page.set(`bR20cfg_hidden`, page.get(`bR20cfg_hidden`).replace(` ${layer}`, ""));
				page.save();
			}
		}
	}

	d20plus.engine._objectsStashProps = (obj, visible) => {
		[
			"emits_bright_light",
			"emits_low_light",
			"has_directional_bright_light",
			"has_directional_dim_light",
			"bar1_value",
			"bar2_value",
			"bar3_value",
			"showname",
		].each((prop) => {
			if (!visible) {
				if (obj.attributes[prop]) {
					obj.attributes[`bR20_${prop}`] = obj.attributes[prop];
					obj.attributes[prop] = false;
				}
			} else {
				if (obj.attributes[`bR20_${prop}`]) {
					obj.attributes[prop] = obj.attributes[`bR20_${prop}`];
					obj.attributes[`bR20_${prop}`] = null;
				}
			}
		});
	}

	d20plus.engine._graphicsStashToRight = (_this, visible) => {
		if (typeof _this.left !== "number") return;
		if (!visible) {
			const page = d20.Campaign.pages.get(_this.page_id);
			const newLeft = _this.left + page.get("width") * 70;
			_this.bR20_left = _this.left;
			_this.left = newLeft;
		} else {
			if (_this.bR20_left) {
				_this.left = _this.bR20_left;
				_this.bR20_left = null;
			}
		}
	}

	d20plus.engine.objectsHideUnhide = (query, val, prefix, visible) => {
		let some = false;
		for (const o of d20.engine.canvas._objects) {
			if (!o.model) continue;
			if (`${o.model.get(query)}`.search(val) > -1) {
				const _this = o.model.attributes;
				const {layer} = o.model.attributes;
				if (visible) {
					if (_this.bR20_hidden && _this.bR20_hidden.search(prefix) > -1) {
						_this.bR20_hidden = _this.bR20_hidden.replace(`${prefix}_`, "");
						if (_this.type !== "path") {
							_this.layer = layer.replace(`${prefix}_`, "");
							if (!_this.bR20_hidden) {
								d20plus.engine._objectsStashProps(o.model, true);
							}
						} else if (!_this.bR20_hidden) {
							d20plus.engine._graphicsStashToRight(_this, true);
						}
						o.saveState();
						o.model.save();
						some = true;
					}
				} else {
					if (!_this.bR20_hidden || _this.bR20_hidden.search(prefix) === -1) {
						_this.bR20_hidden = `${prefix}_${_this.bR20_hidden || ""}`;
						if (_this.type !== "path") {
							_this.layer = `${prefix}_${layer}`;
							d20plus.engine._objectsStashProps(o.model, false);
						} else {
							d20plus.engine._graphicsStashToRight(_this, false);
						}
						o.saveState();
						o.model.save();
						some = true;
					}
				}
			}
		}
		return some;
	};

	d20plus.engine.addLayers = () => {
		d20plus.ut.log("Adding layers");

		d20plus.mod.editingLayerOnclick();
		if (window.is_gm) {
			// Override icons a bit
			$(`#floatingtoolbar .chooseobjects .pictos`).html("U");
			$(`#editinglayer .submenu .choosegmlayer`).html(`
				<span class="pictos">E</span>
				${__("ui_bar_gm")}
			`);

			$(`#floatingtoolbar .choosemap`).html(`
				<span class="pictos" style="padding: 0 3px 0 3px;">G</span> 
				${__("ui_bar_map")}
			`);

			// Add layers to layer dropdown
			if (d20plus.cfg.getOrDefault("canvas", "showBackground")) {
				$(`#floatingtoolbar .choosemap`).after(`
					<li class="choosebackground">
						<span class="pictos">a</span>
						${__("ui_bar_bg")}
						<span class="pictos layer_toggle" title="${__("ui_bar_toggle_layer_title")}">E</span>
					</li>
				`);
				$(".choosebackground > .layer_toggle").on("click", d20plus.engine.layersToggle);
			}

			if (d20plus.cfg.getOrDefault("canvas", "showFloors")) {
				$(`#floatingtoolbar .choosemap`).after(`
					<li class="choosefloors">
						<span class="pictos">I</span>
						${__("ui_bar_fl")}
						<span class="pictos layer_toggle" title="${__("ui_bar_toggle_layer_title")}">E</span>
					</li>
				`);
				$(".choosefloors > .layer_toggle").on("click", d20plus.engine.layersToggle);
			}

			if (d20plus.cfg.getOrDefault("canvas", "showRoofs")) {
				$(`#floatingtoolbar .chooseobjects`).after(`
					<li class="chooseroofs">
						<span class="pictos">H</span>
						${__("ui_bar_rf")}
						<span class="pictos layer_toggle" title="${__("ui_bar_toggle_layer_title")}">E</span>
					</li>
				`);
				$(".chooseroofs > .layer_toggle").on("click", d20plus.engine.layersToggle);
			}

			if (d20plus.cfg.getOrDefault("canvas", "showForeground")) {
				$(`#floatingtoolbar .choosegmlayer`).before(`
					<li class="chooseforeground">
						<span class="pictos">B</span>
						${__("ui_bar_fg")}
						<span class="pictos layer_toggle" title="${__("ui_bar_toggle_layer_title")}">E</span>
					</li>
				`);
				$(".chooseforeground > .layer_toggle").on("click", d20plus.engine.layersToggle);
			}

			if (d20plus.cfg.getOrDefault("canvas", "showWeather")) {
				$(`#floatingtoolbar .choosewalls`).after(`
					<li class="chooseweather">
						<span class="pictos">C</span>
						${__("ui_bar_we")}
					</li>
				`);
			}
		}

		d20.engine.canvas._renderAll = _.bind(d20plus.mod.renderAll, d20.engine.canvas);
		d20.engine.canvas.sortTokens = _.bind(d20plus.mod.sortTokens, d20.engine.canvas);
		d20.engine.canvas.drawAnyLayer = _.bind(d20plus.mod.drawAnyLayer, d20.engine.canvas);
		d20.engine.canvas.drawTokensWithoutAuras = _.bind(d20plus.mod.drawTokensWithoutAuras, d20.engine.canvas);// RB20 EXCLUDE START
		// d20.engine.canvas._renderAll = _.bind(d20plus.mod.legacy_renderAll, d20.engine.canvas);
		// d20.engine.canvas._layerIteratorGenerator = d20plus.mod.legacy_layerIteratorGenerator;// RB20 EXCLUDE END
	};

	d20plus.engine.removeLinkConfirmation = function () {
		d20.utils.handleURL = d20plus.mod.handleURL;
		$(document).off("click", "a").on("click", "a", d20.utils.handleURL);
	};

	d20plus.engine.repairPrototypeMethods = function () {
		d20plus.mod.fixHexMethods();
		d20plus.mod.fixVideoMethods();
	};

	d20plus.engine.disableFrameRecorder = function () {
		if (d20.engine.frame_recorder) {
			d20.engine.frame_recorder.active = false;
			d20.engine.frame_recorder._active = false;
		}
	};
}

SCRIPT_EXTENSIONS.push(d20plusEngine);


function baseMenu () {
	d20plus.menu = {};

	d20plus.menu.addSelectedTokenCommands = () => {
		d20plus.ut.log("Add token rightclick commands");
		if (d20plus.cfg.getOrDefault("canvas", "enableNeatMenus")) {
			$("#tmpl_actions_menu").replaceWith(d20plus.menu.generateNeatActionsMenu());
		} else {
			$("#tmpl_actions_menu").replaceWith(d20plus.html.actionsMenu);
		}

		const getTokenWhisperPart = () => d20plus.cfg.getOrDefault("token", "massRollWhisperName") ? "/w gm Rolling for @{selected|token_name}...\n" : "";

		Mousetrap.bind("b b", function () { // back on layer
			const n = d20plus.engine.getSelectedToMove();
			d20plus.engine.backwardOneLayer(n);
			return false;
		});

		Mousetrap.bind("b f", function () { // forward one layer
			const n = d20plus.engine.getSelectedToMove();
			d20plus.engine.forwardOneLayer(n);
			return false;
		});

		/**
		 * @param token A token.
		 * @return {number} 0 for unknown, 1 for NPC, 2 for PC.
		 */
		function getTokenType (token) {
			if (token && token.model && token.model.toJSON && token.model.toJSON().represents) {
				const charIdMaybe = token.model.toJSON().represents;
				if (!charIdMaybe) return 0; //
				const charMaybe = d20.Campaign.characters.get(charIdMaybe);
				if (charMaybe) {
					const atbs = charMaybe.attribs.toJSON();
					const npcAtbMaybe = atbs.find(it => it.name === "npc");

					if (npcAtbMaybe && Number(npcAtbMaybe.current) === 1) {
						return 1;
					} else {
						return 2;
					}
				} else return 0;
			} else return 0;
		}

		const lastContextSelection = {
			lastAnimUid: null,
			lastSceneUid: null,
		};

		/* eslint-disable */

		// BEGIN ROLL20 CODE
		var e, t = !1, n = [];
		var i = function() {
			t && (t.remove(),
				t = !1),
			e && clearTimeout(e)
		};
		var r = function (r) {
			var o, a;
			r.changedTouches && r.changedTouches.length > 0 ? (o = r.changedTouches[0].pageX,
				a = r.changedTouches[0].pageY) : (o = r.pageX,
				a = r.pageY),
				i(),
				n = [];
			for (var s = [], l = d20.engine.selected(), c = 0; c < l.length; c++)
				n.push(l[c]),
					s.push(l[c].type);
			if (s = _.uniq(s),
			n.length > 0)
				if (1 == s.length) {
					var u = n[0];
					t = $("image" == u.type && 0 == u.model.get("isdrawing") ? $("#tmpl_actions_menu").jqote(u.model) : $("#tmpl_actions_menu").jqote(u.model))
				} else {
					var u = n[0];
					t = $($("#tmpl_actions_menu").jqote(u.model))
				}
			else
				t = $($("#tmpl_actions_menu").jqote({}));
			if (!window.is_gm && t[0].lastElementChild.childElementCount < 1)
				return !1;
			t.appendTo("body");
			// BEGIN MOD
			if (d20plus.cfg.getOrDefault("canvas", "enableNeatMenus")) {
				setTimeout(() => {
					const group = $(`.actions_menu > ul > li`).find(`[data-menuname='token']`);
					if (!group.length) return;
					$('[id^=r20es-token-ctx-menu-button-]').each( function () {
						$(this).detach().appendTo(group);
					});
				}, 10);
			}
			// END MOD
			var d = t.height()
				, h = t.width()
				, p = {};
			return p.top = a > $("#editor-wrapper").height() - $("#playerzone").height() - d - 100 ? a - d + "px" : a + "px",
				p.left = o > $("#editor-wrapper").width() - h ? o + 10 - h + "px" : o + 10 + "px",
				t.css(p),
				$(".actions_menu").bind("mousedown mouseup touchstart", function(e) {
					e.stopPropagation()
				}),
				$(".actions_menu ul > li").bind("mouseover touchend", function() {
					if (e && (clearTimeout(e),
						e = !1),
					$(this).parents(".hasSub").length > 0)
						;
					else if ($(this).hasClass("hasSub")) {
						$(".actions_menu").css({
							width: "215px",
							height: "250px"
						});
						var t = this;
						_.defer(function() {
							$(".actions_menu ul.submenu").hide(),
								$(t).find("ul.submenu:hidden").show()
						})
					} else
						$(".actions_menu ul.submenu").hide()
				}),
				$(".actions_menu ul.submenu").live("mouseover", function() {
					e && (clearTimeout(e),
						e = !1)
				}),
				$(".actions_menu, .actions_menu ul.submenu").live("mouseleave", function() {
					e || (e = setTimeout(function() {
						$(".actions_menu ul.submenu").hide(),
							$(".actions_menu").css("width", "100px").css("height", "auto"),
							e = !1
					}, 500))
				}),
				$(".actions_menu li").on(clicktype, function() {
					var e = $(this).attr("data-action-type");
					if (null != e) {
						if ("copy" == e)
							d20.clipboard.doCopy(),
								i();
						else if ("paste" == e)
							d20.clipboard.doPaste(),
								i();
						else if ("delete" == e) {
							var t = d20.engine.selected();
							d20.engine.canvas.deactivateAllWithDispatch();
							for (var r = 0; r < t.length; r++)
								t[r].model.destroy();
							i()
						} else if ("undo" == e)
							d20.undo && d20.undo.doUndo(),
								i();
						else if ("tofront" == e)
							d20.engine.canvas.getActiveGroup() && d20.engine.unselect(),
								_.each(n, function(e) {
									d20.engine.canvas.bringToFront(e)
								}),
								d20.Campaign.activePage().debounced_recordZIndexes(),
								i();
						else if ("toback" == e)
							d20.engine.canvas.getActiveGroup() && d20.engine.unselect(),
								_.each(n, function(e) {
									d20.engine.canvas.sendToBack(e)
								}),
								d20.Campaign.activePage().debounced_recordZIndexes(),
								i();
						else if (-1 !== e.indexOf("tolayer_")) {
							d20.engine.unselect();
							var o = e.replace("tolayer_", "");
							_.each(n, function(e) {
								e.model.save({
									layer: o
								})
							}),
								i(),
								d20.token_editor.removeRadialMenu()
						} else if ("addturn" == e)
							_.each(n, function(e) {
								d20.Campaign.initiativewindow.addTokenToList(e.model.id)
							}),
								i(),
							d20.tutorial && d20.tutorial.active && $(document.body).trigger("addedTurn");
						else if ("group" == e) {
							var a = [];
							d20.engine.unselect(),
								_.each(n, function(e) {
									a.push(e.model.id)
								}),
								_.each(n, function(e) {
									e.model.addToGroup(a)
								}),
								i();
							var s = n[0];
							d20.engine.select(s)
						} else if ("ungroup" == e)
							d20.engine.unselect(),
								_.each(n, function(e) {
									e.model.clearGroup()
								}),
								d20.token_editor.removeRadialMenu(),
								i();
						else if ("toggledrawing" == e)
							d20.engine.unselect(),
								_.each(n, function(e) {
									e.model.set({
										isdrawing: !e.model.get("isdrawing")
									}).save()
								}),
								i(),
								d20.token_editor.removeRadialMenu();
						else if ("toggleflipv" == e)
							d20.engine.unselect(),
								_.each(n, function(e) {
									e.model.set({
										flipv: !e.model.get("flipv")
									}).save()
								}),
								i(),
								d20.token_editor.removeRadialMenu();
						else if ("togglefliph" == e)
							d20.engine.unselect(),
								_.each(n, function(e) {
									e.model.set({
										fliph: !e.model.get("fliph")
									}).save()
								}),
								i(),
								d20.token_editor.removeRadialMenu();
						else if ("takecard" == e)
							d20.engine.canvas.getActiveGroup() && d20.engine.unselect(),
								_.each(n, function(e) {
									var t = d20.decks.cardByID(e.model.get("cardid"));
									if (e.model.get("isdrawing") === !1)
										var n = {
											bar1_value: e.model.get("bar1_value"),
											bar1_max: e.model.get("bar1_max"),
											bar2_value: e.model.get("bar2_value"),
											bar2_max: e.model.get("bar2_max"),
											bar3_value: e.model.get("bar3_value"),
											bar3_max: e.model.get("bar3_max")
										};
									d20.Campaign.hands.addCardToHandForPlayer(t, window.currentPlayer, n ? n : void 0),
										_.defer(function() {
											e.model.destroy()
										})
								}),
								d20.engine.unselect(),
								i();
						else if ("flipcard" == e)
							d20.engine.canvas.getActiveGroup() && d20.engine.unselect(),
								_.each(n, function(e) {
									var t = e.model.get("sides").split("|")
										, n = e.model.get("currentSide")
										, i = n + 1;
									i > t.length - 1 && (i = 0),
										e.model.set({
											currentSide: i,
											imgsrc: unescape(t[i])
										}).save()
								}),
								i();
						else if ("setdimensions" == e) {
							var l = n[0]
								, c = $($("#tmpl_setdimensions").jqote()).dialog({
								title: "Set Dimensions",
								width: 325,
								height: 225,
								buttons: {
									Set: function() {
										var e, t;
										"pixels" == c.find(".dimtype").val() ? (e = parseInt(c.find("input.width").val(), 10),
											t = parseInt(c.find("input.height").val(), 10)) : (e = parseFloat(c.find("input.width").val()) * window.dpi,
											t = parseFloat(c.find("input.height").val()) * window.dpi),
											l.model.save({
												width: e,
												height: t
											}),
											c.off("change"),
											c.dialog("destroy").remove()
									},
									Cancel: function() {
										c.off("change"),
											c.dialog("destroy").remove()
									}
								},
								beforeClose: function() {
									c.off("change"),
										c.dialog("destroy").remove()
								}
							});
							c.on("change", ".dimtype", function() {
								"pixels" == $(this).val() ? (c.find("input.width").val(Math.round(l.get("width"))),
									c.find("input.height").val(Math.round(l.get("height")))) : (c.find("input.width").val(l.get("width") / window.dpi),
									c.find("input.height").val(l.get("height") / window.dpi))
							}),
								c.find(".dimtype").trigger("change"),
								i()
						} else if ("aligntogrid" == e)
							if (0 === d20.Campaign.activePage().get("snapping_increment")) {
								i();
								var u = $($("#tmpl_grid-disabled").jqote(h)).dialog({
									title: "Grid Off",
									buttons: {
										Ok: function() {
											u.off("change"),
												u.dialog("destroy").remove()
										}
									},
									beforeClose: function() {
										u.off("change"),
											u.dialog("destroy").remove()
									}
								})
							} else
								d20.engine.gridaligner.target = n[0],
									d20plus.setMode("gridalign"),
									i();
						else if ("side_random" == e) {
							d20.engine.canvas.getActiveGroup() && d20.engine.unselect();
							var d = [];
							_.each(n, function(e) {
								if (e.model && "" != e.model.get("sides")) {
									var t = e.model.get("sides").split("|")
										, n = t.length
										, i = d20.textchat.diceengine.random(n);
									// BEGIN MOD
									const imgUrl = unescape(t[i]);
									e.model.save(getRollableTokenUpdate(imgUrl, i)),
									// END MOD
										d.push(t[i])
								}
							}),
								d20.textchat.rawChatInput({
									type: "tokenroll",
									content: d.join("|")
								}),
								i()
						} else if ("side_choose" == e) {
							const e = n[0]
								, t = e.model.toJSON()
								, o = t.sides.split("|");
							let r = t.currentSide;
							const a = $($("#tmpl_chooseside").jqote()).dialog({
								title: "Choose Side",
								width: 325,
								height: 225,
								buttons: {
									Choose: function() {
										const imgUrl = unescape(o[r]);
										d20.engine.canvas.getActiveGroup() && d20.engine.unselect(),
											// BEGIN MOD
											e.model.save(getRollableTokenUpdate(imgUrl, r)),
											// END MOD
											a.off("slide"),
											a.dialog("destroy").remove()
									},
									Cancel: function() {
										a.off("slide"),
											a.dialog("destroy").remove()
									}
								},
								beforeClose: function() {
									a.off("slide"),
										a.dialog("destroy").remove()
								}
							})
								, s = a.find(".sidechoices");
							for (const e of o) {
								const t = unescape(e);
								let n = d20.utils.isVideo(t) ? `<video src="${t.replace("/med.webm", "/thumb.webm")}" muted autoplay loop />` : `<img src="${t}" />`;
								n = `<div class="sidechoice">${n}</div>`,
									s.append(n)
							}
							s.children().attr("data-selected", !1).eq(r).attr("data-selected", !0),
								a.find(".sideslider").slider({
									min: 0,
									max: o.length - 1,
									step: 1,
									value: r
								}),
								a.on("slide", function(e, t) {
									t.value != r && (r = t.value,
										a.find(".sidechoices .sidechoice").attr("data-selected", !1).eq(t.value).attr("data-selected", !0))
								}),
								i(),
								d20.token_editor.removeRadialMenu()
						}
						// BEGIN MOD
						const showRollOptions = (formula, options) => {
							const sel = d20.engine.selected();

							options = options.map(it => `<option>${it}</option>`);

							const dialog= $("<div><p style='font-size: 1.15em;'><strong>" + d20.utils.strip_tags(''+__('ui_dialog_select')) + ":</strong> <select style='width: 150px; margin-left: 5px;'>" + options.join("") + "</select></p></div>");

							dialog.dialog({
								title: __('ui_dialog_title'),
								beforeClose: function() {
									return false;
								},
								buttons: {
									[__('ui_dialog_submit')+'']: function() {
										const val = dialog.find("select").val();
										console.log(val);
										d20.engine.unselect();
										sel.forEach(it => {
											d20.engine.select(it);
											const toRoll = formula(it, val);
											d20.textchat.doChatInput(toRoll);
											d20.engine.unselect();
										});

										dialog.off();
										dialog.dialog("destroy").remove();
										d20.textchat.$textarea.focus();
									},
									[__('ui_dialog_cancel')+'']: function() {
										dialog.off();
										dialog.dialog("destroy").remove();
									}
								}
							});

							i();
						};

						if ("rollsaves" === e) {
							// Mass roll: Saves
							const options = ["str", "dex", "con", "int", "wis", "cha"].map(it => Parser.attAbvToFull(it));
							if (!!d20plus.cfg.get('token','massRollAssumesOGL')) {
								const out_options = [];
								const loc_options = {
									[__('stat_save_str')]: 'Strength',
									[__('stat_save_dex')]: 'Dexterity',
									[__('stat_save_con')]: 'Constitution',
									[__('stat_save_int')]: 'Intelligence',
									[__('stat_save_wis')]: 'Wisdom',
									[__('stat_save_cha')]: 'Charisma',
								}
								for (const i in loc_options) out_options.push(i);
								showRollOptions(
									(token, val) => {
										return `&{template:simple} {{rname=^{${loc_options[val].toLowerCase()}-save-u}}} {{charname=@{selected|token_name}}} {{mod=@{selected|${loc_options[val].toLowerCase()}_save_bonus}}} {{always=1}} {{r1=[[@{selected|d20}+@{selected|${loc_options[val].toLowerCase()}_save_bonus}]]}} {{r2=[[@{selected|d20}+@{selected|${loc_options[val].toLowerCase()}_save_bonus}]]}}`;
									},
									out_options
								);
							}
							else if (d20plus.sheet === "ogl") {
								showRollOptions(
									(token, val) => {
										if (getTokenType(token) === 1) {
											const short = val.substring(0, 3);
											return `${getTokenWhisperPart()}@{selected|wtype}&{template:npc} @{selected|npc_name_flag} {{type=Save}} @{selected|rtype} + [[@{selected|npc_${short.toLowerCase()}_save}]][${short.toUpperCase()}]]]}} {{rname=${val} Save}} {{r1=[[1d20 + [[@{selected|npc_${short.toLowerCase()}_save}]][${short.toUpperCase()}]]]}}`;
										} else {
											return `@{selected|wtype} &{template:simple} {{charname=@{selected|token_name}}} {{always=1}} {{rname=${val} Save}} {{mod=@{selected|${val.toLowerCase()}_save_bonus}}} {{r1=[[1d20+@{selected|${val.toLowerCase()}_save_bonus}]]}} {{r2=[[1d20+@{selected|${val.toLowerCase()}_save_bonus}]]}}`;
										}
									},
									options
								);
							}
							else if (d20plus.sheet === "shaped") {
								showRollOptions(
									(token, val) => `@{selected|output_option}} &{template:5e-shaped} {{ability=1}} {{character_name=@{selected|token_name}}} {{title=${val} Save}} {{mod=@{selected|${val.toLowerCase()}_mod}}} {{roll1=[[1d20+@{selected|${val.toLowerCase()}_mod}]]}} {{roll2=[[1d20+@{selected|${val.toLowerCase()}_mod}]]}}`,
									options
								);
							}
						} else if ("rollinit" === e) {
							// Mass roll: Initiative
							const sel = d20.engine.selected();
							d20.engine.unselect();
							sel.forEach(it => {
								d20.engine.select(it);
								let toRoll = ``;
								if (!!d20plus.cfg.get('token','massRollAssumesOGL')) {
									toRoll = `&{template:simple} {{rname=${__('stat_init')}}} {{charname=@{selected|token_name}}} {{mod=@{selected|initiative_bonus}}} {{always=1}} {{r1=[[@{selected|d20}+@{selected|initiative_bonus} &{tracker}]]}} {{r2=[[@{selected|d20}+@{selected|initiative_bonus}]]}}`;
								}
								else if ((d20plus.sheet === "ogl") || !!d20plus.cfg.get('token','massRollAssumesOGL')) {
									toRoll = `%{selected|Initiative}`;
								}
								else if (d20plus.sheet === "shaped") {
									toRoll = `@{selected|output_option} &{template:5e-shaped} {{ability=1}} {{title=INITIATIVE}} {{roll1=[[@{selected|initiative_formula}]]}}`;
								}
								d20.textchat.doChatInput(toRoll);
								d20.engine.unselect();
							});
							i();
						} else if ("rollskills" === e) {
							// TODO a "roll abilitiy check" option? NPC macro: @{selected|wtype}&{template:npc} @{selected|npc_name_flag} {{type=Check}} @{selected|rtype} + [[@{selected|strength_mod}]][STR]]]}} {{rname=Strength Check}} {{r1=[[1d20 + [[@{selected|strength_mod}]][STR]]]}}

							// Mass roll: Skills
							const options = [
								"Athletics",
								"Acrobatics",
								"Sleight of Hand",
								"Stealth",
								"Arcana",
								"History",
								"Investigation",
								"Nature",
								"Religion",
								"Animal Handling",
								"Insight",
								"Medicine",
								"Perception",
								"Survival",
								"Deception",
								"Intimidation",
								"Performance",
								"Persuasion"
							].sort();

							if (!!d20plus.cfg.get('token','massRollAssumesOGL')) {
								let out_options = [];
								const loc_options = {
									[__('stat_ab_athl')]: 'Athletics',
									[__('stat_ab_acrb')]: 'Acrobatics',
									[__('stat_ab_sloh')]: 'Sleight of Hand',
									[__('stat_ab_stel')]: 'Stealth',
									[__('stat_ab_arcn')]: 'Arcana',
									[__('stat_ab_hist')]: 'History',
									[__('stat_ab_invs')]: 'Investigation',
									[__('stat_ab_natr')]: 'Nature',
									[__('stat_ab_relg')]: 'Religion',
									[__('stat_ab_anih')]: 'Animal Handling',
									[__('stat_ab_insg')]: 'Insight',
									[__('stat_ab_medc')]: 'Medicine',
									[__('stat_ab_perc')]: 'Perception',
									[__('stat_ab_surv')]: 'Survival',
									[__('stat_ab_decp')]: 'Deception',
									[__('stat_ab_intm')]: 'Intimidation',
									[__('stat_ab_perf')]: 'Performance',
									[__('stat_ab_pers')]: 'Persuasion',
								}
								for (const i in loc_options) out_options.push(i);
								out_options = out_options.sort();
								showRollOptions(
									(token, val) => {
										const ready_val = loc_options[val].toLowerCase().replace(/ /g, "_");
										return `&{template:simple} {{rname=^{${ready_val}-u}}} {{charname=@{selected|token_name}}} {{mod=@{selected|${ready_val}_bonus}}} {{always=1}} {{r1=[[@{selected|d20}+@{selected|${ready_val}_bonus}]]}} {{r2=[[@{selected|d20}+@{selected|${ready_val}_bonus}]]}}`;
									},
									out_options
								);
							}
							else {
								showRollOptions(
									(token, val) => {
										const clean = val.toLowerCase().replace(/ /g, "_");
										const abil = `${Parser.attAbvToFull(Parser.skillToAbilityAbv(val.toLowerCase())).toLowerCase()}_mod`;
	
										let doRoll = '';
										if (d20plus.sheet === "ogl") {
											doRoll = (atb = abil) => {
												if (getTokenType(token) === 1) {
													const slugged = val.replace(/\s/g, "_").toLowerCase();
													return `${getTokenWhisperPart()}@{selected|wtype}&{template:npc} @{selected|npc_name_flag} {{type=Skill}} @{selected|rtype} + [[@{selected|npc_${slugged}}]]]]}}; {{rname=${val}}}; {{r1=[[1d20 + [[@{selected|npc_${slugged}}]]]]}}`;
												} else {
													return `@{selected|wtype} &{template:simple} {{charname=@{selected|token_name}}} {{always=1}} {{rname=${val}}} {{mod=@{selected|${atb}}}} {{r1=[[1d20+@{selected|${atb}}]]}} {{r2=[[1d20+@{selected|${atb}}]]}}`;
												}
											}
										} 
										else if (d20plus.sheet === "shaped"){
											doRoll = (atb = abil) => {
												return `@{selected|output_option} &{template:5e-shaped} {{ability=1}} {{character_name=@{selected|token_name}}} {{title=${val}}} {{mod=@{selected|${atb}}}} {{roll1=[[1d20+@{selected|${atb}}]]}} {{roll2=[[1d20+@{selected|${atb}}]]}}`;
											}
										}
	
										try {
											if (token && token.model && token.model.toJSON && token.model.toJSON().represents) {
												const charIdMaybe = token.model.toJSON().represents;
												if (!charIdMaybe) return doRoll();
												const charMaybe = d20.Campaign.characters.get(charIdMaybe);
												if (charMaybe) {
													const atbs = charMaybe.attribs.toJSON();
													const npcAtbMaybe = atbs.find(it => it.name === "npc");
	
													if (npcAtbMaybe && npcAtbMaybe.current == 1) {
														const npcClean = `npc_${clean}`;
														const bonusMaybe = atbs.find(it => it.name === npcClean);
														if (bonusMaybe) return doRoll(npcClean);
														else return doRoll();
													} else {
														const pcClean = `${clean}_bonus`;
														const bonusMaybe = atbs.find(it => it.name === pcClean);
														if (bonusMaybe) return doRoll(pcClean);
														else return doRoll();
													}
												} else return doRoll();
											} else return doRoll();
										} catch (x) {
											console.error(x);
											return doRoll();
										}
									},
									options
								);
							}

							
						} else if ("forward-one" === e) {
							d20plus.engine.forwardOneLayer(n);
							i();
						} else if ("back-one" === e) {
							d20plus.engine.backwardOneLayer(n);
							i();
						} else if ("rollertokenresize" === e) {
							resizeToken();
							i();
						} else if ("copy-tokenid" === e) {
							const sel = d20.engine.selected();
							window.prompt("Copy to clipboard: Ctrl+C, Enter", sel[0].model.id);
							i();
						} else if ("copy-pathid" === e) {
							const sel = d20.engine.selected();
							window.prompt("Copy to clipboard: Ctrl+C, Enter", sel[0].model.id);
							i();
						} else if ("token-fly" === e) {
							const sel = d20.engine.selected().filter(it => it && it.type === "image");
							new Promise((resolve, reject) => {
								const $dialog = $(`
									<div title="Flight Height">
										<input type="number" placeholder="Flight height" name="flight">
									</div>
								`).appendTo($("body"));
								const $iptHeight = $dialog.find(`input[name="flight"]`).on("keypress", evt => {
									if (evt.which === 13) { // return
										doHandleOk();
									}
								});

								const doHandleOk = () => {
									const selected = Number($iptHeight.val());
									$dialog.dialog("close");
									if (isNaN(selected)) reject(`Value "${$iptHeight.val()}" was not a number!`);
									else resolve(selected);
								};

								$dialog.dialog({
									dialogClass: "no-close",
									buttons: [
										{
											text: "Cancel",
											click: function () {
												$(this).dialog("close");
												$dialog.remove();
												reject(`User cancelled the prompt`);
											}
										},
										{
											text: "OK",
											click: function () {
												doHandleOk();
											}
										}
									]
								});
							}).then(num => {
								const STATUS_PREFIX = `fluffy-wing@`;
								const statusString = `${num}`.split("").map(it => `${STATUS_PREFIX}${it}`).join(",");
								sel.forEach(s => {
									const existing = s.model.get("statusmarkers");
									if (existing && existing.trim()) {
										s.model.set("statusmarkers", [statusString, ...existing.split(",").filter(it => it && it && !it.startsWith(STATUS_PREFIX))].join(","));
									} else {
										s.model.set("statusmarkers", statusString);
									}
									s.model.save();
								});
							});
							i();
						} else if ("token-light" === e) {
							const SOURCES = {
								"None (Blind)": {
									bright: 0,
									dim: 0
								},
								"Torch/Light (Spell)": {
									bright: 20,
									dim: 20
								},
								"Lamp": {
									bright: 15,
									dim: 30
								},
								"Lantern, Bullseye": {
									bright: 60,
									dim: 60,
									angle: 30
								},
								"Lantern, Hooded": {
									bright: 30,
									dim: 30
								},
								"Lantern, Hooded (Dimmed)": {
									bright: 0,
									dim: 5
								},
								"Candle": {
									bright: 5,
									dim: 5
								},
								"Darkvision": {
									bright: 0,
									dim: 60,
									hidden: true
								},
								"Superior Darkvision": {
									bright: 0,
									dim: 120,
									hidden: true
								}
							};

							const sel = d20.engine.selected().filter(it => it && it.type === "image");
							new Promise((resolve, reject) => {
								const $dialog = $(`
									<div title="Light">
										<label class="flex">
											<span>Set Light Style</span>
											 <select style="width: 250px;">
												${Object.keys(SOURCES).map(it => `<option>${it}</option>`).join("")}
											</select>
										</label>
									</div>
								`).appendTo($("body"));
								const $selLight = $dialog.find(`select`);

								$dialog.dialog({
									dialogClass: "no-close",
									buttons: [
										{
											text: "Cancel",
											click: function () {
												$(this).dialog("close");
												$dialog.remove();
												reject(`User cancelled the prompt`);
											}
										},
										{
											text: "OK",
											click: function () {
												const selected = $selLight.val();
												$dialog.dialog("close");
												if (!selected) reject(`No value selected!`);
												else resolve(selected);
											}
										}
									]
								});
							}).then(key => {
								const light = SOURCES[key];

								const light_otherplayers = !light.hidden;
								// these are all stored as strings
								const dimRad = (light.dim || 0);
								const brightRad = (light.bright || 0);
								const totalRad = dimRad + brightRad;
								const light_angle = `${light.angle}` || "";
								const light_dimradius = `${totalRad - dimRad}`;
								const light_radius = `${totalRad}`;

								sel.forEach(s => {
									s.model.set("light_angle", light_angle);
									s.model.set("light_dimradius", light_dimradius);
									s.model.set("light_otherplayers", light_otherplayers);
									s.model.set("light_radius", light_radius);
									s.model.save();
								});
							});
							i();
						} else if ("unlock-tokens" === e) {
							d20plus.tool.get("UNLOCKER").openFn();
							i();
						} else if ("lock-token" === e) {
							d20.engine.selected().forEach(it => {
								if (it.model) {
									if (it.model.get("VeLocked")) {
										it.lockMovementX = false;
										it.lockMovementY = false;
										it.lockScalingX = false;
										it.lockScalingY = false;
										it.lockRotation = false;

										it.model.set("VeLocked", false);
									} else {
										it.lockMovementX = true;
										it.lockMovementY = true;
										it.lockScalingX = true;
										it.lockScalingY = true;
										it.lockRotation = true;

										it.model.set("VeLocked", true);
									}
									it.saveState();
									it.model.save();
								}
							});
							i();
						} else if ("token-animate" === e) {
							d20plus.anim.animatorTool.pSelectAnimation(lastContextSelection.lastAnimUid).then(animUid => {
								if (animUid == null) return;

								lastContextSelection.lastAnimUid = animUid;
								const selected = d20.engine.selected();
								d20.engine.unselect();
								selected.forEach(it => {
									if (it.model) {
										d20plus.anim.animator.startAnimation(it.model, animUid)
									}
								});
							});
							i();
						} else if ("util-scenes" === e) {
							d20plus.anim.animatorTool.pSelectScene(lastContextSelection.lastSceneUid).then(sceneUid => {
								if (sceneUid == null) return;

								lastContextSelection.lastSceneUid = sceneUid;
								d20plus.anim.animatorTool.doStartScene(sceneUid);
							});
							i();
						} else if (["assignview0", "assignview1", "assignview2", "assignview3"].includes(e)) {
							const viewId = e.at(-1);
							d20.engine.selected().forEach(it => {
								if (it.model) {
									if (it.model.get(`bR20_view${viewId}`)) {
										it.model.set(`bR20_view${viewId}`, false);
									} else {
										if (!d20plus.engine.tokenRepresentsPc(it.model)) it.model.set(`bR20_view${viewId}`, true);
									}
									it.saveState();
									it.model.save();
								}
							});
							i();
						}
						// END MOD
						return !1
					}
				}),
				!1
		};
		// END ROLL20 CODE

		/* eslint-enable */

		function getRollableTokenUpdate (imgUrl, curSide) {
			const m = /\?roll20_token_size=(.*)/.exec(imgUrl);
			const toSave = {
				currentSide: curSide,
				imgsrc: imgUrl,
			};
			if (m) {
				toSave.width = 70 * Number(m[1]);
				toSave.height = 70 * Number(m[1])
			}
			return toSave;
		}

		function resizeToken () {
			const sel = d20.engine.selected();

			const options = [["Tiny", 0.5], ["Small", 1], ["Medium", 1], ["Large", 2], ["Huge", 3], ["Gargantuan", 4], ["Colossal", 5]].map(it => `<option value='${it[1]}'>${it[0]}</option>`);
			const dialog = $(`<div><p style='font-size: 1.15em;'><strong>${d20.utils.strip_tags("Select Size")}:</strong> <select style='width: 150px; margin-left: 5px;'>${options.join("")}</select></p></div>`);
			dialog.dialog({
				title: "New Size",
				beforeClose: function () {
					return false;
				},
				buttons: {
					Submit: function () {
						const size = dialog.find("select").val();
						d20.engine.unselect();
						sel.forEach(it => {
							const nxtSize = size * 70;
							const sides = it.model.get("sides");
							if (sides) {
								const ueSides = unescape(sides);
								const cur = it.model.get("currentSide");
								const split = ueSides.split("|");
								if (split[cur].includes("roll20_token_size")) {
									split[cur] = split[cur].replace(/(\?roll20_token_size=).*/, `$1${size}`);
								} else {
									split[cur] += `?roll20_token_size=${size}`;
								}
								const toSaveSides = split.map(it => escape(it)).join("|");
								const toSave = {
									sides: toSaveSides,
									width: nxtSize,
									height: nxtSize,
								};
								// eslint-disable-next-line no-console
								console.log(`Updating token:`, toSave);
								it.model.save(toSave);
							} else {
								// eslint-disable-next-line no-console
								console.warn("Token had no side data!")
							}
						});
						dialog.off();
						dialog.dialog("destroy").remove();
						d20.textchat.$textarea.focus();
					},
					Cancel: function () {
						dialog.off();
						dialog.dialog("destroy").remove();
					},
				},
			});
		}

		d20.token_editor.showContextMenu = r;
		d20.token_editor.closeContextMenu = i;
		$(`#editor-wrapper`).on("click", d20.token_editor.closeContextMenu);
	};

	d20plus.menu._neatActionsView = (id) => {
		return `
			<span class="pictos ctx__layer-icon"><$ if (d20.Campaign.activePage().get('bR20cfg_views${id}Icon')) { 
				$> <$!d20.Campaign.activePage().get('bR20cfg_views${id}Icon')$> <$
			} else { 
				$>P<$ 
			} $> </span> <$
			if (d20.Campaign.activePage().get('bR20cfg_views${id}Name')) { 
				$> <$!d20.Campaign.activePage().get('bR20cfg_views${id}Name')$> <$
			} else { 
				$> ${id ? `View ${id}` : `Default`} <$ 
			} $>`;
	};

	d20plus.menu.neatActions = {
		"unlock-tokens": { ln: __("menu_unlock"), condition: "window.is_gm && Object.keys(this).length === 0" },
		"takecard": { ln: __("menu_take_card"), condition: "this.view && this.view.graphic.type == \"image\" && this.get(\"cardid\") !== \"\"" },
		"flipcard": { ln: __("menu_flip_card"), condition: "this.view && this.view.graphic.type == \"image\" && this.get(\"cardid\") !== \"\"" },
		"delete": { ln: __("menu_edit_del"), icon: "#", condition: "this.view" },
		"copy": { ln: __("menu_edit_copy"), icon: "|", condition: "window.is_gm && this.view" },
		"paste": { ln: __("menu_edit_paste"), icon: "W", condition: "window.is_gm && !this.view" },
		"undo": { ln: __("menu_edit_undo"), icon: "1", condition: "window.is_gm" },
		"tofront": { ln: __("menu_move_tofront"), condition: "this.view" },
		"forward-one": { ln: __("menu_move_forwone"), condition: "this.view" },
		"back-one": { ln: __("menu_move_backone"), condition: "this.view", quick: __("menu_quick_toback")},
		"toback": { ln: __("menu_move_toback"), condition: "this.view" },
		"tolayer_map": { ln: __("menu_layer_map"), icon: "G", condition: "this.view", active: "this && this.get && this.get(\"layer\") == \"map\"" },
		"tolayer_floors": { ln: __("menu_layer_fl"), icon: "I", condition: "this.view && d20plus.cfg.getOrDefault(\"canvas\", \"showFloors\")", active: "this && this.get && this.get(\"layer\") == \"floors\"" },
		"tolayer_background": { ln: __("menu_layer_bg"), icon: "a", condition: "this.view && d20plus.cfg.getOrDefault(\"canvas\", \"showBackground\")", active: "this && this.get && this.get(\"layer\") == \"background\"" },
		"tolayer_objects": { ln: __("menu_layer_obj"), icon: "U", condition: "this.view", active: "this && this.get && this.get(\"layer\") == \"objects\"", quick: __("menu_quick_tofg") },
		"tolayer_foreground": { ln: __("menu_layer_fg"), icon: "B", condition: "this.view && d20plus.cfg.getOrDefault(\"canvas\", \"showForeground\")", active: "this && this.get && this.get(\"layer\") == \"foreground\"" },
		"tolayer_roofs": { ln: __("menu_layer_rf"), icon: "H", condition: "this.view && d20plus.cfg.getOrDefault(\"canvas\", \"showRoofs\")", active: "this && this.get && this.get(\"layer\") == \"roofs\"" },
		"tolayer_gmlayer": { ln: __("menu_layer_gm"), icon: "E", condition: "this.view", active: "this && this.get && this.get(\"layer\") == \"gmlayer\"", quick: __("menu_quick_togm")},
		"tolayer_walls": { ln: __("menu_layer_barriers"), icon: "r", condition: "this.view", active: "this && this.get && this.get(\"layer\") == \"walls\"" },
		"tolayer_weather": { ln: __("menu_layer_weather"), icon: "C", condition: "this.view && d20plus.cfg.getOrDefault(\"canvas\", \"showWeather\")", active: "this && this.get && this.get(\"layer\") == \"weather\"" },
		"util-scenes": { ln: __("menu_util_start"), condition: "" },
		"token-animate": { ln: __("menu_util_animate"), condition: "this.get && this.get(\"type\") == \"image\"" },
		"token-fly": { ln: __("menu_util_flight"), condition: "this.get && this.get(\"type\") == \"image\"", active: "this && this.attributes.statusmarkers.search(\"fluffy-wing@\")>-1" },
		"token-light": { ln: __("menu_util_light"), condition: "this.get && this.get(\"type\") == \"image\"" },
		"group": { ln: __("menu_adv_grp"), condition: "this.view && this.get && (d20.engine.selected().length > 1 && !d20.engine.selected().some( el => !!el.model.get(\"groupwith\")) )" },
		"regroup": { ln: __("menu_adv_regrp"), condition: "this.view && this.get && (d20.engine.selected().length > 2 && d20.engine.selected().some( el => !el.model.get(\"groupwith\")) )", action: "group"},
		"ungroup": { ln: __("menu_adv_ungrp"), condition: "this.view && this.get  && d20.engine.selected().some( el => !!el.model.get(\"groupwith\"))" },
		"toggledrawing": { ln: __("menu_adv_isdrv"), condition: "this.get && this.get(\"type\") == \"image\"", active: "this && this.get(\"isdrawing\")" },
		"togglefliph": { ln: __("menu_adv_flh"), condition: "this.get && this.get(\"type\") == \"image\"", active: "this && this.get(\"fliph\")" },
		"toggleflipv": { ln: __("menu_adv_flv"), condition: "this.get && this.get(\"type\") == \"image\"", active: "this && this.get(\"flipv\")" },
		"setdimensions": { ln: __("menu_adv_dimens"), condition: "this.get && this.get(\"type\") == \"image\"" },
		"aligntogrid": { ln: __("menu_adv_align"), condition: "this.get && this.get(\"type\") == \"image\" && window.currentEditingLayer == \"map\"" },
		"lock-token": { ln: __("menu_adv_lock"), condition: "this.view && !this.get(\"lockMovement\") && !this.get(\"VeLocked\")" },
		"unlock-token": { ln: __("menu_adv_unlock"), condition: "this.view && (this.get(\"lockMovement\") || this.get(\"VeLocked\"))", action: "lock-token"},
		"copy-tokenid": { ln: __("menu_adv_tokenid"), condition: "this.get && this.get(\"type\") == \"image\"" },
		"copy-pathid": { ln: __("menu_adv_pathid"), condition: "this.get && this.get(\"type\") == \"path\"" },
		"addturn": { ln: __("menu_token_turn"), condition: "this.get && this.get(\"type\") != \"path\"" },
		"rollinit": { ln: __("menu_mass_init"), condition: "this.character && (d20plus.settingsHtmlHeader.search(\"5etools\") > 0 || d20plus.cfg.getOrDefault(\"token\", \"massRollAssumesOGL\"))" },
		"rollsaves": { ln: __("menu_mass_save"), condition: "this.character && (d20plus.settingsHtmlHeader.search(\"5etools\") > 0 || d20plus.cfg.getOrDefault(\"token\", \"massRollAssumesOGL\"))", quick: __("menu_quick_save")},
		"rollskills": { ln: __("menu_mass_skill"), condition: "this.character && (d20plus.settingsHtmlHeader.search(\"5etools\") > 0 || d20plus.cfg.getOrDefault(\"token\", \"massRollAssumesOGL\"))" },
		"side_random": { ln: __("menu_multi_rnd"), condition: "this.view && this.get && this.get(\"sides\") !== \"\" && this.get(\"cardid\") === \"\"" },
		"side_choose": { ln: __("menu_multi_select"), condition: "this.view && this.get && this.get(\"sides\") !== \"\" && this.get(\"cardid\") === \"\"" },
		"rollertokenresize": { ln: __("menu_multi_size"), condition: "this.view && this.get && this.get(\"sides\") !== \"\" && this.get(\"cardid\") === \"\"" },
		"assignview0": { ln: d20plus.menu._neatActionsView("0"), active: "this && this.get(\"bR20_view0\")", condition: "this.view && this.get && !d20plus.engine.tokenRepresentsPc(this) && d20.Campaign.activePage().get('bR20cfg_viewsEnable')" },
		"assignview1": { ln: d20plus.menu._neatActionsView("1"), active: "this && this.get(\"bR20_view1\")", condition: "this.view && this.get && !d20plus.engine.tokenRepresentsPc(this) && d20.Campaign.activePage().get('bR20cfg_viewsEnable') && d20.Campaign.activePage().get('bR20cfg_views1Enable')" },
		"assignview2": { ln: d20plus.menu._neatActionsView("2"), active: "this && this.get(\"bR20_view2\")", condition: "this.view && this.get && !d20plus.engine.tokenRepresentsPc(this) && d20.Campaign.activePage().get('bR20cfg_viewsEnable') && d20.Campaign.activePage().get('bR20cfg_views2Enable')" },
		"assignview3": { ln: d20plus.menu._neatActionsView("3"), active: "this && this.get(\"bR20_view3\")", condition: "this.view && this.get && !d20plus.engine.tokenRepresentsPc(this) && d20.Campaign.activePage().get('bR20cfg_viewsEnable') && d20.Campaign.activePage().get('bR20cfg_views3Enable')" },
	};

	d20plus.menu._neatStructure = {
		"edit": {
			ln: __("menu_edit_title"),
			subitems: [
				"delete",
				"copy",
				"paste",
				"undo",
			] },
		"move": {
			ln: __("menu_move_title"),
			subitems: [
				"tofront",
				"forward-one",
				"back-one",
				"toback",
			] },
		"layer": {
			ln: __("menu_layer_title"),
			subitems: [
				"tolayer_map",
				"tolayer_floors",
				"tolayer_background",
				"tolayer_objects",
				"tolayer_foreground",
				"tolayer_roofs",
				"tolayer_gmlayer",
				"tolayer_walls",
				"tolayer_weather",
			] },
		"view": {
			ln: __("menu_view_title"),
			subitems: [
				"assignview0",
				"assignview1",
				"assignview2",
				"assignview3",
			] },
		"util": {
			ln: __("menu_util_title"),
			subitems: [
				"util-scenes",
				"-",
				"token-animate",
				"token-fly",
				"token-light",
			] },
		"adv": {
			ln: __("menu_adv_title"),
			subitems: [
				"unlock-tokens",
				"group",
				"regroup",
				"ungroup",
				"lock-token",
				"unlock-token",
				"-",
				"toggledrawing",
				"togglefliph",
				"toggleflipv",
				"setdimensions",
				"aligntogrid",
				"copy-tokenid",
				"copy-pathid",
			] },
		"token": {
			ln: __("menu_token_title"),
			subitems: [
				"addturn",
				"-",
			] },
		"mass": {
			ln: __("menu_mass_title"),
			subitems: [
				"rollinit",
				"rollsaves",
				"rollskills",
			] },
		"multi": {
			ln: __("menu_multi_title"),
			subitems: [
				"side_random",
				"side_choose",
				"-",
				"rollertokenresize",
			] },
		"card": {
			ln: __("menu_card_title"),
			subitems: [
				"takecard",
				"flipcard",
			] },
	};

	d20plus.menu._pushQuickMenus = () => {
		if (d20plus.cfg.getOrDefault("canvas", "enableQuickMenuItems")) {
			let output = "";
			const pushMenu = (num, action, condition) => {
				if (!action) action = d20plus.cfg.getOrDefault(`canvas`, `quickMenuItem${num}`);
				if (action) title = d20plus.menu.neatActions[action].quick || d20plus.menu.neatActions[action].ln;
				if (action && title) {
					if (!condition) {
						condition = d20plus.menu.neatActions[action].condition;
					}
					const conditionStatement = condition ? `if (${condition})` : ``;
					output += `<$ ${conditionStatement} { $><li data-action-type='${action}'>${title}</li><$ } $>`;
				}
			};
			pushMenu(null, "tolayer_objects", `this.view && this.get("layer") == "gmlayer"`);
			pushMenu(null, "tolayer_gmlayer", `this.view && this.get("layer") != "gmlayer"`);
			pushMenu(2);
			pushMenu(3);
			return output;
		} else return "";
	};

	d20plus.menu.generateNeatActionsMenu = () => {
		let templ = "";
		Object.entries(d20plus.menu._neatStructure).forEach((menu) => {
			const menuData = menu[1];
			const menuName = `data-menuname='${menu[0]}'`;
			let menuConditions = [];
			let menuItems = "";
			menuData.subitems.forEach((item) => {
				if (item === "-") {
					menuItems += `\n\t\t<div class="ctx__divider"></div>`;
				} else {
					let itemAction = d20plus.menu.neatActions[item].action || item;
					item = d20plus.menu.neatActions[item];
					const itemName = item.ln;
					const itemCondition = item.condition;
					const iconsStyle = item.icon === "a" ? `` : ` style="font-family:&quot;pictos custom&quot;, pictos"`;
					const itemIcon = item.icon ? `<span class="pictos ctx__layer-icon"${iconsStyle}>${item.icon}</span> ` : ``;
					const itemActive = item.active ? ` class='<$ if(${item.active}) { $>active<$ } $>'` : ``;
					const conditionStatement = itemCondition ? `if (${itemCondition})` : ``;
					if (itemCondition && (menuConditions.at(-1) !== itemCondition)) menuConditions.push(itemCondition);
					if (itemAction === "unlock-token") itemAction = "lock-token";
					menuItems += `\n\t\t<$ ${conditionStatement} { $><li data-action-type='${itemAction}'${itemActive}>${itemIcon}${itemName}</li><$ } $>`;
				}
			})
			templ += `<$ if ((${menuConditions.join(") || (")})) { $><li class='head hasSub' ${menuName}>\n\t${menuData.ln}&nbsp;&raquo;
			<ul class='submenu' ${menuName}>${menuItems}\n\t</ul>\n</li><$ } $>\n`;
		});
		return `
		<script id='tmpl_actions_menu' type='text/html'>
		<div class='actions_menu d20contextmenu'>
		  <ul>
		  	${templ}
			${d20plus.menu._pushQuickMenus()}
		  </ul>
		  </div>
		</script>
		`;
	};

	addConfigOptions("canvas", {
		"_name": __("cfg_tab_canvas"),
		"_player": true,
		"enableQuickMenuItems": {
			"name": __("cfg_option_quick_menu"),
			"default": true,
			"_type": "boolean",
		},
		"quickMenuItem2": {
			"name": __("cfg_option_quick_2"),
			"default": "back-one",
			"_type": "_enum",
			"__values": Object.keys(d20plus.menu.neatActions),
		},
		"quickMenuItem3": {
			"name": __("cfg_option_quick_3"),
			"default": "rollsaves",
			"_type": "_enum",
			"__values": Object.keys(d20plus.menu.neatActions),
		},
	});
}

SCRIPT_EXTENSIONS.push(baseMenu);


function baseWeather () {
	d20plus.weather = {};

	d20plus.weather.props = {
		"weatherType1": "None",
		"weatherTypeCustom1": "",
		"weatherSpeed1": "0.4",
		"weatherDir1": "Northerly",
		"weatherDirCustom1": "180",
		"weatherOpacity1": "0.5",
		"weatherOscillate1": false,
		"weatherOscillateThreshold1": "0.5",
		"weatherIntensity1": "Normal",
		"weatherTint1": false,
		"weatherTintColor1": "#4c566d",
		"weatherTintOpacity1": "0.5",
		"weatherEffect1": "None",
	};

	d20plus.weather.addWeather = () => {
		window.force = false; // missing variable in Roll20's code(?); define it here

		d20plus.ut.log("Adding weather");

		const MAX_ZOOM = 2.5; // max canvas zoom
		const tmp = []; // temp vector
		// cache images
		const IMAGES = {
			"Rain": new Image(),
			"Snow": new Image(),
			"Fog": new Image(),
			"Waves": new Image(),
			"Ripples": new Image(),
			"Blood Rain": new Image(),
		};
		IMAGES.Rain.src = "https://i.imgur.com/lZrqiVk.png";
		IMAGES.Snow.src = "https://i.imgur.com/uwLQjWY.png";
		IMAGES.Fog.src = "https://i.imgur.com/SRsUpHW.png";
		IMAGES.Waves.src = "https://i.imgur.com/iYEzmvB.png";
		IMAGES.Ripples.src = "https://i.imgur.com/fFCr0yx.png";
		IMAGES["Blood Rain"].src = "https://i.imgur.com/SP2aoeq.png";
		const SFX = {
			lightning: [],
		};

		// FIXME find a better way of handling this; `clip` is super-slow
		const clipMode = "EXCLUDE";

		function SfxLightning () {
			this.brightness = 255;
		}

		const $wrpEditor = $("#editor-wrapper");

		// add custom canvas
		const $wrpCanvas = $wrpEditor.find(".canvas-container");

		// make buffer canvas
		const $canBuf = $("<canvas style='position: absolute; z-index: -100; left:0; top: 0; pointer-events: none;' tabindex='-1'/>").appendTo($wrpCanvas);
		const cvBuf = $canBuf[0];
		const ctxBuf = cvBuf.getContext("2d");

		// make weather canvas
		const $canvasWeather = $("<canvas id='Vet-canvas-weather' style='position: absolute; z-index: 2; left:0; top: 0; pointer-events: none;' tabindex='-1'/>").appendTo($wrpCanvas);
		const cv = $canvasWeather[0];
		d20.engine.weathercanvas = cv;

		// add our canvas to those adjusted when canvas size changes
		const cachedSetCanvasSize = d20.engine.setCanvasSize;
		d20.engine.setCanvasSize = function (e, n) {
			cv.width = e;
			cv.height = n;

			cvBuf.width = e;
			cvBuf.height = n;

			cachedSetCanvasSize(e, n);
		};

		cv.width = cvBuf.width = d20.engine.canvas.width;
		cv.height = cvBuf.height = d20.engine.canvas.height;

		const ctx = cv.getContext("2d");

		const CTX = {
			_hasWarned: new Set(),
		};// RB20 EXCLUDE START

		const varyingWeather = (() => {
			const speed = {};
			speed.val = {};
			speed.increment = 0.001;
			speed.interval = 1000;

			speed.get = (page) => {
				if (!speed.val.current) speed._init(page);
				if (speed.wait === 0) {
					if (speed.val.current !== speed.val.next) {
						speed.increment = speed.val.current > speed.val.next ? -Math.abs(speed.increment) : Math.abs(speed.increment);
						speed.val.current = speed._round(speed.val.current + speed.increment, 3);
						d20plus.ut.log("Changing to", speed.val.next);
					} else {
						speed.wait = speed.interval;
						speed.val.next = speed._next();
						d20plus.ut.log("Next change to", speed.val.next, "now", speed.val.current);
					}
				} else --speed.wait;
				return speed.val.current;
			};
			speed._next = () => {
				const delta = speed.val.to - speed.val.from;
				return speed._round(speed.val.from + delta * Math.random(), 2);
			};
			speed._round = (val, decimal) => {
				const multiplier = Math.pow(10, decimal);
				return Math.round(multiplier * val) / multiplier;
			}
			speed._init = (page) => {
				speed.val.from = 0.2;
				speed.val.to = 0.6;
				speed.val.current = (speed.val.from + speed.val.to) / 2;
				speed.wait = speed.interval;
				speed.val.next = speed._next();
			};
			return speed;
		})();// RB20 EXCLUDE END

		function ofX (x) { // offset X
			return x - d20.engine.currentCanvasOffset[0];
		}

		function ofY (y) { // offset Y
			return y - d20.engine.currentCanvasOffset[1];
		}

		function lineIntersectsBounds (points, bounds) {
			return d20plus.math.doPolygonsIntersect([points[0], points[2], points[3], points[1]], bounds);
		}

		function copyPoints (toCopy) {
			return [...toCopy.map(pt => [...pt])];
		}

		function getImage (page) {
			const imageName = page.get("bR20cfg_weatherType1");

			switch (imageName) {
				case "Rain":
				case "Snow":
				case "Fog":
				case "Waves":
				case "Ripples":
				case "Blood Rain":
					IMAGES["Custom"] = null;
					return IMAGES[imageName];
				case "Custom (see below)":
					if (!IMAGES["Custom"] || (
						(IMAGES["Custom"].src !== page.get("bR20cfg_weatherTypeCustom1") && IMAGES["Custom"]._errorSrc == null)
						|| (IMAGES["Custom"]._errorSrc != null && IMAGES["Custom"]._errorSrc !== page.get("bR20cfg_weatherTypeCustom1")))
					) {
						IMAGES["Custom"] = new Image();
						IMAGES["Custom"]._errorSrc = null;
						IMAGES["Custom"].onerror = () => {
							if (IMAGES["Custom"]._errorSrc == null) {
								IMAGES["Custom"]._errorSrc = page.get("bR20cfg_weatherTypeCustom1");
								alert(`Custom weather image "${IMAGES["Custom"].src}" failed to load!`);
							}
							IMAGES["Custom"].src = IMAGES["Rain"].src;
						};
						IMAGES["Custom"].src = page.get("bR20cfg_weatherTypeCustom1");
					}
					return IMAGES["Custom"];
				default:
					IMAGES["Custom"] = null;
					return null;
			}
		}

		function getDirectionRotation (page) {
			const dir = page.get("bR20cfg_weatherDir1") || d20plus.weather.props.weatherDir1;
			switch (dir) {
				case "Northerly": return 0.25 * Math.PI;
				case "North-Easterly": return 0.5 * Math.PI;
				case "Easterly": return 0.75 * Math.PI;
				case "South-Easterly": return Math.PI;
				case "Southerly": return 1.25 * Math.PI;
				case "South-Westerly": return 1.5 * Math.PI;
				case "Westerly": return 1.75 * Math.PI;
				case "North-Westerly": return 0;
				case "Custom (see below)":
					return Number(page.get("bR20cfg_weatherDirCustom1") || d20plus.weather.props.weatherDirCustom1) * Math.PI / 180;
				default: return 0;
			}
		}

		function getOpacity (page) {
			return page.get("bR20cfg_weatherOpacity1") || d20plus.weather.props.weatherOpacity1;
		}

		let oscillateMode = null;
		function isOscillating (page) {
			return !!page.get("bR20cfg_weatherOscillate1");
		}

		function getOscillationThresholdFactor (page) {
			return page.get("bR20cfg_weatherOscillateThreshold1") || d20plus.weather.props.weatherOscillateThreshold1;
		}

		function getIntensity (page) {
			const tint = page.get("bR20cfg_weatherIntensity1");
			switch (tint) {
				case "Heavy": return 1;
				default: return 0;
			}
		}

		function getTintColor (page) {
			const tintEnabled = page.get("bR20cfg_weatherTint1");
			if (tintEnabled) {
				const tintOpacity = page.get("bR20cfg_weatherTintOpacity1") || d20plus.weather.props.weatherTintOpacity1;
				const tintOpacityHex = tintOpacity ? Math.round(255 * tintOpacity).toString(16) : 80;
				return `${(page.get("bR20cfg_weatherTintColor1") || d20plus.weather.props.weatherTintColor1)}${tintOpacityHex}`;
			} else return null;
		}

		function getEffect (page) {
			const effect = page.get("bR20cfg_weatherEffect1");
			switch (effect) {
				case "Lightning": return "lightning";
				default: return null;
			}
		}

		function handleSvgCoord (coords, obj, basesXY, center, angle) {
			const vec = [
				ofX(coords[0] * obj.scaleX) + basesXY[0],
				ofY(coords[1] * obj.scaleY) + basesXY[1],
			];
			d20plus.math.vec2.scale(vec, vec, d20.engine.canvasZoom);
			if (angle) d20plus.math.vec2.rotate(vec, vec, center, angle);
			return vec;
		}

		let accum = 0;
		let then = 0;
		let image;
		let currentSfx;
		let hasWeather = false;
		function drawFrame (now) {
			const deltaTime = now - then;
			then = now;

			const page = d20 && d20.Campaign && d20.Campaign.activePage ? d20.Campaign.activePage() : null;
			if (page && page.get("bR20cfg_weatherType1") !== "None") {
				image = getImage(page);
				currentSfx = getEffect(page);

				// generate SFX
				if (currentSfx) {
					if (currentSfx === "lightning" && Math.random() > 0.999) SFX.lightning.push(new SfxLightning());
				} else {
					SFX.lightning = [];
				}

				if (hasWeather) ctx.clearRect(0, 0, cv.width, cv.height);
				const hasImage = image && image.complete;
				const tint = getTintColor(page);
				const scaledW = hasImage ? Math.ceil((image.width * d20.engine.canvasZoom) / MAX_ZOOM) : -1;
				const scaledH = hasImage ? Math.ceil((image.height * d20.engine.canvasZoom) / MAX_ZOOM) : -1;
				const hasSfx = SFX.lightning.length;
				if (hasImage || tint || hasSfx) {
					hasWeather = true;

					// draw weather
					if (
						hasImage
						&& !(scaledW <= 0 || scaledH <= 0) // sanity check
					) {
						// mask weather
						const doMaskStep = () => {
							ctxBuf.clearRect(0, 0, cvBuf.width, cvBuf.height);

							ctxBuf.fillStyle = "#ffffffff";

							const objectLen = d20.engine.canvas._objects.length;
							for (let i = 0; i < objectLen; ++i) {
								const obj = d20.engine.canvas._objects[i];
								if (obj.type === "path" && obj.model && obj.model.get("layer") === "weather") {
									// obj.top is X pos of center of object
									// obj.left is Y pos of center of object
									const xBase = (obj.left - (obj.width * obj.scaleX / 2));
									const yBase = (obj.top - (obj.height * obj.scaleY / 2));
									const basesXY = [xBase, yBase];
									const angle = (obj.angle > 360 ? obj.angle - 360 : obj.angle) / 180 * Math.PI;
									const center = [ofX(obj.left), ofY(obj.top)];
									d20plus.math.vec2.scale(center, center, d20.engine.canvasZoom);

									ctxBuf.beginPath();
									obj.path.forEach(opp => {
										const [op, x, y, ...others] = opp;
										switch (op) {
											case "M": {
												const vec = handleSvgCoord([x, y], obj, basesXY, center, angle);
												ctxBuf.moveTo(vec[0], vec[1]);
												break;
											}
											case "L": {
												const vec = handleSvgCoord([x, y], obj, basesXY, center, angle);
												ctxBuf.lineTo(vec[0], vec[1]);
												break;
											}
											case "C": {
												const control1 = handleSvgCoord([x, y], obj, basesXY, center, angle);
												const control2 = handleSvgCoord([others[0], others[1]], obj, basesXY, center, angle);
												const end = handleSvgCoord([others[2], others[3]], obj, basesXY, center, angle);
												ctxBuf.bezierCurveTo(...control1, ...control2, ...end);
												break;
											}
											default:
												if (!CTX._hasWarned.has(op)) {
													CTX._hasWarned.add(op);
													// eslint-disable-next-line no-console
													console.error(`UNHANDLED OP!: ${op}`);
												}
										}
									});
									ctxBuf.fill();
									ctxBuf.closePath();
								}
							}

							// draw final weather mask
							/// / change drawing mode
							ctx.globalCompositeOperation = "destination-out";
							ctx.drawImage(cvBuf, 0, 0);

							// handle opacity
							const opacity = Number(getOpacity(page));
							if (opacity !== 1) {
								ctxBuf.clearRect(0, 0, cvBuf.width, cvBuf.height);
								ctxBuf.fillStyle = `#ffffff${Math.round((1 - opacity) * 255).toString(16)}`;
								ctxBuf.fillRect(0, 0, cvBuf.width, cvBuf.height);
								ctx.drawImage(cvBuf, 0, 0);
							}

							/// / reset drawing mode
							ctx.globalCompositeOperation = "source-over";
						};

						// if (clipMode === "INCLUDE") doMaskStep(true);

						const speed = page.get("bR20cfg_weatherSpeed1") || d20plus.weather.props.weatherSpeed1;
						const speedFactor = speed * d20.engine.canvasZoom;
						const maxAccum = Math.floor(scaledW / speedFactor);
						const rot = getDirectionRotation(page);
						const w = scaledW;
						const h = scaledH;
						const boundingBox = [
							[
								-1.5 * w,
								-1.5 * h,
							],
							[
								-1.5 * w,
								cv.height + (1.5 * h) + d20.engine.currentCanvasOffset[1],
							],
							[
								cv.width + (1.5 * w) + d20.engine.currentCanvasOffset[0],
								cv.height + (1.5 * h) + d20.engine.currentCanvasOffset[1],
							],
							[
								cv.width + (1.5 * w) + d20.engine.currentCanvasOffset[0],
								-1.5 * h,
							],
						];
						const BASE_OFFSET_X = -w / 2;
						const BASE_OFFSET_Y = -h / 2;

						// calculate resultant points of a rotated shape
						const pt00 = [0, 0];
						const pt01 = [0, 1];
						const pt10 = [1, 0];
						const pt11 = [1, 1];
						const basePts = [
							pt00,
							pt01,
							pt10,
							pt11,
						].map(pt => [
							(pt[0] * w) + BASE_OFFSET_X - d20.engine.currentCanvasOffset[0],
							(pt[1] * h) + BASE_OFFSET_Y - d20.engine.currentCanvasOffset[1],
						]);
						basePts.forEach(pt => d20plus.math.vec2.rotate(pt, pt, [0, 0], rot));

						// calculate animation values
						(() => {
							if (isOscillating(page)) {
								const oscThreshFactor = getOscillationThresholdFactor(page);

								if (oscillateMode == null) {
									oscillateMode = 1;
									accum += deltaTime;
									if (accum >= maxAccum * oscThreshFactor) accum -= maxAccum;
								} else {
									if (oscillateMode === 1) {
										accum += deltaTime;
										if (accum >= maxAccum * oscThreshFactor) {
											accum -= 2 * deltaTime;
											oscillateMode = -1;
										}
									} else {
										accum -= deltaTime;
										if (accum <= 0) {
											oscillateMode = 1;
											accum += 2 * deltaTime;
										}
									}
								}
							} else {
								oscillateMode = null;
								accum += deltaTime;
								if (accum >= maxAccum) accum -= maxAccum;
							}
						})();

						const intensity = getIntensity(page) * speedFactor;
						const timeOffsetX = Math.ceil(speedFactor * accum);
						const timeOffsetY = Math.ceil(speedFactor * accum);

						/// / rotate coord space
						ctx.rotate(rot);

						// draw base image
						const doDraw = (offsetX, offsetY) => {
							const xPos = BASE_OFFSET_X + timeOffsetX + offsetX - d20.engine.currentCanvasOffset[0];
							const yPos = BASE_OFFSET_Y + timeOffsetY + offsetY - d20.engine.currentCanvasOffset[1];
							ctx.drawImage(
								image,
								xPos,
								yPos,
								w,
								h,
							);

							if (intensity) {
								const offsetIntensity = -Math.floor(w / 4);
								ctx.drawImage(
									image,
									xPos + offsetIntensity,
									yPos + offsetIntensity,
									w,
									h,
								);
							}
						}

						const inBounds = (nextPts) => {
							return lineIntersectsBounds(nextPts, boundingBox);
						}

						const moveXDir = (pt, i, isAdd) => {
							if (i % 2) d20plus.math.vec2.sub(tmp, basePts[3], basePts[1]);
							else d20plus.math.vec2.sub(tmp, basePts[2], basePts[0]);

							if (isAdd) d20plus.math.vec2.add(pt, pt, tmp);
							else d20plus.math.vec2.sub(pt, pt, tmp);
						}

						const moveYDir = (pt, i, isAdd) => {
							if (i > 1) d20plus.math.vec2.sub(tmp, basePts[3], basePts[2]);
							else d20plus.math.vec2.sub(tmp, basePts[1], basePts[0]);

							if (isAdd) d20plus.math.vec2.add(pt, pt, tmp);
							else d20plus.math.vec2.sub(pt, pt, tmp);
						}

						const getMaxMoves = () => {
							const hyp = [];
							d20plus.math.vec2.sub(hyp, boundingBox[2], boundingBox[0]);

							const dist = d20plus.math.vec2.len(hyp);
							const maxMoves = dist / Math.min(w, h);
							return [Math.abs(hyp[0]) > Math.abs(hyp[1]) ? "x" : "y", maxMoves];
						};

						const handleXAxisYIncrease = (nxtPts, maxMoves, moves, xDir) => {
							const handleY = (dir) => {
								let subNxtPts, subMoves;
								subNxtPts = copyPoints(nxtPts);
								subMoves = 0;
								while (subMoves <= maxMoves[1]) {
									subNxtPts.forEach((pt, i) => moveYDir(pt, i, dir > 0));
									subMoves++;
									if (inBounds(subNxtPts)) doDraw(xDir * moves * w, dir * (subMoves * h));
								}
							};

							handleY(1); // y axis increasing
							handleY(-1); // y axis decreasing
						};

						const handleYAxisXIncrease = (nxtPts, maxMoves, moves, yDir) => {
							const handleX = (dir) => {
								let subNxtPts, subMoves;
								subNxtPts = copyPoints(nxtPts);
								subMoves = 0;
								while (subMoves <= maxMoves[1]) {
									subNxtPts.forEach((pt, i) => moveXDir(pt, i, dir > 0));
									subMoves++;
									if (lineIntersectsBounds(subNxtPts, boundingBox)) doDraw(dir * (subMoves * w), yDir * moves * h);
								}
							};

							handleX(1); // x axis increasing
							handleX(-1); // x axis decreasing
						};

						const handleBasicX = (maxMoves) => {
							const handleX = (dir) => {
								let nxtPts, moves;
								nxtPts = copyPoints(basePts);
								moves = 0;
								while (moves < maxMoves) {
									nxtPts.forEach((pt, i) => moveXDir(pt, i, dir > 0));
									moves++;
									if (lineIntersectsBounds(nxtPts, boundingBox)) doDraw(dir * (moves * w), 0);
								}
							};

							handleX(1); // x axis increasing
							handleX(-1); // x axis decreasing
						};

						const handleBasicY = (maxMoves) => {
							const handleY = (dir) => {
								let nxtPts, moves;
								nxtPts = copyPoints(basePts);
								moves = 0;
								while (moves < maxMoves) {
									nxtPts.forEach((pt, i) => moveYDir(pt, i, dir > 0));
									moves++;
									if (lineIntersectsBounds(nxtPts, boundingBox)) doDraw(0, dir * (moves * h));
								}
							};

							handleY(1); // y axis increasing
							handleY(-1); // y axis decreasing
						};

						doDraw(0, 0);

						(() => {
							// choose largest axis
							const maxMoves = getMaxMoves();

							if (maxMoves[0] === "x") {
								const handleX = (dir) => {
									let nxtPts, moves;
									nxtPts = copyPoints(basePts);
									moves = 0;
									while (moves < maxMoves[1]) {
										nxtPts.forEach((pt, i) => moveXDir(pt, i, dir > 0));
										moves++;
										if (lineIntersectsBounds(nxtPts, boundingBox)) doDraw(dir * (moves * w), 0);
										handleXAxisYIncrease(nxtPts, maxMoves, moves, dir);
									}
								};

								handleBasicY(maxMoves[1]);
								handleX(1); // x axis increasing
								handleX(-1); // x axis decreasing
							} else {
								const handleY = (dir) => {
									let nxtPts, moves;
									nxtPts = copyPoints(basePts);
									moves = 0;
									while (moves < maxMoves[1]) {
										nxtPts.forEach((pt, i) => moveYDir(pt, i, dir > 0));
										moves++;
										if (lineIntersectsBounds(nxtPts, boundingBox)) doDraw(0, dir * (moves * h));
										handleYAxisXIncrease(nxtPts, maxMoves, moves, dir);
									}
								};

								handleBasicX(maxMoves[1]);
								handleY(1); // y axis increasing
								handleY(-1); // y axis decreasing
							}
						})();

						/// / revert coord space rotation
						ctx.rotate(-rot);

						if (clipMode === "EXCLUDE") doMaskStep(false);
					}

					// draw sfx
					if (hasSfx) {
						for (let i = SFX.lightning.length - 1; i >= 0; --i) {
							const l = SFX.lightning[i];
							if (l.brightness <= 5) {
								SFX.lightning.splice(i, 1);
							} else {
								ctx.fillStyle = `#effbff${l.brightness.toString(16).padStart(2, "0")}`;
								ctx.fillRect(0, 0, cv.width, cv.height);
								l.brightness -= Math.floor(deltaTime);
							}
						}
					}

					// draw tint
					if (tint) {
						ctx.fillStyle = tint;
						ctx.fillRect(0, 0, cv.width, cv.height);
					}
				}

				requestAnimationFrame(drawFrame);
			} else {
				// if weather is disabled, maintain a background tick
				if (hasWeather) {
					ctx.clearRect(0, 0, cv.width, cv.height);
					hasWeather = false;
				}
				setTimeout(() => {
					drawFrame(0);
				}, 1000);
			}
		}

		requestAnimationFrame(drawFrame);
	};
}

SCRIPT_EXTENSIONS.push(baseWeather);


function baseViews () {
	d20plus.views = {};

	d20plus.views.props = {
		"viewsEnable": false,
		"views0Name": "",
		"views1Enable": false,
		"views1Exclusive": false,
		"views1Name": "",
		"views2Enable": false,
		"views2Exclusive": false,
		"views2Name": "",
		"views3Enable": false,
		"views3Exclusive": false,
		"views3Name": "",
	};

	d20plus.views._initMenuActions = () => {
		$(`body`).on("click", ".chooseViews > li", function () {
			const page = d20.Campaign.activePage();
			const items = $(".chooseViews > li")
			const id = items.index(this);
			const startgroupindex = (() => { for (let i = id; i >= 0; i--) { if (!page.get(`bR20cfg_views${i}Exclusive`)) return i; } })();
			const endgroupindex = (() => { for (let i = id + 1; i <= 5; i++) { if (!page.get(`bR20cfg_views${i}Exclusive`)) return i - 1; } })();
			if (page.get(`bR20cfg_views${id}Off`)) {
				d20plus.views.changeViewState(id, true);
				for (let i = startgroupindex; i <= endgroupindex; i++) {
					if (i !== id) d20plus.views.changeViewState(i, false);
				}
			} else {
				d20plus.views.changeViewState(id, false);
			}
		});
	}

	d20plus.views._initViewsCss = () => {
		d20plus.ut.dynamicStyles("viewsSelect").html(`
			.ui-dialog label.half {display: inline-block; margin-bottom: 6px;}
			.ui-dialog label.half span {margin-right: 20px;}
			#floatingtoolbar ul.chooseViews li {border-width: 1px;border-style: solid; border-color: var(--dark-surface1);}
			#floatingtoolbar ul.chooseViews:empty {display:none;}
			#floatingtoolbar ul.chooseViews li {height: 19px; border-radius: 12px;}
			#floatingtoolbar ul.chooseViews li.fst {border-bottom-left-radius: 0px; border-bottom-right-radius: 0px; border-bottom-width: 0px;}
			#floatingtoolbar ul.chooseViews li.lst {border-top-left-radius: 0px; border-top-right-radius: 0px; border-top-width: 0px;}
			#floatingtoolbar ul.chooseViews li.mst {border-radius: 0px; border-top: 0px; border-bottom: 0px;}
			#floatingtoolbar ul.chooseViews .pictos {padding: 0 3px 0 3px;}
			#floatingtoolbar ul.chooseViews .view_toggle {padding: 4px 8px 3px 4px; margin-right: 8px; border-right: 1px solid; border-color: inherit;}
			#floatingtoolbar ul.chooseViews li.off .view_toggle .pictos {color: #fff0;}
		`);
	}

	d20plus.views._initLayerMenu = () => {
		d20plus.views.layerMenu = $(`<ul class="chooseViews"></ul>`).appendTo($("#editinglayer .submenu"));
	}

	d20plus.views.populateMenu = () => {
		const page = d20.Campaign.activePage();
		if (!page) return;
		if (!page.get("bR20cfg_viewsEnable")) return d20plus.views.layerMenu.html("");
		let menuhtml = "";
		for (let id = 0; id <= 4; id++) {
			if (id && !page.get(`bR20cfg_views${id}Enable`)) continue;
			const viewname = page.get(`bR20cfg_views${id}Name`) || (id ? `View ${id}` : `Default view`);
			const viewicon = page.get(`bR20cfg_views${id}Icon`) || "P";
			const exclCheck = (id) => { return page.get(`bR20cfg_views${id}Exclusive`) };
			const viewexcl = exclCheck(id) ? (exclCheck(id + 1) ? "mst" : "lst") : (exclCheck(id + 1) ? "fst" : "");
			const viewactive = page.get(`bR20cfg_views${id}Off`) ? "off" : "";
			menuhtml += `<li class="${[viewexcl, viewactive].join(" ")}">
				<span class="view_toggle"><span class="pictos">E</span></span>
				<span class="pictos">${viewicon}</span>
				${viewname}
			</li>`;
		}
		d20plus.views.layerMenu.html(menuhtml);
	}

	d20plus.views.changeViewState = (id, state) => {
		const page = d20.Campaign.activePage();
		const menuItem = $(".chooseViews > li").get(id);
		if (state) {
			$(menuItem).removeClass("off");
			page.set(`bR20cfg_views${id}Off`, false);
			d20plus.engine.objectsHideUnhide(`bR20_view${id}`, true, `view${id}off`, true);
		} else {
			$(menuItem).addClass("off");
			page.set(`bR20cfg_views${id}Off`, true);
			d20plus.engine.objectsHideUnhide(`bR20_view${id}`, true, `view${id}off`, false);
		}
		page.save();
		$(`#editinglayer .choose${window.currentEditingLayer}`).click();
	}

	d20plus.views.checkPageSettings = () => {
		if (!d20.Campaign.activePage() || !d20.Campaign.activePage().get) {
			setTimeout(d20plus.views.checkPageSettings, 50);
		} else {
			d20plus.engine.layersVisibilityCheck();
			d20plus.views.populateMenu();
		}
	}

	d20plus.views.addViews = () => {
		if (window.is_gm) {
			d20plus.views._initViewsCss();
			d20plus.views._initLayerMenu();
			d20plus.views._initMenuActions();
			document.addEventListener("VePageChange", d20plus.views.checkPageSettings);
			d20plus.views.checkPageSettings();
		}
	}
}

SCRIPT_EXTENSIONS.push(baseViews);

function d20plusJournal () {
	d20plus.journal = {};

	d20plus.journal.lastClickedFolderId = null;

	d20plus.journal.addJournalCommands = () => {
		// Create new Journal commands
		// stash the folder ID of the last folder clicked
		$("#journalfolderroot").on("contextmenu", ".dd-content", function (e) {
			if ($(this).parent().hasClass("dd-folder")) {
				const lastClicked = $(this).parent();
				d20plus.journal.lastClickedFolderId = lastClicked.attr("data-globalfolderid");
			}

			if ($(this).parent().hasClass("character")) {
				$(`.Vetools-make-tokenactions`).show();
			} else {
				$(`.Vetools-make-tokenactions`).hide();
			}
		});

		let first = $("#journalitemmenu ul li").first();
		// "Make Tokenactions" option
		first.after(`<li class="Vetools-make-tokenactions" data-action-type="additem">Make Tokenactions</li>`);
		$("#journalitemmenu ul").on(window.mousedowntype, "li[data-action-type=additem]", function () {
			let id = $currentItemTarget.attr("data-itemid");
			let character = d20.Campaign.characters.get(id);
			d20plus.ut.log("Making Token Actions..");
			if (character) {
				let npc = character.attribs.find(function (a) {
					return a.get("name").toLowerCase() === "npc";
				});
				let isNPC = npc ? parseInt(npc.get("current")) : 0;
				if (isNPC) {
					// Npc specific tokenactions
					character.abilities.create({
						name: "Perception",
						istokenaction: true,
						action: d20plus.macro.actionMacroPerception,
					});
					character.abilities.create({
						name: "DR/Immunities",
						istokenaction: true,
						action: d20plus.macro.actionMacroDrImmunities,
					});
					character.abilities.create({
						name: "Stats",
						istokenaction: true,
						action: d20plus.macro.actionMacroStats,
					});
					character.abilities.create({
						name: "Saves",
						istokenaction: true,
						action: d20plus.macro.actionMacroSaves,
					});
					character.abilities.create({
						name: "Skill-Check",
						istokenaction: true,
						action: d20plus.macro.actionMacroSkillCheck,
					});
					character.abilities.create({
						name: "Ability-Check",
						istokenaction: true,
						action: d20plus.macro.actionMacroAbilityCheck,
					});
				} else {
					// player specific tokenactions
					// @{selected|repeating_attack_$0_atkname}
					character.abilities.create({
						name: "Attack 1",
						istokenaction: true,
						action: "%{selected|repeating_attack_$0_attack}",
					});
					character.abilities.create({
						name: "Attack 2",
						istokenaction: true,
						action: "%{selected|repeating_attack_$1_attack}",
					});
					character.abilities.create({
						name: "Attack 3",
						istokenaction: true,
						action: "%{selected|repeating_attack_$2_attack}",
					});
					character.abilities.create({
						name: "Tool 1",
						istokenaction: true,
						action: "%{selected|repeating_tool_$0_tool}",
					});
					// " + character.get("name") + "
					character.abilities.create({
						name: "Whisper GM",
						istokenaction: true,
						action: "/w gm ?{Message to whisper the GM?}",
					});
					character.abilities.create({
						name: "Favorite Spells",
						istokenaction: true,
						action: "/w @{character_name} &{template:npcaction} {{rname=Favorite Spells}} {{description=Favorite Spells are the first spells in each level of your spellbook.\n\r[Cantrip](~selected|repeating_spell-cantrip_$0_spell)\n[1st Level](~selected|repeating_spell-1_$0_spell)\n\r[2nd Level](~selected|repeating_spell-2_$0_spell)\n\r[3rd Level](~selected|repeating_spell-3_$0_spell)\n\r[4th Level](~selected|repeating_spell-4_$0_spell)\n\r[5th Level](~selected|repeating_spell-5_$0_spell)}}",
					});
					character.abilities.create({
						name: "Dual Attack",
						istokenaction: false,
						action: "%{selected|repeating_attack_$0_attack}\n\r%{selected|repeating_attack_$0_attack}",
					});
					character.abilities.create({
						name: "Saves",
						istokenaction: true,
						action: "@{selected|wtype}&{template:simple} @{selected|rtype}?{Save|Strength, +@{selected|strength_save_bonus}@{selected|pbd_safe}]]&#125;&#125; {{rname=Strength Save&#125;&#125 {{mod=@{selected|strength_save_bonus}&#125;&#125; {{r1=[[@{selected|d20}+@{selected|strength_save_bonus}@{selected|pbd_safe}]]&#125;&#125; |Dexterity, +@{selected|dexterity_save_bonus}@{selected|pbd_safe}]]&#125;&#125; {{rname=Dexterity Save&#125;&#125 {{mod=@{selected|dexterity_save_bonus}&#125;&#125; {{r1=[[@{selected|d20}+@{selected|dexterity_save_bonus}@{selected|pbd_safe}]]&#125;&#125; |Constitution, +@{selected|constitution_save_bonus}@{selected|pbd_safe}]]&#125;&#125; {{rname=Constitution Save&#125;&#125 {{mod=@{selected|constitution_save_bonus}&#125;&#125; {{r1=[[@{selected|d20}+@{selected|constitution_save_bonus}@{selected|pbd_safe}]]&#125;&#125; |Intelligence, +@{selected|intelligence_save_bonus}@{selected|pbd_safe}]]&#125;&#125; {{rname=Intelligence Save&#125;&#125 {{mod=@{selected|intelligence_save_bonus}&#125;&#125; {{r1=[[@{selected|d20}+@{selected|intelligence_save_bonus}@{selected|pbd_safe}]]&#125;&#125; |Wisdom, +@{selected|wisdom_save_bonus}@{selected|pbd_safe}]]&#125;&#125; {{rname=Wisdom Save&#125;&#125 {{mod=@{selected|wisdom_save_bonus}&#125;&#125; {{r1=[[@{selected|d20}+@{selected|wisdom_save_bonus}@{selected|pbd_safe}]]&#125;&#125; |Charisma, +@{selected|charisma_save_bonus}@{selected|pbd_safe}]]&#125;&#125; {{rname=Charisma Save&#125;&#125 {{mod=@{selected|charisma_save_bonus}&#125;&#125; {{r1=[[@{selected|d20}+@{selected|charisma_save_bonus}@{selected|pbd_safe}]]&#125;&#125;}@{selected|global_save_mod}@{selected|charname_output",
					});
					character.abilities.create({
						name: "Skill-Check",
						istokenaction: true,
						action: "@{selected|wtype}&{template:simple} @{selected|rtype}?{Ability|Acrobatics, +@{selected|acrobatics_bonus}@{selected|pbd_safe} ]]&#125;&#125; {{rname=Acrobatics&#125;&#125; {{mod=@{selected|acrobatics_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|acrobatics_bonus}@{selected|pbd_safe} ]]&#125;&#125; |Animal Handling, +@{selected|animal_handling_bonus}@{selected|pbd_safe} ]]&#125;&#125; {{rname=Animal Handling&#125;&#125; {{mod=@{selected|animal_handling_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|animal_handling_bonus}@{selected|pbd_safe} ]]&#125;&#125; |Arcana, +@{selected|arcana_bonus}@{selected|pbd_safe} ]]&#125;&#125; {{rname=Arcana&#125;&#125; {{mod=@{selected|arcana_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|arcana_bonus}@{selected|pbd_safe} ]]&#125;&#125; |Athletics, +@{selected|athletics_bonus}@{selected|pbd_safe} ]]&#125;&#125; {{rname=Athletics&#125;&#125; {{mod=@{selected|athletics_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|athletics_bonus}@{selected|pbd_safe} ]]&#125;&#125; |Deception, +@{selected|deception_bonus}@{selected|pbd_safe} ]]&#125;&#125; {{rname=Deception&#125;&#125; {{mod=@{selected|deception_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|deception_bonus}@{selected|pbd_safe} ]]&#125;&#125; |History, +@{selected|history_bonus}@{selected|pbd_safe} ]]&#125;&#125; {{rname=History&#125;&#125; {{mod=@{selected|history_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|history_bonus}@{selected|pbd_safe} ]]&#125;&#125; |Insight, +@{selected|insight_bonus}@{selected|pbd_safe} ]]&#125;&#125; {{rname=Insight&#125;&#125; {{mod=@{selected|insight_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|insight_bonus}@{selected|pbd_safe} ]]&#125;&#125; |Intimidation, +@{selected|intimidation_bonus}@{selected|pbd_safe} ]]&#125;&#125; {{rname=Intimidation&#125;&#125; {{mod=@{selected|intimidation_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|intimidation_bonus}@{selected|pbd_safe} ]]&#125;&#125; |Investigation, +@{selected|investigation_bonus}@{selected|pbd_safe} ]]&#125;&#125; {{rname=Investigation&#125;&#125; {{mod=@{selected|investigation_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|investigation_bonus}@{selected|pbd_safe} ]]&#125;&#125; |Medicine, +@{selected|medicine_bonus}@{selected|pbd_safe} ]]&#125;&#125; {{rname=Medicine&#125;&#125; {{mod=@{selected|medicine_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|medicine_bonus}@{selected|pbd_safe} ]]&#125;&#125; |Nature, +@{selected|nature_bonus}@{selected|pbd_safe} ]]&#125;&#125; {{rname=Nature&#125;&#125; {{mod=@{selected|nature_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|nature_bonus}@{selected|pbd_safe} ]]&#125;&#125; |Perception, +@{selected|perception_bonus}@{selected|pbd_safe} ]]&#125;&#125; {{rname=Perception&#125;&#125; {{mod=@{selected|perception_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|perception_bonus}@{selected|pbd_safe} ]]&#125;&#125; |Performance, +@{selected|performance_bonus}@{selected|pbd_safe} ]]&#125;&#125; {{rname=Performance&#125;&#125; {{mod=@{selected|performance_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|performance_bonus}@{selected|pbd_safe} ]]&#125;&#125; |Persuasion, +@{selected|persuasion_bonus}@{selected|pbd_safe} ]]&#125;&#125; {{rname=Persuasion&#125;&#125; {{mod=@{selected|persuasion_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|persuasion_bonus}@{selected|pbd_safe} ]]&#125;&#125; |Religion, +@{selected|religion_bonus}@{selected|pbd_safe} ]]&#125;&#125; {{rname=Religion&#125;&#125; {{mod=@{selected|religion_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|religion_bonus}@{selected|pbd_safe} ]]&#125;&#125; |Sleight of Hand, +@{selected|sleight_of_hand_bonus}@{selected|pbd_safe} ]]&#125;&#125; {{rname=Sleight of Hand&#125;&#125; {{mod=@{selected|sleight_of_hand_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|sleight_of_hand_bonus}@{selected|pbd_safe} ]]&#125;&#125; |Stealth, +@{selected|stealth_bonus}@{selected|pbd_safe} ]]&#125;&#125; {{rname=Stealth&#125;&#125; {{mod=@{selected|stealth_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|stealth_bonus}@{selected|pbd_safe} ]]&#125;&#125; |Survival, +@{selected|survival_bonus}@{selected|pbd_safe} ]]&#125;&#125; {{rname=Survival&#125;&#125; {{mod=@{selected|survival_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|survival_bonus}@{selected|pbd_safe} ]]&#125;&#125; |Strength, +@{selected|strength_mod}@{selected|jack_attr}[STR]]]&#125;&#125; {{rname=Strength&#125;&#125; {{mod=@{selected|strength_mod}@{selected|jack_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|strength_mod}@{selected|jack_attr}[STR]]]&#125;&#125; |Dexterity, +@{selected|dexterity_mod}@{selected|jack_attr}[DEX]]]&#125;&#125; {{rname=Dexterity&#125;&#125; {{mod=@{selected|dexterity_mod}@{selected|jack_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|dexterity_mod}@{selected|jack_attr}[DEX]]]&#125;&#125; |Constitution, +@{selected|constitution_mod}@{selected|jack_attr}[CON]]]&#125;&#125; {{rname=Constitution&#125;&#125; {{mod=@{selected|constitution_mod}@{selected|jack_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|constitution_mod}@{selected|jack_attr}[CON]]]&#125;&#125; |Intelligence, +@{selected|intelligence_mod}@{selected|jack_attr}[INT]]]&#125;&#125; {{rname=Intelligence&#125;&#125; {{mod=@{selected|intelligence_mod}@{selected|jack_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|intelligence_mod}@{selected|jack_attr}[INT]]]&#125;&#125; |Wisdom, +@{selected|wisdom_mod}@{selected|jack_attr}[WIS]]]&#125;&#125; {{rname=Wisdom&#125;&#125; {{mod=@{selected|wisdom_mod}@{selected|jack_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|wisdom_mod}@{selected|jack_attr}[WIS]]]&#125;&#125; |Charisma, +@{selected|charisma_mod}@{selected|jack_attr}[CHA]]]&#125;&#125; {{rname=Charisma&#125;&#125; {{mod=@{selected|charisma_mod}@{selected|jack_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|charisma_mod}@{selected|jack_attr}[CHA]]]&#125;&#125; } @{selected|global_skill_mod} @{selected|charname_output}",
					});
				}
				// for everyone
				character.abilities.create({
					name: "Initiative",
					istokenaction: true,
					action: d20plus.macro.actionMacroInit,
				});
			}
		});

		// New command on FOLDERS
		const last = $("#journalmenu ul li").last();
		last.before("<li data-action-type=\"archiveall\">Archive All Contents</li>");

		const $journalUl = $("#journalmenu ul");

		$journalUl.on(window.mousedowntype, "li[data-action-type=archiveall]", function () {
			d20plus.journal.recursiveArchiveDirById(d20plus.journal.lastClickedFolderId, true);
			$("#journalmenu").hide();
		});
	};

	/**
	 * Takes a path made up of strings and arrays of strings, and turns it into one flat array of strings
	 * Note that paths must be of the form ["folder", "subfolder", "subsubfolder", etc]
	 */
	d20plus.journal.getCleanPath = function (...path) {
		const clean = [];
		getStrings(clean, path);
		return clean.map(s => s.trim()).filter(s => s);

		function getStrings (stack, toProc) {
			toProc.forEach(tp => {
				if (typeof tp === "string") {
					stack.push(tp);
				} else if (tp instanceof Array) {
					getStrings(stack, tp);
				} else {
					throw new Error("Object in path was not a string or an array")
				}
			});
		}
	};

	d20plus.journal.makeDirTree = function (...path) {
		const parts = d20plus.journal.getCleanPath(path);
		// path e.g. d20plus.journal.makeDirTree("Spells", "Cantrips", "1")
		// roll20 allows a max directory depth of 4 :joy: (5, but the 5th level is unusable)
		if (parts.length > 4) throw new Error("Max directory depth exceeded! The maximum is 4.")

		const madeSoFar = [];

		const root = {i: d20plus.ut.getJournalFolderObj()};

		// roll20 folder management is dumb, so just pick the first folder with the right name if there's multiple
		let curDir = root;
		parts.forEach(toMake => {
			const existing = curDir.i.find((it) => {
				// n is folder name (only folders have the n property)
				return it.n && it.n === toMake && it.i;
			});
			if (!existing) {
				if (curDir.id) {
					d20.journal.addFolderToFolderStructure(toMake, curDir.id);
				} else {
					// root has no id
					d20.journal.addFolderToFolderStructure(toMake);
				}
			}
			d20.journal.refreshJournalList();
			madeSoFar.push(toMake);

			// we have to save -> reread the entire directory JSON -> walk back to where we were
			let nextDir = {i: JSON.parse(d20.Campaign.get("journalfolder"))};
			madeSoFar.forEach(f => {
				nextDir = nextDir.i.find(dir => dir.n && (dir.n.toLowerCase() === f.toLowerCase()));
			});

			curDir = nextDir;
		});
		return curDir;
	};

	d20plus.journal.recursiveRemoveDirById = function (folderId, withConfirmation) {
		if (!withConfirmation || confirm("Are you sure you want to delete this folder, and everything in it? This cannot be undone.")) {
			const folder = $(`[data-globalfolderid='${folderId}']`);
			if (folder.length) {
				d20plus.ut.log("Nuking directory...");
				const childItems = folder.find("[data-itemid]").each((i, e) => {
					const $e = $(e);
					const itemId = $e.attr("data-itemid");
					let toDel = d20.Campaign.handouts.get(itemId);
					toDel || (toDel = d20.Campaign.characters.get(itemId));
					if (toDel) toDel.destroy();
				});
				const childFolders = folder.find(`[data-globalfolderid]`).remove();
				folder.remove();
				$("#journalfolderroot").trigger("change");
			}
		}
	};

	d20plus.journal.recursiveArchiveDirById = function (folderId, withConfirmation) {
		if (!withConfirmation || confirm("Are you sure you want to archive this folder, and everything in it? This cannot be undone.")) {
			const folder = $(`[data-globalfolderid='${folderId}']`);
			if (folder.length) {
				d20plus.ut.log("Archiving directory...");
				folder.find("[data-itemid]").each((i, e) => {
					const $e = $(e);
					const itemId = $e.attr("data-itemid");
					let toArchive = d20.Campaign.handouts.get(itemId);
					toArchive || (toArchive = d20.Campaign.characters.get(itemId));
					if (toArchive && toArchive.attributes) {
						toArchive.attributes.archived = true;
						toArchive.save()
					}
				});
			}
		}
	};

	d20plus.journal.removeDirByPath = function (...path) {
		path = d20plus.journal.getCleanPath(path);
		return d20plus.journal._checkOrRemoveDirByPath(true, path);
	};

	d20plus.journal.checkDirExistsByPath = function (...path) {
		path = d20plus.journal.getCleanPath(path);
		return d20plus.journal._checkOrRemoveDirByPath(false, path);
	};

	d20plus.journal._checkOrRemoveDirByPath = function (doDelete, path) {
		const parts = d20plus.journal.getCleanPath(path);

		const root = {i: d20plus.ut.getJournalFolderObj()};

		let curDir = root;
		for (let i = 0; i < parts.length; ++i) {
			const p = parts[i];
			let lastId;
			const existing = curDir.i.find((it) => {
				lastId = it.id;
				// n is folder name (only folders have the n property)
				return it.n && it.n === p;
			});
			if (!existing) return false;
			if (!doDelete) return true;
			curDir = existing;
			if (i === parts.length - 1) {
				d20plus.journal.recursiveRemoveDirById(lastId, false);
				return true;
			}
		}
	};

	d20plus.journal.getExportableJournal = () => {
		// build a list of (id, path) pairs
		const out = [];

		function recurse (entry, pos) {
			if (entry.i) {
				// pos.push({name: entry.n, id: entry.id}); // if IDs are required, use this instead?
				pos.push(entry.n);
				entry.i.forEach(nxt => recurse(nxt, pos));
				pos.pop();
			} else {
				out.push({id: entry, path: MiscUtil.copy(pos)});
			}
		}

		const root = {i: d20plus.ut.getJournalFolderObj(), n: "Root", id: "root"};
		recurse(root, []);
		return out;
	};

	d20plus.journal.removeFileByPath = function (...path) {
		path = d20plus.journal.getCleanPath(path);
		return d20plus.journal._checkOrRemoveFileByPath(true, path);
	};

	d20plus.journal.checkFileExistsByPath = function (...path) {
		path = d20plus.journal.getCleanPath(path);
		return d20plus.journal._checkOrRemoveFileByPath(false, path);
	};

	d20plus.journal._checkOrRemoveFileByPath = function (doDelete, path) {
		const parts = d20plus.journal.getCleanPath(path);

		const root = {i: d20plus.ut.getJournalFolderObj()};

		let curDir = root;
		for (let i = 0; i < parts.length; ++i) {
			const p = parts[i];
			let lastId;
			const existing = curDir.i.find((it) => {
				if (i === parts.length - 1) {
					// for the last item, check handouts/characters to see if the match it (which could be a string ID)
					const char = d20.Campaign.characters.get(it);
					const handout = d20.Campaign.handouts.get(it);
					if ((char && char.get("name") === p) || (handout && handout.get("name") === p)) {
						lastId = it;
						return true;
					}
				} else {
					lastId = it.id;
					// n is folder name (only folders have the n property)
					return it.n && it.n === p;
				}
				return false;
			});
			if (!existing) return false;
			curDir = existing;
			if (i === parts.length - 1) {
				if (doDelete) {
					// on the last item, delete
					let toDel = d20.Campaign.handouts.get(lastId);
					toDel || (toDel = d20.Campaign.characters.get(lastId))
					if (toDel) toDel.destroy();
				}
				return true;
			}
		}
		return false;
	};
}

SCRIPT_EXTENSIONS.push(d20plusJournal);


function baseCss () {
	d20plus.css = {};

	// Convert to regular CSS:
	// `[ ... rules ... ].map(it => `${it.s} {\n${it.r.split(";").map(str => str.trim()).join(";\n")}}\n`).join("\n")`
	d20plus.css.baseCssRules = [
		// generic
		{
			s: ".inline-block, .display-inline-block",
			r: "display: inline-block;",
		},
		{
			s: ".bold",
			r: "font-weight: bold;",
		},
		{
			s: ".italic",
			r: "font-style: italic;",
		},
		{
			s: ".clickable",
			r: "cursor: pointer;",
		},
		{
			s: ".split",
			r: "display: flex; justify-content: space-between;",
		},
		{
			s: ".relative",
			r: "position: relative !important;",
		},
		{
			s: ".flex",
			r: "display: flex;",
		},
		{
			s: ".flex-col",
			r: "display: flex; flex-direction: column;",
		},
		{
			s: ".flex-v-center",
			r: "display: flex; align-items: center;",
		},
		{
			s: ".flex-vh-center",
			r: "display: flex; justify-content: center; align-items: center;",
		},
		{
			s: ".no-shrink",
			r: "flex-shrink: 0;",
		},
		{
			s: ".flex-1",
			r: "flex: 1",
		},
		{
			s: ".full-width",
			r: "width: 100%;",
		},
		{
			s: ".full-height",
			r: "height: 100%;",
		},
		{
			s: ".text-center",
			r: "text-align: center;",
		},
		{
			s: ".text-right",
			r: "text-align: right;",
		},
		{
			s: ".is-error",
			r: "color: #d60000;",
		},
		{
			s: ".flex-label",
			r: "display: inline-flex; align-items: center;",
		},
		{
			s: ".sel-xs",
			r: `
				height: 18px;
				line-height: 18px;
				margin: 0;
				padding: 0;
			`,
		},
		{
			s: ".btn-xs",
			r: `
				height: 18px;
				line-height: 18px;
				margin: 0;
				padding: 0 4px;
			`,
		},
		// // fix Roll20's <p> margins in the text editor // FIXME make this configurable
		// {
		// 	s: ".note-editable p",
		// 	r: "margin-bottom: 0;"
		// },
		// ensure rightclick menu width doesn't break layout // FIXME might be fixing the symptoms and not the cause
		{
			s: ".actions_menu.d20contextmenu > ul > li",
			r: "max-width: 100px;",
		},
		// page view enhancement
		{
			s: "#page-toolbar",
			r: "height: calc(90vh - 40px);",
		},
		{
			s: "#page-toolbar .container",
			r: "height: 100%; white-space: normal;",
		},
		{
			s: "#page-toolbar .pages .availablepage",
			r: "width: 100px; height: 100px;",
		},
		{
			s: "#page-toolbar .pages .availablepage img.pagethumb",
			r: "max-width: 60px; max-height: 60px;",
		},
		{
			s: "#page-toolbar .pages .availablepage span",
			r: "bottom: 1px;",
		},
		{
			s: "#page-toolbar",
			r: "background: #a8aaad80;",
		},
		// search
		{
			s: ".Vetoolsresult",
			r: "background: #ff8080;",
		},
		// config editor
		{
			s: "div.config-table-wrapper",
			r: "min-height: 200px; width: 100%; height: 100%; max-height: 460px; overflow-y: auto; transform: translateZ(0);",
		},
		{
			s: "table.config-table",
			r: "width: 100%; table-layout: fixed;",
		},
		{
			s: "table.config-table tbody tr:nth-child(odd)",
			r: "background-color: #f8f8f8;",
		},
		{
			s: "table.config-table tbody td > *",
			r: "vertical-align: middle; margin: 0;",
		},
		{
			s: ".config-name",
			r: "display: inline-block; line-height: 35px; width: 100%;",
		},
		// tool list
		{
			s: ".tools-list",
			r: "max-height: 70vh;",
		},
		{
			s: ".tool-row",
			r: "min-height: 40px; display: flex; flex-direction: row; align-items: center;",
		},
		{
			s: ".tool-row:nth-child(odd)",
			r: "background-color: #f0f0f0;",
		},
		{
			s: ".tool-row > *",
			r: "flex-shrink: 0;",
		},
		// warning overlay
		{
			s: ".temp-warning",
			r: "position: fixed; top: 12px; left: calc(50vw - 200px); z-index: 10000; width: 320px; background: transparent; color: red; font-weight: bold; font-size: 150%; font-variant: small-caps; border: 1px solid red; padding: 4px; text-align: center; border-radius: 4px;",
		},
		// GM hover text
		{
			s: ".Vetools-token-hover",
			r: "pointer-events: none; position: fixed; z-index: 100000; background: white; padding: 5px 5px 0 5px; border-radius: 5px; border: 1px solid #ccc; max-width: 450px;",
		},
		// drawing tools bar
		{
			s: "#drawingtools.line_splitter .currentselection:after",
			r: "content: '✂️';",
		},
		// "old style" system messages
		{
			s: ".userscript-hacker-chat, .hacker-chat",
			r: "margin-left: -45px; margin-right: -5px; margin-bottom: -7px; margin-top: -15px; display: inline-block; font-weight: bold; font-family: 'Lucida Console', Monaco, monospace; color: #20C20E; background: black; padding: 3px; min-width: calc(100% + 60px);box-sizing: border-box;",
		},
		{
			s: ".userscript-hacker-chat a",
			r: "color: white;",
		},
		{
			s: ".userscript-hacker-chat-error",
			r: "margin-left: -45px; margin-right: -5px; margin-bottom: -7px; margin-top: -15px; display: inline-block; font-weight: bold; font-family: 'Lucida Console', Monaco, monospace; color: #FF69B4; background: black; padding: 3px; min-width: calc(100% + 60px);",
		},
		{
			s: ".userscript-hacker-chat-error a",
			r: "color: white;",
		},
		// "old style" chat tag
		{
			s: ".userscript-hackerintro",
			r: "background: black; padding: 3px;",
		},
		{
			s: ".userscript-hackerintro h1",
			r: "font-family: \"Lucida Console\", Monaco, monospace; color: rgb(32, 194, 14); font-size: 18px;",
		},
		{
			s: ".userscript-hackerintro p",
			r: "font-family: \"Lucida Console\", Monaco, monospace; color: rgb(32, 194, 14); font-size: unset; font-weight: bold; line-height: 20px;",
		},
		// vttes-style chat tag
		{
			s: ".userscript-b20intro img.userscript-b20img",
			r: "content: url('https://wiki.tercept.net/core-wiki-assets/5etoolslogocircle.png') !important",
		},
		{
			s: ".userscript-b20intro",
			r: "box-shadow: 0px 0px 10px rgb( 6 , 26 , 45 ); padding: 8px;background: rgb(6, 26, 45);color: whitesmoke;",
		},
		{
			s: ".userscript-b20intro strong",
			r: "color: orange;",
		},
		{
			s: ".userscript-b20intro h1",
			r: "color: whitesmoke;",
		},
		{
			s: "code",
			r: "padding: 1px 2px;color: rgb(73, 45, 32);background-color: #fff4e8;border: 1px solid;",
		},
		// "player connects/disconnects" messages
		{
			s: ".connects-log",
			r: "display: none; font-variant: small-caps; font-size: 12px; padding: 18px 2px 2px 32px; margin-left: -8px; border: 1px solid; border-top: none; margin-top: -16px; background: rgba(100, 100, 100, 0.2); cursor: pointer;",
		},
		{
			s: ".connects-info, .msg-action-button",
			r: "font-family: pictos; margin-right: 4px; text-decoration: none !important; cursor: pointer; float: right; position: relative; top: -16px;",
		},
		{
			s: ".msg-action-button",
			r: "top: 0px;",
		},
		{
			s: "input:checked + label .connects-info",
			r: "position: unset;",
		},
		{
			s: "input:checked + label .connects-log",
			r: "display: block;",
		},
		{
			s: ".connects-state",
			r: "display: none;",
		},
		{
			s: ".withoutavatars .userscript-hacker-chat",
			r: "margin-left: -15px; min-width: calc(100% + 30px);",
		},
		{
			s: ".Ve-btn-chat",
			r: "margin-top: 10px; margin-left: -35px;",
		},
		{
			s: ".withoutavatars .Ve-btn-chat",
			r: "margin-left: -5px;",
		},
		// Bootstrap-alikes
		{
			s: ".col",
			r: "display: inline-block;",
		},
		{
			s: ".col-1",
			r: "width: 8.333%;",
		},
		{
			s: ".col-2",
			r: "width: 16.666%;",
		},
		{
			s: ".col-3",
			r: "width: 25%;",
		},
		{
			s: ".col-4",
			r: "width: 33.333%;",
		},
		{
			s: ".col-5",
			r: "width: 41.667%;",
		},
		{
			s: ".col-6",
			r: "width: 50%;",
		},
		{
			s: ".col-7",
			r: "width: 58.333%;",
		},
		{
			s: ".col-8",
			r: "width: 66.667%;",
		},
		{
			s: ".col-9",
			r: "width: 75%;",
		},
		{
			s: ".col-10",
			r: "width: 83.333%;",
		},
		{
			s: ".col-11",
			r: "width: 91.667%;",
		},
		{
			s: ".col-12",
			r: "width: 100%;",
		},
		{
			s: ".ib",
			r: "display: inline-block;",
		},
		{
			s: ".float-right",
			r: "float: right;",
		},
		{
			s: ".my-0",
			r: "margin-top: 0 !important; margin-bottom: 0 !important;",
		},
		{
			s: ".m-1",
			r: "margin: 0.25rem !important;",
		},
		{
			s: ".mt-2",
			r: "margin-top: 0.5rem !important;",
		},
		{
			s: ".mr-1",
			r: "margin-right: 0.25rem !important;",
		},
		{
			s: ".ml-1",
			r: "margin-left: 0.25rem !important;",
		},
		{
			s: ".mr-2",
			r: "margin-right: 0.5rem !important;",
		},
		{
			s: ".ml-2",
			r: "margin-left: 0.5rem !important;",
		},
		{
			s: ".mb-2",
			r: "margin-bottom: 0.5rem !important;",
		},
		{
			s: ".mb-1",
			r: "margin-bottom: 0.25rem !important;",
		},
		{
			s: ".p-2",
			r: "padding: 0.5rem !important;",
		},
		{
			s: ".p-3",
			r: "padding: 1rem !important;",
		},
		{
			s: ".split",
			r: "display: flex; justify-content: space-between;",
		},
		{
			s: ".split--center",
			r: "align-items: center;",
		},
		// image rows
		{
			s: ".import-cb-label--img",
			r: "display: flex; height: 64px; align-items: center; padding: 4px;",
		},
		{
			s: ".import-label__img",
			r: "display: inline-block; width: 60px; height: 60px; padding: 0 5px;",
		},
		// importer
		{
			s: ".import-cb-label",
			r: "display: block; margin-right: -13px !important;",
		},
		{
			s: ".import-cb-label span",
			r: "display: inline-block; overflow: hidden; max-height: 18px; letter-spacing: -1px; font-size: 12px;",
		},
		{
			s: ".import-cb-label span.readable",
			r: "letter-spacing: initial",
		},
		{
			s: ".import-cb-label .source",
			r: "width: calc(16.667% - 28px);'",
		},
		// Table importer
		{
			s: ".table-import-search",
			r: "transform: translateZ(0); max-height: 490px; overflow-y: scroll; overflow-x: hidden;",
		},
		{
			s: ".table-import-textarea",
			r: "display: block; width: 600px; height: 340px;",
		},
		// horizontal toolbar
		{
			s: "#secondary-toolbar:hover",
			r: "opacity: 1 !important;",
		},
		// addon layer bar
		{
			s: "#floatinglayerbar ul",
			r: "margin: 0; padding: 0;",
		},
		{
			s: "#floatinglayerbar li:hover, #floatinglayerbar li.activebutton",
			r: "color: #333; background-color: #54C3E8; cursor: pointer;",
		},
		{
			s: "#floatinglayerbar li",
			r: "padding: 3px; margin: 0; border-bottom: 1px solid #999; display: block; text-align: center; line-height: 22px; font-size: 22px; color: #999; position: relative;",
		},
		{
			s: "#floatinglayerbar.map li.choosemap, #floatinglayerbar.objects li.chooseobjects, #floatinglayerbar.gmlayer li.choosegmlayer, #floatinglayerbar.walls li.choosewalls, #floatinglayerbar.weather li.chooseweather, #floatinglayerbar.foreground li.chooseforeground, #floatinglayerbar.roofs li.chooseroofs, #floatinglayerbar.floors li.choosefloors, #floatinglayerbar.background li.choosebackground",
			r: "background-color: #54C3E8; color: #333;",
		},
		// move layer bar to right
		{
			s: "#floatinglayerbar",
			r: "pointer-events: all;",
		},
		{
			s: "#floatinglayerbar.right",
			r: "right: 30px; left: unset!important;",
		},
		{
			s: "#floatinglayerbar",
			r: "left: 20px;",
		},
		// Config & dark mode fixes
		{
			s: ".config-name",
			r: "padding: 6px 0px; line-height: 21px;",
		},
		{
			s: "#d20plus-configeditor .nav li:not(.active) > a",
			r: "cursor: pointer;",
		},
		{
			s: "#d20plus-configeditor table.config-table tbody tr:nth-child(2n+1)",
			r: "background-color: rgba(120, 120, 120, 0.2);",
		},
		{
			s: ".tokeneditor__bar-inputs input[type=\"text\"][disabled], .token_bar_input[disabled]",
			r: "background-color: rgba(180, 180, 180, 0.3);",
		},
		{
			s: ".tool-row:nth-child(2n+1)",
			r: "background-color: rgba(120, 120, 120, 0.2);",
		},
		{
			s: "#floatinglayerbar li",
			r: "background-color: var(--dark-surface2);border-color: var(--dark-surface1);",
		},
		{
			s: ".ui-dialog .artr__side, .ui-dialog .artr__view, .ui-dialog .artr__side__tag_grid, .ui-dialog .artr__side__head",
			r: "background-color: unset;",
		},
		// Fix page options scrollbar color in darkmode on Chrome
		{
			s: ".ui-dialog-content::-webkit-scrollbar-thumb",
			r: "background-color: rgba(100, 100, 100, 0.5);",
		},
		// extra layer buttons
		{
			s: "#editinglayer.weather div.submenu li.chooseweather, #editinglayer.foreground div.submenu li.chooseforeground, #editinglayer.floors div.submenu li.choosefloors, #editinglayer.roofs div.submenu li.chooseroofs, #editinglayer.background div.submenu li.choosebackground",
			r: "background-color: #54C3E8; color: #333;",
		},
		{
			s: "#editinglayer.objects .currentselection::after",
			r: "content: \"U\";",
		},
		{
			s: "#editinglayer.map .currentselection::after",
			r: "content: \"G\";",
		},
		{
			s: "#editinglayer.weather .currentselection:after",
			r: "content: \"C\";",
		},
		{
			s: "#editinglayer.foreground .currentselection:after",
			r: "content: \"B\";",
		},
		{
			s: "#editinglayer.floors .currentselection:after",
			r: "content: \"I\";",
		},
		{
			s: "#editinglayer.roofs .currentselection:after",
			r: "content: \"H\";",
		},
		{
			s: "#editinglayer.background .currentselection:after",
			r: "content: \"a\";",
		},
		{
			s: "#editinglayer.gmlayer .currentselection:after",
			r: "content: \"E\";",
		},
		{
			s: "#editinglayer.gmlayer > span.currentselection",
			r: "display:unset;",
		},
		{
			s: "#editinglayer.gmlayer #editing_layer_icon",
			r: "display:none;",
		},
		// layer visibility toggles
		{
			s: "#editinglayer .pictos.layer_toggle",
			r: "float: right; cursor: alias; pointer-events: all;",
		},
		{
			s: "#editinglayer li.stashed",
			r: "pointer-events: none;",
		},
		{
			s: "#editinglayer li.stashed .pictos.layer_toggle",
			r: "position: relative; left: -19px; margin-right: -20px; margin-left: 0px;",
		},
		{
			s: "#editinglayer li.stashed .pictos.layer_toggle::after",
			r: "content: \"d\"; position: relative; left: -16px; color: rgba(200,50,50,0.7);",
		},
		{
			s: "#playerzone #floatinglayerbar li.off > span::after",
			r: "content: \"d\"; color: rgba(200, 100, 100, 0.7); margin-left: -20px;",
		},
		{
			s: "#playerzone #floatinglayerbar li.off",
			r: "color: rgba(153, 153, 153, 0.5); pointer-events: none;",
		},
		// adjust the "Talking to Yourself" box
		{
			s: "#textchat-notifier",
			r: "top: -5px; background-color: red; opacity: 0.5; color: white;",
		},
		{
			s: "#textchat-notifier:after",
			r: "content: '!'",
		},
		{
			s: ".ctx__layer-icon",
			r: `
			display: inline-block;
			width: 12px;
			text-align: center;
			`,
		},
		// fix the shitty undersized "fire" icon
		{
			s: ".choosewalls > .pictostwo",
			r: "width: 15px; height: 17px; display: inline-block; text-align: center;",
		},
		{
			s: "#editinglayer.walls > .pictos",
			r: "width: 20px; height: 22px; display: inline-block; text-align: center; font-size: 0.9em;",
		},
		// weather config window
		{
			s: ".ui-dialog .wth__row",
			r: "margin-bottom: 10px; align-items: center; padding: 0 0 5px; border-bottom: 1px solid #eee;",
		},
		{
			s: ".wth__row select",
			r: "margin-bottom: 0",
		},
		{
			s: `.wth__row input[type="range"]`,
			r: "width: calc(100% - 8px);",
		},
		// context menu
		{
			s: `.ctx__divider`,
			r: "width: calc(100% - 2px); border: 1px solid black;",
		},
		// sidebar fix
		/* {
			s: `#rightsidebar`,
			r: `
				display: flex;
				flex-direction: column;
			`
		},
		{
			s: `#rightsidebar ul.tabmenu`,
			r: `
				padding: 0;
				flex-shrink: 0;
				position: relative;
				top: 0;
				width: 100%;
			`
		},
		{
			s: `#rightsidebar .ui-tabs-panel`,
			r: `
				height: 100% !important;
				display: block;
				top: 0;
			`
		},
		{
			s: `#textchat-input`,
			r: `
				position: relative;
				flex-shrink: 0;
			`
		},
		{
			s: `#textchat-input textarea`,
			r: `
				width: calc(100% - 8px) !important;
				resize: vertical;
			`
		}, */
		// Ensure page toolbar is displayed
		{
			s: `#page-toolbar`,
			r: `display: block;`,
		},
		// Macro editor styles
		{
			s: `.jsdialog .actionhelp.r20, .jsdialog .commandhelp.r20`,
			r: `display: none;`,
		},
		{
			s: `.jsdialog .actionhelp.js, .jsdialog .commandhelp.js`,
			r: `display: inline-block;`,
		},
		{
			s: `.actionhelp.js, .commandhelp.js`,
			r: `display: none;`,
		},
	];

	d20plus.css.baseCssRulesPlayer = [
		{
			s: ".player-hidden",
			r: "display: none !important;",
		},
		// Force-hide page toolbar
		{
			s: `#page-toolbar`,
			r: `display: none;`,
		},
	];

	d20plus.css.cssRules = []; // other scripts should populate this

	// Mirrors of 5etools CSS
	d20plus.css.cssRules = d20plus.css.cssRules.concat([
		{
			s: ".copied-tip",
			r: "pointer-events: none; position: fixed; background: transparent; user-select: none; z-index: 100000; width: 80px; height: 24px; line-height: 24px;",
		},
		{
			s: ".copied-tip > span",
			r: "display: inline-block; width: 100%; text-align: center;",
		},
		{
			s: ".help",
			r: "cursor: help; text-decoration: underline; text-decoration-style: dotted;",
		},
		{
			s: ".help--subtle",
			r: "cursor: help;",
		},
	]);

	// QOL fixes
	d20plus.css.cssRules = d20plus.css.cssRules.concat([
		// Initiative dialog fixes
		{
			s: ".initiativedialog .ui-dialog-buttonset .ui-button",
			r: "margin: 0px 0px 0px 3px; max-width: 37px; overflow: hidden; box-sizing: border-box;",
		},
		{
			s: ".initiativedialog .ui-dialog-buttonpane span.difficulty",
			r: "width: 40%; margin-top: -9px; font-size: 14px;",
		},
		// Spacing between token-actions
		{
			s: "#secondary-toolbar .tokenactions .btn",
			r: "margin-left: 2px;",
		},
		// Tweak OGL roll template styles
		{
			s: ".sheet-rolltemplate-atkdmg .sheet-desc .sheet-savedc",
			r: "padding-top: 5px",
		},
		{
			s: ".sheet-rolltemplate-simple .sheet-charname, .sheet-rolltemplate-simple3D .sheet-charname, .sheet-rolltemplate-skill .sheet-charname, .sheet-rolltemplate-atk .sheet-charname, .sheet-rolltemplate-dmg .sheet-charname, .sheet-rolltemplate-atkdmg .sheet-charname",
			r: "margin-top: -8px; padding-bottom: 5px;",
		},
		{
			s: ".sheet-rolltemplate-simple .sheet-charname span, .sheet-rolltemplate-simple3D .sheet-charname span, .sheet-rolltemplate-skill .sheet-charname span, .sheet-rolltemplate-atk .sheet-charname span, .sheet-rolltemplate-dmg .sheet-charname span, .sheet-rolltemplate-atkdmg .sheet-charname span",
			r: "font-size: 12px;",
		},
		{
			s: ".sheet-rolltemplate-atkdmg div.sheet-desc.sheet-info",
			r: "width: 98%;",
		},
		// Color rolls in OGL template subtexts
		{
			s: ".sheet-rolltemplate-atkdmg .sheet-sublabel span.showtip.inlinerollresult.fullcrit",
			r: "color: #3FB315",
		},
		{
			s: ".sheet-rolltemplate-atkdmg .sheet-sublabel span.showtip.inlinerollresult.fullfail",
			r: "color: #B31515",
		},
		{
			s: ".sheet-rolltemplate-atkdmg .sheet-sublabel span.showtip.inlinerollresult",
			r: "font-size: medium; padding: 5px 0px;",
		},
		// Style hit dice rolls for auto-updating HP
		{
			s: ".inlinerollresult.showtip.hit-dice",
			r: "cursor: pointer",
		},
		{
			s: ".inlinerollresult.showtip.hit-dice.heal-dice::before",
			r: "content: \"+\"",
		},
		{
			s: ".inlinerollresult.showtip.hit-dice:hover::after",
			r: "content: \"\\2694\";font-size: initial; color: rgba(250,100,100,0.6); position: absolute;",
		},
		// Styles for altered messages
		{
			s: ".userscript-modify-message",
			r: "display: none;",
		},
		{
			s: ".message.inlang i",
			r: "cursor: help;",
		},
		{
			s: ".message.action .avatar, .message.action .by",
			r: "display: none;",
		},
		{
			s: ".message.general.talktomyself, .message.rollresult.talktomyself, .message.private.talktomyself",
			r: "filter: sepia(70%);",
		},
		{
			s: ".message.general.disconnect .by::before",
			r: "font-family: pictos; content: \"[\";",
		},
	]);

	// Rewamped page options
	d20plus.css.cssRules = d20plus.css.cssRules.concat([
		{
			s: ".ui-dialog-pagename",
			r: "padding: 12px 0px 0px 10px; display: inline-block; font-size: 14px; max-width: 130px; white-space: nowrap; text-overflow: ellipsis; overflow: hidden;",
		},
		{
			s: ".nav-tabs--beta .label",
			r: "left: calc( 50% - 21px); right: unset;",
		},
		{
			s: ".nav-tabs > li > ul .nav-tabs--beta .label",
			r: "top: -4px;",
		},
		{
			s: ".nav-tabs > li > ul",
			r: "width: 0px; overflow-x: visible; white-space: nowrap; margin-left: -50px; height: 0px; overflow-y: clip; transition: height 0.3s;",
		},
		{
			s: ".nav-tabs > li.active > ul",
			r: "height: 36px; transition: height 1s;",
		},
		{
			s: ".dialog .nav-tabs > li.active.dl > a",
			r: "background-color: unset; border-color: transparent; text-decoration: none; pointer-events: none; cursor: unset;",
		},
		{
			s: ".ui-dialog .ui-dialog-content",
			r: "background: inherit;",
		},
		{
			s: ".dialog .nav.nav-tabs > li > a",
			r: "cursor: pointer;",
		},
		{
			s: ".nav-tabs > ul > li",
			r: "list-style: none; display: inline-block;",
		},
		{
			s: ".nav-tabs > ul > li a",
			r: "border-radius: 4px 4px 0 0; padding-right: 12px; padding-left: 12px; margin-right: 2px; line-height: 14px; display: inline-block; padding-top: 9px; padding-bottom: 9px; border-style: solid; border-width: 1px; border-bottom: none;",
		},
		{
			s: ".nav-tabs > ul > li.active a",
			r: "background-color: var(--dark-primary); color: var(--dark-primarytext); border-color: var(--dark-primary-highlight); text-decoration-color: var(--color-primary-text); vertical-align: sub;",
		},
		{
			s: ".nav-tabs > ul > li.active,	ul.nav-tabs li.active",
			r: "border-bottom-width: 0px;",
		},
		{
			s: "ul.nav-tabs > li.nav-tabs",
			r: "border-bottom: none;",
		},
		{
			s: ".nav.nav-tabs.pagedetails_navigation",
			r: "position: sticky; top: -10px; z-index: 100; background-color: inherit; padding-top: 7px;",
		},
		{
			s: ".page-input",
			r: "box-sizing: border-box; height: 28px; width: 100%; border-radius: 0.5rem;",
		},
		{
			s: ".page-input.page-hint[type=\"text\"]",
			r: "border-radius: 0.5rem;",
		},
		{
			s: ".weather input[type=\"color\"]",
			r: "width: 100%; height: 24px; border-radius: 0.5rem; padding: 1px;",
		},
		{
			s: ".views .pagedetails h4",
			r: "display: inline;",
		},
		{
			s: ".tab-pane strong .showtip",
			r: "margin-left: 0px; margin-right: 3%; float: left; margin-top: 1px;",
		},
	]);

	// Fix art repo buttons CSS
	d20plus.css.cssRules = d20plus.css.cssRules.concat([
		{
			s: "#imagedialog .searchbox p button",
			r: "width: 100%; margin: 0px 5px !important;",
		},
	]);

	// Art repo browser CSS
	d20plus.css.cssRules = d20plus.css.cssRules.concat([
		// full-width images search header
		{
			s: "#imagedialog .searchbox",
			r: "width: calc(100% - 10px)",
		},
		/// ////////////
		{
			s: ".artr__win",
			r: "display: flex; align-items: stretch; width: 100%; height: 100%; padding: 0 !important;",
		},
		// fix box sizing
		{
			s: ".artr__win *",
			r: "box-sizing: border-box;",
		},
		// custom scrollbars
		{
			s: ".artr__win *::-webkit-scrollbar",
			r: "width: 9px; height: 9px;",
		},
		{
			s: ".artr__win *::-webkit-scrollbar-track",
			r: "background: transparent;",
		},
		{
			s: ".artr__win *::-webkit-scrollbar-thumb",
			r: "background: #cbcbcb;",
		},
		/// ////////////
		{
			s: ".artr__side",
			r: "width: 300px; height: 100%; border-right: 1px solid #ccc; background: #f8f8f8; position: relative; flex-shrink: 0; display: flex; flex-direction: column;",
		},
		{
			s: ".artr__side__head",
			r: "flex-shrink: 0; font-weight: bold; margin-bottom: 7px; margin-bottom: 7px; border-bottom: 3px solid #ccc; background: white;",
		},
		{
			s: ".artr__side__head__title",
			r: "font-size: 16px; font-weight: bold;",
		},
		{
			s: ".artr__side__body",
			r: "flex-shrink: 0; overflow-y: auto; transform: translateZ(0);",
		},
		{
			s: ".artr__side__tag_header",
			r: "width: 100%; border-bottom: 1px solid #ccc; display: flex; justify-content: space-between; padding: 0 6px; cursor: pointer; margin-bottom: 10px;",
		},
		{
			s: ".artr__side__tag_grid",
			r: "display: flex; width: 100%; flex-wrap: wrap; margin-bottom: 15px; background: #f0f0f0; border-radius: 5px;",
		},
		{
			s: ".artr__side__tag",
			r: "padding: 2px 4px; margin: 2px 4px; font-size: 11px;",
		},
		{
			s: `.artr__side__tag[data-state="1"]`,
			r: "background-image: linear-gradient(#fff, #337ab7);",
		},
		{
			s: `.artr__side__tag[data-state="1"]:hover`,
			r: "background-image: linear-gradient(rgb(#337ab7), rgb(#337ab7)); background-position: 0; transition: none;",
		},
		{
			s: `.artr__side__tag[data-state="2"]`,
			r: "background-image: linear-gradient(#fff, #8a1a1b);",
		},
		{
			s: `.artr__side__tag[data-state="2"]:hover`,
			r: "background-image: linear-gradient(rgb(#8a1a1b), rgb(#8a1a1b)); background-position: 0; transition: none;",
		},
		{
			s: ".artr__main",
			r: "width: 100%; height: 100%; display: flex; overflow-y: auto; flex-direction: column; position: relative;",
		},
		{
			s: ".artr__side__loading, .artr__main__loading",
			r: "width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; font-style: italic;",
		},
		{
			s: ".artr__bread",
			r: "width: 100%; margin-bottom: 2px;",
		},
		{
			s: ".artr__crumb",
			r: "border: 1px solid #ccc; border-radius: 5px; padding: 0 5px; display: inline-block; cursor: pointer; user-select: none;",
		},
		{
			s: ".artr__crumb--sep",
			r: "border: 0; cursor: default;",
		},
		{
			s: ".artr__search",
			r: "flex-shrink: 0; width: 100%; border-bottom: 1px solid #ccc; display: flex; flex-direction: column;",
		},
		{
			s: ".artr__search__field",
			r: "width: 100%; height: 26px;",
		},
		{
			s: ".artr__view",
			r: "position: absolute; top: 64px; bottom: 0; left: 0; right: 0; overflow-y: auto; transform: translateZ(0); background-color: whitesmoke;",
		},
		{
			s: ".artr__view_inner",
			r: "display: flex; width: 100%; height: 100%; flex-wrap: wrap; align-content: flex-start;",
		},
		{
			s: ".artr__no_results_wrp",
			r: "width: 100%; height: 100%; display: flex; justify-content: center;",
		},
		{
			s: ".artr__no_results",
			r: "width: 100%; height: 100%; display: flex; justify-content: center; align-items: center;",
		},
		{
			s: ".artr__no_results_headline",
			r: "font-size: 125%; font-weight: bold;",
		},
		{
			s: ".artr__item",
			r: "width: 180px; margin: 5px; box-shadow: 0 0 3px 0 rgba(0, 0, 0, 0.75); display: block; background: white; position: relative;",
			// Using flex makes scrolling extremely sluggish
			// display: flex; flex-direction: column; cursor: pointer; float: left;
		},
		{
			s: ".artr__item__stats",
			r: "position: absolute; left: 0; top: 0; display: none;",
		},
		{
			s: ".artr__item:hover .artr__item__stats",
			r: "display: block;",
		},
		{
			s: ".artr__item__stats_item",
			r: "color: grey; background: white; border-radius: 5px; margin: 4px 2px; padding: 0 2px; text-align: center; border: 1px solid #e0e0e0",
		},
		{
			s: ".artr__item__menu",
			r: "position: absolute; right: 0; top: 0; display: none;",
		},
		{
			s: ".artr__item:hover .artr__item__menu",
			r: "display: block;",
		},
		{
			s: ".artr__item__menu_item",
			r: "cursor: pointer; color: grey; font-size: 26px; line-height: 24px; border-radius: 5px; margin: 4px; padding: 2px; text-align: center; display: block; border: 1px solid #ccc; background: white;",
		},
		{
			s: ".artr__item--index",
			r: "height: 240px;",
		},
		{
			s: ".artr__item--item",
			r: "height: 180px;",
		},
		{
			s: ".artr__item:hover",
			r: "box-shadow: 0 0 8px 0 rgba(38, 167, 242, 1); opacity: 0.95;",
		},
		{
			s: ".artr__item--back",
			r: "display: flex; justify-content: center; align-items: center; font-size: 24px; color: #888;",
		},
		{
			s: ".artr__item__top",
			r: "width: 100%; height: 180px; flex-shrink: 0; margin: 0 auto; display: flex; align-items: center;",
		},
		{
			s: ".artr__item__top--quart",
			r: "display: flex; flex-wrap: wrap;",
		},
		{
			s: ".artr__item__bottom",
			r: "width: 100%; height: 60px; flex-shrink: 0;  border-top: 1px solid #ccc; background: #f8f8f8; display: flex; flex-direction: column; font-size: 12px; justify-content: space-evenly;",
		},
		{
			s: ".artr__item__bottom__row",
			r: "width: 100% height: 20px; flex-shrink: 0; padding: 4px; text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;",
		},
		{
			s: ".artr__item__thumbnail",
			r: "max-width: 100%; max-height: 100%; display: block; margin: 0 auto;",
		},
		{
			s: ".atr__item__quart",
			r: "width: 50%; height: 50%; display: block; margin: 0;",
		},
		{
			s: ".atr__item__quart--more",
			r: "display: flex; justify-content: center; align-items: center;",
		},
		{
			s: ".artr__item__full",
			r: "width: 100%; height: 180px; margin: 0 auto; display: flex; align-items: center; padding: 3px;",
		},
		{
			s: ".artr__wrp_big_img",
			r: "position: fixed; top: 0; bottom: 0; right: 0; left: 0; background: #30303080; padding: 30px; display: flex; justify-content: center; align-items: center; z-index: 99999;",
		},
		{
			s: ".artr__big_img",
			r: "display: block; max-width: 100%; max-height: 100%;",
		},
		// fix row styles
		{
			s: "#d20plus-artfolder .url",
			r: "width: calc(65% - 75px) !important;white-space: nowrap;overflow: hidden;",
		},
		{
			s: "#d20plus-artfolder .library-item",
			r: "line-height: 16px;",
		},
		{
			s: "#d20plus-artfolder .library-item:hover",
			r: "background-color: rgba(100,100,100,0.5);",
		},
		// fix global dialog height for art browser
		{
			s: ".ui-dialog",
			r: "max-height:98vh;",
		},
	]);

	// Animator CSS -- `anm__` prefix
	d20plus.css.cssRules = d20plus.css.cssRules.concat([
		// fix box sizing
		{
			s: ".anm__win *",
			r: "box-sizing: border-box;",
		},
		{
			s: ".ui-dialog .anm__row",
			r: `
				display: flex;
				align-items: center;
				margin-bottom: 3px;
				height: 20px;
			`,
		},
		{
			s: ".anm__row > div",
			r: `
				display: inline-flex;
			`,
		},
		{
			s: ".anm__row-btn",
			r: `
				padding: 0 6px;
			`,
		},
		{
			s: ".anm__row-wrp-cb",
			r: `
				justify-content: center;
				align-items: center;
			`,
		},
		{
			s: ".anm__wrp-sel-all",
			r: `
				align-items: center;
				margin-bottom: 5px;
				display: flex;
				justify-content: space-between;
			`,
		},
		{
			s: ".anm-edit__ipt-lines-wrp",
			r: `
				flex-basis: 100%;
				flex-shrink: 100;
			`,
		},
		{
			s: ".anm-edit__gui .anm-edit__gui-hidden",
			r: `
				display: none;
			`,
		},
		{
			s: ".anm-edit__text .anm-edit__gui-visible",
			r: `
				display: none;
			`,
		},
		{
			s: ".anm-edit__ipt-lines-wrp--gui",
			r: `
				overflow-y: auto;
				display: flex;
				flex-direction: column;
			`,
		},
		{
			s: ".anm-edit__ipt-lines-wrp--gui > *",
			r: `
				flex-shrink: 0;
			`,
		},
		{
			s: ".anm-edit__ipt-lines",
			r: `
				resize: none;
				width: 100%;
				height: 100%;
				margin-bottom: 0;
			`,
		},
		{
			s: ".anm-edit__gui-row",
			r: `
				padding: 4px;
				border: 1px solid #ccc;
				border-radius: 3px;
				margin-bottom: 3px;
			`,
		},
		{
			s: ".anm-edit__gui-row:nth-child(even)",
			r: `
				background: #f8f8f8;
			`,
		},
		{
			s: ".anm-edit__gui-row-name",
			r: `
				color: white;
				-webkit-text-stroke: 1px #555;
				text-stroke: 1px black;
				padding: 3px 5px;
				border-radius: 3px;
				font-size: 16px;
				display: inline-block;
				min-width: 150px;
			`,
		},
		{
			s: ".anm-edit__gui-row-name--Move",
			r: `
				background: #ff0004;
			`,
		},
		{
			s: ".anm-edit__gui-row-name--Rotate",
			r: `
				background: #ff6c00;
			`,
		},
		{
			s: ".anm-edit__gui-row-name--Copy",
			r: `
				background: #fff700;
			`,
		},
		{
			s: ".anm-edit__gui-row-name--Flip",
			r: `
				background: #a3ff00;
			`,
		},
		{
			s: ".anm-edit__gui-row-name--Scale",
			r: `
				background: #5eff00;
			`,
		},
		{
			s: ".anm-edit__gui-row-name--Layer",
			r: `
				background: #00ff25;
			`,
		},
		{
			s: ".anm-edit__gui-row-name--Lighting",
			r: `
				background: #00ffb6;
			`,
		},
		{
			s: [
				".anm-edit__gui-row-name--SetProperty",
				".anm-edit__gui-row-name--SumProperty",
			],
			r: `
				background: #006bff;
			`,
		},
		{
			s: ".anm-edit__gui-row-name--TriggerMacro",
			r: `
				background: #0023ff;
			`,
		},
		{
			s: ".anm-edit__gui-row-name--TriggerAnimation",
			r: `
				background: #9800ff;
			`,
		},
		{
			s: ".anm-scene__wrp-tokens",
			r: `
				width: 100%;
				max-height: 100%;
				overflow-y: auto;
				display: flex;
				flex-wrap: wrap;
			`,
		},
		{
			s: ".anm-scene__wrp-token",
			r: `
				width: 80px;
				height: 100px;
				background: #f0f0f0;
				box-shadow: 0 0 3px 0 rgba(0, 0, 0, 0.75);
				margin: 4px;
				display: flex;
				flex-direction: column;
				padding: 3px;
			`,
		},
		{
			s: ".anm-scene__wrp-token--active",
			r: `
				background: #a0f0ff;
			`,
		},
		{
			s: ".anm-scene__wrp-token-name",
			r: `
				height: 20px;
				overflow: hidden;
			`,
		},
		{
			s: ".anm-scene__wrp-token-name-inner",
			r: `
				height: 20px;
				overflow: hidden;
				text-overflow: ellipsis;
				white-space: nowrap;
			`,
		},
		{
			s: ".flex-row",
			r: `
				display: flex;
				float: left;
				align-items: center;
				margin-bottom: 5px;
			`,
		},
		{
			s: ".pagedetails .flex-row input.units,.pagedetails .flex-row input.pixels",
			r: `
				width: 20%;
				text-align: center;
				border: 1px solid;
				border-radius: 5px;
				margin: 0 2%;
			`,
		},
	]);

	// Jukebox CSS
	d20plus.css.cssRules = d20plus.css.cssRules.concat([
		{
			s: ".jukebox-widget-button",
			r: `
				flex: 1;
				text-overflow: ellipsis;
				overflow: hidden;
				min-width: 50px;
			`,
		},
		{
			s: ".jukebox-widget-slider",
			r: `
				margin: 10px;
				display: inline-block;
				flex: 15;
			`,
		},
		{
			s: ".jukebox-widget-button",
			r: `
				letter-spacing: -1px
			`,
		},
	]);

	d20plus.css.miniInitStyle = `
		#initiativewindow button.initmacrobutton {
			padding: 1px 4px;
		}

		#initiativewindow input {
			font-size: 8px;
		}

		#initiativewindow ul li span.name {
			font-size: 13px;
			padding-top: 0;
			padding-left: 4px;
			margin-top: -3px;
		}

		#initiativewindow ul li img {
			min-height: 15px;
			max-height: 15px;
		}

		#initiativewindow ul li {
			min-height: 15px;
		}

		#initiativewindow div.header span.initiative,
		#initiativewindow ul li span.initiative,
		#initiativewindow ul li span.tracker-col,
		#initiativewindow div.header span.tracker-col,
		#initiativewindow div.header span.initmacro,
		#initiativewindow ul li span.initmacro {
			font-size: 10px;
			font-weight: bold;
			text-align: right;
			float: right;
			padding: 0 5px;
			width: 7%;
			min-height: 20px;
			display: block;
			overflow: hidden;
		}

		#initiativewindow ul li .controls {
			padding: 0 3px;
		}
	`;

	d20plus.css.deserifyDarkmode = `
		.sheet-darkmode #tab-content {
			font-family: unset;
		}
	`;
}

SCRIPT_EXTENSIONS.push(baseCss);


function baseUi () {
	d20plus.ui = {};

	d20plus.ui.addHtmlHeader = () => {
		d20plus.ut.log("Add HTML");
		const $body = $("body");

		const $wrpSettings = $(`<div id="betteR20-settings"/>`);
		$("#settings-accordion").children(".panel.panel-default").first().before($wrpSettings);

		$wrpSettings.append(d20plus.settingsHtmlHeader);
		$body.append(d20plus.html.configEditorHTML);
		if (window.is_gm) {
			$(`#imagedialog`).find(`.searchbox`).find(`.tabcontainer`).first().after(d20plus.html.artTabHtml);
			$(`#button-add-external-art`).on(window.mousedowntype, d20plus.art.button);

			$body.append(d20plus.html.addArtHTML);
			$body.append(d20plus.html.addArtMassAdderHTML);
			$body.append(d20plus.html.toolsListHtml);
			$("#d20plus-artfolder").dialog({
				autoOpen: false,
				resizable: true,
				width: 1000,
				height: 800,
			});
			$("#d20plus-artmassadd").dialog({
				autoOpen: false,
				resizable: true,
				width: 800,
				height: 650,
			});
		}
		const $cfgEditor = $("#d20plus-configeditor");
		$cfgEditor.dialog({
			autoOpen: false,
			resizable: true,
			width: 800,
			height: 650,
		});
		$cfgEditor.parent().append(d20plus.html.configEditorButtonBarHTML);

		// shared GM/player conent
		// quick search box
		const $iptSearch = $(`<input id="player-search" class="ui-autocomplete-input" autocomplete="off" placeholder="Quick search by name...">`);
		const $wrprResults = $(`<div id="player-search-results" class="content searchbox"/>`);

		if (window.is_gm) {
			$iptSearch.css("width", "calc(100% - 5px)");
			const $addPoint = $("#journal").find("button.btn.superadd");
			$addPoint.after($wrprResults);
			$addPoint.after(`<br>`);
			$addPoint.after($iptSearch);
			$addPoint.after(`<br><br>`);
		} else {
			const $wrprControls = $(`<div class="content searchbox" id="search-wrp-controls"/>`);
			$(`#journal .content`).before($wrprControls).before($wrprResults);
			$iptSearch.css("max-width", "calc(100% - 140px)");
			$wrprControls.append($iptSearch);
		}
		d20plus.engine.initQuickSearch($iptSearch, $wrprResults);
	};

	d20plus.ui.addHtmlFooter = () => {
		const $wrpSettings = $(`#betteR20-settings`);
		$wrpSettings.append(d20plus.html.settingsHtmlPtFooter);
		$wrpSettings.css("margin", "5px");

		$("#button-edit-config").on(window.mousedowntype, d20plus.cfg.openConfigEditor);
		d20plus.tool.addTools();
	};

	d20plus.ui.addQuickUiGm = () => {
		const $wrpBtnsMain = $(`#floatingtoolbar`);

		// add quick layer selection panel
		const $ulBtns = $(`<div id="floatinglayerbar"><ul/></div>`)
			.css({
				width: 30,
				position: "absolute",
				left: 10,
				top: $wrpBtnsMain.height() + 90,
				border: "1px solid #666",
				boxShadow: "1px 1px 3px #666",
				zIndex: 10600,
				backgroundColor: "rgba(255,255,255,0.80)",
			})
			.appendTo($(`#playerzone`)).find(`ul`);

		const handleClick = (clazz, evt) => $wrpBtnsMain.find(`.${clazz}`).trigger("click", evt);

		// Add layers to second side bar
		$(`<li title="${__("ui_bar_map")}" class="choosemap"><span class="pictos" style="padding: 0 3px;">G</span></li>`).appendTo($ulBtns).click((evt) => handleClick(`choosemap`, evt));
		if (d20plus.cfg.getOrDefault("canvas", "showFloors")) {
			$(`<li title="${__("ui_bar_fl")}" class="choosefloors"><span class="pictos">I</span></li>`).appendTo($ulBtns).click((evt) => handleClick(`choosefloors`, evt));
		}
		if (d20plus.cfg.getOrDefault("canvas", "showBackground")) {
			$(`<li title="${__("ui_bar_bg")}" class="choosebackground"><span class="pictos">a</span></li>`).appendTo($ulBtns).click((evt) => handleClick(`choosebackground`, evt));
		}
		$(`<li title="${__("ui_bar_obj")}" class="chooseobjects"><span class="pictos">U</span></li>`).appendTo($ulBtns).click((evt) => handleClick(`chooseobjects`, evt));
		if (d20plus.cfg.getOrDefault("canvas", "showRoofs")) {
			$(`<li title="${__("ui_bar_rf")}" class="chooseroofs"><span class="pictos">H</span></li>`).appendTo($ulBtns).click((evt) => handleClick(`chooseroofs`, evt));
		}
		if (d20plus.cfg.getOrDefault("canvas", "showForeground")) {
			$(`<li title="${__("ui_bar_fg")}" class="chooseforeground"><span class="pictos">B</span></li>`).appendTo($ulBtns).click((evt) => handleClick(`chooseforeground`, evt));
		}
		$(`<li title="GM Info Overlay" class="choosegmlayer"><span class="pictos">E</span></li>`).appendTo($ulBtns).click((evt) => handleClick(`choosegmlayer`, evt));
		$(`<li title="${__("ui_bar_barriers")}" class="choosewalls"><span class="pictostwo">r</span></li>`).appendTo($ulBtns).click((evt) => handleClick(`choosewalls`, evt));
		if (d20plus.cfg.getOrDefault("canvas", "showWeather")) {
			$(`<li title="${__("ui_bar_we")}" class="chooseweather"><span class="pictos">C</span></li>`).appendTo($ulBtns).click((evt) => handleClick(`chooseweather`, evt));
		}

		$("body").on("click", "#editinglayer li", function () {
			$("#floatinglayerbar").removeClass("map")
				.removeClass("floors")
				.removeClass("background")
				.removeClass("objects")
				.removeClass("foreground")
				.removeClass("roofs")
				.removeClass("gmlayer")
				.removeClass("walls")
				.removeClass("weather");
			setTimeout(() => {
				$("#floatinglayerbar").addClass(window.currentEditingLayer)
			}, 1);
		});

		// add "desc sort" button to init tracker
		const $initTracker = $(`#initiativewindow`);
		const addInitSortBtn = () => {
			$(`<div class="btn" id="init-quick-sort-desc" style="margin-right: 5px; padding:5px 2px;"><span class="pictos">l</span></div>`).click(() => {
				// this will throw a benign error if the settings dialog has never been opened
				$("#initiativewindow_settings .sortlist_numericdesc").click();
			}).prependTo($initTracker.parent().find(`.ui-dialog-buttonset`).parent());
		};
		const addInitResetBtn = () => { // also add "reset tracker" button
			$(`<div class="btn" id="init-quick-reset" style="margin-right: 5px; padding:5px 2px;"><span class="pictos">#</span></div>`).click(() => {
				// this will throw a benign error if the settings dialog has never been opened
				$("#initiativewindow_settings .clearlist").click();
			}).prependTo($initTracker.parent().find(`.ui-dialog-buttonset`).parent());
		};
		if (d20.Campaign.initiativewindow.model.attributes.initiativepage) {
			addInitSortBtn();
			addInitResetBtn();
		} else {
			d20.Campaign.initiativewindow.model.on("change", (e) => {
				if (d20.Campaign.initiativewindow.model.attributes.initiativepage && $(`#init-quick-sort-desc`).length === 0) {
					addInitSortBtn();
					addInitResetBtn();
					d20plus.cfg.baseHandleConfigChange();
				}
			})
		}
	};

	/**
	 * Prompt the user to choose from a list of checkboxes. By default, one checkbox can be selected, but a "count"
	 * option can be provided to allow the user to choose multiple options.
	 *
	 * @param dataArray options to choose from
	 * @param dataTitle title for the window
	 * @param displayFormatter function to format dataArray for display
	 * @param count exact number of  options the user must, mutually exclusive with countMin and countMax
	 * @param countMin lowest number of options the user must choose, requires countMax, mutually exclusive with count
	 * @param countMax highest number of options the user must choose, requires countMax, mutually exclusive with count
	 * @param additionalHTML additional html code, such as a button
	 * @param note add a note at the bottom of the window
	 * @param messageCountIncomplete message when user does not choose correct number of choices
	 * @param random show button for random choices
	 * @param randomMax Enforce max random choices
	 * @param totallyRandom select randomly number of items between countMin and countMax. Requires count to be null. This has higher priority than randomMax
	 * @return {Promise}
	 */
	d20plus.ui.chooseCheckboxList = async function (dataArray, dataTitle, {displayFormatter = null, count = null, countMin = null, countMax = null, additionalHTML = null, note = null, messageCountIncomplete = null, random = null, randomMax = null, totallyRandom = null} = {}) {
		return new Promise((resolve, reject) => {
			// Ensure count, countMin, and countMax don't mess up
			// Note if(var) is false if the number is 0. countMin is the only count allowed to be 0
			if ((Number.isInteger(count) && Number.isInteger(countMin))
			|| (Number.isInteger(count) && Number.isInteger(countMax))
			|| (count == null && (Number.isInteger(countMin) ^ Number.isInteger(countMax)))
			|| (countMin > countMax)) {
				reject(new Error("Bad arguments--count is mutually exclusive with countMin and countMax, and countMin and countMax require each other."))
			}
			const useRange = Number.isInteger(countMin) && countMax;

			// Generate the HTML
			const $dialog = $(`
				<div title="${dataTitle}">
					${Number.isInteger(count) ? `<div name="remain" class="bold">Remaining: ${count}</div>` : ""}
					${Number.isInteger(countMax) ? `<div name="remain" class="bold">Remaining: ${countMax}, Minimum: ${countMin}</div>` : ""}
					<div>
						${dataArray.map(it => `<label class="split"><span>${displayFormatter ? displayFormatter(it) : it}</span> <input data-choice="${it}" type="checkbox"></label>`).join("")}
					</div>
					${additionalHTML ? `<br><div>${additionalHTML}</div>` : ""}
					${note ? `<br><div class="italic">${note}</div>` : ""}
				</div>
			`).appendTo($("body"));
			const $remain = $dialog.find(`[name="remain"]`);
			const $cbChoices = $dialog.find(`input[type="checkbox"]`);

			// Ensure the proper number of items is chosen
			if (count != null || useRange) {
				const targetCount = count || countMax;
				const remainMin = countMax ? `, Minimum: ${countMin}` : "";
				$cbChoices.on("change", function () {
					const $e = $(this);
					let selectedCount = getSelected().length;
					if (selectedCount > targetCount) {
						$e.prop("checked", false);
						selectedCount--;
					}
					$remain.text(`Remaining: ${targetCount - selectedCount}${remainMin}`);
				});
			}

			function getSelected () {
				return $cbChoices.map((i, e) => ({choice: $(e).data("choice"), selected: $(e).prop("checked")})).get()
					.filter(it => it.selected).map(it => it.choice);
			}

			// Accept or reject selection
			$dialog.dialog({
				dialogClass: "no-close",
				buttons: [
					{
						text: "Cancel",
						click: function () {
							$(this).dialog("close");
							$dialog.remove();
							reject(new Error(`User cancelled the prompt`));
						},
					},
					(random ? {
						text: "Choose randomly",
						click: function () {
							document.querySelectorAll("input[type=checkbox]").forEach(el => el.checked = false);
							let alreadySelected = [];
							if (count != null) {
								for (let i = 0; i < count; i++) {
									let randomSelection = dataArray[Math.floor(Math.random() * dataArray.length)];
									while (alreadySelected.includes(randomSelection)) {
										randomSelection = dataArray[Math.floor(Math.random() * dataArray.length)];
									}
									alreadySelected.push(randomSelection);
									let chkbx = document.querySelector(`[data-choice="${randomSelection}"]`);
									chkbx.checked = true;
								}
							} else {
								let loops;
								if (totallyRandom) {
									loops = Math.floor(Math.random() * (countMax - countMin + 1) + countMin);
								} else {
									loops = randomMax ? countMax : countMin;
								}

								for (let i = 0; i < loops; i++) {
									let randomSelection = dataArray[Math.floor(Math.random() * dataArray.length)];
									if (randomMax) {
										while (alreadySelected.includes(randomSelection)) {
											randomSelection = dataArray[Math.floor(Math.random() * dataArray.length)];
										}
									}
									alreadySelected.push(randomSelection);
									let chkbx = document.querySelector(`[data-choice="${randomSelection}"]`);
									chkbx.checked = true;
								}
							}
						},
					} : null),
					{
						text: "OK",
						click: function () {
							const selected = getSelected();
							if (Number.isInteger(countMin) && countMax && count == null && selected.length >= countMin && selected.length <= countMax) {
								$(this).dialog("close");
								$dialog.remove();
								resolve(selected);
							} else if (!useRange && (selected.length === count || count == null)) {
								$(this).dialog("close");
								$dialog.remove();
								resolve(selected);
							} else {
								alert(messageCountIncomplete ?? "Please select more options!");
							}
						},
					},
				].filter(Boolean),
			})
		});
	};

	/**
	 * Prompt the user to choose from a list of radios. Radio button allow exactly one choice.
	 *
	 * @param dataArray options to choose from
	 * @param dataTitle title for the window
	 * @param displayFormatter function to format dataArray for display
	 * @param random show button for random choices
	 * @param additionalHTML additional html code, such as a button
	 * @param note add a note at the bottom of the window
	 * @param messageCountIncomplete message when user does not choose correct number of choices
	 * @return {Promise}
	 */
	d20plus.ui.chooseRadioList = async function (dataArray, dataTitle, {displayFormatter = null, random = null, additionalHTML = null, note = null, messageCountIncomplete = null} = {}) {
		return new Promise((resolve, reject) => {
			// Generate the HTML
			const $dialog = $(`
				<div title="${dataTitle}">
					<div>
						${dataArray.map(it => `<label class="split"><span>${displayFormatter ? displayFormatter(it) : it}</span> <input data-choice="${it}" type="radio" name="${dataTitle}"></label>`).join("")}
					</div>
					${additionalHTML ? `<br><div>${additionalHTML}</div>` : ""}
					${note ? `<br><div class="italic">${note}</div>` : ""}
				</div>
			`).appendTo($("body"));
			const $remain = $dialog.find(`[name="remain"]`);
			const $cbChoices = $dialog.find(`input[type="radio"]`);

			function getSelected () {
				return $cbChoices.map((i, e) => ({choice: $(e).data("choice"), selected: $(e).prop("checked")})).get()
					.filter(it => it.selected).map(it => it.choice);
			}

			// Accept or reject selection
			$dialog.dialog({
				dialogClass: "no-close",
				buttons: [
					{
						text: "Cancel",
						click: function () {
							$(this).dialog("close");
							$dialog.remove();
							reject(new Error(`User cancelled the prompt`));
						},
					},
					(random ? {
						text: "Choose randomly",
						click: function () {
							const randomSelection = dataArray[Math.floor(Math.random() * dataArray.length)];
							const radio = document.querySelector(`[data-choice="${randomSelection}"]`);
							radio.checked = true;
						},
					} : null),
					{
						text: "OK",
						click: function () {
							const selected = getSelected();
							if (selected.length === 1) {
								$(this).dialog("close");
								$dialog.remove();
								resolve(selected);
							} else if (!useRange && (selected.length === count || count == null)) {
								$(this).dialog("close");
								$dialog.remove();
								resolve(selected);
							} else {
								alert(messageCountIncomplete ?? "Please an option!");
							}
						},
					},
				].filter(Boolean),
			})
		});
	};
}

SCRIPT_EXTENSIONS.push(baseUi);


/**
 * All the modified minified based on parts of Roll20's `app.js`
 */
function d20plusMod () {
	d20plus.mod = {};

	d20plus.mod.setMode = function (t) {
		d20plus.ut.log(`Setting mode ${t}`);
		const preserveDrawingColor = (stash) => {
			const drawingTools = ["rect", "ellipse", "text", "path", "polygon"];
			const drawingProps = [{nm: "fill", el: "fillcolor"}, {nm: "color", el: "strokecolor"}];
			if (!drawingTools.includes(t)) return;
			drawingProps.forEach(prop => {
				if (stash) d20plus.mod[`drawing${prop.nm}`] = d20.engine.canvas.freeDrawingBrush[prop.nm];
				else {
					if (d20plus.mod[`drawingcolor`] === "rgb(0, 0, 0)" || !d20plus.mod[`drawingcolor`]) return;
					$(`#path_${prop.el}`).val(d20plus.mod[`drawing${prop.nm}`]).trigger("change");
				}
			});
		}
		try {
			preserveDrawingColor(true);
			d20.Campaign.activePage().setModeRef(t);
			preserveDrawingColor();
		} catch (e) {
			d20plus.ut.log(`Switching using legacy because ${e.message}`);
			d20plus.mod.setModeLegacy(t);
		}
	}

	// modified to allow players to use the FX tool, and to keep current colour selections when switching tool
	/* eslint-disable */
	// BEGIN ROLL20 CODE
	d20plus.mod.setModeLegacy = function (e) {
		// BEGIN MOD
		// "text" === e || "rect" === e || "ellipse" === e || "polygon" === e || "path" === e || "pan" === e || "select" === e || "targeting" === e || "measure" === e || window.is_gm || (e = "select"),
		// END MOD
		"text" == e ? $("#editor").addClass("texteditmode") : $("#editor").removeClass("texteditmode"),
			$("#floatingtoolbar li").removeClass("activebutton"),
			$("#" + e).addClass("activebutton"),
		"fog" == e.substring(0, 3) && $("#fogcontrols").addClass("activebutton");

		const drawingTools = ["rect", "ellipse", "text", "path", "polygon", "line_splitter"];
		if (drawingTools.includes(e)) {
			if ("ellipse" == e) $('#drawingtools span.subicon').addClass('fas fa-circle');
			else $('#drawingtools span.subicon').removeClass('fas fa-circle');
			$("#drawingtools").addClass("activebutton").removeClass("text rect ellipse path polygon line_splitter");
			"rect" == e && $("#drawingtools").addClass("rect");
			"ellipse" == e && $("#drawingtools").addClass("ellipse");
			"text" == e && $("#drawingtools").addClass("activebutton").removeClass("rect ellipse path polygon line_splitter").addClass("text");
			"path" == e && $("#drawingtools").addClass("path");
			"polygon" == e && $("#drawingtools").addClass("polygon");
			// BEGIN MOD (also line_splitter added to above removeClass calls
			"line_splitter" == e && $("#drawingtools").addClass("line_splitter");
			// END MOD
		}
		"polygon" != e && d20.engine.finishCurrentPolygon();

		"pan" !== e && "select" !== e && d20.engine.unselect(),
			"pan" == e ? ($("#select").addClass("pan").removeClass("select").addClass("activebutton"),
				d20.token_editor.removeRadialMenu(),
				$("#editor-wrapper").addClass("panning")) : $("#editor-wrapper").removeClass("panning"),
		"select" == e && $("#select").addClass("select").removeClass("pan").addClass("activebutton"),
			$("#floatingtoolbar .mode").hide(),
		("text" == e || "select" == e) && $("#floatingtoolbar ." + e).show(),
			"gridalign" == e ? $("#gridaligninstructions").show() : "gridalign" === d20.engine.mode && $("#gridaligninstructions").hide(),
			"targeting" === e ? ($("#targetinginstructions").show(),
				$("#finalcanvas").addClass("targeting"),
				d20.engine.canvas.hoverCursor = "crosshair") : "targeting" === d20.engine.mode && ($("#targetinginstructions").hide(),
				$("#finalcanvas").removeClass("targeting"),
			d20.engine.nextTargetCallback && _.defer(function () {
				d20.engine.nextTargetCallback && d20.engine.nextTargetCallback(!1)
			}),
				d20.engine.canvas.hoverCursor = "move"),
			// BEGIN MOD
			d20.engine.mode = e,
		"measure" !== e && window.currentPlayer && d20.engine.measurements[window.currentPlayer.id] && !d20.engine.measurements[window.currentPlayer.id].sticky && (d20.engine.announceEndMeasure({
			player: window.currentPlayer.id
		}),
			d20.engine.endMeasure()),
			d20.engine.canvas.isDrawingMode = "path" == e ? !0 : !1;
		if ("text" == e || "path" == e || "rect" == e || "ellipse" == e || "polygon" == e || "fxtools" == e) {
			$("#secondary-toolbar").show();
			$("#secondary-toolbar .mode").hide();
			$("#secondary-toolbar ." + e).show();
			("path" == e || "rect" == e || "ellipse" == e || "polygon" == e) && ("" === $("#path_strokecolor").val() && ($("#path_strokecolor").val("#000000").trigger("change-silent"),
				$("#path_fillcolor").val("transparent").trigger("change-silent")),
				d20.engine.canvas.freeDrawingBrush.color = $("#path_strokecolor").val(),
				d20.engine.canvas.freeDrawingBrush.fill = $("#path_fillcolor").val() || "transparent",
				$("#path_width").trigger("change")),
			"fxtools" == e && "" === $("#fxtools_color").val() && $("#fxtools_color").val("#a61c00").trigger("change-silent"),
				$("#floatingtoolbar").trigger("blur")
		} else {
			$("#secondary-toolbar").hide();
			$("#floatingtoolbar").trigger("blur");
		}
		// END MOD
		'placelight' === e ? ($('#placelight').addClass('activebutton'), $('#babylonCanvas').addClass('torch-cursor')) : $('#babylonCanvas').removeClass('torch-cursor'),
		'placeWindow' === e ? ($('#placeWindow').addClass('activebutton'), $('#babylonCanvas').addClass('window-cursor')) : $('#babylonCanvas').removeClass('window-cursor'),
		'placeDoor' === e ? ($('#placeDoor').addClass('activebutton'), $('#babylonCanvas').addClass('door-cursor')) : $('#babylonCanvas').removeClass('door-cursor'),
		d20.engine.redrawScreenNextTick()
	};
	// END ROLL20 CODE

	d20plus.mod.overwriteStatusEffects = function () {
		d20.engine.canvasDirty = true;
		d20.engine.canvasTopDirty = true;
		d20.engine.canvas._objects.forEach(it => {
			// avoid adding it to any objects that wouldn't have it to begin with
			if (!it.model || !it.model.view || !it.model.view.updateBackdrops) return;

			// BEGIN ROLL20 CODE
			it.model.view.updateBackdrops = function (e) {
				if (!this.nohud && ("objects" == this.model.get("layer") || "gmlayer" == this.model.get("layer")) && "image" == this.model.get("type") && this.model && this.model.collection && this.graphic) {
					// BEGIN MOD
					const scaleFact = (d20plus.cfg.get("canvas", "scaleNamesStatuses") && d20.Campaign.activePage().get("snapping_increment"))
						? d20.Campaign.activePage().get("snapping_increment")
						: 1;
					// END MOD
					var t = this.model.collection.page
						, n = e || d20.engine.canvas.getContext();
					n.save(),
					(this.graphic.get("flipX") || this.graphic.get("flipY")) && n.scale(this.graphic.get("flipX") ? -1 : 1, this.graphic.get("flipY") ? -1 : 1);
					var i = this
						, r = Math.floor(this.graphic.get("width") / 2)
						, o = Math.floor(this.graphic.get("height") / 2)
						, a = (parseFloat(t.get("scale_number")),
						this.model.get("statusmarkers").split(","));
					-1 !== a.indexOf("dead") && (n.strokeStyle = "rgba(189,13,13,0.60)",
						n.lineWidth = 10,
						n.beginPath(),
						n.moveTo(-r + 7, -o + 15),
						n.lineTo(r - 7, o - 5),
						n.moveTo(r - 7, -o + 15),
						n.lineTo(-r + 7, o - 5),
						n.closePath(),
						n.stroke()),
						n.rotate(-this.graphic.get("angle") * Math.PI / 180),
						n.strokeStyle = "rgba(0,0,0,0.65)",
						n.lineWidth = 1;
					var s = 0
						, l = i.model.get("bar1_value")
						, c = i.model.get("bar1_max");
					if ("" != c && (window.is_gm || this.model.get("showplayers_bar1") || this.model.currentPlayerControls() && this.model.get("playersedit_bar1"))) {
						var u = parseInt(l, 10) / parseInt(c, 10)
							, d = -o - 20 + 0;
						n.fillStyle = "rgba(" + d20.Campaign.tokendisplay.bar1_rgb + ",0.75)",
							n.beginPath(),
							n.rect(-r + 3, d, Math.floor((2 * r - 6) * u), 8),
							n.closePath(),
							n.fill(),
							n.beginPath(),
							n.rect(-r + 3, d, 2 * r - 6, 8),
							n.closePath(),
							n.stroke(),
							s++
					}
					var l = i.model.get("bar2_value")
						, c = i.model.get("bar2_max");
					if ("" != c && (window.is_gm || this.model.get("showplayers_bar2") || this.model.currentPlayerControls() && this.model.get("playersedit_bar2"))) {
						var u = parseInt(l, 10) / parseInt(c, 10)
							, d = -o - 20 + 12;
						n.fillStyle = "rgba(" + d20.Campaign.tokendisplay.bar2_rgb + ",0.75)",
							n.beginPath(),
							n.rect(-r + 3, d, Math.floor((2 * r - 6) * u), 8),
							n.closePath(),
							n.fill(),
							n.beginPath(),
							n.rect(-r + 3, d, 2 * r - 6, 8),
							n.closePath(),
							n.stroke(),
							s++
					}
					var l = i.model.get("bar3_value")
						, c = i.model.get("bar3_max");
					if ("" != c && (window.is_gm || this.model.get("showplayers_bar3") || this.model.currentPlayerControls() && this.model.get("playersedit_bar3"))) {
						var u = parseInt(l, 10) / parseInt(c, 10)
							, d = -o - 20 + 24;
						n.fillStyle = "rgba(" + d20.Campaign.tokendisplay.bar3_rgb + ",0.75)",
							n.beginPath(),
							n.rect(-r + 3, d, Math.floor((2 * r - 6) * u), 8),
							n.closePath(),
							n.fill(),
							n.beginPath(),
							n.rect(-r + 3, d, 2 * r - 6, 8),
							n.closePath(),
							n.stroke()
					}
					var h, p, g = 1, f = !1;
					switch (d20.Campaign.get("markers_position")) {
						case "bottom":
							h = o - 10,
								p = r;
							break;
						case "left":
							h = -o - 10,
								p = -r,
								f = !0;
							break;
						case "right":
							h = -o - 10,
								p = r - 18,
								f = !0;
							break;
						default:
							h = -o + 10,
								p = r
					}
					// BEGIN MOD
					n.strokeStyle = "white";
					n.lineWidth = 3 * scaleFact;
					const scaledFont = 14 * scaleFact;
					n.font = "bold " + scaledFont + "px Arial";
					// END MOD
					_.each(a, function (e) {
						var t = d20.token_editor.statusmarkers[e.split("@")[0]];
						if (!t)
							return !0;
						if ("dead" === e)
							return !0;
						var i = 0;
						if (g--,
						"#" === t.substring(0, 1))
							n.fillStyle = t,
								n.beginPath(),
								f ? h += 16 : p -= 16,
								n.arc(p + 8, f ? h + 4 : h, 6, 0, 2 * Math.PI, !0),
								n.closePath(),
								n.stroke(),
								n.fill(),
								i = f ? 10 : 4;
						else {
							// BEGIN MOD
							if (!d20.token_editor.statussheet_ready) return;
							const scaledWH = 21 * scaleFact;
							const scaledOffset = 22 * scaleFact;
							f ? h += scaledOffset : p -= scaledOffset;

							if (d20.engine.canvasZoom <= 1) {
								n.drawImage(d20.token_editor.statussheet_small, parseInt(t, 10), 0, 21, 21, p, h - 9, scaledWH, scaledWH);
							} else {
								n.drawImage(d20.token_editor.statussheet, parseInt(t, 10), 0, 24, 24, p, h - 9, scaledWH, scaledWH)
							}

							i = f ? 14 : 12;
							i *= scaleFact;
							// END MOD
						}
						if (-1 !== e.indexOf("@")) {
							var r = e.split("@")[1];
							// BEGIN MOD
							// bing backtick to "clear counter"
							if (r === "`") return;
							n.fillStyle = "rgb(222,31,31)";
							var o = f ? 9 : 14;
							o *= scaleFact;
							o -= (14 - (scaleFact * 14));
							n.strokeText(r + "", p + i, h + o);
							n.fillText(r + "", p + i, h + o);
							// END MOD
						}
					});
					var m = i.model.get("name");
					if ("" != m && 1 == this.model.get("showname") && (window.is_gm || this.model.get("showplayers_name") || this.model.currentPlayerControls() && this.model.get("playersedit_name"))) {
						n.textAlign = "center";
						// BEGIN MOD
						const fontSize = 14;
						var scaledFontSize = fontSize * scaleFact;
						const scaledY = 22 * scaleFact;
						const scaled6 = 6 * scaleFact;
						const scaled8 = 8 * scaleFact;
						n.font = "bold " + scaledFontSize + "px Arial";
						var v = n.measureText(m).width;

						/*
							Note(stormy): compatibility with R20ES's ScaleTokenNamesBySize module.
						 */
						if(window.r20es && window.r20es.drawNameplate) {
							window.r20es.drawNameplate(this.model, n, v, o, fontSize, m);
						} else {
							n.fillStyle = "rgba(255,255,255,0.50)";
							n.fillRect(-1 * Math.floor((v + scaled6) / 2), o + scaled8, v + scaled6, scaledFontSize + scaled6);
							n.fillStyle = "rgb(0,0,0)";
							n.fillText(m + "", 0, o + scaledY, v);
						}
						// END MOD
					}
					n.restore()
				}
			}
			// END ROLL20 CODE
		});
	};

	d20plus.mod.mouseEnterMarkerMenu = function () {
		var e = this;
		$(this).on("mouseover.statusiconhover", ".statusicon", function () {
			a = $(this).attr("data-action-type").replace("toggle_status_", "")
		}),
			$(document).on("keypress.statusnum", function (t) {
				// BEGIN MOD // TODO see if this clashes with keyboard shortcuts
				let currentcontexttarget = d20.engine.selected()[0];
				if ("dead" !== a && currentcontexttarget) {
					// END MOD
					var n = String.fromCharCode(t.which)
						,
						i = "" == currentcontexttarget.model.get("statusmarkers") ? [] : currentcontexttarget.model.get("statusmarkers").split(",")
						, r = (_.map(i, function (e) {
							return e.split("@")[0]
						}),
							!1);
					i = _.map(i, function (e) {
						return e.split("@")[0] == a ? (r = !0,
						a + "@" + n) : e
					}),
					r || ($(e).find(".statusicon[data-action-type=toggle_status_" + a + "]").addClass("active"),
						i.push(a + "@" + n)),
						currentcontexttarget.model.save({
							statusmarkers: i.join(",")
						})
				}
			})
	};

	// BEGIN ROLL20 CODE
	d20plus.mod.handleURL = function(e) {
		if (!($(this).hasClass("lightly") || $(this).parents(".note-editable").length > 0)) {
			var t = $(this).attr("href");
			if (void 0 === t)
				return !1;
			if (-1 !== t.indexOf("journal.roll20.net") || -1 !== t.indexOf("wiki.roll20.net")) {
				var n = t.split("/")[3]
					, i = t.split("/")[4]
					, o = d20.Campaign[n + "s"].get(i);
				if (o) {
					var r = o.get("inplayerjournals").split(",");
					(window.is_gm || -1 !== _.indexOf(r, "all") || window.currentPlayer && -1 !== _.indexOf(r, window.currentPlayer.id)) && o.view.showDialog()
				}
				return $("#existing" + n + "s").find("tr[data-" + n + "id=" + i + "]").trigger("click"),
					!1
			}
			var a = /(?:(?:http(?:s?):\/\/(?:app\.)?roll20(?:staging)?\.(?:net|local:5000)\/|^\/?)compendium\/)([^\/]+)\/([^\/#?]+)/i
				, s = t.match(a);
			if (s)
				return d20.utils.openCompendiumPage(s[1], s[2]),
					e.stopPropagation(),
					void e.preventDefault();
			if (-1 !== t.indexOf("javascript:"))
				return !1;
			if ("`" === t.substring(0, 1))
				return d20.textchat.doChatInput(t.substring(1)),
					!1;
			if ("!" === t.substring(0, 1))
				return d20.textchat.doChatInput(t),
					!1;
			if ("~" === t.substring(0, 1))
				return d20.textchat.doChatInput("%{" + t.substring(1, t.length) + "}"),
					!1;
			if (t !== undefined && ("external" === $(this).attr("rel") || -1 === t.indexOf("javascript:") && -1 !== t.indexOf("://"))) {
				// BEGIN MOD
				e.stopPropagation();
				e.preventDefault();
				window.open(t);
				// END MOD
			}
		}
	};
	// END ROLL20 CODE// RB20 EXCLUDE START

	d20plus.mod._renderAll_middleLayers = new Set(["objects", "background"]);
	d20plus.mod._renderAll_serviceLayers = new Set(["map", "floors", "walls", "gmlayer"]);
	// BEGIN ROLL20 CODE
	d20plus.mod.legacy_renderAll = function (e) {
		const t = e && e.context || this.contextContainer
			, i = this.getActiveGroup()
			, n = [d20.engine.canvasWidth / d20.engine.canvasZoom, d20.engine.canvasHeight / d20.engine.canvasZoom]
			, o = new d20.math.Rectangle(...d20.math.add(d20.engine.currentCanvasOffset, d20.math.div(n, 2)),...n,0);
		i && !window.is_gm && (i.hideResizers = !0),
			this.clipTo ? fabric.util.clipContext(this, t) : t.save();
		const r = {
			map: [],
			// BEGIN MOD
			floors: [],
			background: [],
			// END MOD
			walls: [],
			objects: [],
			// BEGIN MOD
			foreground: [],
			roofs: [],
			// END MOD
			gmlayer: []
			// BEGIN MOD
			, weather: [],
			// END MOD
			_save_map_layer: this._save_map_layer
		};
		r[Symbol.iterator] = this._layerIteratorGenerator.bind(r, e);
		const a = e && e.tokens_to_render || this._objects;
		for (let e of a)
			if (e.model) {
				const t = e.model.get("layer");
				if (!r[t])
					continue;
				r[t].push(e)
			} else
				r[window.currentEditingLayer].push(e);

		// BEGIN MOD
		// Here we get the layers and look if there's a foreground in the current map
		let layers = d20.engine.canvas._objects.map(it => it.model?.get("layer") || window.currentEditingLayer)
		const noForegroundLayer = !layers.some(it => it === 'foreground');
		// END MOD

		for (const [n,a] of r) {
			switch (a) {
				case "lighting and fog":
					d20.engine.drawHighlights(this.contextContainer), d20.dyn_fog.render({
						main_canvas: this.contextContainer.canvas
					});
					continue;
				case "grid":
					d20.canvas_overlay.drawGrid(t);
					continue;
				case "afow":
					d20.canvas_overlay.drawAFoW(d20.engine.advfowctx, d20.engine.work_canvases.floater.context);
					continue;
				// BEGIN MOD
				case "gmlayer":
					if ("gmlayer" !== window.currentEditingLayer) {
						t.globalAlpha = d20.engine.gm_layer_opacity;
					} else {
						t.globalAlpha = 1;
					}
					break;
				case "floors":
					if ("map" === window.currentEditingLayer && window.is_gm) {
						t.globalAlpha = .45;
						break
					} else {
						t.globalAlpha = 1;
						break;
					}
				case "roofs":
					if (d20plus.mod._renderAll_middleLayers.has(window.currentEditingLayer) && window.is_gm) {
						t.globalAlpha = .45;
						break;
					}
				case "background":
				case "foreground":
				case "objects":
					if (d20plus.mod._renderAll_serviceLayers.has(window.currentEditingLayer) && window.is_gm) {
						t.globalAlpha = .45;
						break
					}
				// END MOD
				default:
					t.globalAlpha = 1
			}
			_.chain(n).filter(n=>{
					let r;
					return i && n && i.contains(n) ? (n.renderingInGroup = i,
						n.hasControls = !1) : (n.renderingInGroup = null,
						n.hasControls = !0,
						"text" !== n.type && window.is_gm ? n.hideResizers = !1 : n.hideResizers = !0),
						e && e.invalid_rects ? (r = n.intersects([o]) && (n.needsToBeDrawn || n.intersects(e.invalid_rects)),
						!e.skip_prerender && n.renderPre && n.renderPre(t)) : (r = n.needsRender(o),
						(!e || !e.skip_prerender) && r && n.renderPre && n.renderPre(t, {
							should_update: !0
						})),
						r
				}
			).each(i=> {
				// BEGIN MOD
				let toRender = false;
				// END MOD

				const n = "image" === i.type.toLowerCase() && i.model.controlledByPlayer(window.currentPlayer.id)

				// BEGIN MOD
				// If there is a foreground layer, do not give "owned tokens with sight" special treatment;
				//   render them during the normal render flow (rather than skipping them)
				 const o = noForegroundLayer ? e && e.owned_with_sight_auras_only : false;
				// END MOD

				let r = i._model;
				r && d20.dyn_fog.ready() ? r = i._model.get("has_bright_light_vision") || i._model.get("has_low_light_vision") || i._model.get("has_night_vision") : r && (r = i._model.get("light_hassight")),
				// BEGIN MOD
				// We don't draw immediately the token. Instead, we mark it as "to render"
				o && (!o || n && r) || (toRender = true);

				if (toRender) {
					// For the token checked "to render", we draw them if
					//  - we're in a "render everything" call (i.e. no specific `tokens_to_render`), rather than a "render own tokens" call
					//  - there isn't a foreground layer for the map or
					//  - is everything but an object
					if (!e.tokens_to_render || noForegroundLayer || a !== 'objects') {
						this._draw(t, i);
					}
					i.renderingInGroup = null;
				}
				// END MOD
			})
		}
		return t.restore(),
			this
	};
	// END ROLL20 CODE

	// shoutouts to Roll20 for making me learn how `yield` works
	// BEGIN ROLL20 CODE
	d20plus.mod.legacy_layerIteratorGenerator = function*(e) {
		yield [this.map, "map"],
		this._save_map_layer && (d20.dyn_fog.setMapTexture(d20.engine.canvas.contextContainer),
			this._save_map_layer = !1);

		// BEGIN MOD
		yield [this.floors, "floors"];
		// END MOD

		const grid_before_afow = e && e.grid_before_afow;
		const adv_fow_disabled = !d20.Campaign.activePage().get("adv_fow_enabled") || e && e.disable_afow;
		const grid_hide = !d20.Campaign.activePage().get("showgrid") || e && e.disable_grid;

		if (grid_before_afow && !grid_hide) yield [null, "grid"];
		if (!adv_fow_disabled) yield [null, "afow"];
		if (!grid_before_afow && !grid_hide) yield [null, "grid"];

		// BEGIN MOD
		yield [this.background, "background"];
		// END MOD

		yield [this.objects, "objects"];

		// BEGIN MOD
		yield [this.roofs, "roofs"];
		yield [this.foreground, "foreground"];
		// END MOD

		if (window.is_gm) yield [this.gmlayer, "gmlayer"];

		const enable_dynamic_fog = e && e.enable_dynamic_fog;
		if (d20.dyn_fog.ready() && enable_dynamic_fog) yield [null, "lighting and fog"];

		// BEGIN MOD
		if (window.is_gm && "weather" === window.currentEditingLayer) yield [this.weather, "weather"];
		if (window.is_gm && "walls" === window.currentEditingLayer) yield [this.walls, "walls"];
		// END MOD
	};
	// END ROLL20 CODE// RB20 EXCLUDE END

	// BEGIN ROLL20 CODE
	d20plus.mod.renderAll = function(v) {
		const p = v && v.context || this.contextContainer
		  , e = this.getActiveGroup()
		  , u = this.sortTokens();
		e && !window.is_gm && (e.hideResizers = !0),
		this.clipTo ? fabric.util.clipContext(this, p) : p.save(),
		v.tokens = u.map,
		this.drawMapLayer(p, v),
		// BEGIN MOD
		v.tokens = u.floors,
		this.drawAnyLayer(p, v, "floors");
		// END MOD
		const n = v && v.grid_before_afow
		  , y = !d20.Campaign.activePage().get("adv_fow_enabled") || v && v.disable_afow
		  , d = !d20.Campaign.activePage().get("showgrid") || v && v.disable_grid;
		return n && !d && d20.canvas_overlay.drawGrid(p),
		!y && window.largefeats && d20.canvas_overlay.drawAFoW(d20.engine.advfowctx, d20.engine.work_canvases.floater.context),
		!n && !d && d20.canvas_overlay.drawGrid(p),
		// BEGIN MOD
		["background", "objects", "roofs", "foreground"].forEach(layer => {
			v.tokens = u[layer],
			this.drawAnyLayer(p, v, layer);
		}),// RB20 EXCLUDE START 
		/* this.renderAbove = function (p, v) {
			["roofs", "foreground"].forEach(layer => {
				v.tokens = u[layer],
				this.drawAnyLayer(p, v, layer);
			}),
			window.is_gm && (v.tokens = u.gmlayer,
			this.drawAnyLayer(p, v, "gmlayer"))
		},*/ // RB20 EXCLUDE END
		window.is_gm && (v.tokens = u.gmlayer,
		this.drawAnyLayer(p, v, "gmlayer")),
		window.is_gm && window.currentEditingLayer === "walls" && (v.tokens = u.walls,
		this.drawDynamicLightingLayer(p, v)),
		window.currentEditingLayer === "weather" && (v.tokens = u.weather,
		this.drawAnyLayer(p, v, "weather")),
		// END MOD
		p.restore(),
		this
	}
	// END ROLL20 CODE

	// BEGIN ROLL20 CODE
	d20plus.mod.sortTokens = function() {
		const v = {
			map: [],
			// BEGIN MOD
			floors: [],
			background: [],
			objects: [],
			roofs: [],
			foreground: [],
			gmlayer: [],
			weather: [],
			// END MOD
			walls: []
		};
		for (const p of this._objects) {
			const e = v[p.model.get("layer")];
			e && e.push(p)
		}
		return v
	}
	// END ROLL20 CODE

	d20plus.mod.setAlpha = function (layer) {
		const l = ["map", "floors", "walls", "weather", "background", "objects", "roofs", "foreground", "gmlayer"];
		const o = ["background", "objects", "foreground"];
		return !window.is_gm 
			|| (o.includes(layer) && o.includes(window.currentEditingLayer))
			|| (l.indexOf(window.currentEditingLayer) >= l.indexOf(layer)
				&& !((layer === "roofs" || o.includes(layer)) && window.currentEditingLayer === "gmlayer"))
			? 1 : (layer === "gmlayer" ? d20.engine.gm_layer_opacity : .5);
	}

	// BEGIN ROLL20 CODE
	d20plus.mod.drawAnyLayer = function(v, p={}, layer) {
		const e = p.tokens || this._objects.filter(u=>{
			const n = u.model;
			// BEGIN MOD
			return n && n.get("layer") === layer
			// END MOD
		});
		v.save(),
		// BEGIN MOD
		v.globalAlpha = d20plus.mod.setAlpha(layer),
		// END MOD
		this.drawTokenList(v, e, p),
		v.restore()
	},
	// END ROLL20 CODE

	// BEGIN ROLL20 CODE
	d20plus.mod.drawTokensWithoutAuras = function (v, p) {
		const e = this.getActiveGroup();
		v.save(),
		p.forEach(u=>{
			e && u && e.contains(u) ? (u.renderingInGroup = e,
			u.hasControls = !1) : (u.renderingInGroup = null,
			u.hasControls = !0,
			u.hideResizers = !window.is_gm);
			// BEGIN MOD
			v.globalAlpha = d20plus.mod.setAlpha(u.model.get("layer")),
			// END MOD
			u.renderPre(v, {
				noAuras: !0,
				should_update: !0
			}),
			this._draw(v, u)
		}
		),
		v.restore()
	},
	// END ROLL20 CODE

	// BEGIN ROLL20 CODE
	d20plus.mod.editingLayerOnclick = () => {
		$("#editinglayer").off(clicktype).on(clicktype, "li", function() {
			var e = $(this);
			$("#editinglayer").removeClass(window.currentEditingLayer);
			$("#drawingtools .choosepath").show();
			"polygon" !== d20.engine.mode && $("#drawingtools").hasClass("polygon") && $("#drawingtools").removeClass("polygon").addClass("path");

			// BEGIN MOD
			if (e.hasClass("chooseweather")) {
				window.currentEditingLayer = "weather";
				$("#drawingtools .choosepath").hide();
				"path" !== d20.engine.mode && $("#drawingtools").removeClass("path").addClass("polygon")
			} else {
				e.hasClass("choosebackground") ? window.currentEditingLayer = "background" : e.hasClass("chooseroofs") ? window.currentEditingLayer = "roofs" : e.hasClass("choosefloors") ? window.currentEditingLayer = "floors" : e.hasClass("chooseforeground") ? window.currentEditingLayer = "foreground" : e.hasClass("chooseobjects") ? window.currentEditingLayer = "objects" : e.hasClass("choosemap") ? window.currentEditingLayer = "map" : e.hasClass("choosegmlayer") ? window.currentEditingLayer = "gmlayer" : e.hasClass("choosewalls") && (window.currentEditingLayer = "walls",
					$("#drawingtools .choosepath").hide(),
				"path" !== d20.engine.mode && $("#drawingtools").removeClass("path").addClass("polygon"));
			}
			// END MOD
			$("#editinglayer").addClass(window.currentEditingLayer);
			// BEGIN MOD
			d20.Campaign.activePage().onLayerChange();
			// END MOD
		});
	};
	// END ROLL20 CODE

	// prevent prototype methods from breaking some poorly-written property loops
	d20plus.mod.fixHexMethods = () => {
		try {
			// BEGIN ROLL20 CODE
			HT.Grid.prototype.GetHexAt = function(e) {
				// BEGIN MOD
				for (const t of this.Hexes)
					if (t.Contains(e))
						return t;
				// END MOD
				return null
			};
			// END ROLL20 CODE
		} catch (ignored) {
			console.error(ignored)
		}

		try {
			// BEGIN ROLL20 CODE
			HT.Grid.prototype.GetHexById = function(e) {
				// BEGIN MOD
				for (const t of this.Hexes)
					if (t.Id == e)
						return t;
				// END MOD
				return null
			};
			// END ROLL20 CODE
		} catch (ignored) {
			console.error(ignored)
		}
	};

	// prevent prototype methods from breaking some poorly-written property loops
	d20plus.mod.fixVideoMethods = () => {
		const arr = [];
		for (const k in arr) {
			const v = arr[k];
			if (typeof v === "function") {
				v.getReceiver = v.getReceiver || (() => null);
				v.getSender = v.getSender || (() => null);
			}
		}
	};

	/* eslint-enable */
}

SCRIPT_EXTENSIONS.push(d20plusMod);


const baseMacro = function () {
	d20plus.macro = {};

	d20plus.macro.actionMacroTrait = function (index) {
		return `@{selected|wtype} &{template:npcaction} {{name=@{selected|npc_name}}} {{rname=@{selected|repeating_npctrait_$${index}_name}}} {{description=@{selected|repeating_npctrait_$${index}_desc} }}`;
	};

	d20plus.macro.actionMacroAction = function (baseAction, index) {
		return `%{selected|${baseAction}_$${index}_npc_action}`;
	};

	d20plus.macro.actionMacroReaction = function (index) {
		return `@{selected|wtype} &{template:npcaction} {{name=@{selected|npc_name}}} {{rname=@{selected|repeating_npcreaction_$${index}_name}}} {{description=@{selected|repeating_npcreaction_$${index}_desc} }} `;
	};

	d20plus.macro.actionMacroLegendary = function (tokenactiontext) {
		return `@{selected|wtype} @{selected|wtype}&{template:npcaction} {{name=@{selected|npc_name}}} {{rname=Legendary Actions}} {{description=The @{selected|npc_name} can take @{selected|npc_legendary_actions} legendary actions, choosing from the options below. Only one legendary option can be used at a time and only at the end of another creature's turn. The @{selected|npc_name} regains spent legendary actions at the start of its turn.\n\r${tokenactiontext}}} `;
	}

	d20plus.macro.actionMacroMythic = function (tokenactiontext) {
		return `@{selected|wtype} @{selected|wtype}&{template:npcaction} {{name=@{selected|npc_name}}} {{rname=Mythic Actions}} {{description=The @{selected|npc_name} can take @{selected|npc_legendary_actions} mythic actions, choosing from the options below. Only one mythic option can be used at a time and only at the end of another creature's turn. The @{selected|npc_name} regains spent mythic actions at the start of its turn.\n\r${tokenactiontext}}} `;
	}

	d20plus.macro.actionMacroPerception = "%{Selected|npc_perception} @{selected|wtype} &{template:default} {{name=Senses}}  @{selected|wtype} @{Selected|npc_senses} ";
	d20plus.macro.actionMacroInit = "%{selected|npc_init}";
	d20plus.macro.actionMacroDrImmunities = "@{selected|wtype} &{template:default} {{name=DR/Immunities}} {{Damage Resistance= @{selected|npc_resistances}}} {{Damage Vulnerability= @{selected|npc_vulnerabilities}}} {{Damage Immunity= @{selected|npc_immunities}}} {{Condition Immunity= @{selected|npc_condition_immunities}}} ";
	d20plus.macro.actionMacroStats = "@{selected|wtype} &{template:default} {{name=Stats}} {{Armor Class= @{selected|npc_AC}}} {{Hit Dice= @{selected|npc_hpformula}}} {{Speed= @{selected|npc_speed}}} {{Senses= @{selected|npc_senses}}} {{Languages= @{selected|npc_languages}}} {{Challenge= @{selected|npc_challenge}(@{selected|npc_xp}xp)}}";
	d20plus.macro.actionMacroSaves = "@{selected|wtype} &{template:simple}{{always=1}}?{Saving Throw?|STR,{{rname=Strength Save&#125;&#125;{{mod=@{npc_str_save}&#125;&#125; {{r1=[[1d20+@{npc_str_save}]]&#125;&#125;{{r2=[[1d20+@{npc_str_save}]]&#125;&#125;|DEX,{{rname=Dexterity Save&#125;&#125;{{mod=@{npc_dex_save}&#125;&#125; {{r1=[[1d20+@{npc_dex_save}]]&#125;&#125;{{r2=[[1d20+@{npc_dex_save}]]&#125;&#125;|CON,{{rname=Constitution Save&#125;&#125;{{mod=@{npc_con_save}&#125;&#125; {{r1=[[1d20+@{npc_con_save}]]&#125;&#125;{{r2=[[1d20+@{npc_con_save}]]&#125;&#125;|INT,{{rname=Intelligence Save&#125;&#125;{{mod=@{npc_int_save}&#125;&#125; {{r1=[[1d20+@{npc_int_save}]]&#125;&#125;{{r2=[[1d20+@{npc_int_save}]]&#125;&#125;|WIS,{{rname=Wisdom Save&#125;&#125;{{mod=@{npc_wis_save}&#125;&#125; {{r1=[[1d20+@{npc_wis_save}]]&#125;&#125;{{r2=[[1d20+@{npc_wis_save}]]&#125;&#125;|CHA,{{rname=Charisma Save&#125;&#125;{{mod=@{npc_cha_save}&#125;&#125; {{r1=[[1d20+@{npc_cha_save}]]&#125;&#125;{{r2=[[1d20+@{npc_cha_save}]]&#125;&#125;}{{charname=@{character_name}}} ";
	d20plus.macro.actionMacroSkillCheck = "@{selected|wtype} &{template:simple}{{always=1}}?{Ability?|Acrobatics,{{rname=Acrobatics&#125;&#125;{{mod=@{npc_acrobatics}&#125;&#125; {{r1=[[1d20+@{npc_acrobatics}]]&#125;&#125;{{r2=[[1d20+@{npc_acrobatics}]]&#125;&#125;|Animal Handling,{{rname=Animal Handling&#125;&#125;{{mod=@{npc_animal_handling}&#125;&#125; {{r1=[[1d20+@{npc_animal_handling}]]&#125;&#125;{{r2=[[1d20+@{npc_animal_handling}]]&#125;&#125;|Arcana,{{rname=Arcana&#125;&#125;{{mod=@{npc_arcana}&#125;&#125; {{r1=[[1d20+@{npc_arcana}]]&#125;&#125;{{r2=[[1d20+@{npc_arcana}]]&#125;&#125;|Athletics,{{rname=Athletics&#125;&#125;{{mod=@{npc_athletics}&#125;&#125; {{r1=[[1d20+@{npc_athletics}]]&#125;&#125;{{r2=[[1d20+@{npc_athletics}]]&#125;&#125;|Deception,{{rname=Deception&#125;&#125;{{mod=@{npc_deception}&#125;&#125; {{r1=[[1d20+@{npc_deception}]]&#125;&#125;{{r2=[[1d20+@{npc_deception}]]&#125;&#125;|History,{{rname=History&#125;&#125;{{mod=@{npc_history}&#125;&#125; {{r1=[[1d20+@{npc_history}]]&#125;&#125;{{r2=[[1d20+@{npc_history}]]&#125;&#125;|Insight,{{rname=Insight&#125;&#125;{{mod=@{npc_insight}&#125;&#125; {{r1=[[1d20+@{npc_insight}]]&#125;&#125;{{r2=[[1d20+@{npc_insight}]]&#125;&#125;|Intimidation,{{rname=Intimidation&#125;&#125;{{mod=@{npc_intimidation}&#125;&#125; {{r1=[[1d20+@{npc_intimidation}]]&#125;&#125;{{r2=[[1d20+@{npc_intimidation}]]&#125;&#125;|Investigation,{{rname=Investigation&#125;&#125;{{mod=@{npc_investigation}&#125;&#125; {{r1=[[1d20+@{npc_investigation}]]&#125;&#125;{{r2=[[1d20+@{npc_investigation}]]&#125;&#125;|Medicine,{{rname=Medicine&#125;&#125;{{mod=@{npc_medicine}&#125;&#125; {{r1=[[1d20+@{npc_medicine}]]&#125;&#125;{{r2=[[1d20+@{npc_medicine}]]&#125;&#125;|Nature,{{rname=Nature&#125;&#125;{{mod=@{npc_nature}&#125;&#125; {{r1=[[1d20+@{npc_nature}]]&#125;&#125;{{r2=[[1d20+@{npc_nature}]]&#125;&#125;|Perception,{{rname=Perception&#125;&#125;{{mod=@{npc_perception}&#125;&#125; {{r1=[[1d20+@{npc_perception}]]&#125;&#125;{{r2=[[1d20+@{npc_perception}]]&#125;&#125;|Performance,{{rname=Performance&#125;&#125;{{mod=@{npc_performance}&#125;&#125; {{r1=[[1d20+@{npc_performance}]]&#125;&#125;{{r2=[[1d20+@{npc_performance}]]&#125;&#125;|Persuasion,{{rname=Persuasion&#125;&#125;{{mod=@{npc_persuasion}&#125;&#125; {{r1=[[1d20+@{npc_persuasion}]]&#125;&#125;{{r2=[[1d20+@{npc_persuasion}]]&#125;&#125;|Religion,{{rname=Religion&#125;&#125;{{mod=@{npc_religion}&#125;&#125; {{r1=[[1d20+@{npc_religion}]]&#125;&#125;{{r2=[[1d20+@{npc_religion}]]&#125;&#125;|Sleight of Hand,{{rname=Sleight of Hand&#125;&#125;{{mod=@{npc_sleight_of_hand}&#125;&#125; {{r1=[[1d20+@{npc_sleight_of_hand}]]&#125;&#125;{{r2=[[1d20+@{npc_sleight_of_hand}]]&#125;&#125;|Stealth,{{rname=Stealth&#125;&#125;{{mod=@{npc_stealth}&#125;&#125; {{r1=[[1d20+@{npc_stealth}]]&#125;&#125;{{r2=[[1d20+@{npc_stealth}]]&#125;&#125;|Survival,{{rname=Survival&#125;&#125;{{mod=@{npc_survival}&#125;&#125; {{r1=[[1d20+@{npc_survival}]]&#125;&#125;{{r2=[[1d20+@{npc_survival}]]&#125;&#125;}{{charname=@{character_name}}} ";
	d20plus.macro.actionMacroAbilityCheck = "@{selected|wtype} &{template:simple}{{always=1}}?{Ability?|STR,{{rname=Strength&#125;&#125;{{mod=@{strength_mod}&#125;&#125; {{r1=[[1d20+@{strength_mod}]]&#125;&#125;{{r2=[[1d20+@{strength_mod}]]&#125;&#125;|DEX,{{rname=Dexterity&#125;&#125;{{mod=@{dexterity_mod}&#125;&#125; {{r1=[[1d20+@{dexterity_mod}]]&#125;&#125;{{r2=[[1d20+@{dexterity_mod}]]&#125;&#125;|CON,{{rname=Constitution&#125;&#125;{{mod=@{constitution_mod}&#125;&#125; {{r1=[[1d20+@{constitution_mod}]]&#125;&#125;{{r2=[[1d20+@{constitution_mod}]]&#125;&#125;|INT,{{rname=Intelligence&#125;&#125;{{mod=@{intelligence_mod}&#125;&#125; {{r1=[[1d20+@{intelligence_mod}]]&#125;&#125;{{r2=[[1d20+@{intelligence_mod}]]&#125;&#125;|WIS,{{rname=Wisdom&#125;&#125;{{mod=@{wisdom_mod}&#125;&#125; {{r1=[[1d20+@{wisdom_mod}]]&#125;&#125;{{r2=[[1d20+@{wisdom_mod}]]&#125;&#125;|CHA,{{rname=Charisma&#125;&#125;{{mod=@{charisma_mod}&#125;&#125; {{r1=[[1d20+@{charisma_mod}]]&#125;&#125;{{r2=[[1d20+@{charisma_mod}]]&#125;&#125;}{{charname=@{character_name}}} ";
};

SCRIPT_EXTENSIONS.push(baseMacro);


const baseChatEmoji = function () {
	d20plus.chat = d20plus.chat || {};

	/* eslint-disable */

	// to dump the keys as one-per-line colon-fotmatted: `JSON.stringify(Object.keys(d20plus.chat.emojiIndex).sort(SortUtil.ascSortLower), null, 1).replace(/",/g, ":").replace(/"/g, ":").replace(/[ \[\]]/g, "").trim()`
	d20plus.chat.emojiIndex = {
		joy: !0,
		heart: !0,
		heart_eyes: !0,
		sob: !0,
		blush: !0,
		unamused: !0,
		kissing_heart: !0,
		two_hearts: !0,
		weary: !0,
		ok_hand: !0,
		pensive: !0,
		smirk: !0,
		grin: !0,
		recycle: !0,
		wink: !0,
		thumbsup: !0,
		pray: !0,
		relieved: !0,
		notes: !0,
		flushed: !0,
		raised_hands: !0,
		see_no_evil: !0,
		cry: !0,
		sunglasses: !0,
		v: !0,
		eyes: !0,
		sweat_smile: !0,
		sparkles: !0,
		sleeping: !0,
		smile: !0,
		purple_heart: !0,
		broken_heart: !0,
		expressionless: !0,
		sparkling_heart: !0,
		blue_heart: !0,
		confused: !0,
		information_desk_person: !0,
		stuck_out_tongue_winking_eye: !0,
		disappointed: !0,
		yum: !0,
		neutral_face: !0,
		sleepy: !0,
		clap: !0,
		cupid: !0,
		heartpulse: !0,
		revolving_hearts: !0,
		arrow_left: !0,
		speak_no_evil: !0,
		kiss: !0,
		point_right: !0,
		cherry_blossom: !0,
		scream: !0,
		fire: !0,
		rage: !0,
		smiley: !0,
		tada: !0,
		tired_face: !0,
		camera: !0,
		rose: !0,
		stuck_out_tongue_closed_eyes: !0,
		muscle: !0,
		skull: !0,
		sunny: !0,
		yellow_heart: !0,
		triumph: !0,
		new_moon_with_face: !0,
		laughing: !0,
		sweat: !0,
		point_left: !0,
		heavy_check_mark: !0,
		heart_eyes_cat: !0,
		grinning: !0,
		mask: !0,
		green_heart: !0,
		wave: !0,
		persevere: !0,
		heartbeat: !0,
		arrow_forward: !0,
		arrow_backward: !0,
		arrow_right_hook: !0,
		leftwards_arrow_with_hook: !0,
		crown: !0,
		kissing_closed_eyes: !0,
		stuck_out_tongue: !0,
		disappointed_relieved: !0,
		innocent: !0,
		headphones: !0,
		white_check_mark: !0,
		confounded: !0,
		arrow_right: !0,
		angry: !0,
		grimacing: !0,
		star2: !0,
		gun: !0,
		raising_hand: !0,
		thumbsdown: !0,
		dancer: !0,
		musical_note: !0,
		no_mouth: !0,
		dizzy: !0,
		fist: !0,
		point_down: !0,
		red_circle: !0,
		no_good: !0,
		boom: !0,
		thought_balloon: !0,
		tongue: !0,
		poop: !0,
		cold_sweat: !0,
		gem: !0,
		ok_woman: !0,
		pizza: !0,
		joy_cat: !0,
		sun_with_face: !0,
		leaves: !0,
		sweat_drops: !0,
		penguin: !0,
		zzz: !0,
		walking: !0,
		airplane: !0,
		balloon: !0,
		star: !0,
		ribbon: !0,
		ballot_box_with_check: !0,
		worried: !0,
		underage: !0,
		fearful: !0,
		four_leaf_clover: !0,
		hibiscus: !0,
		microphone: !0,
		open_hands: !0,
		ghost: !0,
		palm_tree: !0,
		bangbang: !0,
		nail_care: !0,
		x: !0,
		alien: !0,
		bow: !0,
		cloud: !0,
		soccer: !0,
		angel: !0,
		dancers: !0,
		exclamation: !0,
		snowflake: !0,
		point_up: !0,
		kissing_smiling_eyes: !0,
		rainbow: !0,
		crescent_moon: !0,
		heart_decoration: !0,
		gift_heart: !0,
		gift: !0,
		beers: !0,
		anguished: !0,
		earth_africa: !0,
		movie_camera: !0,
		anchor: !0,
		zap: !0,
		heavy_multiplication_x: !0,
		runner: !0,
		sunflower: !0,
		earth_americas: !0,
		bouquet: !0,
		dog: !0,
		moneybag: !0,
		herb: !0,
		couple: !0,
		fallen_leaf: !0,
		tulip: !0,
		birthday: !0,
		cat: !0,
		coffee: !0,
		dizzy_face: !0,
		point_up_2: !0,
		open_mouth: !0,
		hushed: !0,
		basketball: !0,
		christmas_tree: !0,
		ring: !0,
		full_moon_with_face: !0,
		astonished: !0,
		two_women_holding_hands: !0,
		money_with_wings: !0,
		crying_cat_face: !0,
		hear_no_evil: !0,
		dash: !0,
		cactus: !0,
		hotsprings: !0,
		telephone: !0,
		maple_leaf: !0,
		princess: !0,
		massage: !0,
		love_letter: !0,
		trophy: !0,
		person_frowning: !0,
		us: !0,
		confetti_ball: !0,
		blossom: !0,
		lips: !0,
		fries: !0,
		doughnut: !0,
		frowning: !0,
		ocean: !0,
		bomb: !0,
		ok: !0,
		cyclone: !0,
		rocket: !0,
		umbrella: !0,
		couplekiss: !0,
		couple_with_heart: !0,
		lollipop: !0,
		clapper: !0,
		pig: !0,
		smiling_imp: !0,
		imp: !0,
		bee: !0,
		kissing_cat: !0,
		anger: !0,
		musical_score: !0,
		santa: !0,
		earth_asia: !0,
		football: !0,
		guitar: !0,
		panda_face: !0,
		speech_balloon: !0,
		strawberry: !0,
		smirk_cat: !0,
		banana: !0,
		watermelon: !0,
		snowman: !0,
		smile_cat: !0,
		top: !0,
		eggplant: !0,
		crystal_ball: !0,
		fork_and_knife: !0,
		calling: !0,
		iphone: !0,
		partly_sunny: !0,
		warning: !0,
		scream_cat: !0,
		small_orange_diamond: !0,
		baby: !0,
		feet: !0,
		footprints: !0,
		beer: !0,
		wine_glass: !0,
		o: !0,
		video_camera: !0,
		rabbit: !0,
		tropical_drink: !0,
		smoking: !0,
		space_invader: !0,
		peach: !0,
		snake: !0,
		turtle: !0,
		cherries: !0,
		kissing: !0,
		frog: !0,
		milky_way: !0,
		rotating_light: !0,
		hatching_chick: !0,
		closed_book: !0,
		candy: !0,
		hamburger: !0,
		bear: !0,
		tiger: !0,
		fast_forward: !0,
		icecream: !0,
		pineapple: !0,
		ear_of_rice: !0,
		syringe: !0,
		put_litter_in_its_place: !0,
		chocolate_bar: !0,
		black_small_square: !0,
		tv: !0,
		pill: !0,
		octopus: !0,
		jack_o_lantern: !0,
		grapes: !0,
		smiley_cat: !0,
		cd: !0,
		cocktail: !0,
		cake: !0,
		video_game: !0,
		arrow_down: !0,
		no_entry_sign: !0,
		lipstick: !0,
		whale: !0,
		cookie: !0,
		dolphin: !0,
		loud_sound: !0,
		man: !0,
		hatched_chick: !0,
		monkey: !0,
		books: !0,
		japanese_ogre: !0,
		guardsman: !0,
		loudspeaker: !0,
		scissors: !0,
		girl: !0,
		mortar_board: !0,
		fr: !0,
		baseball: !0,
		vertical_traffic_light: !0,
		woman: !0,
		fireworks: !0,
		stars: !0,
		sos: !0,
		mushroom: !0,
		pouting_cat: !0,
		left_luggage: !0,
		high_heel: !0,
		dart: !0,
		swimmer: !0,
		key: !0,
		bikini: !0,
		family: !0,
		pencil2: !0,
		elephant: !0,
		droplet: !0,
		seedling: !0,
		apple: !0,
		cool: !0,
		telephone_receiver: !0,
		dollar: !0,
		house_with_garden: !0,
		book: !0,
		haircut: !0,
		computer: !0,
		bulb: !0,
		question: !0,
		back: !0,
		boy: !0,
		closed_lock_with_key: !0,
		person_with_pouting_face: !0,
		tangerine: !0,
		sunrise: !0,
		poultry_leg: !0,
		blue_circle: !0,
		oncoming_automobile: !0,
		shaved_ice: !0,
		bird: !0,
		first_quarter_moon_with_face: !0,
		eyeglasses: !0,
		goat: !0,
		night_with_stars: !0,
		older_woman: !0,
		black_circle: !0,
		new_moon: !0,
		two_men_holding_hands: !0,
		white_circle: !0,
		customs: !0,
		tropical_fish: !0,
		house: !0,
		arrows_clockwise: !0,
		last_quarter_moon_with_face: !0,
		round_pushpin: !0,
		full_moon: !0,
		athletic_shoe: !0,
		lemon: !0,
		baby_bottle: !0,
		spaghetti: !0,
		wind_chime: !0,
		fish_cake: !0,
		evergreen_tree: !0,
		up: !0,
		arrow_up: !0,
		arrow_upper_right: !0,
		arrow_lower_right: !0,
		arrow_lower_left: !0,
		performing_arts: !0,
		nose: !0,
		pig_nose: !0,
		fish: !0,
		man_with_turban: !0,
		koala: !0,
		ear: !0,
		eight_spoked_asterisk: !0,
		small_blue_diamond: !0,
		shower: !0,
		bug: !0,
		ramen: !0,
		tophat: !0,
		bride_with_veil: !0,
		fuelpump: !0,
		checkered_flag: !0,
		horse: !0,
		watch: !0,
		monkey_face: !0,
		baby_symbol: !0,
		new: !0,
		free: !0,
		sparkler: !0,
		corn: !0,
		tennis: !0,
		alarm_clock: !0,
		battery: !0,
		grey_exclamation: !0,
		wolf: !0,
		moyai: !0,
		cow: !0,
		mega: !0,
		older_man: !0,
		dress: !0,
		link: !0,
		chicken: !0,
		whale2: !0,
		arrow_upper_left: !0,
		deciduous_tree: !0,
		bento: !0,
		pushpin: !0,
		soon: !0,
		repeat: !0,
		dragon: !0,
		hamster: !0,
		golf: !0,
		surfer: !0,
		mouse: !0,
		waxing_crescent_moon: !0,
		blue_car: !0,
		a: !0,
		interrobang: !0,
		u5272: !0,
		electric_plug: !0,
		first_quarter_moon: !0,
		cancer: !0,
		trident: !0,
		bread: !0,
		cop: !0,
		tea: !0,
		fishing_pole_and_fish: !0,
		bike: !0,
		rice: !0,
		radio: !0,
		baby_chick: !0,
		arrow_heading_down: !0,
		waning_crescent_moon: !0,
		arrow_up_down: !0,
		last_quarter_moon: !0,
		radio_button: !0,
		sheep: !0,
		person_with_blond_hair: !0,
		waning_gibbous_moon: !0,
		lock: !0,
		green_apple: !0,
		japanese_goblin: !0,
		curly_loop: !0,
		triangular_flag_on_post: !0,
		arrows_counterclockwise: !0,
		racehorse: !0,
		fried_shrimp: !0,
		sunrise_over_mountains: !0,
		volcano: !0,
		rooster: !0,
		inbox_tray: !0,
		wedding: !0,
		sushi: !0,
		wavy_dash: !0,
		ice_cream: !0,
		rewind: !0,
		tomato: !0,
		rabbit2: !0,
		eight_pointed_black_star: !0,
		small_red_triangle: !0,
		high_brightness: !0,
		heavy_plus_sign: !0,
		man_with_gua_pi_mao: !0,
		convenience_store: !0,
		busts_in_silhouette: !0,
		beetle: !0,
		small_red_triangle_down: !0,
		arrow_heading_up: !0,
		name_badge: !0,
		bath: !0,
		no_entry: !0,
		crocodile: !0,
		dog2: !0,
		cat2: !0,
		hammer: !0,
		meat_on_bone: !0,
		shell: !0,
		sparkle: !0,
		b: !0,
		m: !0,
		poodle: !0,
		aquarius: !0,
		stew: !0,
		jeans: !0,
		honey_pot: !0,
		musical_keyboard: !0,
		unlock: !0,
		black_nib: !0,
		statue_of_liberty: !0,
		heavy_dollar_sign: !0,
		snowboarder: !0,
		white_flower: !0,
		necktie: !0,
		diamond_shape_with_a_dot_inside: !0,
		aries: !0,
		womens: !0,
		ant: !0,
		scorpius: !0,
		city_sunset: !0,
		hourglass_flowing_sand: !0,
		o2: !0,
		dragon_face: !0,
		snail: !0,
		dvd: !0,
		shirt: !0,
		game_die: !0,
		heavy_minus_sign: !0,
		dolls: !0,
		sagittarius: !0,
		"8ball": !0,
		bus: !0,
		custard: !0,
		crossed_flags: !0,
		part_alternation_mark: !0,
		camel: !0,
		curry: !0,
		steam_locomotive: !0,
		hospital: !0,
		large_blue_diamond: !0,
		tanabata_tree: !0,
		bell: !0,
		leo: !0,
		gemini: !0,
		pear: !0,
		large_orange_diamond: !0,
		taurus: !0,
		globe_with_meridians: !0,
		door: !0,
		clock6: !0,
		oncoming_police_car: !0,
		envelope_with_arrow: !0,
		closed_umbrella: !0,
		saxophone: !0,
		church: !0,
		bicyclist: !0,
		pisces: !0,
		dango: !0,
		capricorn: !0,
		office: !0,
		rowboat: !0,
		womans_hat: !0,
		mans_shoe: !0,
		love_hotel: !0,
		mount_fuji: !0,
		dromedary_camel: !0,
		handbag: !0,
		hourglass: !0,
		negative_squared_cross_mark: !0,
		trumpet: !0,
		school: !0,
		cow2: !0,
		construction_worker: !0,
		toilet: !0,
		pig2: !0,
		grey_question: !0,
		beginner: !0,
		violin: !0,
		on: !0,
		credit_card: !0,
		id: !0,
		secret: !0,
		ferris_wheel: !0,
		bowling: !0,
		libra: !0,
		virgo: !0,
		barber: !0,
		purse: !0,
		roller_coaster: !0,
		rat: !0,
		date: !0,
		rugby_football: !0,
		ram: !0,
		arrow_up_small: !0,
		black_square_button: !0,
		mobile_phone_off: !0,
		tokyo_tower: !0,
		congratulations: !0,
		kimono: !0,
		ship: !0,
		mag_right: !0,
		mag: !0,
		fire_engine: !0,
		clock1130: !0,
		police_car: !0,
		black_joker: !0,
		bridge_at_night: !0,
		package: !0,
		oncoming_taxi: !0,
		calendar: !0,
		horse_racing: !0,
		tiger2: !0,
		boot: !0,
		ambulance: !0,
		white_square_button: !0,
		boar: !0,
		school_satchel: !0,
		loop: !0,
		pound: !0,
		information_source: !0,
		ox: !0,
		rice_ball: !0,
		vs: !0,
		end: !0,
		parking: !0,
		sandal: !0,
		tent: !0,
		seat: !0,
		taxi: !0,
		black_medium_small_square: !0,
		briefcase: !0,
		newspaper: !0,
		circus_tent: !0,
		six_pointed_star: !0,
		mens: !0,
		european_castle: !0,
		flashlight: !0,
		foggy: !0,
		arrow_double_up: !0,
		bamboo: !0,
		ticket: !0,
		helicopter: !0,
		minidisc: !0,
		oncoming_bus: !0,
		melon: !0,
		white_small_square: !0,
		european_post_office: !0,
		keycap_ten: !0,
		notebook: !0,
		no_bell: !0,
		oden: !0,
		flags: !0,
		carousel_horse: !0,
		blowfish: !0,
		chart_with_upwards_trend: !0,
		sweet_potato: !0,
		ski: !0,
		clock12: !0,
		signal_strength: !0,
		construction: !0,
		black_medium_square: !0,
		satellite: !0,
		euro: !0,
		womans_clothes: !0,
		ledger: !0,
		leopard: !0,
		low_brightness: !0,
		clock3: !0,
		department_store: !0,
		truck: !0,
		sake: !0,
		railway_car: !0,
		speedboat: !0,
		vhs: !0,
		clock1: !0,
		arrow_double_down: !0,
		water_buffalo: !0,
		arrow_down_small: !0,
		yen: !0,
		mute: !0,
		running_shirt_with_sash: !0,
		white_large_square: !0,
		wheelchair: !0,
		clock2: !0,
		paperclip: !0,
		atm: !0,
		cinema: !0,
		telescope: !0,
		rice_scene: !0,
		blue_book: !0,
		white_medium_square: !0,
		postbox: !0,
		"e-mail": !0,
		mouse2: !0,
		bullettrain_side: !0,
		ideograph_advantage: !0,
		nut_and_bolt: !0,
		ng: !0,
		hotel: !0,
		wc: !0,
		izakaya_lantern: !0,
		repeat_one: !0,
		mailbox_with_mail: !0,
		chart_with_downwards_trend: !0,
		green_book: !0,
		tractor: !0,
		fountain: !0,
		metro: !0,
		clipboard: !0,
		no_mobile_phones: !0,
		clock4: !0,
		no_smoking: !0,
		black_large_square: !0,
		slot_machine: !0,
		clock5: !0,
		bathtub: !0,
		scroll: !0,
		station: !0,
		rice_cracker: !0,
		bank: !0,
		wrench: !0,
		u6307: !0,
		articulated_lorry: !0,
		page_facing_up: !0,
		ophiuchus: !0,
		bar_chart: !0,
		no_pedestrians: !0,
		vibration_mode: !0,
		clock10: !0,
		clock9: !0,
		bullettrain_front: !0,
		minibus: !0,
		tram: !0,
		clock8: !0,
		u7a7a: !0,
		traffic_light: !0,
		mountain_bicyclist: !0,
		microscope: !0,
		japanese_castle: !0,
		bookmark: !0,
		bookmark_tabs: !0,
		pouch: !0,
		ab: !0,
		page_with_curl: !0,
		flower_playing_cards: !0,
		clock11: !0,
		fax: !0,
		clock7: !0,
		white_medium_small_square: !0,
		currency_exchange: !0,
		sound: !0,
		chart: !0,
		cl: !0,
		floppy_disk: !0,
		post_office: !0,
		speaker: !0,
		japan: !0,
		u55b6: !0,
		mahjong: !0,
		incoming_envelope: !0,
		orange_book: !0,
		restroom: !0,
		u7121: !0,
		u6709: !0,
		triangular_ruler: !0,
		train: !0,
		u7533: !0,
		trolleybus: !0,
		u6708: !0,
		notebook_with_decorative_cover: !0,
		u7981: !0,
		u6e80: !0,
		postal_horn: !0,
		factory: !0,
		children_crossing: !0,
		train2: !0,
		straight_ruler: !0,
		pager: !0,
		accept: !0,
		u5408: !0,
		lock_with_ink_pen: !0,
		clock130: !0,
		sa: !0,
		outbox_tray: !0,
		twisted_rightwards_arrows: !0,
		mailbox: !0,
		light_rail: !0,
		clock930: !0,
		busstop: !0,
		open_file_folder: !0,
		file_folder: !0,
		potable_water: !0,
		card_index: !0,
		clock230: !0,
		monorail: !0,
		clock1230: !0,
		clock1030: !0,
		abc: !0,
		mailbox_closed: !0,
		clock430: !0,
		mountain_railway: !0,
		do_not_litter: !0,
		clock330: !0,
		heavy_division_sign: !0,
		clock730: !0,
		clock530: !0,
		capital_abcd: !0,
		mailbox_with_no_mail: !0,
		symbols: !0,
		aerial_tramway: !0,
		clock830: !0,
		clock630: !0,
		abcd: !0,
		mountain_cableway: !0,
		koko: !0,
		passport_control: !0,
		"non-potable_water": !0,
		suspension_railway: !0,
		baggage_claim: !0,
		no_bicycles: !0,
		skull_crossbones: !0,
		hugging: !0,
		thinking: !0,
		nerd: !0,
		zipper_mouth: !0,
		rolling_eyes: !0,
		upside_down: !0,
		slight_smile: !0,
		middle_finger: !0,
		writing_hand: !0,
		dark_sunglasses: !0,
		eye: !0,
		man_in_suit: !0,
		golfer: !0,
		heart_exclamation: !0,
		star_of_david: !0,
		cross: !0,
		"fleur-de-lis": !0,
		atom: !0,
		wheel_of_dharma: !0,
		yin_yang: !0,
		peace: !0,
		star_and_crescent: !0,
		orthodox_cross: !0,
		biohazard: !0,
		radioactive: !0,
		place_of_worship: !0,
		anger_right: !0,
		menorah: !0,
		om_symbol: !0,
		coffin: !0,
		gear: !0,
		alembic: !0,
		scales: !0,
		crossed_swords: !0,
		keyboard: !0,
		shield: !0,
		bed: !0,
		shopping_bags: !0,
		sleeping_accommodation: !0,
		ballot_box: !0,
		compression: !0,
		wastebasket: !0,
		file_cabinet: !0,
		trackball: !0,
		printer: !0,
		joystick: !0,
		hole: !0,
		candle: !0,
		prayer_beads: !0,
		camera_with_flash: !0,
		amphora: !0,
		label: !0,
		flag_black: !0,
		flag_white: !0,
		film_frames: !0,
		control_knobs: !0,
		level_slider: !0,
		thermometer: !0,
		airplane_arriving: !0,
		airplane_departure: !0,
		railway_track: !0,
		motorway: !0,
		synagogue: !0,
		mosque: !0,
		kaaba: !0,
		stadium: !0,
		desert: !0,
		classical_building: !0,
		cityscape: !0,
		camping: !0,
		bow_and_arrow: !0,
		rosette: !0,
		volleyball: !0,
		medal: !0,
		reminder_ribbon: !0,
		popcorn: !0,
		champagne: !0,
		hot_pepper: !0,
		burrito: !0,
		taco: !0,
		hotdog: !0,
		shamrock: !0,
		comet: !0,
		turkey: !0,
		scorpion: !0,
		lion_face: !0,
		crab: !0,
		spider_web: !0,
		spider: !0,
		chipmunk: !0,
		wind_blowing_face: !0,
		fog: !0,
		play_pause: !0,
		track_previous: !0,
		track_next: !0,
		beach_umbrella: !0,
		chains: !0,
		pick: !0,
		stopwatch: !0,
		ferry: !0,
		mountain: !0,
		shinto_shrine: !0,
		ice_skate: !0,
		skier: !0,
		flag_ac: !0,
		flag_ad: !0,
		flag_ae: !0,
		flag_af: !0,
		flag_ag: !0,
		flag_ai: !0,
		flag_al: !0,
		flag_am: !0,
		"flag-ao": !0,
		"flag-aq": !0,
		"flag-ar": !0,
		"flag-as": !0,
		"flag-at": !0,
		"flag-au": !0,
		"flag-aw": !0,
		"flag-ax": !0,
		"flag-az": !0,
		"flag-ba": !0,
		"flag-bb": !0,
		"flag-bd": !0,
		"flag-be": !0,
		"flag-bf": !0,
		"flag-bg": !0,
		"flag-bh": !0,
		"flag-bi": !0,
		"flag-bj": !0,
		"flag-bl": !0,
		"flag-bm": !0,
		"flag-bn": !0,
		"flag-bo": !0,
		"flag-bq": !0,
		"flag-br": !0,
		"flag-bs": !0,
		"flag-bt": !0,
		"flag-bv": !0,
		"flag-bw": !0,
		"flag-by": !0,
		"flag-bz": !0,
		"flag-ca": !0,
		"flag-cc": !0,
		"flag-cd": !0,
		"flag-cf": !0,
		"flag-cg": !0,
		"flag-ch": !0,
		"flag-ci": !0,
		"flag-ck": !0,
		"flag-cl": !0,
		"flag-cm": !0,
		"flag-cn": !0,
		"flag-co": !0,
		"flag-cp": !0,
		"flag-cr": !0,
		"flag-cu": !0,
		"flag-cv": !0,
		"flag-cw": !0,
		"flag-cx": !0,
		"flag-cy": !0,
		"flag-cz": !0,
		"flag-de": !0,
		"flag-dg": !0,
		"flag-dj": !0,
		"flag-dk": !0,
		"flag-dm": !0,
		"flag-do": !0,
		"flag-dz": !0,
		"flag-ea": !0,
		"flag-ec": !0,
		"flag-ee": !0,
		"flag-eg": !0,
		"flag-eh": !0,
		"flag-er": !0,
		"flag-es": !0,
		"flag-et": !0,
		"flag-eu": !0,
		"flag-fi": !0,
		"flag-fj": !0,
		"flag-fk": !0,
		"flag-fm": !0,
		"flag-fo": !0,
		"flag-fr": !0,
		"flag-ga": !0,
		"flag-gb": !0,
		"flag-gd": !0,
		"flag-ge": !0,
		"flag-gf": !0,
		"flag-gg": !0,
		"flag-gh": !0,
		"flag-gi": !0,
		"flag-gl": !0,
		"flag-gm": !0,
		"flag-gn": !0,
		"flag-gp": !0,
		"flag-gq": !0,
		"flag-gr": !0,
		"flag-gs": !0,
		"flag-gt": !0,
		"flag-gu": !0,
		"flag-gw": !0,
		"flag-gy": !0,
		"flag-hk": !0,
		"flag-hm": !0,
		"flag-hn": !0,
		"flag-hr": !0,
		"flag-ht": !0,
		"flag-hu": !0,
		"flag-ic": !0,
		"flag-id": !0,
		"flag-ie": !0,
		"flag-il": !0,
		"flag-im": !0,
		"flag-in": !0,
		"flag-io": !0,
		"flag-iq": !0,
		"flag-ir": !0,
		"flag-is": !0,
		"flag-it": !0,
		"flag-je": !0,
		"flag-jm": !0,
		"flag-jo": !0,
		"flag-jp": !0,
		"flag-ke": !0,
		"flag-kg": !0,
		"flag-kh": !0,
		"flag-ki": !0,
		"flag-km": !0,
		"flag-kn": !0,
		"flag-kp": !0,
		"flag-kr": !0,
		"flag-kw": !0,
		"flag-ky": !0,
		"flag-kz": !0,
		"flag-la": !0,
		"flag-lb": !0,
		"flag-lc": !0,
		"flag-li": !0,
		"flag-lk": !0,
		"flag-lr": !0,
		"flag-ls": !0,
		"flag-lt": !0,
		"flag-lu": !0,
		"flag-lv": !0,
		"flag-ly": !0,
		"flag-ma": !0,
		"flag-mc": !0,
		"flag-md": !0,
		"flag-me": !0,
		"flag-mf": !0,
		"flag-mg": !0,
		"flag-mh": !0,
		"flag-mk": !0,
		"flag-ml": !0,
		"flag-mm": !0,
		"flag-mn": !0,
		"flag-mo": !0,
		"flag-mp": !0,
		"flag-mq": !0,
		"flag-mr": !0,
		"flag-ms": !0,
		"flag-mt": !0,
		"flag-mu": !0,
		"flag-mv": !0,
		"flag-mw": !0,
		"flag-mx": !0,
		"flag-my": !0,
		"flag-mz": !0,
		"flag-na": !0,
		"flag-nc": !0,
		"flag-ne": !0,
		"flag-nf": !0,
		"flag-ng": !0,
		"flag-ni": !0,
		"flag-nl": !0,
		"flag-no": !0,
		"flag-np": !0,
		"flag-nr": !0,
		"flag-nu": !0,
		"flag-nz": !0,
		"flag-om": !0,
		"flag-pa": !0,
		"flag-pe": !0,
		"flag-pf": !0,
		"flag-pg": !0,
		"flag-ph": !0,
		"flag-pk": !0,
		"flag-pl": !0,
		"flag-pm": !0,
		"flag-pn": !0,
		"flag-pr": !0,
		"flag-ps": !0,
		"flag-pt": !0,
		"flag-pw": !0,
		"flag-py": !0,
		"flag-qa": !0,
		"flag-re": !0,
		"flag-ro": !0,
		"flag-rs": !0,
		"flag-ru": !0,
		"flag-rw": !0,
		"flag-sa": !0,
		"flag-sb": !0,
		"flag-sc": !0,
		"flag-sd": !0,
		"flag-se": !0,
		"flag-sg": !0,
		"flag-sh": !0,
		"flag-si": !0,
		"flag-sj": !0,
		"flag-sk": !0,
		"flag-sl": !0,
		"flag-sm": !0,
		"flag-sn": !0,
		"flag-so": !0,
		"flag-sr": !0,
		"flag-ss": !0,
		"flag-st": !0,
		"flag-sv": !0,
		"flag-sx": !0,
		"flag-sy": !0,
		"flag-sz": !0,
		"flag-ta": !0,
		"flag-tc": !0,
		"flag-td": !0,
		"flag-tf": !0,
		"flag-tg": !0,
		"flag-th": !0,
		"flag-tj": !0,
		"flag-tk": !0,
		"flag-tl": !0,
		"flag-tm": !0,
		"flag-tn": !0,
		"flag-to": !0,
		"flag-tr": !0,
		"flag-tt": !0,
		"flag-tv": !0,
		"flag-tw": !0,
		"flag-tz": !0,
		"flag-ua": !0,
		"flag-ug": !0,
		"flag-um": !0,
		"flag-us": !0,
		"flag-uy": !0,
		"flag-uz": !0,
		"flag-va": !0,
		"flag-vc": !0,
		"flag-ve": !0,
		"flag-vg": !0,
		"flag-vi": !0,
		"flag-vn": !0,
		flag_vu: !0,
		flag_wf: !0,
		flag_ws: !0,
		flag_xk: !0,
		flag_ye: !0,
		flag_yt: !0,
		flag_za: !0,
		flag_zm: !0,
		flag_zw: !0,
		black_heart: !0,
		speech_left: !0,
		egg: !0,
		octagonal_sign: !0,
		spades: !0,
		hearts: !0,
		diamonds: !0,
		clubs: !0,
		drum: !0,
		left_right_arrow: !0,
		tm: !0,
		"100": !0
	};

	/* eslint-enable */

	addConfigOptions(
		"chat", {
			_name: __("cfg_tab_chat"),
			_player: true,
			emoji: {
				name: __("cfg_option_emoji"),
				default: true,
				_type: "boolean",
				_player: true,
			},
		},
	);
};

SCRIPT_EXTENSIONS.push(baseChatEmoji);


function baseChatLanguages () {
	d20plus.chat = d20plus.chat || {};

	// Data for generating fake messages in in-game languages in base-chat gibberish()
	// lexis: list of 100 fake words for each in-game language;
	// particles: 9 fake short words imitating parts of speech like prepositions or
	// conjunctions or interjections etc. adding more "flavor" to generated text
	// factor: integer that determines the frequency of particle occurrences
	/* eslint-disable */
	d20plus.chat.languages = {
		"common": {
			"title": "common",
			// Most words copied or modified from
			// https://forgottenrealms.fandom.com/wiki/Common_dictionary
			"lexis": [
				"alae",
				"alavairthae",
				"alehose",
				"amarast",
				"anyhail",
				"badaulder",
				"darchains",
				"dathna",
				"deven",
				"drios",
				"durgos",
				"elsun",
				"evenfeast",
				"eventide",
				"fieldings",
				"fireseared",
				"galad",
				"glim",
				"haelhard",
				"harbright",
				"hardjaws",
				"harnor",
				"haularake",
				"hawksnarl",
				"highsun",
				"hrammar",
				"hrast",
				"hrasting",
				"hugor",
				"hykyath",
				"jursak",
				"keghand",
				"kell",
				"lalandath",
				"lamenor",
				"lammath",
				"lifeblood",
				"marrado",
				"mayhap",
				"murdath",
				"naed",
				"naeth",
				"nandra",
				"navalar",
				"nightjack",
				"nightmaid",
				"olor",
				"orbal",
				"parharding",
				"plounce",
				"potjack",
				"potmaid",
				"punnet",
				"rhambukkya",
				"rivvim",
				"roofwrack",
				"sabbas",
				"sabruin",
				"saer",
				"sark",
				"scorchkettle",
				"sel",
				"shaeling",
				"sheelie",
				"sildur",
				"silverfin",
				"skaether",
				"slake",
				"sorn",
				"spear",
				"spurnarmor",
				"standath",
				"steading",
				"stettar",
				"stlarn",
				"stomran",
				"straek",
				"sumbor",
				"tantam",
				"tasmar",
				"tenday",
				"thael",
				"thargur",
				"tharsun",
				"thoats",
				"thruss",
				"thulsun",
				"tindertwig",
				"tluin",
				"topon",
				"tumin",
				"uluvathae",
				"vasark",
				"vlandranna",
				"voh",
				"waelo",
				"wanton",
				"wenich",
				"winker",
				"zzar"
			],
			"particles": [
				"fol",
				"a",
				"me",
				"on",
				"an",
				"fo-",
				"to-",
				"do",
				"per"
			],
			"alias": [
				"human",// RB20 EXCLUDE START
				"ортанский"// RB20 EXCLUDE END
			],
			"factor": 4
		},
		"dwarvish": {
			"title": "dwarvish",
			// Most words copied or modified from
			// http://www.bugmansbrewery.com/tutorials/article/115-dwarf-language-english-to-khazalid-dictionary/
			"lexis": [
				"akrak",
				"angaz",
				"azamar",
				"azgal",
				"azul",
				"bakraz",
				"barag",
				"barak",
				"baraz",
				"binaz",
				"bolg",
				"brog",
				"chuf",
				"dal",
				"dar",
				"dharkhangron",
				"doh",
				"drakk",
				"drazh",
				"drek",
				"drongnel",
				"fleg",
				"gorak",
				"gorm",
				"gorog",
				"goruz",
				"grim",
				"grimaz",
				"grom",
				"gromdal",
				"grongol",
				"gronit",
				"grumbak",
				"guz",
				"guzzen",
				"hunk",
				"karu",
				"kazad",
				"kazak",
				"kazhunki",
				"kazid",
				"khaz",
				"khazukan",
				"klad",
				"krink",
				"kro",
				"kron",
				"kruk",
				"kruti",
				"migdhal",
				"mizpal",
				"muzkhgrum",
				"naggrund",
				"nar",
				"onk",
				"orrud",
				"ragarin",
				"rik",
				"rikigraz",
				"rorkaz",
				"ruf",
				"runk",
				"ruvalk",
				"sar",
				"skarrenruf",
				"skruff",
				"skrund",
				"skuf",
				"stok",
				"thagi",
				"thingaz",
				"thongli",
				"throng",
				"thrund",
				"thrynaz",
				"tiwaz",
				"trogg",
				"umanar",
				"und",
				"undi",
				"ungor",
				"urbaz",
				"urk",
				"varaz",
				"varf",
				"varn",
				"vengryn",
				"vithang",
				"vlag",
				"vorkhul",
				"wan",
				"wanaz",
				"wattock",
				"wazzock",
				"werit",
				"wyr",
				"zak",
				"zaki",
				"zan",
				"zank"
			],
			"particles": [
				"ha",
				"a-",
				"un",
				"um",
				"dum-",
				"on-",
				"or",
				"ad",
				"har"
			],
			"alias": [
				"dwarven"
			],
			"factor": 3
		},
		"elvish": {
			"title": "elvish",
			// Most words copied or modified from
			// https://www.elfdict.com/w/?language=quenya
			"lexis": [
				"alahen",
				"alamanyar",
				"alaninquitálima",
				"alasaila",
				"alaurē",
				"alcárima",
				"alcorin",
				"aleldarin",
				"alfárima",
				"alfirin",
				"alistima",
				"alómear",
				"alquettima",
				"ampanotalea",
				"ancale",
				"ancárima",
				"andúne",
				"asanye",
				"avante",
				"celure",
				"ceníte",
				"cirmacin",
				"ennie",
				"etya",
				"etyarin",
				"farale",
				"farastea",
				"himíte",
				"ilquárea",
				"induinen",
				"indyel",
				"insil",
				"intin",
				"isil",
				"istalima",
				"istare",
				"lacalima",
				"laistea",
				"laistila",
				"laman",
				"lamate",
				"lambion",
				"lamélima",
				"lirale",
				"líruima",
				"manar",
				"mára",
				"mastima",
				"mecin",
				"milyar",
				"mólome",
				"nairea",
				"naitie",
				"nandor",
				"nasque",
				"nefíte",
				"nemestea",
				"nengwear",
				"níríte",
				"noldorin",
				"númen",
				"númerea",
				"nyárula",
				"nyelle",
				"ocamnar",
				"ólamar",
				"ontale",
				"ortalima",
				"ortare",
				"perómandar",
				"púlima",
				"puntar",
				"qualme",
				"quende",
				"quenderin",
				"quenelya",
				"quettima",
				"raiqua",
				"símen",
				"sinan",
				"sinar",
				"sindar",
				"sinome",
				"sintar",
				"súrimar",
				"suryar",
				"taltea",
				"tancal",
				"tauvar",
				"telerin",
				"tírima",
				"turindura",
				"túvima",
				"tyen",
				"úcalima",
				"úcárima",
				"umbar",
				"vanima",
				"vórear",
				"yúlima"
			],
			"particles": [
				"na",
				"en'",
				"il'",
				"né",
				"ol'",
				"an",
				"o'",
				"lor-",
				"i-"
			],
			"alias": [
				"elven",
				"elf"
			],
			"factor": 5
		},
		"giant": {
			"title": "giant",
			// Most words copied or modified from
			// https://www.paolini.net/fans/invented-languages-inheritance-cycle/dwarf-language/dwarf-language-english-dictionary/
			"lexis": [
				"arûna",
				"ascûdgamln",
				"astim",
				"athrid",
				"bahst",
				"barzûl",
				"barzûln",
				"belard",
				"beor",
				"borith",
				"brâgha",
				"brak",
				"carharûg",
				"carkna",
				"carn",
				"darm",
				"delva",
				"dem",
				"derûndân",
				"dômar",
				"dorzada",
				"drâth",
				"dûnost",
				"dûrgrimst",
				"dûrmgrist",
				"ebardac",
				"edaris",
				"egraz",
				"encesti",
				"erôth",
				"erôthknurl",
				"estvarn",
				"estver",
				"etal",
				"fanghur",
				"feldûnost",
				"felfarthen",
				"felrast",
				"formv",
				"frekk",
				"fûthmér",
				"gáld",
				"gáldhiem",
				"gaml",
				"ganaht",
				"garth",
				"gauhnith",
				"gedthrall",
				"gerdûm",
				"ghastgar",
				"goroth",
				"grimstnzhadn",
				"gûntera",
				"harng",
				"harûg",
				"hefthyn",
				"helzvog",
				"hert",
				"hiem",
				"hírna",
				"hort",
				"hrenth",
				"hrestvog",
				"hreth",
				"hrethcarach",
				"hûthvír",
				"hûtt",
				"ingeitum",
				"knurlcarathn",
				"ledwonnû",
				"meitder",
				"mendûnost",
				"menknurlan",
				"mensagh",
				"menthiv",
				"menwarrev",
				"mérna",
				"mezzintar",
				"mithrim",
				"môgh",
				"môgren",
				"nal",
				"narho",
				"quan",
				"ragni",
				"sartos",
				"sartosvrenht",
				"sesti",
				"sheilve",
				"sweld",
				"thardsvergûndnzmal",
				"thargen",
				"thorv",
				"thriknzdal",
				"thrond",
				"trangnarn",
				"urzhad",
				"vrem",
				"vrenht",
				"wharn"
			],
			"particles": [
				"dûr",
				"az",
				"azt",
				"og",
				"rra-",
				"rna-",
				"da-",
				"rr-",
				"gro"
			],
			"alias": [
				"ogre"
			],
			"factor": 3
		},
		"gnomish": {
			"title": "gnomish",
			// Most words copied or modified from
			// https://www.elfdict.com/w/?language=telerin
			"lexis": [
				"athon",
				"aumata",
				"budhu",
				"burbo",
				"buspo",
				"caw",
				"cewin",
				"cha",
				"curunír",
				"eglath",
				"ettuli",
				"ghaik",
				"ghustil",
				"gurgof",
				"hacta",
				"hadhwa",
				"haedh",
				"hamna",
				"hanin",
				"hatta",
				"hauda",
				"haudh",
				"hîn",
				"huine",
				"jez",
				"kaincha",
				"kainu",
				"kait",
				"kalach",
				"kalas",
				"kel",
				"kelu",
				"khamu",
				"kheru",
				"kith",
				"koilu",
				"koiru",
				"koitā",
				"kuinu",
				"kuitā",
				"kurwē",
				"lauda",
				"laudh",
				"linna",
				"liru",
				"madha",
				"mascu",
				"matjā",
				"matulā",
				"melā",
				"mîdh",
				"mirhanac",
				"nacte",
				"nadha",
				"naedh",
				"nathu",
				"natte",
				"ndilā",
				"necte",
				"nette",
				"nidh",
				"nîdh",
				"nídha",
				"niñkwis",
				"ōmata",
				"omnu",
				"peles",
				"pelsa",
				"pentro",
				"psar",
				"psára",
				"raef",
				"rak",
				"rakkma",
				"rathki",
				"resta",
				"revrykal",
				"rîdh",
				"sedu",
				"taltas",
				"tancula",
				"tañkas",
				"teles",
				"telu",
				"thar",
				"thillu",
				"thilnu",
				"thoron",
				"tinnúviel",
				"tithilla",
				"tolen",
				"tolu",
				"tuilu",
				"tyaz",
				"uba",
				"umitl",
				"varsh",
				"vlaakith",
				"xarā",
				"xenna"
			],
			"particles": [
				"ae",
				"et",
				"en",
				"dam",
				"bom",
				"ne",
				"m",
				"ik",
				"ro"
			],
			"alias": [
				"gnome"
			],
			"factor": 4
		},
		"goblin": {
			"title": "goblin",
			// Most words copied or modified from
			// https://forgottenrealms.fandom.com/wiki/Goblin_dictionary
			"lexis": [
				"ana",
				"ari",
				"armauk",
				"auga",
				"bagal",
				"banam",
				"banos",
				"bauruk",
				"bizel",
				"booyahg",
				"braeunk",
				"breek",
				"dabog",
				"dargrath",
				"dargum",
				"daul",
				"dha",
				"durbuluk",
				"fak",
				"foshnu",
				"fund",
				"fushat",
				"gever",
				"gog",
				"golog",
				"guthash",
				"hak",
				"hruggekolohk",
				"huhak",
				"hum",
				"illska",
				"karanzol",
				"karkat",
				"karkitas",
				"kherek",
				"kurrauz",
				"kykat",
				"laug",
				"lind",
				"lodar",
				"lorach",
				"loz",
				"mabus",
				"magas",
				"margim",
				"mub",
				"mubaram",
				"mubulat",
				"mug",
				"nagransham",
				"namat",
				"nixir",
				"noldo",
				"nor",
				"nying",
				"ovani",
				"paflok",
				"pafund",
				"paken",
				"palkas",
				"parat",
				"parhor",
				"pik",
				"plak",
				"plasas",
				"plasi",
				"pluhun",
				"poni",
				"porandor",
				"rup",
				"ryk",
				"sapat",
				"shakab",
				"shakapon",
				"shakutarbik",
				"shat",
				"skag",
				"tarthur",
				"thag",
				"tharb",
				"thark",
				"tharm",
				"thos",
				"thur",
				"tok",
				"trolkh",
				"vadoksam",
				"vadoksog",
				"vaws",
				"vaza",
				"vek",
				"vhos",
				"vok",
				"vosh",
				"voz",
				"yark",
				"zabraz",
				"zan",
				"zongot",
				"zorrat"
			],
			"particles": [
				"ta",
				"vo",
				"no",
				"suk",
				"ya",
				"yol",
				"mar",
				"mak",
				"psa"
			],
			"alias": [
				"goblinoid"
			],
			"factor": 3
		},
		"halfling": {
			"title": "halfling",
			// Most words copied or modified from
			// http://www.quicksilver899.com/Tolkien/Hobbitry.html
			"lexis": [
				"adaldrida",
				"balc",
				"banakil",
				"banta",
				"banzir",
				"barabatta",
				"bas",
				"bilba",
				"bolgra",
				"bophîn",
				"branda",
				"brandu",
				"brandugamba",
				"bree",
				"carbandur",
				"carbanga",
				"cast",
				"castu",
				"chet",
				"cubuc",
				"cugbagu",
				"dûkan",
				"dûkaru",
				"fallohide",
				"froda",
				"gad",
				"galab",
				"galbassi",
				"galpsi",
				"gamba",
				"globa",
				"gluva",
				"grad",
				"hamanullas",
				"hamfast",
				"harfoots",
				"hloth",
				"hlothran",
				"isen",
				"kali",
				"kalimac",
				"karningul",
				"kast",
				"kili",
				"kûd",
				"kuduk",
				"labin",
				"labingi",
				"lograd",
				"loho",
				"lohtur",
				"lothran",
				"luthran",
				"luthur",
				"mathom",
				"maura",
				"nahald",
				"nargian",
				"nec",
				"nîn",
				"peppin",
				"pharë",
				"phur",
				"phurunargian",
				"ram",
				"ran",
				"rapha",
				"rasputa",
				"raspûta",
				"raza",
				"razan",
				"razanur",
				"razar",
				"rog",
				"sharku",
				"smial",
				"soval",
				"stenr",
				"stjarna",
				"stoor",
				"stydja",
				"sund",
				"sûza",
				"tapuc",
				"thain",
				"tharantin",
				"tharni",
				"tóbias",
				"tragu",
				"trahald",
				"trahan",
				"trân",
				"tuca",
				"tung",
				"tur",
				"turac",
				"wini",
				"zara",
				"zilbirapha",
				"zir"
			],
			"particles": [
				"a",
				"o",
				"ol-",
				"nî",
				"ul",
				"lo",
				"u",
				"u-",
				"so-"
			],
			"alias": [
				"hobbit",// RB20 EXCLUDE START
				"таларийский"// RB20 EXCLUDE END
			],
			"factor": 4
		},
		"orcish": {
			"title": "orcish",
			// Most words copied or modified from
			// https://www.angelfire.com/ia/orcishnations/englishorcish.html
			"lexis": [
				"arau",
				"asht",
				"bartas",
				"bashkaum",
				"blog",
				"blotaz",
				"bogi",
				"bosnauk",
				"broz",
				"brulk",
				"bujukasi",
				"buk",
				"bukol",
				"bungo",
				"curr",
				"dajal",
				"dhaub",
				"dorr",
				"doturog",
				"fatoft",
				"frib",
				"fushjalut",
				"gijak",
				"gijakpis",
				"gijakudob",
				"gogan",
				"goltur",
				"gubuk",
				"hanksar",
				"inras",
				"kafsog",
				"kakok",
				"kalaum",
				"kalkan",
				"kalush",
				"kapuk",
				"karash",
				"kartart",
				"kaup",
				"kazorm",
				"kishaulus",
				"kishtraum",
				"kokan",
				"kokar",
				"kolaubar",
				"kolk",
				"korpaus",
				"kosh",
				"krah",
				"kridash",
				"krimp",
				"kular",
				"kumbon",
				"lak",
				"larg",
				"lavozagh",
				"lundar",
				"lup",
				"lutaum",
				"mabas",
				"maush",
				"mazat",
				"mikar",
				"molva",
				"mosal",
				"mosh",
				"moshar",
				"motsham",
				"mubarshtaum",
				"nadar",
				"nudertog",
				"pargijakun",
				"parkulun",
				"paustar",
				"pogalm",
				"rraus",
				"rung",
				"shataz",
				"shaugit",
				"shendrautsham",
				"shul",
				"skalkisham",
				"skopar",
				"skort",
				"skup",
				"stargush",
				"staz",
				"suksh",
				"sulmog",
				"sulmus",
				"tanfuksham",
				"thoror",
				"thrak",
				"ugrukh",
				"urdanog",
				"ushtar",
				"ushtarak",
				"zagavarr",
				"zemaraum",
				"zoshkat"
			],
			"particles": [
				"uk",
				"agh",
				"ur",
				"zug",
				"rek",
				"rog",
				"dru",
				"sud-",
				"vor-"
			],
			"alias": [
				"orc"
			],
			"factor": 2
		},
		"abyssal": {
			"title": "abyssal",
			// Most words copied or modified from
			// https://www.paolini.net/fans/invented-languages-inheritance-cycle/ancient-language/ancient-language-english-dictionary/
			"lexis": [
				"aldanarí",
				"argetlam",
				"äthalvard",
				"bjartskular",
				"bjartstál",
				"blödhgarm",
				"blödhren",
				"brisingr",
				"dagshelgr",
				"darmthrell",
				"dauthdaert",
				"dauthleikr",
				"dröttning",
				"dröttningu",
				"ebrithil",
				"edoc’sil",
				"eïnradhin",
				"eldhrimner",
				"eldrvarí",
				"eldrvarya",
				"eldunarí",
				"ellesméra",
				"elthrimórno",
				"ethilnadras",
				"ethildurin",
				"faelnirv",
				"fëon",
				"finiarel",
				"flutningr",
				"förn",
				"framvír",
				"frethya",
				"galbatorix",
				"garjzla",
				"gëuloth",
				"haldthin",
				"helgrind",
				"herdtha",
				"hernskja",
				"hljödhr",
				"hröslvalhr",
				"ikonoka",
				"íllgrathr",
				"ilumaro",
				"indlvarn",
				"islingr",
				"istalrí",
				"könungr",
				"kvaedhí",
				"kvaedhí",
				"kveykva",
				"lámarae",
				"laufsblädr",
				"lethrblaka",
				"loivissa",
				"malthinae",
				"midhring",
				"mor’ranr",
				"mulabra",
				"nalgask",
				"nangoröth",
				"nángoröth",
				"nïdhwal",
				"niernen",
				"orgetorix",
				"orothrim",
				"osthato",
				"otherúm",
				"pömnuria",
				"rextugenos",
				"ristvak’baen",
				"sharjalví",
				"shur’tugal",
				"silbena",
				"sköliro",
				"skulblaka",
				"snalglí",
				"sundavar",
				"sundavrblaka",
				"svit-kona",
				"thaefathan",
				"theirra",
				"thelduin",
				"thornessa",
				"thrautha",
				"threyja",
				"thrífask",
				"thringa",
				"thrysta",
				"titlingr",
				"traevam",
				"vanyalí",
				"vercingetorix",
				"vergandí",
				"vergarí",
				"vergathos",
				"verrunsmal",
				"vervada",
				"weldenvarden",
				"weohnataí"
			],
			"particles": [
				"ash'",
				"ash'",
				"ath'",
				"ath'",
				"tero-",
				"tero-",
				"al'",
				"al'",
				"al'"
			],
			"alias": [
				"demon"
			],
			"factor": 2
		},
		"celestial": {
			"title": "celestial",
			// Most words copied or modified from
			// https://dndtopics.com/languages/celestial/
			"lexis": [
				"aujinn",
				"aurix",
				"aussit",
				"austrat",
				"axun",
				"baeshran",
				"bakam",
				"barb",
				"bejik",
				"bensvelk",
				"caesin",
				"caex",
				"chaorkartel",
				"charchukan",
				"charil",
				"chmertehoschta",
				"ciaptoop",
				"clax",
				"darahar",
				"darastrix",
				"darastrixethe",
				"djerad",
				"eanm",
				"eesem",
				"farang",
				"farothai",
				"fintir",
				"fliaot",
				"flolhwouth",
				"flonn",
				"flonna",
				"frahr",
				"garurt",
				"geth",
				"ghent",
				"ghik",
				"ghontix",
				"gixustrat",
				"grovisv",
				"hengoth",
				"henich",
				"hesjing",
				"hlarn",
				"horthinn",
				"hwinn",
				"hwith",
				"hwoul",
				"hwulceat",
				"koshqal",
				"kosja",
				"kosjth",
				"kothan",
				"kuhri",
				"kuhroom",
				"laraek",
				"lauth",
				"leirith",
				"levethix",
				"levex",
				"lexi",
				"litrix",
				"loerchik",
				"loex",
				"loreat",
				"lovac",
				"maekrix",
				"malsvir",
				"martivir",
				"miirik",
				"moonth",
				"mrith",
				"munthrek",
				"nannan",
				"ner",
				"noachi",
				"nurh",
				"nurthul",
				"nychaki",
				"okarthel",
				"oth",
				"pehweenm",
				"saurach",
				"scithhwo",
				"setfloom",
				"siapsceth",
				"sootn",
				"svern",
				"taaldarax",
				"taloosch",
				"teack",
				"terunt",
				"thaenar",
				"theethweet",
				"thlann",
				"thraenn",
				"throden",
				"vegatus",
				"virlym",
				"vivex",
				"volikma"
			],
			"particles": [
				"har",
				"sa",
				"hel",
				"k'",
				"x'",
				"ma'",
				"hal",
				"tha",
				"aln"
			],
			"alias": [],
			"factor": 3
		},
		"draconic": {
			"title": "draconic",
			// Most words copied or modified from
			// https://forgottenrealms.fandom.com/wiki/Draconic_dictionary
			"lexis": [
				"aesthyr",
				"aithyas",
				"arcaniss",
				"aryte",
				"arytiss",
				"athear",
				"bahamuti",
				"darasv",
				"darathric",
				"darss",
				"ekess",
				"elaress",
				"eorikc",
				"erekess",
				"faessi",
				"faestir",
				"ghoros",
				"karshoj",
				"kear",
				"kepesk",
				"kethend",
				"kiskartchi",
				"korth",
				"kosjmyrni",
				"oposs",
				"ossalur",
				"osvith",
				"othokent",
				"panjar",
				"persvek",
				"petisse",
				"pok",
				"pothachi",
				"pothoc",
				"potvych",
				"qalli",
				"qallim",
				"rach",
				"rasvim",
				"rauhiss",
				"renthisj",
				"rhyaex",
				"rhyisj",
				"rhyvos",
				"sauriv",
				"shafaer",
				"shar",
				"shuk",
				"sjach",
				"sjashukri",
				"sjek",
				"sjerit",
				"sjir",
				"ssearth",
				"ssej",
				"ssifisv",
				"ssissth",
				"sthyr",
				"strix",
				"strixiki",
				"sukriya",
				"sunathaer",
				"sveargith",
				"throtominarr",
				"thurgix",
				"thurirl",
				"thurkear",
				"tiamash",
				"tiathar",
				"tibur",
				"toovir",
				"troth",
				"tundar",
				"tuor",
				"turalisj",
				"turalisjth",
				"turasjir",
				"vaecaesin",
				"vaeri",
				"vaess",
				"vaex",
				"valeij",
				"valignat",
				"vargach",
				"vargus",
				"vayemniri",
				"versel",
				"versvesh",
				"veschik",
				"vorastrix",
				"vorel",
				"vorellim",
				"vrak",
				"vur",
				"vutha",
				"vyth",
				"waere",
				"waeth",
				"wux",
				"xorvintaal"
			],
			"particles": [
				"qal",
				"irn",
				"orn",
				"oth'",
				"va",
				"qa",
				"ia",
				"iss",
				"osh"
			],
			"alias": [
				"tymantheran",
				"yipyak"
			],
			"factor": 3
		},
		"deepspeech": {
			"title": "deepspeech",
			// Most words copied or modified from
			// https://lingojam.com/CommontoDwarvishTranslator
			"lexis": [
				"aat",
				"abakavith",
				"achthend",
				"achuak",
				"adreda",
				"alor",
				"alstgrana",
				"arboth",
				"arn",
				"ath",
				"avglaga",
				"avka",
				"avobi",
				"avrez",
				"avurtsi",
				"azlang",
				"badorank",
				"bathjert",
				"bavta",
				"beal",
				"blozwatan",
				"bod",
				"bodsith",
				"borla",
				"bosumr",
				"djor",
				"djorr",
				"dramath",
				"eom",
				"ertond",
				"ezol",
				"gamlormeth",
				"gelevan",
				"gemagal",
				"gerk",
				"hjandlom",
				"hrut",
				"hverth",
				"ialdra",
				"ialdrar",
				"imurt",
				"imurtr",
				"jarburrir",
				"jektor",
				"jektorgurd",
				"jektorigur",
				"jektraldr",
				"kolav",
				"konuxja",
				"krenl",
				"krugg",
				"kruggr",
				"legjan",
				"lether",
				"lurl",
				"lurlom",
				"lurlthjold",
				"lurlurt",
				"matmurzar",
				"merklesh",
				"morz",
				"morzr",
				"navlat",
				"neastlik",
				"nutha",
				"ommathur",
				"orgrad",
				"orthrumt",
				"orthrumtr",
				"orzra",
				"oved",
				"ovgathi",
				"rithar",
				"rothilr",
				"skegga",
				"skjurvjaklud",
				"slalig",
				"sloshtar",
				"sloshtard",
				"tjorn",
				"unge",
				"ungermoth",
				"ura",
				"uxja",
				"valbleth",
				"valblethr",
				"vethethaz",
				"vlitagana",
				"vold",
				"voldreg",
				"vothnak",
				"vrenka",
				"vrutan",
				"withaur",
				"wundstr",
				"yrja",
				"zarathag",
				"zirund",
				"zirundr",
				"zwatan"
			],
			"particles": [],
			"alias": ["deep speech"],
			"factor": 0
		},
		"infernal": {
			"title": "infernal",
			// Most words copied or modified from
			// https://wowpedia.fandom.com/wiki/Eredun
			"lexis": [
				"achor",
				"adare",
				"akimkurai",
				"akminkurai",
				"akreesh",
				"akris",
				"amanalar",
				"amanare",
				"amanemodas",
				"arakal",
				"arakalada",
				"archim",
				"archimtiros",
				"ashjraka",
				"ashjrakamas",
				"ashjrethul",
				"azgala",
				"azgalada",
				"azrathud",
				"ban",
				"belan",
				"belankar",
				"belaros",
				"benthadoom",
				"buras",
				"burasadare",
				"danashj",
				"enkil",
				"enkilgular",
				"enkilzar",
				"ered",
				"faramos",
				"galar",
				"golad",
				"gulamir",
				"gular",
				"kamil",
				"kamilgolad",
				"kanrethad",
				"karaman",
				"karkun",
				"kazile",
				"kieldaz",
				"kirasath",
				"kirestalak",
				"kurai",
				"maev",
				"maladath",
				"mannor",
				"mannorgulan",
				"matheredor",
				"melar",
				"melarnagas",
				"melarorah",
				"mishun",
				"mishunadare",
				"modas",
				"mordanas",
				"nagas",
				"nagasraka",
				"nash",
				"nazthagos",
				"naztheros",
				"normenoth",
				"nortalesh",
				"pathrebosh",
				"rakeesh",
				"rakir",
				"rakkan",
				"rakkas",
				"reesh",
				"refir",
				"rethul",
				"rethule",
				"revola",
				"revos",
				"romathis",
				"rukadare",
				"shazakiel",
				"sheekthrish",
				"sheetsah",
				"sheki",
				"shudas",
				"soran",
				"soranaman",
				"sorankar",
				"teamanare",
				"theramas",
				"thorje",
				"tichar",
				"ticharamir",
				"tiriosh",
				"tiros",
				"toralar",
				"urzul",
				"zekul",
				"zekulrakkas",
				"zennrakkan",
				"zennshi",
				"zilthuras"
			],
			"particles": [
				"al'",
				"al'",
				"al'",
				"al'",
				"al'",
				"al'",
				"al'",
				"al'",
				"al'"
			],
			"alias": [
				"devil"
			],
			"factor": 2
		},
		"primordial": {
			"title": "primordial",
			// Most words copied or modified from
			// https://lingojam.com/CommontoDwarvishTranslator
			"lexis": [
				"aav",
				"alr",
				"andtur",
				"askung",
				"avur",
				"baksmalk",
				"bal",
				"balr",
				"bjorgart",
				"bondra",
				"bort",
				"bortr",
				"dagr",
				"dehur",
				"djerg",
				"djergr",
				"dlizik",
				"druld",
				"dwjord",
				"dwjorgumal",
				"eigur",
				"erz",
				"erzan",
				"erzanr",
				"fraluv",
				"gebork",
				"genogan",
				"gerkun",
				"glaek",
				"gleen",
				"gog",
				"gotek",
				"goth",
				"gothr",
				"grazz",
				"grea",
				"grethir",
				"guthavok",
				"guthavokr",
				"halkbrelna",
				"herolstor",
				"hign",
				"horukneth",
				"hrendi",
				"hrendir",
				"humtje",
				"hvorbl",
				"inni",
				"ithorm",
				"ithormr",
				"jarlethurkon",
				"jarnjulbort",
				"javnung",
				"jerklirunslaak",
				"jommok",
				"jooki",
				"jookir",
				"kaeleth",
				"kjekje",
				"kralt",
				"kyrv",
				"kyrvr",
				"luglaus",
				"lurl",
				"lyr",
				"lyrglang",
				"lyrr",
				"migvulur",
				"mimm",
				"mimmal",
				"monmur",
				"nenn",
				"nothaar",
				"nunoff",
				"ogalthr",
				"olv",
				"orvrutanr",
				"othruf",
				"othyrth",
				"ott",
				"slok",
				"slokspral",
				"snarla",
				"theov",
				"tjuni",
				"tjunir",
				"torth",
				"trarzurjald",
				"ulvunr",
				"ungvliz",
				"ungvlizr",
				"unnlat",
				"vargunr",
				"varzank",
				"vavi",
				"vavir",
				"verol",
				"veroldr",
				"vlel",
				"vromungvro"
			],
			"particles": [],
			"alias": [
				"elemental",
				"auran",
				"aquan",
				"ignan",
				"rettan"
			],
			"factor": 0
		},
		"sylvan": {
			"title": "sylvan",
			// Most words copied or modified from
			// https://forgottenrealms.fandom.com/wiki/Elven_dictionary
			"lexis": [
				"aegiskeryn",
				"aerister",
				"aethen",
				"akhiilor",
				"aloun",
				"amakiir",
				"ammur",
				"ansrivarr",
				"arakhor",
				"armiel",
				"arselu",
				"auglathla",
				"bhin",
				"biir",
				"bwaelan",
				"calann",
				"cinnaelos",
				"cryshal",
				"damia",
				"darrdartha",
				"dhaerow",
				"durmista",
				"ebrath",
				"elgg",
				"erdel",
				"faer",
				"groef",
				"hethtalos",
				"hirdel",
				"holimion",
				"hond",
				"huan",
				"hurbryn",
				"huthammuth",
				"illunathros",
				"ilphelkiir",
				"iqua",
				"irinal",
				"ivaebhin",
				"kelytha",
				"kerym",
				"kiira",
				"kirthol",
				"kyre",
				"ladrother",
				"lalala",
				"laranlors",
				"liadon",
				"liyan",
				"lurleath",
				"malenti",
				"meliamne",
				"naes",
				"noromath",
				"nyrhlas",
				"nyrtlassa",
				"oloth",
				"pyesigen",
				"quessir",
				"raer",
				"relthwin",
				"renyth",
				"ruathimaer",
				"rum",
				"rysar",
				"sablaes",
				"saece",
				"sathu",
				"savalir",
				"selu",
				"shaedar",
				"shantar",
				"solicallor",
				"sreea",
				"srendaen",
				"ssussun",
				"taar",
				"talibund",
				"tammin",
				"taran",
				"tath",
				"telere",
				"tellarier",
				"tellyath",
				"thaethiira",
				"thiil",
				"tirith",
				"trazaethe",
				"uluvathaer",
				"vaelhar",
				"vaendaan",
				"vaendin",
				"velahr",
				"vyshaan",
				"wael",
				"walaxyrvaan",
				"xiloscient",
				"yyllethyn",
				"zenar",
				"zeranas"
			],
			"particles": [
				"ef",
				"byr",
				"hir",
				"ath-",
				"ai",
				"sa",
				"ol",
				"reb-",
				"thy-"
			],
			"alias": [
				"fey"
			],
			"factor": 5
		},
		"undercommon": {
			"title": "undercommon",
			// Most words copied or modified from
			// https://forgottenrealms.fandom.com/wiki/Drow_dictionary
			"lexis": [
				"abban",
				"abbil",
				"angardh",
				"araj",
				"asanque",
				"bae",
				"bauth",
				"belbol",
				"brorn",
				"caballin",
				"colbauth",
				"crinti",
				"darthiir",
				"dobluth",
				"dosst",
				"dosstan",
				"draa",
				"draada",
				"draghazar",
				"droc",
				"elamshin",
				"elendar",
				"elghinn",
				"feleal",
				"fhaazht",
				"golhyrr",
				"harl",
				"honglath",
				"hyrr",
				"ilharess",
				"ilharn",
				"ilindith",
				"inthigg",
				"jivvin",
				"khal",
				"khaless",
				"khazid",
				"kulg",
				"kyone",
				"kyorl",
				"kyorlin",
				"llar",
				"lueth",
				"malla",
				"mzild",
				"natha",
				"neideirra",
				"neirt",
				"nindyn",
				"noamuth",
				"obsul",
				"olist",
				"oloth",
				"orthae",
				"phindar",
				"phlar",
				"pholar",
				"phuul",
				"plynn",
				"qeshel",
				"qual",
				"quarthen",
				"ragar",
				"rathrae",
				"rivvil",
				"sargh",
				"sargtlin",
				"shavrak",
				"shea",
				"shrome",
				"streea",
				"taga",
				"talinth",
				"talthalra",
				"thae",
				"thaerra",
				"thalack",
				"thalra",
				"tinguin",
				"tuth",
				"uente",
				"ultrin",
				"ultrinnan",
				"usstan",
				"valsharess",
				"velkyn",
				"velve",
				"vidrinath",
				"wund",
				"xittalsh",
				"xorr",
				"xund",
				"xundus",
				"yath",
				"yathrin",
				"yathtallar",
				"yorn",
				"zedrinset",
				"zhah",
				"zhaun"
			],
			"particles": [
				"dro",
				"duk",
				"tak",
				"il",
				"zin-",
				"qu-",
				"uh",
				"uss",
				"akh-"
			],
			"alias": [
				"underdark"
			],
			"factor": 4
		},
		"fakeitalian": {
			"title": "fakeitalian",
			// Most words copied or modified from
			// https://www.generatormix.com/random-italian-words-generator
			"lexis": [
				"abby",
				"affrontare",
				"agenzia",
				"albert",
				"andiamo",
				"fratello",
				"non",
				"mastroianni",
				"tutti",
				"funyunsetti",
				"angolo",
				"apri",
				"ascoltato",
				"baciare",
				"braccia",
				"buonanotte",
				"cameriera",
				"campeggio",
				"carrie",
				"cassetto",
				"cazzata",
				"chiede",
				"circostanze",
				"colonnello",
				"combinato",
				"consegnare",
				"cooper",
				"corona",
				"credete",
				"desiderio",
				"dire",
				"distrutta",
				"dito",
				"dottor",
				"dovuto",
				"effetti",
				"ellie",
				"eroina",
				"facesse",
				"finestre",
				"fonte",
				"for",
				"freddo",
				"gentiluomo",
				"gioca",
				"gridare",
				"hey",
				"incontro",
				"indizio",
				"intendi",
				"jimmy",
				"leon",
				"libera",
				"litigato",
				"malato",
				"morirai",
				"museo",
				"naomi",
				"occhio",
				"offrire",
				"ottenere",
				"pesante",
				"portafoglio",
				"possano",
				"preferisco",
				"preparare",
				"promessa",
				"pulizie",
				"puntata",
				"puttane",
				"quartiere",
				"quelli",
				"radio",
				"rende",
				"revisione",
				"riuscite",
				"roma",
				"rotto",
				"salire",
				"saprai",
				"scoprire",
				"scorsa",
				"scusarmi",
				"sederti",
				"sembri",
				"servi",
				"settembre",
				"sociale",
				"sollievo",
				"sorpreso",
				"terribili",
				"torniamo",
				"trattamento",
				"troveremo",
				"utile",
				"vacanze",
				"vada",
				"vari",
				"vinto",
				"viviamo"
			],
			"particles": [
				"di",
				"del",
				"al",
				"il",
				"la",
				"in",
				"su",
				"da",
				"ai"
			],
			"alias": [],
			"factor": 3
		},
		"fakespanish": {
			"title": "fakespanish",
			// Most words copied or modified from
			// https://www.generatormix.com/random-spanish-words
			"lexis": [
				"abajo",
				"abrazo",
				"acabar",
				"acercarse",
				"acompañar",
				"acostarse",
				"agradecer",
				"alcalde",
				"arriba",
				"atrás",
				"autoridad",
				"averiguar",
				"barrio",
				"bonito",
				"bosillo",
				"broma",
				"bulto",
				"caballero",
				"camarero",
				"campana",
				"canción",
				"claro",
				"cliente",
				"cobrar",
				"conmigo",
				"corregir",
				"cosa",
				"costumbre",
				"cuaderno",
				"cuadra",
				"cuarto",
				"deporte",
				"descubrir",
				"devolver",
				"dirección",
				"dónde",
				"durar",
				"ejemplo",
				"enfermo",
				"entrar",
				"equipaje",
				"escribir",
				"escuela",
				"estómago",
				"estudiar",
				"extrañar",
				"extraño",
				"fósforo",
				"frontera",
				"hombre",
				"huésped",
				"jamás",
				"jardín",
				"joven",
				"juez",
				"kilómetro",
				"laudar",
				"levantar",
				"listo",
				"lleno",
				"mañana",
				"mediodía",
				"mentira",
				"merienda",
				"método",
				"mientras",
				"muerto",
				"nevar",
				"norte",
				"nunca",
				"obligar",
				"pariente",
				"patrón",
				"permiso",
				"picante",
				"pico",
				"pierna",
				"píldora",
				"planchar",
				"pluma",
				"pobre",
				"promesa",
				"receta",
				"recuerdo",
				"regalo",
				"régimen",
				"repente",
				"repitir",
				"reunión",
				"rodilla",
				"según",
				"señorita",
				"servir",
				"siempre",
				"silla",
				"sólo",
				"temprano",
				"tijeras",
				"tinta",
				"vestirse"
			],
			"particles": [
				"las",
				"la",
				"de",
				"des",
				"a",
				"con",
				"por",
				"el",
				"acá"
			],
			"alias": [],
			"factor": 3
		},
		"fakefrench": {
			"title": "fakefrench",
			// Most words copied or modified from
			// https://www.generatormix.com/random-french-words-generator
			"lexis": [
				"aide",
				"aille",
				"aimait",
				"allons",
				"américains",
				"annonce",
				"appelles",
				"appris",
				"asseoir",
				"attendre",
				"aucun",
				"autrement",
				"avons",
				"beaucoup",
				"blanche",
				"certaine",
				"chez",
				"coffre",
				"connaissez",
				"connaître",
				"conneries",
				"contraire",
				"crains",
				"crime",
				"dégage",
				"déjà",
				"difficile",
				"emmène",
				"enfant",
				"extérieur",
				"fallait",
				"félicitations",
				"femmes",
				"feras",
				"file",
				"finir",
				"formidable",
				"fort",
				"frappé",
				"fusil",
				"garçons",
				"génial",
				"genoux",
				"grande",
				"honneur",
				"image",
				"intéressant",
				"jake",
				"joie",
				"leurs",
				"lycée",
				"maman",
				"manqué",
				"message",
				"met",
				"militaire",
				"moyens",
				"noire",
				"nul",
				"oublier",
				"ouest",
				"ouvre",
				"partez",
				"pas",
				"passera",
				"patron",
				"pensait",
				"personnes",
				"petit",
				"points",
				"premier",
				"presse",
				"preuves",
				"prochain",
				"projet",
				"puisse",
				"puissant",
				"queue",
				"ravi",
				"rencontré",
				"répondu",
				"reprendre",
				"retrouve",
				"revient",
				"rouge",
				"salut",
				"signer",
				"soldats",
				"sorte",
				"souris",
				"télé",
				"tenir",
				"fournir",
				"trés",
				"trouver",
				"tueur",
				"univers",
				"vidéo",
				"vient",
				"vrais"
			],
			"particles": [
				"en",
				"de",
				"pour",
				"le",
				"au-",
				"d'",
				"il",
				"à",
				"sur"
			],
			"alias": [],
			"factor": 3
		},
		"fakerussian": {
			"title": "fakerussian",
			// Most words copied or modified from
			// https://www.generatormix.com/random-russian-words-generator
			"lexis": [
				"avtor",
				"babushka",
				"beseda",
				"chas",
				"dengi",
				"devushka",
				"doktor",
				"dokument",
				"dom",
				"drug",
				"drugi",
				"dver",
				"golos",
				"golova",
				"gorod",
				"groznii",
				"gusto",
				"hleb",
				"hudozhnik",
				"igra",
				"imperskii",
				"institut",
				"interes",
				"izbrannii",
				"kabinet",
				"kachestvo",
				"koleno",
				"komnata",
				"kompaniya",
				"konets",
				"koridor",
				"kuhnya",
				"ladon",
				"leitenant",
				"litso",
				"logicheskii",
				"lopata",
				"mesto",
				"metr",
				"minuta",
				"molodaya",
				"moloko",
				"morozhenoe",
				"muzhik",
				"nabratsya",
				"nachalo",
				"nastoyaschii",
				"natknutsya",
				"nauka",
				"noch",
				"noga",
				"obeschanie",
				"obraschat",
				"okno",
				"otets",
				"pachka",
				"polovina",
				"posol",
				"pravda",
				"predshestvennik",
				"protsessor",
				"pyatsot",
				"rabota",
				"rasskaz",
				"razvitie",
				"rebyonok",
				"reshenie",
				"rodstvennii",
				"roman",
				"ryad",
				"samolet",
				"schet",
				"sila",
				"slovo",
				"sluzhba",
				"spokoistvie",
				"sponsor",
				"stalnoi",
				"stol",
				"storona",
				"strana",
				"supruzheskii",
				"svet",
				"techenie",
				"temperatura",
				"tezis",
				"trubka",
				"vibratsya",
				"voda",
				"voina",
				"voobsche",
				"vopros",
				"vosstanovlenie",
				"vrag",
				"vsemirnii",
				"vstrecha",
				"zanyatie",
				"zemlya",
				"zhena",
				"zhuchara"
			],
			"particles": [
				"da",
				"na",
				"ot",
				"i",
				"ne",
				"po",
				"do",
				"pro",
				"ty"
			],
			"alias": [],
			"factor": 3
		},
		"fakegerman": {
			"title": "fakegerman",
			// Most words copied or modified from
			// https://www.generatormix.com/random-german-words-generator
			"lexis": [
				"allem",
				"anderer",
				"anders",
				"angefangen",
				"beispiel",
				"bier",
				"blut",
				"brauchen",
				"brüder",
				"dein",
				"deshalb",
				"druck",
				"durch",
				"eher",
				"eigenen",
				"eingeladen",
				"erstes",
				"fand",
				"fantastisch",
				"fast",
				"fehler",
				"fern",
				"fertig",
				"frage",
				"frank",
				"freuen",
				"funktioniert",
				"gefällt",
				"geliebt",
				"geschlafen",
				"geschlagen",
				"gewehr",
				"glaube",
				"glückwunsch",
				"gutes",
				"haltet",
				"hand",
				"hasst",
				"heiß",
				"held",
				"hielt",
				"hoffentlich",
				"holen",
				"irgendetwas",
				"jemandem",
				"jungen",
				"kennst",
				"kennt",
				"knie",
				"kommen",
				"krankenhaus",
				"lehrer",
				"leiden",
				"lhrem",
				"lst",
				"monster",
				"namens",
				"ohne",
				"person",
				"plan",
				"planeten",
				"rechte",
				"rom",
				"ruhig",
				"sagten",
				"schätze",
				"schreiben",
				"schuld",
				"freitag",
				"schwer",
				"schwierig",
				"seine",
				"seiten",
				"senator",
				"solange",
				"spiel",
				"steckt",
				"stimmen",
				"super",
				"tag",
				"taten",
				"töte",
				"überleben",
				"unglaublich",
				"versuchte",
				"voller",
				"völlig",
				"weib",
				"weil",
				"weise",
				"weisst",
				"weit",
				"werd",
				"werfen",
				"wohnen",
				"wollt",
				"zeiten",
				"zeug",
				"zweite",
				"zeitgeist"
			],
			"particles": [
				"ich",
				"bin",
				"sie",
				"zu",
				"auf",
				"an",
				"du",
				"wir",
				"für"
			],
			"alias": [],
			"factor": 3
		}
	};
	/* eslint-enable */
}

SCRIPT_EXTENSIONS.push(baseChatLanguages);


function baseChat () {
	d20plus.chat = d20plus.chat || {};

	d20plus.chat.localHistory = [];
	d20plus.chat.lastRespondent = "";
	const languages = d20plus.chat.languages;

	function buildLanguageIndex () {
		d20plus.chat.languageIndex = {};
		d20plus.chat.languageAdditions = {};
		Object.keys(languages).forEach(id => {
			const language = languages[id];// RB20 EXCLUDE START

			const alias = `${__(`lang_alias_${id}`)}`
			language.title = `${__(`lang_${id}`)}`;
			if (!language.alias) language.alias = alias.split(", ");
			else language.alias = [].concat(language.alias, alias.split(", "));
			// RB20 EXCLUDE END
			d20plus.chat.languageIndex[id] = id;
			d20plus.chat.languageIndex[language.title.toLowerCase()] = id;
			language.alias.forEach(name => {
				d20plus.chat.languageIndex[name] = id;
			})
		});
	}

	function gibberish (string, langId, incompetent) {
		if (!languages[langId]) langId = d20plus.chat.languageAdditions[langId];
		if (!languages[langId]) return string;

		const paragraphs = string.split("\n");
		if (paragraphs.length > 1) return paragraphs.map(str => gibberish(str, langId, incompetent)).join("\n");

		// The code below generates pseudo-random text "in selected language".
		// Each separate word replacement is different in each case, yet chunks of 3 and more
		// words are always replaced with the same "words" to create an illusion of real translation.
		// This is done by calculating numerical value for each 3 words, and then using its last 2 digits
		// as an index to select "translated word" from the dictionary of 100 fake words.

		const particle = { left: false };
		const words = string.toLowerCase().match(/(--\p{L}+|\p{L}+)/gu);
		if (words === null) return "";
		if (incompetent) words.shuffle();

		const calcIndex = (word) => {
			return Array.from(`${word}`).reduce((index, letter) =>
				index + letter.charCodeAt(0)
			, 0);
		};
		const indexes = words.map((word, i) => {
			const left = i ? calcIndex(words[i - 1]) : 0;
			const right = 2 * calcIndex(words[i + 1]);
			return left + calcIndex(word) + right;
		});

		const translations = indexes.map((index, i) => {
			particle.left = particle.this && particle.left;
			particle.this = (index - 1) % 9 + 1 < languages[langId].factor;
			const spacing = i < words.length - 1 ? " " : "";
			if (incompetent && Math.random() > 0.5) {
				return words[i] + spacing;
			} else if (words[i].indexOf("--") === 0) { // RB20 EXCLUDE START
				words[i] = d20plus.ut.transliterate(words[i])// RB20 EXCLUDE END
				return words[i].replace(/--/gu, "").uppercaseFirst() + spacing;
			} else if (particle.this && !particle.left && i < words.length - 1) {
				particle.left = true;
				const transId = (index.toString().charAt(0) + index - 1) % 9;
				const spacing = /['-]$/.test(languages[langId].particles[transId]) ? "" : " ";
				return languages[langId].particles[transId] + spacing;
			} else {
				const transId = index.toString().slice(-2);
				return languages[langId].lexis[parseInt(transId)] + spacing;
			}
		});

		translations[0] = translations[0].uppercaseFirst();
		return translations.join("");
	}

	function availableLanguages (charId) {
		const char = d20.Campaign.characters.get(charId);
		const langId = d20.journal.customSheets.availableAttributes.repeating_proficiencies_prof_type;
		if (!char) return [];
		if (!char.attribs.length) {
			const fetched = d20plus.ut.fetchCharAttribs(char);
			fetched.then(d20plus.chat.refreshLanguages);
		}
		// roll20 OGL sheet stores languages differently compared to other traits
		// by default, they don't have corresponging "proficiency type" attribute
		// however, if you create a trait and THEN change it to be language, it will have LOCALIZED "language" proficiency type
		// so to find all languages, we must filter out other named traits, except for the traits named "language" or "(localized word for LANGUAGE)"
		const traits = char.attribs.models
			.filter(prop => {
				return prop.attributes.name.match(/repeating_proficiencies_(.*?)_prof_type/)
				&& ![langId, "LANGUAGE"].includes(prop.attributes.current);
			})
			.map(trait => trait.attributes.name.replace(/repeating_proficiencies_(.*?)_prof_type/, "$1"));
		// now that we have a list of named non-language traits we can just find what we need
		const charspeaks = char.attribs.models.map(prop => {
			const filter = /repeating_proficiencies_(.*?)_name/;
			if (prop.attributes.name.match(filter)) {
				const isSimpleTrait = traits.includes(filter.exec(prop.attributes.name)[1]);
				if (!isSimpleTrait) return prop.attributes.current;
			} else if (prop.attributes.name === "npc_languages") {
				return prop.attributes.current.split(", ");
			}
		}).filter(lang => lang !== undefined);
		return charspeaks.flatten().map(lang => lang.normalize());
	}

	function availableLanguagesPlayer (playerId) {
		const characters = d20.Campaign.characters.models
			.filter(char => {
				const actors = char.attributes.controlledby.split(",");
				return actors.includes(playerId);
			})
			.map(char => char.id);
		return characters
			.map(charId => availableLanguages(charId))
			.flatten();
	}

	function hasLanguageProficiency (langId) {
		const proficientIn = availableLanguagesPlayer(d20_player_id)
			.map(lang => d20plus.chat.getLanguageId(lang));
		return proficientIn.includes(d20plus.chat.getLanguageId(langId));
	}

	d20plus.chat.listSpeakingIn = (available) => {
		$("#speakingin").html(available
			.map(lang => lang.toSentenceCase())
			.reduce((html, lang) => `${html}<option>${lang}</option>`, "<option></option>"),
		);
	}

	d20plus.chat.getLanguageId = (lang) => {
		if (Array.isArray(lang)) return lang.map(language => d20plus.chat.getLanguageId(language));
		else return d20plus.chat.languageIndex[lang.normalize().toLowerCase()] || lang.normalize().toLowerCase();
	}

	d20plus.chat.refreshLanguages = () => {
		const $speakingIn = $("#speakingin");
		const speakingAs = $("#speakingas").val().split("|");
		const actorId = speakingAs[1];
		const actorIsPlayer = speakingAs[0] === "player";
		if (actorIsPlayer) {
			if (window.is_gm) {
				const prev = $speakingIn.val();
				d20plus.chat.listSpeakingIn(Object.keys(languages)
					.filter(lang => !lang.includes("fake"))
					.map(lang => languages[lang].title));
				$speakingIn.val(prev);
			} else {
				d20plus.chat.listSpeakingIn([]);
				$speakingIn.val("<option></option>");
			}
		} else {
			const prev = $speakingIn.val();
			const langs = availableLanguages(actorId);
			d20plus.chat.listSpeakingIn(langs);
			$speakingIn.val(prev);
		}
	}

	d20plus.chat.availableAddressees = () => {
		const players = d20.Campaign.players.models
			.filter(player => player.attributes.online && player.attributes.id !== d20_player_id)
			.map(player => ({name: player.attributes.displayname, id: player.attributes.id}));
		const characters = d20.Campaign.characters.models
			.filter(char => {
				if (!char.attributes.inplayerjournals) return false;
				const actors = char.attributes.controlledby.split(",");
				return actors.some(actor => actor && players.map(player => player.id).includes(actor))
			})
			.map(char => ({name: char.attributes.name}));
		return players.concat(characters);
	}

	d20plus.chat.setLanguagePreset = (message, language) => {
		if ($("#soundslike").length) return;
		const dialog = $(languageDialogTemplate(message, language));
		const src = d20.textchat.$textarea.val();
		const msg = {};
		setTimeout(() => {
			d20.textchat.$textarea.val(src);
			dialog.find("#soundslike").focus();
		}, 200);
		dialog.dialog({
			title: __("ui_lang_subst_title"),
			modal: true,
			width: 365,
			open: () => {
				msg.selected = dialog.find("#soundslike");
				msg.sample = dialog.find("#languageeg");
				$("#soundslike").change(() => {
					msg.sample.html(gibberish(message, msg.selected.val()));
				});
				msg.selected.focus();
			},
			close: () => {
				dialog.off();
				dialog.dialog("destroy").remove();
			},
			buttons: {
				[`${__("ui_dialog_submit")}`]: function () {
					const val = msg.selected.val();
					const langId = language.normalize().toLowerCase();
					d20plus.ut.log(`Select language style ${language} to ${val}`);

					dialog.off();
					dialog.dialog("destroy").remove();
					d20.textchat.$textarea.focus();

					d20plus.chat.languageAdditions[langId] = val;
					$("#textchat-input button.btn").get(0).click();
				},
				[`${__("ui_dialog_cancel")}`]: function () {
					dialog.off();
					dialog.dialog("destroy").remove();
				},
			},
		});
	}

	const languageTemplate = () => `
		<script id="sheet-rolltemplate-inlanguage" type="text/html">{{displaymessage}}<br>
			<span style="font-style:italic" title="${__("msg_chat_lang_title")} {{titlelanguage}}">
			<span style="font-weight:bold">{{displaylanguage}}</span> {{translated}}
			</span>
		</script>
	`;

	const languageDialogTemplate = (msg, language) => `
			<div>
				<p><strong>${__("ui_lang_subst_subtitle", [language])}</strong></p>
				<p>${__("ui_lang_subst_p1")}</p>
				<p>${__("ui_lang_subst_p2")}</p>
				<p>${__("ui_lang_subst_p3")}</p>
				<span style="display:block; height: 40px;">
					<label style="display: inline-block;" for="soundslike">${__("ui_lang_subst_select")}</label>
					<select id="soundslike" style="float: right; width: 60%;">
						${Object.keys(languages).reduce((options, lang) => `${options}<option value="${lang}">${lang}</option>`, "")}
					</select>
				</span>
				<p>${__("ui_lang_subst_p_eg", [language])}</p>
				<p><textarea id="languageeg" disabled="" style="width: 100%; box-sizing: border-box; height: 50px;cursor: default;resize: none; background: rgba(100, 100, 150, 0.2);"
					>${gibberish(msg, "common")}</textarea>
				</p>
			</div>
	`;

	const playerVersionsTemplate = (id) => `
			<input type="checkbox" class="connects-state" id="connects${id}-state"/>
			<label for="connects${id}-state">
				<span id="connects${id}-info" class="connects-info" title="Show player details">0</span>
				<span id="connects${id}" class="connects-log">
				B20 not responding...
				</span>
			</label>
	`;

	const removeClassUserscript = (html) => {
		return html.replace(/class="(?<class>[^""]*)"/g, (...str) => {
			const cls = str.last().class;
			return `class="${cls.replaceAll("userscript-", "")}"`
		});
	};

	const chatHelp = [
		{
			code: "/w %%",
			descr: __("msg_chat_help_w"),
			param: "name",
			tip: "Name of a player or a character, put in quotation marks if it contains spaces",
		},
		{
			code: "/w gm",
			descr: __("msg_chat_help_wgm"),
		},
		{
			code: "/wb",
			descr: __("msg_chat_help_wb"),
			b20: true,
		},
		{
			code: "/ws",
			descr: __("msg_chat_help_ws"),
			b20: true,
			gm: true,
		},
		{
			code: "/v %%",
			descr: __("msg_chat_help_versions"),
			param: "name",
			tip: "Name of a player that you want to get version info from, put in quotation marks if it contains spaces",
			b20: true,
			gm: true,
		},
		{
			code: "/em, /me",
			descr: __("msg_chat_help_em"),
		},
		{
			code: "/ooc, /o",
			descr: __("msg_chat_help_ooc"),
		},
		{
			code: "/desc",
			descr: __("msg_chat_help_desc"),
			gm: true,
		},
		{
			code: "/as %%",
			descr: __("msg_chat_help_as"),
			param: "name",
			tip: "Name of the personified character, put in quotation marks if it contains spaces",
			gm: true,
		},
		{
			code: "/emas %%",
			descr: __("msg_chat_help_emas"),
			param: "name",
			tip: "Name of the described character, put in quotation marks if it contains spaces",
			gm: true,
		},
		{
			code: "/in %%",
			descr: __("msg_chat_help_in"),
			param: "language",
			tip: "Name of a language that you know, put in quotation marks if it contains spaces",
			b20: true,
		},
		{
			code: "--%%",
			descr: __("msg_chat_help_inname"),
			param: "word",
			tip: "Any single word inside in-language text that you want to keep from being translated, without spaces or hyphens",
			b20: true,
		},
		{
			code: "/talktomyself",
			descr: __("msg_chat_help_sm"),
		},
		{
			code: "/ttms",
			descr: __("msg_chat_help_ttms"),
			b20: true,
		},
		{
			code: "/mtms %%",
			descr: __("msg_chat_help_mtms"),
			param: "commands",
			tip: "Set of commands, separated by line breaks, to be executed in /ttms mode",
			b20: true,
		},
		{
			code: "/roll, /r %%",
			descr: __("msg_chat_help_r"),
			param: "XdY",
			tip: "Dice roll formula, like 1d20 +5",
		},
		{
			code: "/gmroll, /gr %%",
			descr: __("msg_chat_help_gr"),
			param: "XdY",
			tip: "Dice roll formula, like 1d20 +5, the result of which will be visible only to GM",
		},
		{
			code: "[[%%]]",
			descr: __("msg_chat_help_il"),
			param: "XdY",
			tip: "Dice roll formula, like 1d20 +5, to be shown inside any other text",
		},
		{
			code: "&#42;%%&#42;",
			descr: __("msg_chat_help_fi"),
			param: "text",
			tip: "Any formatted text without line breaks",
		},
		{
			code: "&#42;&#42;%%&#42;&#42;",
			descr: __("msg_chat_help_fb"),
			param: "text",
			tip: "Any formatted text without line breaks",
		},
		{
			code: "&#96;&#96;%%&#96;&#96;",
			descr: __("msg_chat_help_fc"),
			param: "text",
			tip: "Any formatted text without line breaks",
		},
		{
			code: "&#126;&#126;%%&#126;&#126;",
			descr: __("msg_chat_help_fs"),
			param: "text",
			tip: "Any formatted text without line breaks",
		},
		{
			code: "/fx %%",
			descr: __("msg_chat_help_fx"),
			param: "effect",
			tip: "Effect parameters, using the following syntax: Type&#8209;Color&nbsp;SourceID&nbsp;[TargetID]",
		},
		{
			code: "#%%",
			descr: __("msg_chat_help_m"),
			param: "macro",
			tip: "Name of the macro to be executed",
		},
		{
			code: "/help",
			descr: __("msg_chat_help"),
			b20: true,
		},
		{
			code: "",
			descr: "<a style=\"font-variant: diagonal-fractions; font-size: smaller; font-variant-caps: small-caps;\" href=\"https://wiki.roll20.net/Text_Chat\">roll20 wiki</a>",
		},
	];

	d20plus.chat.help = (text, msg) => {
		d20plus.chat.modifyMsg(null, {legalize: true, sys: true});
		d20plus.ut.sendHackerChat(chatHelp.reduce((html, it) => {
			const isb20 = it.b20 ? `<span class="showtip tipsy-n-right" style="cursor:help;font-weight: bold;" title="This command was added by betteR20">&#42;</span>` : "";
			const param = it.param ? `<span class="showtip tipsy-n-right" style="background: rgba(206, 96, 96, 0.3);" title="${it.tip}">${it.param}</span>` : "";
			const code = it.code ? `<code>${it.code.replace("%%", param)}</code>${isb20}` : "&nbsp;";
			const gmcheck = !it.gm || window.is_gm;
			const langcheck = d20plus.cfg.getOrDefault("chat", "languages") || it.code.search(/^\/in|^--/) === -1;
			if (gmcheck && langcheck) return `${html}<br>${code}<span style="float:right"> ${it.descr}</span>`;
			return html;
		}, __("msg_b20_chat_help_title")));
		return "";
	}

	d20plus.chat.actions = { run: (id) => {
		d20plus.chat.actions[id]?.callback(d20plus.chat.actions[id]?.params);
		delete d20plus.chat.actions[id];
	}};

	d20plus.chat.smallActionBtnAdd = (msg, action) => {
		const id = d20plus.ut.generateRowId();
		const actions = {
			hp: {title: "Revert damage", icon: "r", callback: d20plus.engine.alterTokensHP},
			spell: {title: "Revert spell slots", icon: "r", callback: d20plus.engine.expendResources},
			item: {title: "Revert item usage", icon: "r", callback: d20plus.engine.expendResources},
			resource: {title: "Revert spending resources", icon: "r", callback: d20plus.engine.expendResources},
			repeated: {title: "Revert spending resources", icon: "r", callback: d20plus.engine.expendResources},
			request: {title: "Request script info", icon: "?", callback: d20plus.chat.requestScriptVersions},
		}[action.type];
		d20plus.chat.actions[id] = Object.assign({params: action}, actions);
		msg.append(`<span class="msg-action-button showtip tipsy-n-right"
			data-action="${id}" title="${actions.title}">${actions.icon}
		</span>`);
	}

	d20plus.chat.smallActionBtnPress = (event) => {
		const $el = $(event.target);
		const id = $el.attr("data-action");
		d20plus.chat.actions.run(id);
	}

	d20plus.chat.requestScriptVersions = (params, msg) => {
		const id = d20plus.ut.generateRowId();
		msg = msg || `"${params.name}"`;
		msg.replace(/^("?)(?<name>[^ ]+|[^"]+)\1.*$/u, (...str) => {
			const name = str.last().name;
			const transport = {type: "handshake", id};
			d20.textchat.doChatInput(`/w "${name}" &nbsp;`, undefined, transport);
		});
		return "";
	}

	d20plus.chat.modifyMsg = (id, mod) => {
		id = id || d20plus.ut.generateRowId();
		d20plus.chat.modify = d20plus.chat.modify || {};
		d20plus.chat.modify[id] = d20plus.chat.modify[id] || {};
		Object.assign(d20plus.chat.modify[id], mod);
	}

	d20plus.chat.checkTTMSStatus = () => {
		const $speakingTo = $("#speakingto");
		if (d20.textchat.talktomyself) {
			if (d20plus.cfg.getOrDefault("chat", "highlightttms")) $("#textchat-input").addClass("talkingtoself");
			$speakingTo.val("ttms");
		} else {
			$("#textchat-input").removeClass("talkingtoself");
			if ($speakingTo.val() === "ttms") $speakingTo.val("");
		}
	}

	d20plus.chat.resetSendMyself = () => {
		if (d20plus.chat.mtms?.await) {
			d20.textchat.talktomyself = false;
			delete d20plus.chat.mtms;
		}
	}

	d20plus.chat.sendMyself = (text, msg) => {
		// This enables talktomyself mode only for the block of commands in the textarea
		// and then a hook in d20plus.chat.r20outgoing (doChatInput injection) disables it
		d20.textchat.talktomyself = true;
		setTimeout(() => {
			d20.textchat.doChatInput(msg);
			d20plus.chat.mtms = {await: true};
		}, 100);
		return "";
	}

	d20plus.chat.sendReply = (text, msg) => {
		const lastRespondent = d20plus.chat.lastRespondent;
		if (lastRespondent) return `/w "${lastRespondent}"${msg}`;
		else d20plus.ut.sendHackerChat("You have to start a private chat with someone first", true);
		return "";
	}

	d20plus.chat.sendToSelected = (text, msg) => {
		const canSpeakTo = d20plus.chat.availableAddressees().map(char => char.name);
		const addressees = d20.engine.selected()
			.map(token => token._model.character.attributes?.name)
			.filter(name => canSpeakTo.includes(name));
		if (addressees.length) return addressees.reduce((result, name) => { return `${result}/w "${name}"${msg}\n` }, "");
		else d20plus.ut.sendHackerChat("You have to select tokens belonging to actual players", true);
		return "";
	}

	d20plus.chat.sendInLanguage = (message, language) => {
		let langId = d20plus.chat.getLanguageId(language);
		if (!languages[langId] && !d20plus.chat.languageAdditions[langId]) {
			d20plus.chat.setLanguagePreset(message, language);
			return "";
		}
		const knows = window.is_gm || hasLanguageProficiency(langId);
		message = knows ? message : gibberish(message, langId, true);
		return `${gibberish(message, langId)}|&inlang|${language}|&meta|${langId}|&meta|${message}`;
	}

	d20plus.chat.sendParsedInLanguage = (text, msg) => {
		return msg.replace(/^("?)(?<lang>[^ ]+|[^"]+)\1 (?<msg>.+)$/u, (...str) => {
			const inlang = str.last();
			return d20plus.chat.sendInLanguage(inlang.msg, inlang.lang);
		});
	}

	d20plus.chat.getSpeakingTo = () => {
		const $speakingTo = $("#speakingto");
		const prev = $speakingTo.val();
		$speakingTo.html((() => {
			return d20plus.chat.availableAddressees().reduce((result, addressee) => {
				const icon = addressee.id ? "🗣" : "⚑";
				const option = `${icon} ${addressee.name}`;
				const value = `value="${addressee.name}"`;
				result += `<option ${value}>${option}</option>`;
				return result;
			}, `<option value="">All</option><option value="ttms">None</option>`);
		})());
		$speakingTo.val(prev);
	}

	addConfigOptions(
		"chat", {
			"social": {
				"name": __("cfg_option_enable_social"),
				"default": true,
				"_type": "boolean",
				"_player": true,
			},
			"showPlayerConnects": {
				"name": __("cfg_option_log_players_in_chat"),
				"default": true,
				"_type": "boolean",
			},
			"commands": {
				"name": __("cfg_option_additional_commands"),
				"default": true,
				"_type": "boolean",
				"_player": true,
			},
			"highlightttms": {
				"name": __("cfg_option_highlight_ttms"),
				"default": true,
				"_type": "boolean",
				"_player": true,
			}, // RB20 EXCLUDE START
			/* "shareVersions": {
				"name": __("cfg_option_share_version_info"),
				"default": true,
				"_type": "boolean",
				"_player": true,
			}, */
			"autoExpend": {
				"name": "Expend spell slots & class resources",
				"default": "b20",
				"_type": "_enum",
				"__values": ["none", "b20", "auto", "debug"],
				"__texts": ["disabled", "only b20 expressions", "b20 expressions and OGL attack templates", "debug mode (not for actual game!)"],
				"_player": true,
			},
			"autoDmg": {
				"name": "Apply damage and attack rolls",
				"default": "b20mods",
				"_type": "_enum",
				"__values": ["none", "b20", "b20mods", "auto", "debug"],
				"__texts": ["disabled", "only b20 expressions", "use b20 expressions & suggest actions for every roll", "b20 expressions and OGL attack templates", "debug mode (not for actual game!)"],
				"_player": true,
			},
			"dmgTokenBar": {
				"name": "Token bar to apply HP changes to",
				"default": "3",
				"_type": "_enum",
				"__values": ["1", "2", "3"],
				"_player": true,
			}, // RB20 EXCLUDE END
			"executeJSMacro": {
				"name": "Execute JS script in macros",
				"default": "own",
				"_type": "_enum",
				"__values": ["none", "own", "all"],
				"__texts": [
					"Disabled",
					"Run your own scripts",
					"Run all scripts (only if you trust your GM!)",
				],
				"_player": true,
			},
		},
	);

	d20plus.chat.onSocial = () => {
		const $inputContainer = $("#textchat-input");
		if (!d20plus.chat.social) {
			const resized = $inputContainer.attr("style").includes("height")
			if (resized) $inputContainer.addClass("social-resized");
			else $inputContainer.addClass("social-default");
			d20plus.chat.refreshLanguages();
			d20plus.chat.getSpeakingTo();
			d20plus.chat.social = true;
		} else {
			d20plus.chat.closeSocial();
		}
	}

	d20plus.chat.onSpeakingAs = () => {
		d20plus.chat.refreshLanguages();
	}

	d20plus.chat.onSpeakingTo = () => {
		const speakingTo = $("#speakingto").val();
		const ttms = speakingTo === "ttms";
		if (d20.textchat.talktomyself && !ttms) {
			d20.textchat.doChatInput(`/talktomyself off`);
			d20plus.chat.localHistory.push(false);
			setTimeout(() => d20plus.chat.checkTTMSStatus(), 10);
		} else if (!d20.textchat.talktomyself && ttms) {
			d20.textchat.doChatInput(`/talktomyself on`);
			d20plus.chat.localHistory.push(false);
			setTimeout(() => d20plus.chat.checkTTMSStatus(), 10);
		}
		if (speakingTo && !ttms) {
			$("#textchat-social-notifier").addClass("b20-to");
			$("#textchat-social-notifier-to").text(speakingTo);
		} else {
			$("#textchat-social-notifier").removeClass("b20-to");
		}
	}

	d20plus.chat.onSpeakingIn = () => {
		const speakingIn = $("#speakingin").val();
		if (speakingIn) {
			$("#textchat-social-notifier").addClass("b20-in");
			$("#textchat-social-notifier-in").text(speakingIn);
		} else {
			$("#textchat-social-notifier").removeClass("b20-in");
		}
	}

	d20plus.chat.resetSocial = () => {
		$("#speakingin").val("");
		if (!d20.textchat.talktomyself) $("#speakingto").val("");
		$("#textchat-social-notifier").removeClass("b20-in b20-to");
		d20plus.chat.closeSocial();
	}

	d20plus.chat.resetTTMS = () => {
		$("#speakingto").val("");
		d20plus.chat.closeSocial();
		d20plus.chat.onSpeakingTo();
	}

	d20plus.chat.closeSocial = () => {
		d20plus.chat.social = false;
		$("#textchat-input").removeClass("social-resized social-default");
	}// RB20 EXCLUDE START

	d20plus.chat.parseAOE = ($el) => {
		const msg = $el.closest(".message.general");
		const rollData = /\[(\d*)(?<type>chk|dmg|sdmg)[^\]]*\]/;
		const targetData = /<span.*class=("|'?)inlinerollresult.*(?<success>fullcrit|fullfail|showtip).*\1.*title=("|'?).*Rolling.*\[chk(?<id>[^\]]*)\].*\3>\d+<\/span>/g;
		const targets = [];
		const makeList = (success) => {
			return targets
				.filter(target => success ^ (target.success !== "fullcrit"))
				.map(target => target.id)
				.join("|");
		}
		msg.html().replace(targetData, (...str) => {
			const data = str.last();
			targets.push(data);
		});
		msg.find(".inlinerollresult.showtip").each(function () {
			const roll = $(this);
			const tooltipsrc = roll.attr("title") || roll.attr("original-title");
			let isdmg = "";
			let newtip = tooltipsrc.replace(rollData, (...str) => {
				const data = str.last();
				const dmg = roll.text();
				if (data.type === "chk") {
					roll.attr("data-damage", "check");
				} else if (data.type === "dmg" || data.type === "sdmg") {
					const targets = makeList(data.type === "sdmg");
					const num = !targets ? 0 : targets.split("|").length;
					roll.addClass("hit-dice");
					roll.attr("data-damage", dmg);
					roll.attr("data-targets", targets);
					isdmg = `<span class="hit-dice-tip hit-aoe hit-aoe${num}"></span>`;
				}
				return "";
			});
			newtip += isdmg;
			roll.attr((roll.attr("original-title") ? "original-title" : "title"), newtip);
		});
	}

	d20plus.chat.processDice = ($msg) => {
		const dmgCfg = d20plus.cfg.getOrDefault("chat", "autoDmg");
		const rollData = /\[(\d*)(?<type>chk|dmg|sdmg|heal)(?<targets>[^\]]*)\]/;
		$msg.find(".inlinerollresult").each((i, el) => {
			const roll = {$el: $(el)};
			if (roll.$el.attr("data-damage")) return;
			const tooltipsrc = roll.$el.attr("title") || roll.$el.attr("original-title");
			roll.dmg = roll.$el.text();
			roll.tooltip = tooltipsrc.replace(rollData, (...parsed) => {
				Object.assign(roll, parsed.last());
				roll.$el.attr("data-targets", roll.targets);
				return "";
			});
			// d20plus.ut.log("DICE!!!", roll);
			if (dmgCfg === "none") {
				if (roll.type) roll.$el.attr("title", roll.tooltip);
				return;
			} else if (roll.type === "chk" || isNaN(roll.dmg)) {
				if (roll.targets.length > 2) {
					d20plus.chat.parseAOE(roll.$el);
					return;
				}
				roll.$el.attr("data-damage", "check");
			} else if (roll.type) {
				if (roll.targets === "aoe") {
					d20plus.chat.parseAOE(roll.$el);
					return;
				}
				roll.$el.attr("data-damage", roll.type === "heal" ? -roll.dmg : +roll.dmg);
				if (roll.type === "heal") roll.$el.addClass("heal-dice");
				if (roll.targets) roll.tooltip += "<span class=\"hit-dice-tip hit-targeted\"></span>";
				else roll.tooltip += "<span class=\"hit-dice-tip\"></span>";
				roll.$el.addClass("hit-dice");
			} else {
				if (dmgCfg === "b20") return;
				roll.$el.attr("data-damage", roll.dmg);
				roll.tooltip += "<span class=\"hit-dice-tip\"></span>";
				roll.$el.addClass("mod-dice");
			}
			roll.$el.attr("title", roll.tooltip);
		});
	}// RB20 EXCLUDE END

	d20plus.chat.processPlayersList = (changelist) => {
		if (!d20plus.chat.players) d20plus.chat.players = {};
		d20.Campaign.players.models.forEach(current => {
			const player = {
				on: current.attributes.online,
				name: current.attributes.displayname,
			};
			let notification = false;
			player.name = player.name.length > 17 ? `${player.name.slice(0, 15)}...` : player.name;
			if (!d20plus.chat.players[current.id]) {
				d20plus.chat.players[current.id] = { online: player.on };
				notification = __("msg_player_joined");
			} else {
				if (d20plus.chat.players[current.id].online && !player.on) {
					notification = __("msg_player_disconnected");
					d20plus.chat.players[current.id].online = false;
				} else if (!d20plus.chat.players[current.id].online && player.on) {
					notification = __("msg_player_connected");
					d20plus.chat.players[current.id].online = true;
				}
			}
			if (changelist && notification && d20plus.cfg.getOrDefault("chat", "showPlayerConnects")) {
				const id = d20plus.ut.generateRowId();
				d20plus.chat.modifyMsg(id, {class: "system connect", decolon: true});
				if (!player.on) d20plus.chat.modifyMsg(id, {class: "system disconnect"});
				if (player.on) d20plus.chat.modifyMsg(id, {action: {type: "request", name: player.name}});
				d20.textchat.incoming(false, { id,
					type: "general",
					who: `${player.on ? "" : "&nbsp;"}${player.name}`,
					avatar: `/users/avatar/${current.attributes.d20userid}/30`,
					content: `${notification}`,
				});
			}
		})
	}

	d20plus.chat.processIncomingMsg = (msg, msgData) => { // RB20 EXCLUDE START
		const expendSlots = d20plus.cfg.getOrDefault("chat", "autoExpend") !== "none";
		const b20expend = /\[exp(?<charid>[^\]^|]+?)\|(?<type>spl|res|ammo)(?<slot>[cor\d]?)-?(?<name>[\p{L}\d _]*)(?:\|(?<quantity>\d*)|)\]/ug;// RB20 EXCLUDE END
		if (msg.listenerid?.language && d20plus.cfg.getOrDefault("chat", "languages")) {
			const speech = msg.listenerid;
			const inKnownLanguage = hasLanguageProficiency(speech.languageid);
			if (window.is_gm || msgData.from_me || inKnownLanguage) {
				const translated = speech.message.replace(/\n/g, "<br>").replace(/ --([^ ^-])/g, " $1");
				msg.content += `<br><i class="showtip tipsy-n-right" title="You understand this because one of your characters speaks ${speech.language}">
					<strong>(${speech.language})</strong> ${translated}</i>`;
				d20plus.chat.modifyMsg(msg.id, {class: "inlang", legalize: true});
			}
		} else if (msg.listenerid?.type === "handshake") {
			if (msgData.from_me && !msg.listenerid.data) {
				msg.content = `script versions info`;
				msg.avatar = `/users/avatar/${d20plus.ut.getAccountById(msg.target)}/30`;
				d20plus.chat.modifyMsg(msg.id, {class: "system connects", decolon: true, versions: msg.listenerid.id});
			} else if (msgData.from_me && msg.listenerid.data) {
				return false;
			} else if (msgData.to_me && !msg.listenerid.data) {
				const name = d20plus.ut.getPlayerNameById(msg.playerid);
				msg.listenerid.data = d20plus.ut.generateVersionInfo();
				d20.textchat.doChatInput(`/w "${name}" &nbsp;`, undefined, msg.listenerid);
				return false;
			} else if (msgData.to_me && msg.listenerid.data) {
				$(`#connects${msg.listenerid.id}`).html(d20plus.ut.parseVersionInfo(msg.listenerid.data));
				$(`#connects${msg.listenerid.id}-state`).attr("checked", "true");
				$(`#connects${msg.listenerid.id}-info`).text("3");
				return false;
			}// RB20 EXCLUDE START
		} else if (msg.listenerid?.type === "automation") {
			const broadcast = msg.type !== "whisper";
			if (is_gm || broadcast || msgData.to_me) {
				msg.id = d20plus.ut.generateRowId();
				msg.who = "b20action";
				msg.type = "general";
				msg.avatar = `/users/avatar/${d20plus.ut.getAccountById(msg.playerid)}/30`;
				const span = `class="showtip tipsy-n-right" style="cursor: help;"`;
				const avatar = `<img src="${msg.avatar}" height="20px" width="20px"> `;
				d20plus.chat.modifyMsg(msg.id, {class: "action"});
				d20plus.chat.modifyMsg(msg.id, {legalize: true});
				if (msg.listenerid.undo) d20plus.chat.modifyMsg(msg.id, {action: msg.listenerid.undo});
				msg.content = `<span ${span} title='${avatar} ${msg.listenerid.author}'>${msg.content}</span>`;
			}
		} else if (msgData.from_me && expendSlots) {
			const expend = {};
			const oglStandard = {
				spellLevel: /{{spelllevel=[\w ]*(?<splvl>\d|cantrip)}}/,
				addLevelDice: /{{hldmg=\$\[\[(?<addlvl>\d)\]\]}}/,
				charID: /{{spelldesc_link=\[.*\]\(~(?<charid>.*?)\|/,
			};
			msg.content = msg.content.replace(b20expend, (...str) => {
				$(".btn.btn-danger.canceltargeting:visible").click();
				const exp = {};
				const data = str.last();
				if (data.type === "spl" && data.slot) {
					exp.type = "spell";
					({slot: exp.lvl, charid: exp.charID} = data);
				} else if (data.type === "res" && data.slot) {
					exp.type = "resource";
					exp.res = data.slot === "c" ? "class" : "other";
					if (data.quantity) exp.amt = data.quantity;
					if (data.slot === "r" && data.name) exp.type = "repeated";
					({name: exp.name, charid: exp.charID} = data);
				} else if (data.type === "ammo" && data.name) {
					exp.type = "item";
					exp.name = data.name;
					if (data.quantity) exp.amt = data.quantity;
					({name: exp.name, charid: exp.charID} = data);
				}
				if (exp.type) {
					d20plus.engine.expendResources(exp);
					expend.type = exp.type;
				}
				return "";
			});
			if (msg.rolltemplate && msg.inlinerolls && !expend.type) {
				const data = {};
				$(".btn.btn-danger.canceltargeting:visible").click();
				Object.entries(oglStandard).forEach(([param, exp]) => {
					data[param] = msg.content.match(exp)?.last();
				});
				if (data.charID) {
					expend.lvl = data.spellLevel || 1;
					expend.charID = data.charID;
					if (!isNaN(expend.lvl)) expend.type = "spell";
					if (data.addLevelDice) {
						const raise = msg.inlinerolls[data.addLevelDice]
							?.expression.match(/\(\d+\*(?<addlvl>\d)\)/).last();
						if (!isNaN(raise)) expend.lvl -= -raise;
					}
				}
				if (expend.type) {
					d20plus.engine.expendResources(expend);
				}
			}
			if (expend.type) {
				msg.id = d20plus.ut.generateRowId(); // this is supposed to trick r20 not to revert msg contents
			}
		} else if (!msgData.from_me) {
			msg.content = msg.content.replace(b20expend, ""); // hide other's formulas even if you don't use 'em // RB20 EXCLUDE END
		}// RB20 EXCLUDE START
		if (msg.inlinerolls) {
			d20plus.chat.modifyMsg(msg.id, {dice: true});
		}// RB20 EXCLUDE END
		if (d20.textchat.talktomyself && msgData.from_me) {
			if (d20plus.cfg.getOrDefault("chat", "highlightttms")) d20plus.chat.modifyMsg(msg.id, {class: "talktomyself"});
		}
		return true;
	}

	d20plus.chat.r20outgoing = (r20outgoing, params) => {
		if (!params[2]) {
			d20plus.chat.resetSendMyself();
		}
		const macroJS = d20plus.cfg.getOrDefault("chat", "executeJSMacro");// RB20 EXCLUDE START
		const dmgCfg = d20plus.cfg.getOrDefault("chat", "autoDmg");
		const expCfg = d20plus.cfg.getOrDefault("chat", "autoExpend");

		if (d20plus.chat.logAll) d20plus.ut.log("OUTGOING!", params);

		if (dmgCfg !== "none" || expCfg !== "none") {
			const template = /^%\{(?<charRef>[^|^}^{]*)\|(?<ability>[^|^}^{]*)\}$/mg;
			params[0] = params[0].replace(template, (...string) => {
				const found = string[0];
				if (dmgCfg === "auto" || expCfg === "auto") {
					return d20plus.ut.getActionTmpl(found);
				} else if (dmgCfg === "debug" || expCfg === "debug") {
					const resolved = d20plus.ut.getActionTmpl(found);
					const debugOutput = resolved.substr(0, 80).replaceAll("{", "&#123;").concat(resolved.length > 100 ? "..." : "");
					if (found === resolved) return found;
					return `${found.replaceAll("{", "&#123;")}\n${found}\n\n${debugOutput}\n${resolved}`;
				} else {
					return found;
				}
			});
		}

		// %{Archmage|0: Dagger}
		// %{selected|repeating_npcaction_$0_npc_action}
		// %{selected|repeating_spell-cantrip_-NQ2lfNWgVG3czB5jPsq_spell}
		// {{savedc=[[[[(@{Книжник|wisdom_mod}+8+@{Книжник|spell_dc_mod}+@{Книжник|pb})]][SAVE]]]}}
		// {{savedc=[[[[(+8++@{Книжник|pb})]][SAVE]]]}}

		// [Show Spell Description](~-N9de-OdA-r__6AwN_sc|repeating_attack_-NPHrzBGDu7rZ10z9hMJ_spelldesc_link)
		// [Show Spell Description](~-N9de-OdA-r__6AwN_sc|repeating_spell-1_-nphrusyez3giymyggvq_output)

		//  d20plus.ut.getCharMetaAttribByName(d20plus.ut.getCharacter("Книжник"), "repeating_attack_-NPHrzBGDu7rZ10z9hMJ")
		// RB20 EXCLUDE END

		if (macroJS !== "none") {
			const template = /#(?<macroid>[^ ^#]+)/g;
			params[0] = params[0].replace(template, (...match) => {
				const macroId = match.last().macroid;
				const macroObj = d20plus.ut.getMacroByName(macroId);
				if (!macroObj) return match[0];
				const macro = macroObj.attributes.action;
				const script = d20plus.engine.decodeScript(macro);
				if (!script) return match[0];
				if (macroObj.collection.player.id !== d20_player_id && macroJS !== "all") {
					d20plus.ut.sendHackerChat(`
						Enable execution for scripts shared by other players
						(select Execute All in betteR20 options for JS Script).
						You should do this only if you trust your GM
					`, true);
					return "";
				}
				return d20plus.engine.runScript(script, macroObj);
			});
		}

		return r20outgoing(...params);
	}

	d20plus.chat.r20incoming = (r20incoming, params) => {
		const msg = params[1];
		const msgData = {};
		msgData.from_me = msg.playerid === d20_player_id;
		msgData.to_me = msg.target?.includes(d20_player_id);// RB20 EXCLUDE START

		if (d20plus.chat.logAll) {
			d20plus.ut.log("INCOMING!", Object.assign({
				p: [params[0], params[2], params[3]]}, msg, {
				history: d20plus.chat.localHistory}));
		}// RB20 EXCLUDE END

		// For rolls &  r20 generates duplicate messages that don't show on the log with
		// params [sound, msg, true, true]. Hence check params[2]&[3] !== true to avoid double processing
		const skipProcessing = (
			(params[2] === true && params[3] === true)
			|| (d20.textchat.chatstartingup)
		);

		if (msgData.from_me || msg.type === "system") {
			const stash = [];
			while (d20plus.chat.localHistory.length) {
				const record = d20plus.chat.localHistory.pop();
				if (record) {
					stash.push(record);
					d20.textchat.commandhistory.pop();
				}
			}
			d20.textchat.commandhistory = d20.textchat.commandhistory.concat(stash);
		}

		if (msg.type === "whisper" && !skipProcessing) {
			if (msgData.from_me) {
				d20plus.chat.lastRespondent = msg.target_name;
			} else if (msgData.to_me) {
				d20plus.chat.lastRespondent = d20plus.ut.getPlayerNameById(msg.playerid);
			}
		}

		if (skipProcessing || d20plus.chat.processIncomingMsg(msg, msgData)) {
			const result = r20incoming(...params);
			d20plus.chat.displaying();
			return result;
		}
	}

	d20plus.chat.displaying = () => { // RB20 EXCLUDE START
		if (d20plus.chat.logAll) d20plus.ut.log("DISPLAY", JSON.stringify(d20plus.chat.modify)); // RB20 EXCLUDE END
		Object.entries({...d20plus.chat.modify}).forEach(([id, mods]) => {
			const msg = mods.sys ? $(`#textchat .message.system`).last() : $(`[data-messageid=${id}]`);

			if (mods.intro) {
				const code = "<code style='cursor:pointer'>/help</code>";
				const wiki = "https://wiki.roll20.net/Text_Chat#Chat";
				const intro = $(".userscript-commandintro ul");
				if (intro.get(0)) {
					intro.last().append(__("msg_b20_chat_help", [code, wiki]));
					delete d20plus.chat.modify[id];
				}
			}

			if (msg.get(0)) {
				if (mods.declass) msg.removeClass(mods.declass);
				if (mods.class) msg.addClass(mods.class);
				if (mods.versions) msg.append(playerVersionsTemplate(mods.versions));
				if (mods.decolon) msg.find(".by").text((i, txt) => txt.replace(/(?:\(To |)(.+?)\)?:/, "$1"));
				if (mods.legalize) msg.html(removeClassUserscript(msg.html()));
				if (mods.action) d20plus.chat.smallActionBtnAdd(msg, mods.action);
				if (mods.dice) d20plus.chat.processDice(msg);
				delete d20plus.chat.modify[id];
			}
		});
	}

	d20plus.chat.sending = () => {
		d20plus.chat.resetSendMyself();
		const $tc = d20.textchat.$textarea;

		if (d20plus.cfg.getOrDefault("chat", "emoji")) {
			$tc.val($tc.val().replace(/(:\w*?:)/g, (m0, m1) => {
				const clean = m1.replace(/:/g, "");
				return d20plus.chat.emojiIndex && d20plus.chat.emojiIndex[clean] ? `[${clean}](https://github.com/TheGiddyLimit/emoji-dump/raw/master/out/${clean}.png)` : m1;
			}));
		}

		let text = $tc.val();
		const srcText = text;

		if (d20plus.cfg.getOrDefault("chat", "commands")) {
			// add custom commands
			text = text.replace(/^\/wb (.*?)$/gm, d20plus.chat.sendReply);
			if (is_gm) text = text.replace(/^\/ws (.*?)$/gm, d20plus.chat.sendToSelected);
			text = text.replace(/^\/ttms( |$)/s, "/talktomyself$1");
			text = text.replace(/^\/help(.*?)$/s, d20plus.chat.help);
			if (!d20.textchat.talktomyself) text = text.replace(/^\/mtms ?(.*?)$/s, d20plus.chat.sendMyself);
			if (is_gm) text = text.replace(/^\/v (.*?)$/s, d20plus.chat.requestScriptVersions);
			if (d20plus.cfg.getOrDefault("chat", "languages")) text = text.replace(/\/in (.*?)$/gm, d20plus.chat.sendParsedInLanguage);// RB20 EXCLUDE START
			// text = text.replace(/^\/cl (on|off)$/sm, comprehendLanguages);// RB20 EXCLUDE END
		}

		if (d20plus.cfg.getOrDefault("chat", "social")) {
			const speakingto = $("#speakingto").val();
			const speakingin = $("#speakingin").val();

			if (speakingin) {
				text = text.replace(/^[^/][^{^}]*?$/gm, msg => {
					return d20plus.chat.sendInLanguage(msg, speakingin);
				});
			}

			if (speakingto && speakingto !== "ttms") {
				text = text.replace(/^([^/]*?)$/mgu, (...str) => {
					const prepared = str[1].replace(/\/(r|roll) (?<dice>[ \dd+-]*)$/umg, "[[$<dice>]]");
					return `/w "${speakingto}" ${prepared}`;
				});
			}
		}

		// $.trim() instead of .trim() cause it's used in roll20's doChatInput()
		let toSend = $.trim(text);
		if (text !== srcText && text) d20plus.chat.localHistory.push($.trim(srcText));
		if ($("#soundslike").get(0)) toSend = "";

		if (toSend.includes("|&inlang|")) {
			toSend.split("\n").forEach((str, i) => {
				const data = str.split("|&inlang|");
				if (data.length === 2) {
					const msg = data[0];
					const meta = data[1].split("|&meta|");
					const transport = {language: meta[0], languageid: meta[1], message: meta[2]};
					d20.textchat.doChatInput(msg, undefined, transport);
				} else {
					d20.textchat.doChatInput(str);
				}
			})
			$tc.val("").focus();
		} else {
			d20.textchat.doChatInput(toSend);
			$tc.val("").focus();
		}

		if (d20plus.cfg.getOrDefault("chat", "highlightttms")) {
			if (toSend.includes("/talktomyself")) {
				setTimeout(() => d20plus.chat.checkTTMSStatus(), 20);
			}
		}
	}// RB20 EXCLUDE START

	d20plus.chat.enhanceRolls = () => {
		d20.textchat.$textchat.on("click", ".inlinerollresult.showtip", event => {
			const dmg = event.target.getAttribute("data-damage");
			const dtargets = event.target.getAttribute("data-targets");
			if (isNaN(dmg) || !dmg) return;
			if (event.shiftKey && event.ctrlKey) {
				d20plus.engine.alterTokensHP({dmg: -Math.abs(dmg)});
			} else if (event.shiftKey) {
				d20plus.engine.alterTokensHP({dmg: Math.abs(dmg)});
			} else if (event.ctrlKey) {
				d20plus.engine.alterTokensHP({dmg: Math.floor(Math.abs(dmg) / 2)});
			} else if (dtargets) {
				const targets = dtargets.split("|")
					.map(targetID => d20plus.ut.getTokenById(targetID))
					.filter(token => !!token);
				d20plus.engine.alterTokensHP({dmg, targets});
			}
		})
		d20plus.ut.dynamicStyles("hit-dice-tips").html(`
			.hit-dice-tip::after {display:block; font-size:smaller; content:"Select targets & hold ctrl/shift (or both) to alter HP"}
			.hit-dice-tip.hit-targeted::after {content:"Click to apply HP changes"}
			.hit-dice-tip.hit-aoe::after {content:"Click to auto-dmg targets"}
			.hit-dice-tip.hit-aoe0::after {content:"This damage affects 0 targets"}
			.hit-dice-tip.hit-aoe1::after {content:"Click to auto-dmg 1 target"}
			.hit-dice-tip.hit-aoe2::after {content:"Click to auto-dmg 2 targets"}
			.hit-dice-tip.hit-aoe3::after {content:"Click to auto-dmg 3 targets"}
			.hit-dice-tip.hit-aoe4::after {content:"Click to auto-dmg 4 targets"}
			.hit-dice-tip.hit-aoe5::after {content:"Click to auto-dmg 5 targets"}
			.hit-dice-tip.hit-aoe6::after {content:"Click to auto-dmg 6 targets"}
			.shift-pressed .mod-dice, .ctrl-pressed .mod-dice {cursor: pointer}
			.shift-pressed .hit-dice-tip::after {content:"Shft+Click to decrease HP to selected tokens"}
			.ctrl-pressed .hit-dice-tip::after {content:"Ctrl+Click to decrease HP (halved value) to selected tokens"}
			.ctrl-pressed.shift-pressed .hit-dice-tip::after {content:"Shft+Ctrl+Click to increase HP to selected tokens"}
		`);
	}// RB20 EXCLUDE END

	d20plus.chat.enhanceChat = () => {
		d20plus.ut.log("Enhancing chat");
		d20plus.ut.injectCode(d20.textchat, "incoming", d20plus.chat.r20incoming);
		d20plus.ut.injectCode(d20.textchat, "doChatInput", d20plus.chat.r20outgoing);

		$(document.body)
			.append(languageTemplate())
			.on("click", ".macro > .name", (evt) => {
				const {currentTarget: target} = evt;
				const openedMacroId = $(target).closest(`[data-macroid]`).data("macroid");
				d20plus.engine.enhanceMacros(openedMacroId);
			});
		availableLanguagesPlayer(d20_player_id);
		buildLanguageIndex();// RB20 EXCLUDE START
		/// d20plus.chat.logAll = true// RB20 EXCLUDE END

		if (window.is_gm) {
			d20plus.chat.processPlayersList();
			const obsconfig = { childList: true, subtree: false };
			d20plus.cfg.playerWatcher = new MutationObserver(d20plus.chat.processPlayersList);
			d20plus.cfg.playerWatcher.observe($("#avatarContainer").get(0), obsconfig);
		}

		if (d20plus.cfg.getOrDefault("chat", "social")) {
			const $inputContainer = $("#textchat-input");
			const $chatNotifier = $("#textchat-notifier");
			const $chatTextarea = d20.textchat.$textarea;

			$inputContainer.append(d20plus.html.chatSocial);
			$inputContainer.prepend(d20plus.html.chatSocialNotifier);

			const $socialSwitch = $("#socialswitch");
			$("#chatSendBtn").after($socialSwitch);
			$("#textchat-note-container").append($chatNotifier);

			$chatTextarea.on("focus", d20plus.chat.closeSocial);
			$chatNotifier.on("click", d20plus.chat.resetTTMS);
			$("#textchat-social-notifier").on("click", d20plus.chat.resetSocial);

			$socialSwitch.on("click", d20plus.chat.onSocial);
			$("#speakingas").on("change", d20plus.chat.onSpeakingAs);
			$("#speakingto").on("change", d20plus.chat.onSpeakingTo);
			$("#speakingin").on("change", d20plus.chat.onSpeakingIn);

			d20plus.chat.getSpeakingTo();
		}

		if (d20plus.cfg.getOrDefault("chat", "commands")) {
			d20plus.chat.modifyMsg(null, {intro: true});
			d20.textchat.$textchat
				.on("click", ".userscript-commandintro ul code", d20plus.chat.help)
				.on("click", ".msg-action-button", d20plus.chat.smallActionBtnPress);
		}// RB20 EXCLUDE START

		$(window).on("keydown.Shift keydown.Control keyup.Shift keyup.Control", event => {
			const $root = $(document.body);
			["shift", "ctrl"].forEach(mod => {
				if (event[`${mod}Key`]) $root.addClass(`${mod}-pressed`);
				else $root.removeClass(`${mod}-pressed`);
			})
		});
		d20plus.chat.enhanceRolls();// RB20 EXCLUDE END

		$("#textchat-input")
			.off("click", "button")
			.on("click", "button", d20plus.chat.sending);
	};
}

SCRIPT_EXTENSIONS.push(baseChat);


function remoteLibre () {
	d20plus.remoteLibre = {
		getRemotePlaylists () {
			return fetch("https://api.github.com/repos/DMsGuild201/Roll20_resources/contents/playlist")
				.then(response => response.json())
				.then(data => {
					const promises = data.filter(file => file.download_url.toLowerCase().endsWith(".json"))
						.map(file => d20plus.remoteLibre.downloadPlaylist(file.download_url));
					return Promise.all(promises).then(res => d20plus.remoteLibre.processRemotePlaylists(res));
				})
				// eslint-disable-next-line no-console
				.catch(error => console.error(error));
		},

		downloadPlaylist (url) {
			return fetch(url)
				.then(response => response.json())
				// eslint-disable-next-line no-console
				.catch(error => console.error("Error when fetching", url, error));
		},

		processRemotePlaylists (imports) {
			return $.map(imports.filter(p => !!p), entry => {
				return $.map(entry.playlists, playlist => playlist.songs);
			}).filter(track => track.source === "My Audio");
		},

		drawRemoteLibreResults (tracks) {
			return tracks.map((t, i) => `
                <p style="margin-top:15px">${t.title}</p>
                <div class="br20-result" style="display: flex">
                    <audio class="audio" controls preload="none" style="flex: 35" src="${t.track_id}"></audio>

                    <button class="remote-track btn" data-id=${i} style="margin-top:auto;margin-bottom:auto;flex:1;font-size:15px;margin-left:10px;">
                        <span class="pictos">&amp;</span>
                    </button>
                </div>
            `);
		},

		drawJukeBoxTab (tracks) {
			const trackHtml = d20plus.remoteLibre.drawRemoteLibreResults(tracks);
			return `
            <div class="betteR20 tab-pane" style="display: none;">
                <div class="row-fluid">
                    <div class="span12">
                        <h3 style="margin-top: 6px; margin-bottom: 10px; text-align:initial;">Search for:</h3>
                        <input id="remoteLibreSearch" type="text" placeholder="Begin typing to choose tracks by title..." style="width: 100%;">
                        <div id="remoteLibreResults">
                            ${trackHtml.join("")}
                        </div>
                    </div>
                </div>
            </div>`;
		},

		wireTrackButtons () {
			$(".remote-track.btn").click((e) => {
				const id = $(e.currentTarget).data().id;
				d20plus.jukebox.createTrack(d20plus.remoteLibre.filteredResults[id]);
			});
		},

		init () {
			d20plus.remoteLibre.jukeboxInjected = false;
			d20plus.remoteLibre.remoteLibreTracks = {};
			d20plus.remoteLibre.filteredResults = {};

			d20plus.remoteLibre.getRemotePlaylists().then((tracks) => {
				d20plus.remoteLibre.remoteLibreTracks = tracks;
				d20plus.remoteLibre.filteredResults = tracks;
			});

			$("#addjukebox").click(() => {
				if (!d20plus.remoteLibre.jukeboxInjected) {
					setTimeout(() => {
						const html = d20plus.remoteLibre.drawJukeBoxTab(d20plus.remoteLibre.filteredResults);
						$(".nav.nav-tabs").append(`<li><a data-tab="betteR20" href="javascript:void(0);">BetteR20</a></li>`);
						$(".tab-content").append(html);
						d20plus.remoteLibre.wireTrackButtons();
						$("#remoteLibreSearch").bind("paste keyup", function () {
							if ($(this).val()) {
								d20plus.remoteLibre.filteredResults = d20plus.remoteLibre.remoteLibreTracks.filter(t => t.title.toLowerCase().indexOf($(this).val()) >= 0);
							} else {
								d20plus.remoteLibre.filteredResults = d20plus.remoteLibre.remoteLibreTracks;
							}
							const results = d20plus.remoteLibre.drawRemoteLibreResults(d20plus.remoteLibre.filteredResults);
							$("#remoteLibreResults").html(results);
							d20plus.remoteLibre.wireTrackButtons();
						});
						// this needs to be moved
						d20plus.remoteLibre.jukeboxInjected = true;
					}, 100);
				}
			});
		},

	};
}

SCRIPT_EXTENSIONS.push(remoteLibre);


function jukeboxWidget () {
	d20plus.jukeboxWidget = {
		getPlaylistButtonsHtml () {
			const buttons = d20plus.jukebox.getJukeboxFileStructure()
				.map((playlist, i) => {
					const hotkey = i + 1 < 10 ? i + 1 : false;
					let baseName, id;
					if (typeof playlist === "object") {
						baseName = playlist.n;
						id = playlist.id;
					} else {
						baseName = d20plus.jukebox.getTrackById(playlist).attributes.title;
						id = playlist;
					}
					const title = `${hotkey ? `[ALT+${hotkey}] ` : ""}${baseName}`;

					return `
						<div
							class="btn btn-xs jukebox-widget-button m-1"
							title="${title}"
							data-id=${id}
						>
							<span>${hotkey ? `[${i + 1}] ` : ""}${baseName}</span>
						</div>
					`;
				})
				.filter(p => !!p);

			return buttons.join("");
		},

		init () {
			const changeTrackVolume = (trackId, value) => {
				const track = d20plus.jukebox.getTrackById(trackId);
				if (track && value) {
					track.changeVolume(value);
				}
			};

			$(`<div id="masterVolume" style="margin:10px;display:inline-block;width:80%;"></div>`)
				.insertAfter("#jukeboxwhatsplaying").slider({
					slide: (e, ui) => {
						if ($("#masterVolumeEnabled").prop("checked")) {
							window.d20.jukebox.lastFolderStructure.forEach(playlist => {
							// The track is outside a playlist
								if (!playlist.i) {
									changeTrackVolume(playlist, ui.value);
								} else {
									playlist.i.forEach(trackId => changeTrackVolume(trackId, ui.value))
								}
							});
						}
						$("#jbwMasterVolume").slider("value", ui.value);
					},
					value: 50,
				});
			$("<h4>Master Volume</h4>").insertAfter("#jukeboxwhatsplaying").css("margin-left", "10px");
			$(`<input type="checkbox" id="masterVolumeEnabled" style="position:relative;top:-11px;" title="Enable this to change the volume of all the tracks at the same time"/>`).insertAfter("#masterVolume").tooltip();

			// TODO: Make the slider a separate component at some point
			const slider = $(`<div id="jbwMasterVolume" class="jukebox-widget-slider"></div>`)
				.slider({
					slide: (e, ui) => {
						if ($("#masterVolumeEnabled").prop("checked")) {
							window.d20.jukebox.lastFolderStructure.forEach(playlist => {
								// The track is outside a playlist
								if (!playlist.i) {
									changeTrackVolume(playlist, ui.value);
								} else {
									playlist.i.forEach(trackId => changeTrackVolume(trackId, ui.value));
								}
							});
						}
						$("#masterVolume").slider("value", ui.value);
					},
					value: 50,
				});

			// Stop and skip buttons
			const controls = $(`
			<div class="flex mb-2">
				<div id="jbwStop" title="ALT+S" class="btn btn-inverse flex-1 mr-2"><span class="pictos">6</span></div>
				<div id="jbwSkip" title="ALT+D" class="btn btn-inverse flex-1 mr-2"><span class="pictos">7</span></div>
			</div>
			`).append(slider);

			// Jukebox widget layout
			const dialog = $(`<div id="jukeboxWidget" title="Jukebox Player" style="margin-top:10px"></div>`)
				.dialog({
					autoOpen: false,
					resizable: true,
					width: 350,
				})
				.append("body")
				.css("padding-top", "0")
				.html(`<div id="jbwButtons" style="display:flex;flex-wrap:wrap">${d20plus.jukeboxWidget.getPlaylistButtonsHtml()}</div>`)
				.prepend(controls)
				.prepend(`<div id="widgeNowPlaying"></div>`);

			dialog.parent().find(".ui-dialog-title").css("margin", "0").css("padding", "0");
			$("#jbwStop").click(d20plus.jukebox.stopAll);
			$("#jbwSkip").click(d20plus.jukebox.skip);

			// Start listening to jukebox state changes
			d20plus.jukebox.addJukeboxChangeHandler(() => {
				$("#jbwButtons").html(d20plus.jukeboxWidget.getPlaylistButtonsHtml());
				$(".jukebox-widget-button")
					.removeClass("active")
					.click((e) => {
						const id = e.currentTarget.dataset.id;
						if (d20plus.jukebox.getCurrentPlayingPlaylist() === id || d20plus.jukebox.getCurrentPlayingTracks().find(t => t.id === id)) {
							d20plus.jukebox.stop(e.currentTarget.dataset.id);
						} else {
							d20plus.jukebox.play(e.currentTarget.dataset.id);
						}
					});
				$(`.jukebox-widget-button[data-id=${d20plus.jukebox.getCurrentPlayingPlaylist()}]`).addClass("active");
				d20plus.jukebox.getCurrentPlayingTracks().forEach(t => {
					$(`.jukebox-widget-button[data-id=${t.id}]`).addClass("active");
				});
			});

			// Add widget button in the Jukebox tab
			$(`<button class="btn" style="margin-right:10px;"><span class="pictos">|</span>Widget</button>`)
				.click(() => {
					dialog.dialog("open");
				})
				.insertAfter("[href=#superjukeboxadd]");

			// Add keyboard shortcuts
			$(document).keyup((e) => {
				if (e.altKey) {
					if (e.keyCode > 48 && e.keyCode < 58) {
						const numberKey = e.keyCode - 48;
						const playElement = d20plus.jukebox.getJukeboxFileStructure()[numberKey - 1];
						if (typeof playElement === "object") {
							if (d20plus.jukebox.getCurrentPlayingPlaylist() === playElement.id) {
								d20plus.jukebox.stopPlaylist(playElement.id);
							} else {
								d20plus.jukebox.playPlaylist(playElement.id);
							}
						} else {
							if (d20plus.jukebox.getCurrentPlayingTracks().find(t => t.id === playElement)) {
								d20plus.jukebox.stopTrack(playElement);
							} else {
								d20plus.jukebox.playTrack(playElement);
							}
						}
					} else if (e.keyCode === 83) {
						d20plus.jukebox.stopAll();
					} else if (e.keyCode === 68) {
						d20plus.jukebox.skip();
					}
				}
			});
		},
	};
}

SCRIPT_EXTENSIONS.push(jukeboxWidget);


const betteR20Core = function () {
	// Page fully loaded and visible
	d20plus.Init = async () => {
		d20plus.scriptName = `betteR20-core v${d20plus.version}`;
		try {
			d20plus.ut.log(`Init (v${d20plus.version})`);// RB20 EXCLUDE START
			d20plus.ut.selectLocale();// RB20 EXCLUDE END
			d20plus.settingsHtmlHeader = `<hr><h3>betteR20-core v${d20plus.version}</h3>`;

			await d20plus.js.pAddScripts();
			await d20plus.qpi.pInitMockApi();
			await d20plus.js.pAddApiScripts();

			if (window.is_gm) await d20plus.cfg.pLoadConfig();
			else await d20plus.cfg.pLoadPlayerConfig();

			d20plus.ut.showLoadingMessage();

			d20plus.engine.swapTemplates();
			d20plus.ut.addAllCss();

			if (window.is_gm) {
				d20plus.ut.log("Is GM");
				d20plus.engine.enhancePageSelector();
			} else {
				d20plus.ut.log("Not GM. Some functionality will be unavailable.");
			}

			JqueryUtil.initEnhancements();

			if (window.is_gm) await d20plus.art.pLoadArt();

			d20plus.engine.enhanceMarkdown();
			d20plus.engine.addProFeatures();
			d20plus.engine.enhanceMouseDown();
			d20plus.engine.enhanceMouseMove();
			d20plus.engine.enhanceStatusEffects();
			// It doesn't work with current version of roll20
			// d20plus.engine.addLineCutterTool();
			d20plus.ui.addHtmlHeader();
			d20plus.ui.addHtmlFooter();
			d20plus.art.initArtFromUrlButtons();
			if (window.is_gm) {
				d20plus.journal.addJournalCommands();
				d20plus.menu.addSelectedTokenCommands();
				d20plus.art.addCustomArtSearch();
				d20plus.engine.addTokenHover();
				d20plus.engine.enhanceTransmogrifier();
				d20plus.engine.removeLinkConfirmation();
				d20plus.artBrowse.initRepoBrowser();
				d20plus.ui.addQuickUiGm();
				d20plus.anim.animatorTool.init();
				// Better20 jukebox tab
				d20plus.remoteLibre.init();
				d20plus.jukeboxWidget.init();
			}
			d20plus.engine.enhancePathWidths();
			// d20plus.ut.fix3dDice();
			d20plus.engine.addLayers();
			d20plus.weather.addWeather();
			d20plus.views.addViews();
			d20plus.engine.repairPrototypeMethods();
			d20plus.engine.disableFrameRecorder();
			// d20plus.ut.fixSidebarLayout();
			d20plus.chat.enhanceChat();

			// apply config
			if (window.is_gm) {
				d20plus.cfg.baseHandleConfigChange();
			} else {
				d20plus.cfg.startPlayerConfigHandler();
			}

			// output welcome msg when the chat is ready
			const welcome = setInterval(() => {
				if (!d20.textchat.chatstartingup) {
					d20plus.ut.checkVersion();
					d20plus.ut.log("All systems operational");
					d20plus.ut.chatTag();
					clearInterval(welcome);
				}
			}, 500);
		} catch (e) {
			// eslint-disable-next-line no-console
			console.error(e);
			alert(`${d20plus.scriptName} failed to initialise! See the logs (CTRL-SHIFT-J) for more information.`)
		}
	};
};

SCRIPT_EXTENSIONS.push(betteR20Core);


if (unsafeWindow.d20plus) {
	unsafeWindow.eval(`alert("An instance of betteR20 is already running! You may have two versions of betteR20 installed (e.g core and 5etools). Please only use one.");`);
	unsafeWindow.eval(`alert("Your game may not launch. Please only run one instance of betteR20.");`);
	throw new Error("");
}

unsafeWindow.d20plus = {};

const betteR20Base = function () {
	/* eslint-disable */
	CONSOLE_LOG = console.log;
	console.log = (...args) => {
		if (args.length === 1 && typeof args[0] === "string" && args[0].startsWith("Switch mode to ")) {
			const mode = args[0].replace("Switch mode to ", "");
			if (typeof d20plus !== "undefined" && d20plus.setMode) d20plus.setMode(mode);
		}
		CONSOLE_LOG(...args);
	};
	/* eslint-enable */
};

const D20plus = function (version) {
	d20plus.version = version;

	// Window loaded
	function doBootstrap () {
		d20plus.ut.log("Waiting for enhancement suite...");

		let timeWaitedForEnhancementSuiteMs = 0;

		(function waitForEnhancementSuite () {
			let hasRunInit = false;
			if (window.d20 || window.enhancementSuiteEnabled) {
				d20plus.ut.log("Bootstrapping...");

				// r20es will expose the d20 variable if we wait
				// this should always trigger after window.onload has fired, but track init state just in case
				(function waitForD20 () {
					if ($("#textchat").get(0) && !$(".boring-chat").get(0)) d20plus.ut.showInitMessage();
					if (typeof window.d20 !== "undefined" && !$("#loading-overlay").is(":visible") && !hasRunInit) {
						hasRunInit = true;
						d20plus.Init();
					} else {
						setTimeout(waitForD20, 50);
					}
				})();

				window.d20plus = d20plus;
				d20plus.ut.log("Injection successful...");
			} else {
				if (timeWaitedForEnhancementSuiteMs > 2 * 5000) {
					alert("betteR20 requires the VTTES (R20ES) extension to be installed!\nPlease install it from https://ssstormy.github.io/roll20-enhancement-suite/\nClicking ok will take you there.");
					window.open("https://ssstormy.github.io/roll20-enhancement-suite/", "_blank");
				} else {
					timeWaitedForEnhancementSuiteMs += 100;
					setTimeout(waitForEnhancementSuite, 100);
				}
			}
		})();
	}

	(function doCheckDepsLoaded () {
		if (typeof $ !== "undefined") {
			doBootstrap();
		} else {
			setTimeout(doCheckDepsLoaded, 50);
		}
	})();
};

// if we are the topmost frame, inject
if (window.top === window.self) {
	const strip = (str) => {
		return `${str.replace(/use strict/, "").substring(str.indexOf("\n") + 1, str.lastIndexOf("\n"))}\n`;
	};

	let stack = "function (version) {\n";
	stack += strip(betteR20Base.toString());

	for (let i = 0; i < SCRIPT_EXTENSIONS.length; ++i) {
		stack += strip(SCRIPT_EXTENSIONS[i].toString())
	}
	stack += strip(D20plus.toString());

	stack += "\n}";
	unsafeWindow.eval(`(${stack})('${GM_info.script.version}')`);
}



EXT_LIB_SCRIPTS.push((function lib_script_0 () {
/*! List.js v1.5.0 (http://listjs.com) by Jonny Strömberg (http://javve.com) */
var List=function(t){function e(n){if(r[n])return r[n].exports;var i=r[n]={i:n,l:!1,exports:{}};return t[n].call(i.exports,i,i.exports,e),i.l=!0,i.exports}var r={};return e.m=t,e.c=r,e.i=function(t){return t},e.d=function(t,r,n){e.o(t,r)||Object.defineProperty(t,r,{configurable:!1,enumerable:!0,get:n})},e.n=function(t){var r=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(r,"a",r),r},e.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},e.p="",e(e.s=11)}([function(t,e,r){function n(t){if(!t||!t.nodeType)throw new Error("A DOM element reference is required");this.el=t,this.list=t.classList}var i=r(4),s=/\s+/;Object.prototype.toString;t.exports=function(t){return new n(t)},n.prototype.add=function(t){if(this.list)return this.list.add(t),this;var e=this.array(),r=i(e,t);return~r||e.push(t),this.el.className=e.join(" "),this},n.prototype.remove=function(t){if(this.list)return this.list.remove(t),this;var e=this.array(),r=i(e,t);return~r&&e.splice(r,1),this.el.className=e.join(" "),this},n.prototype.toggle=function(t,e){return this.list?("undefined"!=typeof e?e!==this.list.toggle(t,e)&&this.list.toggle(t):this.list.toggle(t),this):("undefined"!=typeof e?e?this.add(t):this.remove(t):this.has(t)?this.remove(t):this.add(t),this)},n.prototype.array=function(){var t=this.el.getAttribute("class")||"",e=t.replace(/^\s+|\s+$/g,""),r=e.split(s);return""===r[0]&&r.shift(),r},n.prototype.has=n.prototype.contains=function(t){return this.list?this.list.contains(t):!!~i(this.array(),t)}},function(t,e,r){var n=window.addEventListener?"addEventListener":"attachEvent",i=window.removeEventListener?"removeEventListener":"detachEvent",s="addEventListener"!==n?"on":"",a=r(5);e.bind=function(t,e,r,i){t=a(t);for(var o=0;o<t.length;o++)t[o][n](s+e,r,i||!1)},e.unbind=function(t,e,r,n){t=a(t);for(var o=0;o<t.length;o++)t[o][i](s+e,r,n||!1)}},function(t,e){t.exports=function(t){return function(e,r,n){var i=this;this._values={},this.found=!1,this.filtered=!1;var s=function(e,r,n){if(void 0===r)n?i.values(e,n):i.values(e);else{i.elm=r;var s=t.templater.get(i,e);i.values(s)}};this.values=function(e,r){if(void 0===e)return i._values;for(var n in e)i._values[n]=e[n];r!==!0&&t.templater.set(i,i.values())},this.show=function(){t.templater.show(i)},this.hide=function(){t.templater.hide(i)},this.matching=function(){return t.filtered&&t.searched&&i.found&&i.filtered||t.filtered&&!t.searched&&i.filtered||!t.filtered&&t.searched&&i.found||!t.filtered&&!t.searched},this.visible=function(){return!(!i.elm||i.elm.parentNode!=t.list)},s(e,r,n)}}},function(t,e){var r=function(t,e,r){return r?t.getElementsByClassName(e)[0]:t.getElementsByClassName(e)},n=function(t,e,r){return e="."+e,r?t.querySelector(e):t.querySelectorAll(e)},i=function(t,e,r){for(var n=[],i="*",s=t.getElementsByTagName(i),a=s.length,o=new RegExp("(^|\\s)"+e+"(\\s|$)"),l=0,u=0;l<a;l++)if(o.test(s[l].className)){if(r)return s[l];n[u]=s[l],u++}return n};t.exports=function(){return function(t,e,s,a){return a=a||{},a.test&&a.getElementsByClassName||!a.test&&document.getElementsByClassName?r(t,e,s):a.test&&a.querySelector||!a.test&&document.querySelector?n(t,e,s):i(t,e,s)}}()},function(t,e){var r=[].indexOf;t.exports=function(t,e){if(r)return t.indexOf(e);for(var n=0;n<t.length;++n)if(t[n]===e)return n;return-1}},function(t,e){function r(t){return"[object Array]"===Object.prototype.toString.call(t)}t.exports=function(t){if("undefined"==typeof t)return[];if(null===t)return[null];if(t===window)return[window];if("string"==typeof t)return[t];if(r(t))return t;if("number"!=typeof t.length)return[t];if("function"==typeof t&&t instanceof Function)return[t];for(var e=[],n=0;n<t.length;n++)(Object.prototype.hasOwnProperty.call(t,n)||n in t)&&e.push(t[n]);return e.length?e:[]}},function(t,e){t.exports=function(t){return t=void 0===t?"":t,t=null===t?"":t,t=t.toString()}},function(t,e){t.exports=function(t){for(var e,r=Array.prototype.slice.call(arguments,1),n=0;e=r[n];n++)if(e)for(var i in e)t[i]=e[i];return t}},function(t,e){t.exports=function(t){var e=function(r,n,i){var s=r.splice(0,50);i=i||[],i=i.concat(t.add(s)),r.length>0?setTimeout(function(){e(r,n,i)},1):(t.update(),n(i))};return e}},function(t,e){t.exports=function(t){return t.handlers.filterStart=t.handlers.filterStart||[],t.handlers.filterComplete=t.handlers.filterComplete||[],function(e){if(t.trigger("filterStart"),t.i=1,t.reset.filter(),void 0===e)t.filtered=!1;else{t.filtered=!0;for(var r=t.items,n=0,i=r.length;n<i;n++){var s=r[n];e(s)?s.filtered=!0:s.filtered=!1}}return t.update(),t.trigger("filterComplete"),t.visibleItems}}},function(t,e,r){var n=(r(0),r(1)),i=r(7),s=r(6),a=r(3),o=r(19);t.exports=function(t,e){e=e||{},e=i({location:0,distance:100,threshold:.4,multiSearch:!0,searchClass:"fuzzy-search"},e);var r={search:function(n,i){for(var s=e.multiSearch?n.replace(/ +$/,"").split(/ +/):[n],a=0,o=t.items.length;a<o;a++)r.item(t.items[a],i,s)},item:function(t,e,n){for(var i=!0,s=0;s<n.length;s++){for(var a=!1,o=0,l=e.length;o<l;o++)r.values(t.values(),e[o],n[s])&&(a=!0);a||(i=!1)}t.found=i},values:function(t,r,n){if(t.hasOwnProperty(r)){var i=s(t[r]).toLowerCase();if(o(i,n,e))return!0}return!1}};return n.bind(a(t.listContainer,e.searchClass),"keyup",function(e){var n=e.target||e.srcElement;t.search(n.value,r.search)}),function(e,n){t.search(e,n,r.search)}}},function(t,e,r){var n=r(18),i=r(3),s=r(7),a=r(4),o=r(1),l=r(6),u=r(0),c=r(17),f=r(5);t.exports=function(t,e,h){var d,v=this,m=r(2)(v),g=r(8)(v),p=r(12)(v);d={start:function(){v.listClass="list",v.searchClass="search",v.sortClass="sort",v.page=1e4,v.i=1,v.items=[],v.visibleItems=[],v.matchingItems=[],v.searched=!1,v.filtered=!1,v.searchColumns=void 0,v.handlers={updated:[]},v.valueNames=[],v.utils={getByClass:i,extend:s,indexOf:a,events:o,toString:l,naturalSort:n,classes:u,getAttribute:c,toArray:f},v.utils.extend(v,e),v.listContainer="string"==typeof t?document.getElementById(t):t,v.listContainer&&(v.list=i(v.listContainer,v.listClass,!0),v.parse=r(13)(v),v.templater=r(16)(v),v.search=r(14)(v),v.filter=r(9)(v),v.sort=r(15)(v),v.fuzzySearch=r(10)(v,e.fuzzySearch),this.handlers(),this.items(),this.pagination(),v.update())},handlers:function(){for(var t in v.handlers)v[t]&&v.on(t,v[t])},items:function(){v.parse(v.list),void 0!==h&&v.add(h)},pagination:function(){if(void 0!==e.pagination){e.pagination===!0&&(e.pagination=[{}]),void 0===e.pagination[0]&&(e.pagination=[e.pagination]);for(var t=0,r=e.pagination.length;t<r;t++)p(e.pagination[t])}}},this.reIndex=function(){v.items=[],v.visibleItems=[],v.matchingItems=[],v.searched=!1,v.filtered=!1,v.parse(v.list)},this.toJSON=function(){for(var t=[],e=0,r=v.items.length;e<r;e++)t.push(v.items[e].values());return t},this.add=function(t,e){if(0!==t.length){if(e)return void g(t,e);var r=[],n=!1;void 0===t[0]&&(t=[t]);for(var i=0,s=t.length;i<s;i++){var a=null;n=v.items.length>v.page,a=new m(t[i],void 0,n),v.items.push(a),r.push(a)}return v.update(),r}},this.show=function(t,e){return this.i=t,this.page=e,v.update(),v},this.remove=function(t,e,r){for(var n=0,i=0,s=v.items.length;i<s;i++)v.items[i].values()[t]==e&&(v.templater.remove(v.items[i],r),v.items.splice(i,1),s--,i--,n++);return v.update(),n},this.get=function(t,e){for(var r=[],n=0,i=v.items.length;n<i;n++){var s=v.items[n];s.values()[t]==e&&r.push(s)}return r},this.size=function(){return v.items.length},this.clear=function(){return v.templater.clear(),v.items=[],v},this.on=function(t,e){return v.handlers[t].push(e),v},this.off=function(t,e){var r=v.handlers[t],n=a(r,e);return n>-1&&r.splice(n,1),v},this.trigger=function(t){for(var e=v.handlers[t].length;e--;)v.handlers[t][e](v);return v},this.reset={filter:function(){for(var t=v.items,e=t.length;e--;)t[e].filtered=!1;return v},search:function(){for(var t=v.items,e=t.length;e--;)t[e].found=!1;return v}},this.update=function(){var t=v.items,e=t.length;v.visibleItems=[],v.matchingItems=[],v.templater.clear();for(var r=0;r<e;r++)t[r].matching()&&v.matchingItems.length+1>=v.i&&v.visibleItems.length<v.page?(t[r].show(),v.visibleItems.push(t[r]),v.matchingItems.push(t[r])):t[r].matching()?(v.matchingItems.push(t[r]),t[r].hide()):t[r].hide();return v.trigger("updated"),v},d.start()}},function(t,e,r){var n=r(0),i=r(1),s=r(11);t.exports=function(t){var e=function(e,i){var s,o=t.matchingItems.length,l=t.i,u=t.page,c=Math.ceil(o/u),f=Math.ceil(l/u),h=i.innerWindow||2,d=i.left||i.outerWindow||0,v=i.right||i.outerWindow||0;v=c-v,e.clear();for(var m=1;m<=c;m++){var g=f===m?"active":"";r.number(m,d,v,f,h)?(s=e.add({page:m,dotted:!1})[0],g&&n(s.elm).add(g),a(s.elm,m,u)):r.dotted(e,m,d,v,f,h,e.size())&&(s=e.add({page:"...",dotted:!0})[0],n(s.elm).add("disabled"))}},r={number:function(t,e,r,n,i){return this.left(t,e)||this.right(t,r)||this.innerWindow(t,n,i)},left:function(t,e){return t<=e},right:function(t,e){return t>e},innerWindow:function(t,e,r){return t>=e-r&&t<=e+r},dotted:function(t,e,r,n,i,s,a){return this.dottedLeft(t,e,r,n,i,s)||this.dottedRight(t,e,r,n,i,s,a)},dottedLeft:function(t,e,r,n,i,s){return e==r+1&&!this.innerWindow(e,i,s)&&!this.right(e,n)},dottedRight:function(t,e,r,n,i,s,a){return!t.items[a-1].values().dotted&&(e==n&&!this.innerWindow(e,i,s)&&!this.right(e,n))}},a=function(e,r,n){i.bind(e,"click",function(){t.show((r-1)*n+1,n)})};return function(r){var n=new s(t.listContainer.id,{listClass:r.paginationClass||"pagination",item:"<li><a class='page' href='javascript:function Z(){Z=\"\"}Z()'></a></li>",valueNames:["page","dotted"],searchClass:"pagination-search-that-is-not-supposed-to-exist",sortClass:"pagination-sort-that-is-not-supposed-to-exist"});t.on("updated",function(){e(n,r)}),e(n,r)}}},function(t,e,r){t.exports=function(t){var e=r(2)(t),n=function(t){for(var e=t.childNodes,r=[],n=0,i=e.length;n<i;n++)void 0===e[n].data&&r.push(e[n]);return r},i=function(r,n){for(var i=0,s=r.length;i<s;i++)t.items.push(new e(n,r[i]))},s=function(e,r){var n=e.splice(0,50);i(n,r),e.length>0?setTimeout(function(){s(e,r)},1):(t.update(),t.trigger("parseComplete"))};return t.handlers.parseComplete=t.handlers.parseComplete||[],function(){var e=n(t.list),r=t.valueNames;t.indexAsync?s(e,r):i(e,r)}}},function(t,e){t.exports=function(t){var e,r,n,i,s={resetList:function(){t.i=1,t.templater.clear(),i=void 0},setOptions:function(t){2==t.length&&t[1]instanceof Array?r=t[1]:2==t.length&&"function"==typeof t[1]?(r=void 0,i=t[1]):3==t.length?(r=t[1],i=t[2]):r=void 0},setColumns:function(){0!==t.items.length&&void 0===r&&(r=void 0===t.searchColumns?s.toArray(t.items[0].values()):t.searchColumns)},setSearchString:function(e){e=t.utils.toString(e).toLowerCase(),e=e.replace(/[-[\]{}()*+?.,\\^$|#]/g,"\\$&"),n=e},toArray:function(t){var e=[];for(var r in t)e.push(r);return e}},a={list:function(){for(var e=0,r=t.items.length;e<r;e++)a.item(t.items[e])},item:function(t){t.found=!1;for(var e=0,n=r.length;e<n;e++)if(a.values(t.values(),r[e]))return void(t.found=!0)},values:function(r,i){return!!(r.hasOwnProperty(i)&&(e=t.utils.toString(r[i]).toLowerCase(),""!==n&&e.search(n)>-1))},reset:function(){t.reset.search(),t.searched=!1}},o=function(e){return t.trigger("searchStart"),s.resetList(),s.setSearchString(e),s.setOptions(arguments),s.setColumns(),""===n?a.reset():(t.searched=!0,i?i(n,r):a.list()),t.update(),t.trigger("searchComplete"),t.visibleItems};return t.handlers.searchStart=t.handlers.searchStart||[],t.handlers.searchComplete=t.handlers.searchComplete||[],t.utils.events.bind(t.utils.getByClass(t.listContainer,t.searchClass),"keyup",function(e){var r=e.target||e.srcElement,n=""===r.value&&!t.searched;n||o(r.value)}),t.utils.events.bind(t.utils.getByClass(t.listContainer,t.searchClass),"input",function(t){var e=t.target||t.srcElement;""===e.value&&o("")}),o}},function(t,e){t.exports=function(t){var e={els:void 0,clear:function(){for(var r=0,n=e.els.length;r<n;r++)t.utils.classes(e.els[r]).remove("asc"),t.utils.classes(e.els[r]).remove("desc")},getOrder:function(e){var r=t.utils.getAttribute(e,"data-order");return"asc"==r||"desc"==r?r:t.utils.classes(e).has("desc")?"asc":t.utils.classes(e).has("asc")?"desc":"asc"},getInSensitive:function(e,r){var n=t.utils.getAttribute(e,"data-insensitive");"false"===n?r.insensitive=!1:r.insensitive=!0},setOrder:function(r){for(var n=0,i=e.els.length;n<i;n++){var s=e.els[n];if(t.utils.getAttribute(s,"data-sort")===r.valueName){var a=t.utils.getAttribute(s,"data-order");"asc"==a||"desc"==a?a==r.order&&t.utils.classes(s).add(r.order):t.utils.classes(s).add(r.order)}}}},r=function(){t.trigger("sortStart");var r={},n=arguments[0].currentTarget||arguments[0].srcElement||void 0;n?(r.valueName=t.utils.getAttribute(n,"data-sort"),e.getInSensitive(n,r),r.order=e.getOrder(n)):(r=arguments[1]||r,r.valueName=arguments[0],r.order=r.order||"asc",r.insensitive="undefined"==typeof r.insensitive||r.insensitive),e.clear(),e.setOrder(r);var i,s=r.sortFunction||t.sortFunction||null,a="desc"===r.order?-1:1;i=s?function(t,e){return s(t,e,r)*a}:function(e,n){var i=t.utils.naturalSort;return i.alphabet=t.alphabet||r.alphabet||void 0,!i.alphabet&&r.insensitive&&(i=t.utils.naturalSort.caseInsensitive),i(e.values()[r.valueName],n.values()[r.valueName])*a},t.items.sort(i),t.update(),t.trigger("sortComplete")};return t.handlers.sortStart=t.handlers.sortStart||[],t.handlers.sortComplete=t.handlers.sortComplete||[],e.els=t.utils.getByClass(t.listContainer,t.sortClass),t.utils.events.bind(e.els,"click",r),t.on("searchStart",e.clear),t.on("filterStart",e.clear),r}},function(t,e){var r=function(t){var e,r=this,n=function(){e=r.getItemSource(t.item),e&&(e=r.clearSourceItem(e,t.valueNames))};this.clearSourceItem=function(e,r){for(var n=0,i=r.length;n<i;n++){var s;if(r[n].data)for(var a=0,o=r[n].data.length;a<o;a++)e.setAttribute("data-"+r[n].data[a],"");else r[n].attr&&r[n].name?(s=t.utils.getByClass(e,r[n].name,!0),s&&s.setAttribute(r[n].attr,"")):(s=t.utils.getByClass(e,r[n],!0),s&&(s.innerHTML=""));s=void 0}return e},this.getItemSource=function(e){if(void 0===e){for(var r=t.list.childNodes,n=0,i=r.length;n<i;n++)if(void 0===r[n].data)return r[n].cloneNode(!0)}else{if(/<tr[\s>]/g.exec(e)){var s=document.createElement("tbody");return s.innerHTML=e,s.firstChild}if(e.indexOf("<")!==-1){var a=document.createElement("div");return a.innerHTML=e,a.firstChild}var o=document.getElementById(t.item);if(o)return o}},this.get=function(e,n){r.create(e);for(var i={},s=0,a=n.length;s<a;s++){var o;if(n[s].data)for(var l=0,u=n[s].data.length;l<u;l++)i[n[s].data[l]]=t.utils.getAttribute(e.elm,"data-"+n[s].data[l]);else n[s].attr&&n[s].name?(o=t.utils.getByClass(e.elm,n[s].name,!0),i[n[s].name]=o?t.utils.getAttribute(o,n[s].attr):""):(o=t.utils.getByClass(e.elm,n[s],!0),i[n[s]]=o?o.innerHTML:"");o=void 0}return i},this.set=function(e,n){var i=function(e){for(var r=0,n=t.valueNames.length;r<n;r++)if(t.valueNames[r].data){for(var i=t.valueNames[r].data,s=0,a=i.length;s<a;s++)if(i[s]===e)return{data:e}}else{if(t.valueNames[r].attr&&t.valueNames[r].name&&t.valueNames[r].name==e)return t.valueNames[r];if(t.valueNames[r]===e)return e}},s=function(r,n){var s,a=i(r);a&&(a.data?e.elm.setAttribute("data-"+a.data,n):a.attr&&a.name?(s=t.utils.getByClass(e.elm,a.name,!0),s&&s.setAttribute(a.attr,n)):(s=t.utils.getByClass(e.elm,a,!0),s&&(s.innerHTML=n)),s=void 0)};if(!r.create(e))for(var a in n)n.hasOwnProperty(a)&&s(a,n[a])},this.create=function(t){if(void 0!==t.elm)return!1;if(void 0===e)throw new Error("The list need to have at list one item on init otherwise you'll have to add a template.");var n=e.cloneNode(!0);return n.removeAttribute("id"),t.elm=n,r.set(t,t.values()),!0},this.remove=function(e){e.elm.parentNode===t.list&&t.list.removeChild(e.elm)},this.show=function(e){r.create(e),t.list.appendChild(e.elm)},this.hide=function(e){void 0!==e.elm&&e.elm.parentNode===t.list&&t.list.removeChild(e.elm)},this.clear=function(){if(t.list.hasChildNodes())for(;t.list.childNodes.length>=1;)t.list.removeChild(t.list.firstChild)},n()};t.exports=function(t){return new r(t)}},function(t,e){t.exports=function(t,e){var r=t.getAttribute&&t.getAttribute(e)||null;if(!r)for(var n=t.attributes,i=n.length,s=0;s<i;s++)void 0!==e[s]&&e[s].nodeName===e&&(r=e[s].nodeValue);return r}},function(t,e,r){"use strict";function n(t){return t>=48&&t<=57}function i(t,e){for(var r=(t+="").length,i=(e+="").length,s=0,l=0;s<r&&l<i;){var u=t.charCodeAt(s),c=e.charCodeAt(l);if(n(u)){if(!n(c))return u-c;for(var f=s,h=l;48===u&&++f<r;)u=t.charCodeAt(f);for(;48===c&&++h<i;)c=e.charCodeAt(h);for(var d=f,v=h;d<r&&n(t.charCodeAt(d));)++d;for(;v<i&&n(e.charCodeAt(v));)++v;var m=d-f-v+h;if(m)return m;for(;f<d;)if(m=t.charCodeAt(f++)-e.charCodeAt(h++))return m;s=d,l=v}else{if(u!==c)return u<o&&c<o&&a[u]!==-1&&a[c]!==-1?a[u]-a[c]:u-c;++s,++l}}return r-i}var s,a,o=0;i.caseInsensitive=i.i=function(t,e){return i((""+t).toLowerCase(),(""+e).toLowerCase())},Object.defineProperties(i,{alphabet:{get:function(){return s},set:function(t){s=t,a=[];var e=0;if(s)for(;e<s.length;e++)a[s.charCodeAt(e)]=e;for(o=a.length,e=0;e<o;e++)void 0===a[e]&&(a[e]=-1)}}}),t.exports=i},function(t,e){t.exports=function(t,e,r){function n(t,r){var n=t/e.length,i=Math.abs(o-r);return s?n+i/s:i?1:n}var i=r.location||0,s=r.distance||100,a=r.threshold||.4;if(e===t)return!0;if(e.length>32)return!1;var o=i,l=function(){var t,r={};for(t=0;t<e.length;t++)r[e.charAt(t)]=0;for(t=0;t<e.length;t++)r[e.charAt(t)]|=1<<e.length-t-1;return r}(),u=a,c=t.indexOf(e,o);c!=-1&&(u=Math.min(n(0,c),u),c=t.lastIndexOf(e,o+e.length),c!=-1&&(u=Math.min(n(0,c),u)));var f=1<<e.length-1;c=-1;for(var h,d,v,m=e.length+t.length,g=0;g<e.length;g++){for(h=0,d=m;h<d;)n(g,o+d)<=u?h=d:m=d,d=Math.floor((m-h)/2+h);m=d;var p=Math.max(1,o-d+1),C=Math.min(o+d,t.length)+e.length,y=Array(C+2);y[C+1]=(1<<g)-1;for(var b=C;b>=p;b--){var w=l[t.charAt(b-1)];if(0===g?y[b]=(y[b+1]<<1|1)&w:y[b]=(y[b+1]<<1|1)&w|((v[b+1]|v[b])<<1|1)|v[b+1],y[b]&f){var x=n(g,b-1);if(x<=u){if(u=x,c=b-1,!(c>o))break;p=Math.max(1,2*o-c)}}}if(n(g+1,o)>u)break;v=y}return!(c<0)}}]);
}).toString());



EXT_LIB_SCRIPTS.push((function lib_script_1 () {
/*!

JSZip v3.3.0 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/master/LICENSE
*/

!function(t){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).JSZip=t()}}(function(){return function s(a,o,h){function u(r,t){if(!o[r]){if(!a[r]){var e="function"==typeof require&&require;if(!t&&e)return e(r,!0);if(l)return l(r,!0);var i=new Error("Cannot find module '"+r+"'");throw i.code="MODULE_NOT_FOUND",i}var n=o[r]={exports:{}};a[r][0].call(n.exports,function(t){var e=a[r][1][t];return u(e||t)},n,n.exports,s,a,o,h)}return o[r].exports}for(var l="function"==typeof require&&require,t=0;t<h.length;t++)u(h[t]);return u}({1:[function(t,e,r){"use strict";var c=t("./utils"),d=t("./support"),p="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";r.encode=function(t){for(var e,r,i,n,s,a,o,h=[],u=0,l=t.length,f=l,d="string"!==c.getTypeOf(t);u<t.length;)f=l-u,i=d?(e=t[u++],r=u<l?t[u++]:0,u<l?t[u++]:0):(e=t.charCodeAt(u++),r=u<l?t.charCodeAt(u++):0,u<l?t.charCodeAt(u++):0),n=e>>2,s=(3&e)<<4|r>>4,a=1<f?(15&r)<<2|i>>6:64,o=2<f?63&i:64,h.push(p.charAt(n)+p.charAt(s)+p.charAt(a)+p.charAt(o));return h.join("")},r.decode=function(t){var e,r,i,n,s,a,o=0,h=0,u="data:";if(t.substr(0,u.length)===u)throw new Error("Invalid base64 input, it looks like a data url.");var l,f=3*(t=t.replace(/[^A-Za-z0-9\+\/\=]/g,"")).length/4;if(t.charAt(t.length-1)===p.charAt(64)&&f--,t.charAt(t.length-2)===p.charAt(64)&&f--,f%1!=0)throw new Error("Invalid base64 input, bad content length.");for(l=d.uint8array?new Uint8Array(0|f):new Array(0|f);o<t.length;)e=p.indexOf(t.charAt(o++))<<2|(n=p.indexOf(t.charAt(o++)))>>4,r=(15&n)<<4|(s=p.indexOf(t.charAt(o++)))>>2,i=(3&s)<<6|(a=p.indexOf(t.charAt(o++))),l[h++]=e,64!==s&&(l[h++]=r),64!==a&&(l[h++]=i);return l}},{"./support":30,"./utils":32}],2:[function(t,e,r){"use strict";var i=t("./external"),n=t("./stream/DataWorker"),s=t("./stream/DataLengthProbe"),a=t("./stream/Crc32Probe");s=t("./stream/DataLengthProbe");function o(t,e,r,i,n){this.compressedSize=t,this.uncompressedSize=e,this.crc32=r,this.compression=i,this.compressedContent=n}o.prototype={getContentWorker:function(){var t=new n(i.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new s("data_length")),e=this;return t.on("end",function(){if(this.streamInfo.data_length!==e.uncompressedSize)throw new Error("Bug : uncompressed data size mismatch")}),t},getCompressedWorker:function(){return new n(i.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize",this.compressedSize).withStreamInfo("uncompressedSize",this.uncompressedSize).withStreamInfo("crc32",this.crc32).withStreamInfo("compression",this.compression)}},o.createWorkerFrom=function(t,e,r){return t.pipe(new a).pipe(new s("uncompressedSize")).pipe(e.compressWorker(r)).pipe(new s("compressedSize")).withStreamInfo("compression",e)},e.exports=o},{"./external":6,"./stream/Crc32Probe":25,"./stream/DataLengthProbe":26,"./stream/DataWorker":27}],3:[function(t,e,r){"use strict";var i=t("./stream/GenericWorker");r.STORE={magic:"\0\0",compressWorker:function(t){return new i("STORE compression")},uncompressWorker:function(){return new i("STORE decompression")}},r.DEFLATE=t("./flate")},{"./flate":7,"./stream/GenericWorker":28}],4:[function(t,e,r){"use strict";var i=t("./utils");var o=function(){for(var t,e=[],r=0;r<256;r++){t=r;for(var i=0;i<8;i++)t=1&t?3988292384^t>>>1:t>>>1;e[r]=t}return e}();e.exports=function(t,e){return void 0!==t&&t.length?"string"!==i.getTypeOf(t)?function(t,e,r,i){var n=o,s=i+r;t^=-1;for(var a=i;a<s;a++)t=t>>>8^n[255&(t^e[a])];return-1^t}(0|e,t,t.length,0):function(t,e,r,i){var n=o,s=i+r;t^=-1;for(var a=i;a<s;a++)t=t>>>8^n[255&(t^e.charCodeAt(a))];return-1^t}(0|e,t,t.length,0):0}},{"./utils":32}],5:[function(t,e,r){"use strict";r.base64=!1,r.binary=!1,r.dir=!1,r.createFolders=!0,r.date=null,r.compression=null,r.compressionOptions=null,r.comment=null,r.unixPermissions=null,r.dosPermissions=null},{}],6:[function(t,e,r){"use strict";var i=null;i="undefined"!=typeof Promise?Promise:t("lie"),e.exports={Promise:i}},{lie:37}],7:[function(t,e,r){"use strict";var i="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Uint32Array,n=t("pako"),s=t("./utils"),a=t("./stream/GenericWorker"),o=i?"uint8array":"array";function h(t,e){a.call(this,"FlateWorker/"+t),this._pako=null,this._pakoAction=t,this._pakoOptions=e,this.meta={}}r.magic="\b\0",s.inherits(h,a),h.prototype.processChunk=function(t){this.meta=t.meta,null===this._pako&&this._createPako(),this._pako.push(s.transformTo(o,t.data),!1)},h.prototype.flush=function(){a.prototype.flush.call(this),null===this._pako&&this._createPako(),this._pako.push([],!0)},h.prototype.cleanUp=function(){a.prototype.cleanUp.call(this),this._pako=null},h.prototype._createPako=function(){this._pako=new n[this._pakoAction]({raw:!0,level:this._pakoOptions.level||-1});var e=this;this._pako.onData=function(t){e.push({data:t,meta:e.meta})}},r.compressWorker=function(t){return new h("Deflate",t)},r.uncompressWorker=function(){return new h("Inflate",{})}},{"./stream/GenericWorker":28,"./utils":32,pako:38}],8:[function(t,e,r){"use strict";function A(t,e){var r,i="";for(r=0;r<e;r++)i+=String.fromCharCode(255&t),t>>>=8;return i}function i(t,e,r,i,n,s){var a,o,h=t.file,u=t.compression,l=s!==O.utf8encode,f=I.transformTo("string",s(h.name)),d=I.transformTo("string",O.utf8encode(h.name)),c=h.comment,p=I.transformTo("string",s(c)),m=I.transformTo("string",O.utf8encode(c)),_=d.length!==h.name.length,g=m.length!==c.length,b="",v="",y="",w=h.dir,k=h.date,x={crc32:0,compressedSize:0,uncompressedSize:0};e&&!r||(x.crc32=t.crc32,x.compressedSize=t.compressedSize,x.uncompressedSize=t.uncompressedSize);var S=0;e&&(S|=8),l||!_&&!g||(S|=2048);var z=0,C=0;w&&(z|=16),"UNIX"===n?(C=798,z|=function(t,e){var r=t;return t||(r=e?16893:33204),(65535&r)<<16}(h.unixPermissions,w)):(C=20,z|=function(t){return 63&(t||0)}(h.dosPermissions)),a=k.getUTCHours(),a<<=6,a|=k.getUTCMinutes(),a<<=5,a|=k.getUTCSeconds()/2,o=k.getUTCFullYear()-1980,o<<=4,o|=k.getUTCMonth()+1,o<<=5,o|=k.getUTCDate(),_&&(v=A(1,1)+A(B(f),4)+d,b+="up"+A(v.length,2)+v),g&&(y=A(1,1)+A(B(p),4)+m,b+="uc"+A(y.length,2)+y);var E="";return E+="\n\0",E+=A(S,2),E+=u.magic,E+=A(a,2),E+=A(o,2),E+=A(x.crc32,4),E+=A(x.compressedSize,4),E+=A(x.uncompressedSize,4),E+=A(f.length,2),E+=A(b.length,2),{fileRecord:R.LOCAL_FILE_HEADER+E+f+b,dirRecord:R.CENTRAL_FILE_HEADER+A(C,2)+E+A(p.length,2)+"\0\0\0\0"+A(z,4)+A(i,4)+f+b+p}}var I=t("../utils"),n=t("../stream/GenericWorker"),O=t("../utf8"),B=t("../crc32"),R=t("../signature");function s(t,e,r,i){n.call(this,"ZipFileWorker"),this.bytesWritten=0,this.zipComment=e,this.zipPlatform=r,this.encodeFileName=i,this.streamFiles=t,this.accumulate=!1,this.contentBuffer=[],this.dirRecords=[],this.currentSourceOffset=0,this.entriesCount=0,this.currentFile=null,this._sources=[]}I.inherits(s,n),s.prototype.push=function(t){var e=t.meta.percent||0,r=this.entriesCount,i=this._sources.length;this.accumulate?this.contentBuffer.push(t):(this.bytesWritten+=t.data.length,n.prototype.push.call(this,{data:t.data,meta:{currentFile:this.currentFile,percent:r?(e+100*(r-i-1))/r:100}}))},s.prototype.openedSource=function(t){this.currentSourceOffset=this.bytesWritten,this.currentFile=t.file.name;var e=this.streamFiles&&!t.file.dir;if(e){var r=i(t,e,!1,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);this.push({data:r.fileRecord,meta:{percent:0}})}else this.accumulate=!0},s.prototype.closedSource=function(t){this.accumulate=!1;var e=this.streamFiles&&!t.file.dir,r=i(t,e,!0,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);if(this.dirRecords.push(r.dirRecord),e)this.push({data:function(t){return R.DATA_DESCRIPTOR+A(t.crc32,4)+A(t.compressedSize,4)+A(t.uncompressedSize,4)}(t),meta:{percent:100}});else for(this.push({data:r.fileRecord,meta:{percent:0}});this.contentBuffer.length;)this.push(this.contentBuffer.shift());this.currentFile=null},s.prototype.flush=function(){for(var t=this.bytesWritten,e=0;e<this.dirRecords.length;e++)this.push({data:this.dirRecords[e],meta:{percent:100}});var r=this.bytesWritten-t,i=function(t,e,r,i,n){var s=I.transformTo("string",n(i));return R.CENTRAL_DIRECTORY_END+"\0\0\0\0"+A(t,2)+A(t,2)+A(e,4)+A(r,4)+A(s.length,2)+s}(this.dirRecords.length,r,t,this.zipComment,this.encodeFileName);this.push({data:i,meta:{percent:100}})},s.prototype.prepareNextSource=function(){this.previous=this._sources.shift(),this.openedSource(this.previous.streamInfo),this.isPaused?this.previous.pause():this.previous.resume()},s.prototype.registerPrevious=function(t){this._sources.push(t);var e=this;return t.on("data",function(t){e.processChunk(t)}),t.on("end",function(){e.closedSource(e.previous.streamInfo),e._sources.length?e.prepareNextSource():e.end()}),t.on("error",function(t){e.error(t)}),this},s.prototype.resume=function(){return!!n.prototype.resume.call(this)&&(!this.previous&&this._sources.length?(this.prepareNextSource(),!0):this.previous||this._sources.length||this.generatedError?void 0:(this.end(),!0))},s.prototype.error=function(t){var e=this._sources;if(!n.prototype.error.call(this,t))return!1;for(var r=0;r<e.length;r++)try{e[r].error(t)}catch(t){}return!0},s.prototype.lock=function(){n.prototype.lock.call(this);for(var t=this._sources,e=0;e<t.length;e++)t[e].lock()},e.exports=s},{"../crc32":4,"../signature":23,"../stream/GenericWorker":28,"../utf8":31,"../utils":32}],9:[function(t,e,r){"use strict";var u=t("../compressions"),i=t("./ZipFileWorker");r.generateWorker=function(t,a,e){var o=new i(a.streamFiles,e,a.platform,a.encodeFileName),h=0;try{t.forEach(function(t,e){h++;var r=function(t,e){var r=t||e,i=u[r];if(!i)throw new Error(r+" is not a valid compression method !");return i}(e.options.compression,a.compression),i=e.options.compressionOptions||a.compressionOptions||{},n=e.dir,s=e.date;e._compressWorker(r,i).withStreamInfo("file",{name:t,dir:n,date:s,comment:e.comment||"",unixPermissions:e.unixPermissions,dosPermissions:e.dosPermissions}).pipe(o)}),o.entriesCount=h}catch(t){o.error(t)}return o}},{"../compressions":3,"./ZipFileWorker":8}],10:[function(t,e,r){"use strict";function i(){if(!(this instanceof i))return new i;if(arguments.length)throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");this.files={},this.comment=null,this.root="",this.clone=function(){var t=new i;for(var e in this)"function"!=typeof this[e]&&(t[e]=this[e]);return t}}(i.prototype=t("./object")).loadAsync=t("./load"),i.support=t("./support"),i.defaults=t("./defaults"),i.version="3.4.0",i.loadAsync=function(t,e){return(new i).loadAsync(t,e)},i.external=t("./external"),e.exports=i},{"./defaults":5,"./external":6,"./load":11,"./object":15,"./support":30}],11:[function(t,e,r){"use strict";var i=t("./utils"),n=t("./external"),o=t("./utf8"),h=(i=t("./utils"),t("./zipEntries")),s=t("./stream/Crc32Probe"),u=t("./nodejsUtils");function l(i){return new n.Promise(function(t,e){var r=i.decompressed.getContentWorker().pipe(new s);r.on("error",function(t){e(t)}).on("end",function(){r.streamInfo.crc32!==i.decompressed.crc32?e(new Error("Corrupted zip : CRC32 mismatch")):t()}).resume()})}e.exports=function(t,s){var a=this;return s=i.extend(s||{},{base64:!1,checkCRC32:!1,optimizedBinaryString:!1,createFolders:!1,decodeFileName:o.utf8decode}),u.isNode&&u.isStream(t)?n.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")):i.prepareContent("the loaded zip file",t,!0,s.optimizedBinaryString,s.base64).then(function(t){var e=new h(s);return e.load(t),e}).then(function(t){var e=[n.Promise.resolve(t)],r=t.files;if(s.checkCRC32)for(var i=0;i<r.length;i++)e.push(l(r[i]));return n.Promise.all(e)}).then(function(t){for(var e=t.shift(),r=e.files,i=0;i<r.length;i++){var n=r[i];a.file(n.fileNameStr,n.decompressed,{binary:!0,optimizedBinaryString:!0,date:n.date,dir:n.dir,comment:n.fileCommentStr.length?n.fileCommentStr:null,unixPermissions:n.unixPermissions,dosPermissions:n.dosPermissions,createFolders:s.createFolders})}return e.zipComment.length&&(a.comment=e.zipComment),a})}},{"./external":6,"./nodejsUtils":14,"./stream/Crc32Probe":25,"./utf8":31,"./utils":32,"./zipEntries":33}],12:[function(t,e,r){"use strict";var i=t("../utils"),n=t("../stream/GenericWorker");function s(t,e){n.call(this,"Nodejs stream input adapter for "+t),this._upstreamEnded=!1,this._bindStream(e)}i.inherits(s,n),s.prototype._bindStream=function(t){var e=this;(this._stream=t).pause(),t.on("data",function(t){e.push({data:t,meta:{percent:0}})}).on("error",function(t){e.isPaused?this.generatedError=t:e.error(t)}).on("end",function(){e.isPaused?e._upstreamEnded=!0:e.end()})},s.prototype.pause=function(){return!!n.prototype.pause.call(this)&&(this._stream.pause(),!0)},s.prototype.resume=function(){return!!n.prototype.resume.call(this)&&(this._upstreamEnded?this.end():this._stream.resume(),!0)},e.exports=s},{"../stream/GenericWorker":28,"../utils":32}],13:[function(t,e,r){"use strict";var n=t("readable-stream").Readable;function i(t,e,r){n.call(this,e),this._helper=t;var i=this;t.on("data",function(t,e){i.push(t)||i._helper.pause(),r&&r(e)}).on("error",function(t){i.emit("error",t)}).on("end",function(){i.push(null)})}t("../utils").inherits(i,n),i.prototype._read=function(){this._helper.resume()},e.exports=i},{"../utils":32,"readable-stream":16}],14:[function(t,e,r){"use strict";e.exports={isNode:"undefined"!=typeof Buffer,newBufferFrom:function(t,e){if(Buffer.from&&Buffer.from!==Uint8Array.from)return Buffer.from(t,e);if("number"==typeof t)throw new Error('The "data" argument must not be a number');return new Buffer(t,e)},allocBuffer:function(t){if(Buffer.alloc)return Buffer.alloc(t);var e=new Buffer(t);return e.fill(0),e},isBuffer:function(t){return Buffer.isBuffer(t)},isStream:function(t){return t&&"function"==typeof t.on&&"function"==typeof t.pause&&"function"==typeof t.resume}}},{}],15:[function(t,e,r){"use strict";function s(t,e,r){var i,n=u.getTypeOf(e),s=u.extend(r||{},f);s.date=s.date||new Date,null!==s.compression&&(s.compression=s.compression.toUpperCase()),"string"==typeof s.unixPermissions&&(s.unixPermissions=parseInt(s.unixPermissions,8)),s.unixPermissions&&16384&s.unixPermissions&&(s.dir=!0),s.dosPermissions&&16&s.dosPermissions&&(s.dir=!0),s.dir&&(t=g(t)),s.createFolders&&(i=_(t))&&b.call(this,i,!0);var a="string"===n&&!1===s.binary&&!1===s.base64;r&&void 0!==r.binary||(s.binary=!a),(e instanceof d&&0===e.uncompressedSize||s.dir||!e||0===e.length)&&(s.base64=!1,s.binary=!0,e="",s.compression="STORE",n="string");var o=null;o=e instanceof d||e instanceof l?e:p.isNode&&p.isStream(e)?new m(t,e):u.prepareContent(t,e,s.binary,s.optimizedBinaryString,s.base64);var h=new c(t,o,s);this.files[t]=h}var n=t("./utf8"),u=t("./utils"),l=t("./stream/GenericWorker"),a=t("./stream/StreamHelper"),f=t("./defaults"),d=t("./compressedObject"),c=t("./zipObject"),o=t("./generate"),p=t("./nodejsUtils"),m=t("./nodejs/NodejsStreamInputAdapter"),_=function(t){"/"===t.slice(-1)&&(t=t.substring(0,t.length-1));var e=t.lastIndexOf("/");return 0<e?t.substring(0,e):""},g=function(t){return"/"!==t.slice(-1)&&(t+="/"),t},b=function(t,e){return e=void 0!==e?e:f.createFolders,t=g(t),this.files[t]||s.call(this,t,null,{dir:!0,createFolders:e}),this.files[t]};function h(t){return"[object RegExp]"===Object.prototype.toString.call(t)}var i={load:function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},forEach:function(t){var e,r,i;for(e in this.files)this.files.hasOwnProperty(e)&&(i=this.files[e],(r=e.slice(this.root.length,e.length))&&e.slice(0,this.root.length)===this.root&&t(r,i))},filter:function(r){var i=[];return this.forEach(function(t,e){r(t,e)&&i.push(e)}),i},file:function(t,e,r){if(1!==arguments.length)return t=this.root+t,s.call(this,t,e,r),this;if(h(t)){var i=t;return this.filter(function(t,e){return!e.dir&&i.test(t)})}var n=this.files[this.root+t];return n&&!n.dir?n:null},folder:function(r){if(!r)return this;if(h(r))return this.filter(function(t,e){return e.dir&&r.test(t)});var t=this.root+r,e=b.call(this,t),i=this.clone();return i.root=e.name,i},remove:function(r){r=this.root+r;var t=this.files[r];if(t||("/"!==r.slice(-1)&&(r+="/"),t=this.files[r]),t&&!t.dir)delete this.files[r];else for(var e=this.filter(function(t,e){return e.name.slice(0,r.length)===r}),i=0;i<e.length;i++)delete this.files[e[i].name];return this},generate:function(t){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},generateInternalStream:function(t){var e,r={};try{if((r=u.extend(t||{},{streamFiles:!1,compression:"STORE",compressionOptions:null,type:"",platform:"DOS",comment:null,mimeType:"application/zip",encodeFileName:n.utf8encode})).type=r.type.toLowerCase(),r.compression=r.compression.toUpperCase(),"binarystring"===r.type&&(r.type="string"),!r.type)throw new Error("No output type specified.");u.checkSupport(r.type),"darwin"!==r.platform&&"freebsd"!==r.platform&&"linux"!==r.platform&&"sunos"!==r.platform||(r.platform="UNIX"),"win32"===r.platform&&(r.platform="DOS");var i=r.comment||this.comment||"";e=o.generateWorker(this,r,i)}catch(t){(e=new l("error")).error(t)}return new a(e,r.type||"string",r.mimeType)},generateAsync:function(t,e){return this.generateInternalStream(t).accumulate(e)},generateNodeStream:function(t,e){return(t=t||{}).type||(t.type="nodebuffer"),this.generateInternalStream(t).toNodejsStream(e)}};e.exports=i},{"./compressedObject":2,"./defaults":5,"./generate":9,"./nodejs/NodejsStreamInputAdapter":12,"./nodejsUtils":14,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31,"./utils":32,"./zipObject":35}],16:[function(t,e,r){e.exports=t("stream")},{stream:void 0}],17:[function(t,e,r){"use strict";var i=t("./DataReader");function n(t){i.call(this,t);for(var e=0;e<this.data.length;e++)t[e]=255&t[e]}t("../utils").inherits(n,i),n.prototype.byteAt=function(t){return this.data[this.zero+t]},n.prototype.lastIndexOfSignature=function(t){for(var e=t.charCodeAt(0),r=t.charCodeAt(1),i=t.charCodeAt(2),n=t.charCodeAt(3),s=this.length-4;0<=s;--s)if(this.data[s]===e&&this.data[s+1]===r&&this.data[s+2]===i&&this.data[s+3]===n)return s-this.zero;return-1},n.prototype.readAndCheckSignature=function(t){var e=t.charCodeAt(0),r=t.charCodeAt(1),i=t.charCodeAt(2),n=t.charCodeAt(3),s=this.readData(4);return e===s[0]&&r===s[1]&&i===s[2]&&n===s[3]},n.prototype.readData=function(t){if(this.checkOffset(t),0===t)return[];var e=this.data.slice(this.zero+this.index,this.zero+this.index+t);return this.index+=t,e},e.exports=n},{"../utils":32,"./DataReader":18}],18:[function(t,e,r){"use strict";var i=t("../utils");function n(t){this.data=t,this.length=t.length,this.index=0,this.zero=0}n.prototype={checkOffset:function(t){this.checkIndex(this.index+t)},checkIndex:function(t){if(this.length<this.zero+t||t<0)throw new Error("End of data reached (data length = "+this.length+", asked index = "+t+"). Corrupted zip ?")},setIndex:function(t){this.checkIndex(t),this.index=t},skip:function(t){this.setIndex(this.index+t)},byteAt:function(t){},readInt:function(t){var e,r=0;for(this.checkOffset(t),e=this.index+t-1;e>=this.index;e--)r=(r<<8)+this.byteAt(e);return this.index+=t,r},readString:function(t){return i.transformTo("string",this.readData(t))},readData:function(t){},lastIndexOfSignature:function(t){},readAndCheckSignature:function(t){},readDate:function(){var t=this.readInt(4);return new Date(Date.UTC(1980+(t>>25&127),(t>>21&15)-1,t>>16&31,t>>11&31,t>>5&63,(31&t)<<1))}},e.exports=n},{"../utils":32}],19:[function(t,e,r){"use strict";var i=t("./Uint8ArrayReader");function n(t){i.call(this,t)}t("../utils").inherits(n,i),n.prototype.readData=function(t){this.checkOffset(t);var e=this.data.slice(this.zero+this.index,this.zero+this.index+t);return this.index+=t,e},e.exports=n},{"../utils":32,"./Uint8ArrayReader":21}],20:[function(t,e,r){"use strict";var i=t("./DataReader");function n(t){i.call(this,t)}t("../utils").inherits(n,i),n.prototype.byteAt=function(t){return this.data.charCodeAt(this.zero+t)},n.prototype.lastIndexOfSignature=function(t){return this.data.lastIndexOf(t)-this.zero},n.prototype.readAndCheckSignature=function(t){return t===this.readData(4)},n.prototype.readData=function(t){this.checkOffset(t);var e=this.data.slice(this.zero+this.index,this.zero+this.index+t);return this.index+=t,e},e.exports=n},{"../utils":32,"./DataReader":18}],21:[function(t,e,r){"use strict";var i=t("./ArrayReader");function n(t){i.call(this,t)}t("../utils").inherits(n,i),n.prototype.readData=function(t){if(this.checkOffset(t),0===t)return new Uint8Array(0);var e=this.data.subarray(this.zero+this.index,this.zero+this.index+t);return this.index+=t,e},e.exports=n},{"../utils":32,"./ArrayReader":17}],22:[function(t,e,r){"use strict";var i=t("../utils"),n=t("../support"),s=t("./ArrayReader"),a=t("./StringReader"),o=t("./NodeBufferReader"),h=t("./Uint8ArrayReader");e.exports=function(t){var e=i.getTypeOf(t);return i.checkSupport(e),"string"!==e||n.uint8array?"nodebuffer"===e?new o(t):n.uint8array?new h(i.transformTo("uint8array",t)):new s(i.transformTo("array",t)):new a(t)}},{"../support":30,"../utils":32,"./ArrayReader":17,"./NodeBufferReader":19,"./StringReader":20,"./Uint8ArrayReader":21}],23:[function(t,e,r){"use strict";r.LOCAL_FILE_HEADER="PK",r.CENTRAL_FILE_HEADER="PK",r.CENTRAL_DIRECTORY_END="PK",r.ZIP64_CENTRAL_DIRECTORY_LOCATOR="PK",r.ZIP64_CENTRAL_DIRECTORY_END="PK",r.DATA_DESCRIPTOR="PK\b"},{}],24:[function(t,e,r){"use strict";var i=t("./GenericWorker"),n=t("../utils");function s(t){i.call(this,"ConvertWorker to "+t),this.destType=t}n.inherits(s,i),s.prototype.processChunk=function(t){this.push({data:n.transformTo(this.destType,t.data),meta:t.meta})},e.exports=s},{"../utils":32,"./GenericWorker":28}],25:[function(t,e,r){"use strict";var i=t("./GenericWorker"),n=t("../crc32");function s(){i.call(this,"Crc32Probe"),this.withStreamInfo("crc32",0)}t("../utils").inherits(s,i),s.prototype.processChunk=function(t){this.streamInfo.crc32=n(t.data,this.streamInfo.crc32||0),this.push(t)},e.exports=s},{"../crc32":4,"../utils":32,"./GenericWorker":28}],26:[function(t,e,r){"use strict";var i=t("../utils"),n=t("./GenericWorker");function s(t){n.call(this,"DataLengthProbe for "+t),this.propName=t,this.withStreamInfo(t,0)}i.inherits(s,n),s.prototype.processChunk=function(t){if(t){var e=this.streamInfo[this.propName]||0;this.streamInfo[this.propName]=e+t.data.length}n.prototype.processChunk.call(this,t)},e.exports=s},{"../utils":32,"./GenericWorker":28}],27:[function(t,e,r){"use strict";var i=t("../utils"),n=t("./GenericWorker");function s(t){n.call(this,"DataWorker");var e=this;this.dataIsReady=!1,this.index=0,this.max=0,this.data=null,this.type="",this._tickScheduled=!1,t.then(function(t){e.dataIsReady=!0,e.data=t,e.max=t&&t.length||0,e.type=i.getTypeOf(t),e.isPaused||e._tickAndRepeat()},function(t){e.error(t)})}i.inherits(s,n),s.prototype.cleanUp=function(){n.prototype.cleanUp.call(this),this.data=null},s.prototype.resume=function(){return!!n.prototype.resume.call(this)&&(!this._tickScheduled&&this.dataIsReady&&(this._tickScheduled=!0,i.delay(this._tickAndRepeat,[],this)),!0)},s.prototype._tickAndRepeat=function(){this._tickScheduled=!1,this.isPaused||this.isFinished||(this._tick(),this.isFinished||(i.delay(this._tickAndRepeat,[],this),this._tickScheduled=!0))},s.prototype._tick=function(){if(this.isPaused||this.isFinished)return!1;var t=null,e=Math.min(this.max,this.index+16384);if(this.index>=this.max)return this.end();switch(this.type){case"string":t=this.data.substring(this.index,e);break;case"uint8array":t=this.data.subarray(this.index,e);break;case"array":case"nodebuffer":t=this.data.slice(this.index,e)}return this.index=e,this.push({data:t,meta:{percent:this.max?this.index/this.max*100:0}})},e.exports=s},{"../utils":32,"./GenericWorker":28}],28:[function(t,e,r){"use strict";function i(t){this.name=t||"default",this.streamInfo={},this.generatedError=null,this.extraStreamInfo={},this.isPaused=!0,this.isFinished=!1,this.isLocked=!1,this._listeners={data:[],end:[],error:[]},this.previous=null}i.prototype={push:function(t){this.emit("data",t)},end:function(){if(this.isFinished)return!1;this.flush();try{this.emit("end"),this.cleanUp(),this.isFinished=!0}catch(t){this.emit("error",t)}return!0},error:function(t){return!this.isFinished&&(this.isPaused?this.generatedError=t:(this.isFinished=!0,this.emit("error",t),this.previous&&this.previous.error(t),this.cleanUp()),!0)},on:function(t,e){return this._listeners[t].push(e),this},cleanUp:function(){this.streamInfo=this.generatedError=this.extraStreamInfo=null,this._listeners=[]},emit:function(t,e){if(this._listeners[t])for(var r=0;r<this._listeners[t].length;r++)this._listeners[t][r].call(this,e)},pipe:function(t){return t.registerPrevious(this)},registerPrevious:function(t){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.streamInfo=t.streamInfo,this.mergeStreamInfo(),this.previous=t;var e=this;return t.on("data",function(t){e.processChunk(t)}),t.on("end",function(){e.end()}),t.on("error",function(t){e.error(t)}),this},pause:function(){return!this.isPaused&&!this.isFinished&&(this.isPaused=!0,this.previous&&this.previous.pause(),!0)},resume:function(){if(!this.isPaused||this.isFinished)return!1;var t=this.isPaused=!1;return this.generatedError&&(this.error(this.generatedError),t=!0),this.previous&&this.previous.resume(),!t},flush:function(){},processChunk:function(t){this.push(t)},withStreamInfo:function(t,e){return this.extraStreamInfo[t]=e,this.mergeStreamInfo(),this},mergeStreamInfo:function(){for(var t in this.extraStreamInfo)this.extraStreamInfo.hasOwnProperty(t)&&(this.streamInfo[t]=this.extraStreamInfo[t])},lock:function(){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.isLocked=!0,this.previous&&this.previous.lock()},toString:function(){var t="Worker "+this.name;return this.previous?this.previous+" -> "+t:t}},e.exports=i},{}],29:[function(t,e,r){"use strict";var h=t("../utils"),n=t("./ConvertWorker"),s=t("./GenericWorker"),u=t("../base64"),i=t("../support"),a=t("../external"),o=null;if(i.nodestream)try{o=t("../nodejs/NodejsStreamOutputAdapter")}catch(t){}function l(t,o){return new a.Promise(function(e,r){var i=[],n=t._internalType,s=t._outputType,a=t._mimeType;t.on("data",function(t,e){i.push(t),o&&o(e)}).on("error",function(t){i=[],r(t)}).on("end",function(){try{var t=function(t,e,r){switch(t){case"blob":return h.newBlob(h.transformTo("arraybuffer",e),r);case"base64":return u.encode(e);default:return h.transformTo(t,e)}}(s,function(t,e){var r,i=0,n=null,s=0;for(r=0;r<e.length;r++)s+=e[r].length;switch(t){case"string":return e.join("");case"array":return Array.prototype.concat.apply([],e);case"uint8array":for(n=new Uint8Array(s),r=0;r<e.length;r++)n.set(e[r],i),i+=e[r].length;return n;case"nodebuffer":return Buffer.concat(e);default:throw new Error("concat : unsupported type '"+t+"'")}}(n,i),a);e(t)}catch(t){r(t)}i=[]}).resume()})}function f(t,e,r){var i=e;switch(e){case"blob":case"arraybuffer":i="uint8array";break;case"base64":i="string"}try{this._internalType=i,this._outputType=e,this._mimeType=r,h.checkSupport(i),this._worker=t.pipe(new n(i)),t.lock()}catch(t){this._worker=new s("error"),this._worker.error(t)}}f.prototype={accumulate:function(t){return l(this,t)},on:function(t,e){var r=this;return"data"===t?this._worker.on(t,function(t){e.call(r,t.data,t.meta)}):this._worker.on(t,function(){h.delay(e,arguments,r)}),this},resume:function(){return h.delay(this._worker.resume,[],this._worker),this},pause:function(){return this._worker.pause(),this},toNodejsStream:function(t){if(h.checkSupport("nodestream"),"nodebuffer"!==this._outputType)throw new Error(this._outputType+" is not supported by this method");return new o(this,{objectMode:"nodebuffer"!==this._outputType},t)}},e.exports=f},{"../base64":1,"../external":6,"../nodejs/NodejsStreamOutputAdapter":13,"../support":30,"../utils":32,"./ConvertWorker":24,"./GenericWorker":28}],30:[function(t,e,r){"use strict";if(r.base64=!0,r.array=!0,r.string=!0,r.arraybuffer="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof Uint8Array,r.nodebuffer="undefined"!=typeof Buffer,r.uint8array="undefined"!=typeof Uint8Array,"undefined"==typeof ArrayBuffer)r.blob=!1;else{var i=new ArrayBuffer(0);try{r.blob=0===new Blob([i],{type:"application/zip"}).size}catch(t){try{var n=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);n.append(i),r.blob=0===n.getBlob("application/zip").size}catch(t){r.blob=!1}}}try{r.nodestream=!!t("readable-stream").Readable}catch(t){r.nodestream=!1}},{"readable-stream":16}],31:[function(t,e,s){"use strict";for(var o=t("./utils"),h=t("./support"),r=t("./nodejsUtils"),i=t("./stream/GenericWorker"),u=new Array(256),n=0;n<256;n++)u[n]=252<=n?6:248<=n?5:240<=n?4:224<=n?3:192<=n?2:1;u[254]=u[254]=1;function a(){i.call(this,"utf-8 decode"),this.leftOver=null}function l(){i.call(this,"utf-8 encode")}s.utf8encode=function(t){return h.nodebuffer?r.newBufferFrom(t,"utf-8"):function(t){var e,r,i,n,s,a=t.length,o=0;for(n=0;n<a;n++)55296==(64512&(r=t.charCodeAt(n)))&&n+1<a&&56320==(64512&(i=t.charCodeAt(n+1)))&&(r=65536+(r-55296<<10)+(i-56320),n++),o+=r<128?1:r<2048?2:r<65536?3:4;for(e=h.uint8array?new Uint8Array(o):new Array(o),n=s=0;s<o;n++)55296==(64512&(r=t.charCodeAt(n)))&&n+1<a&&56320==(64512&(i=t.charCodeAt(n+1)))&&(r=65536+(r-55296<<10)+(i-56320),n++),r<128?e[s++]=r:(r<2048?e[s++]=192|r>>>6:(r<65536?e[s++]=224|r>>>12:(e[s++]=240|r>>>18,e[s++]=128|r>>>12&63),e[s++]=128|r>>>6&63),e[s++]=128|63&r);return e}(t)},s.utf8decode=function(t){return h.nodebuffer?o.transformTo("nodebuffer",t).toString("utf-8"):function(t){var e,r,i,n,s=t.length,a=new Array(2*s);for(e=r=0;e<s;)if((i=t[e++])<128)a[r++]=i;else if(4<(n=u[i]))a[r++]=65533,e+=n-1;else{for(i&=2===n?31:3===n?15:7;1<n&&e<s;)i=i<<6|63&t[e++],n--;1<n?a[r++]=65533:i<65536?a[r++]=i:(i-=65536,a[r++]=55296|i>>10&1023,a[r++]=56320|1023&i)}return a.length!==r&&(a.subarray?a=a.subarray(0,r):a.length=r),o.applyFromCharCode(a)}(t=o.transformTo(h.uint8array?"uint8array":"array",t))},o.inherits(a,i),a.prototype.processChunk=function(t){var e=o.transformTo(h.uint8array?"uint8array":"array",t.data);if(this.leftOver&&this.leftOver.length){if(h.uint8array){var r=e;(e=new Uint8Array(r.length+this.leftOver.length)).set(this.leftOver,0),e.set(r,this.leftOver.length)}else e=this.leftOver.concat(e);this.leftOver=null}var i=function(t,e){var r;for((e=e||t.length)>t.length&&(e=t.length),r=e-1;0<=r&&128==(192&t[r]);)r--;return r<0?e:0===r?e:r+u[t[r]]>e?r:e}(e),n=e;i!==e.length&&(h.uint8array?(n=e.subarray(0,i),this.leftOver=e.subarray(i,e.length)):(n=e.slice(0,i),this.leftOver=e.slice(i,e.length))),this.push({data:s.utf8decode(n),meta:t.meta})},a.prototype.flush=function(){this.leftOver&&this.leftOver.length&&(this.push({data:s.utf8decode(this.leftOver),meta:{}}),this.leftOver=null)},s.Utf8DecodeWorker=a,o.inherits(l,i),l.prototype.processChunk=function(t){this.push({data:s.utf8encode(t.data),meta:t.meta})},s.Utf8EncodeWorker=l},{"./nodejsUtils":14,"./stream/GenericWorker":28,"./support":30,"./utils":32}],32:[function(t,e,a){"use strict";var o=t("./support"),h=t("./base64"),r=t("./nodejsUtils"),i=t("set-immediate-shim"),u=t("./external");function n(t){return t}function l(t,e){for(var r=0;r<t.length;++r)e[r]=255&t.charCodeAt(r);return e}a.newBlob=function(e,r){a.checkSupport("blob");try{return new Blob([e],{type:r})}catch(t){try{var i=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);return i.append(e),i.getBlob(r)}catch(t){throw new Error("Bug : can't construct the Blob.")}}};var s={stringifyByChunk:function(t,e,r){var i=[],n=0,s=t.length;if(s<=r)return String.fromCharCode.apply(null,t);for(;n<s;)"array"===e||"nodebuffer"===e?i.push(String.fromCharCode.apply(null,t.slice(n,Math.min(n+r,s)))):i.push(String.fromCharCode.apply(null,t.subarray(n,Math.min(n+r,s)))),n+=r;return i.join("")},stringifyByChar:function(t){for(var e="",r=0;r<t.length;r++)e+=String.fromCharCode(t[r]);return e},applyCanBeUsed:{uint8array:function(){try{return o.uint8array&&1===String.fromCharCode.apply(null,new Uint8Array(1)).length}catch(t){return!1}}(),nodebuffer:function(){try{return o.nodebuffer&&1===String.fromCharCode.apply(null,r.allocBuffer(1)).length}catch(t){return!1}}()}};function f(t){var e=65536,r=a.getTypeOf(t),i=!0;if("uint8array"===r?i=s.applyCanBeUsed.uint8array:"nodebuffer"===r&&(i=s.applyCanBeUsed.nodebuffer),i)for(;1<e;)try{return s.stringifyByChunk(t,r,e)}catch(t){e=Math.floor(e/2)}return s.stringifyByChar(t)}function d(t,e){for(var r=0;r<t.length;r++)e[r]=t[r];return e}a.applyFromCharCode=f;var c={};c.string={string:n,array:function(t){return l(t,new Array(t.length))},arraybuffer:function(t){return c.string.uint8array(t).buffer},uint8array:function(t){return l(t,new Uint8Array(t.length))},nodebuffer:function(t){return l(t,r.allocBuffer(t.length))}},c.array={string:f,array:n,arraybuffer:function(t){return new Uint8Array(t).buffer},uint8array:function(t){return new Uint8Array(t)},nodebuffer:function(t){return r.newBufferFrom(t)}},c.arraybuffer={string:function(t){return f(new Uint8Array(t))},array:function(t){return d(new Uint8Array(t),new Array(t.byteLength))},arraybuffer:n,uint8array:function(t){return new Uint8Array(t)},nodebuffer:function(t){return r.newBufferFrom(new Uint8Array(t))}},c.uint8array={string:f,array:function(t){return d(t,new Array(t.length))},arraybuffer:function(t){return t.buffer},uint8array:n,nodebuffer:function(t){return r.newBufferFrom(t)}},c.nodebuffer={string:f,array:function(t){return d(t,new Array(t.length))},arraybuffer:function(t){return c.nodebuffer.uint8array(t).buffer},uint8array:function(t){return d(t,new Uint8Array(t.length))},nodebuffer:n},a.transformTo=function(t,e){if(e=e||"",!t)return e;a.checkSupport(t);var r=a.getTypeOf(e);return c[r][t](e)},a.getTypeOf=function(t){return"string"==typeof t?"string":"[object Array]"===Object.prototype.toString.call(t)?"array":o.nodebuffer&&r.isBuffer(t)?"nodebuffer":o.uint8array&&t instanceof Uint8Array?"uint8array":o.arraybuffer&&t instanceof ArrayBuffer?"arraybuffer":void 0},a.checkSupport=function(t){if(!o[t.toLowerCase()])throw new Error(t+" is not supported by this platform")},a.MAX_VALUE_16BITS=65535,a.MAX_VALUE_32BITS=-1,a.pretty=function(t){var e,r,i="";for(r=0;r<(t||"").length;r++)i+="\\x"+((e=t.charCodeAt(r))<16?"0":"")+e.toString(16).toUpperCase();return i},a.delay=function(t,e,r){i(function(){t.apply(r||null,e||[])})},a.inherits=function(t,e){function r(){}r.prototype=e.prototype,t.prototype=new r},a.extend=function(){var t,e,r={};for(t=0;t<arguments.length;t++)for(e in arguments[t])arguments[t].hasOwnProperty(e)&&void 0===r[e]&&(r[e]=arguments[t][e]);return r},a.prepareContent=function(r,t,i,n,s){return u.Promise.resolve(t).then(function(i){return o.blob&&(i instanceof Blob||-1!==["[object File]","[object Blob]"].indexOf(Object.prototype.toString.call(i)))&&"undefined"!=typeof FileReader?new u.Promise(function(e,r){var t=new FileReader;t.onload=function(t){e(t.target.result)},t.onerror=function(t){r(t.target.error)},t.readAsArrayBuffer(i)}):i}).then(function(t){var e=a.getTypeOf(t);return e?("arraybuffer"===e?t=a.transformTo("uint8array",t):"string"===e&&(s?t=h.decode(t):i&&!0!==n&&(t=function(t){return l(t,o.uint8array?new Uint8Array(t.length):new Array(t.length))}(t))),t):u.Promise.reject(new Error("Can't read the data of '"+r+"'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"))})}},{"./base64":1,"./external":6,"./nodejsUtils":14,"./support":30,"set-immediate-shim":54}],33:[function(t,e,r){"use strict";var i=t("./reader/readerFor"),n=t("./utils"),s=t("./signature"),a=t("./zipEntry"),o=(t("./utf8"),t("./support"));function h(t){this.files=[],this.loadOptions=t}h.prototype={checkSignature:function(t){if(!this.reader.readAndCheckSignature(t)){this.reader.index-=4;var e=this.reader.readString(4);throw new Error("Corrupted zip or bug: unexpected signature ("+n.pretty(e)+", expected "+n.pretty(t)+")")}},isSignature:function(t,e){var r=this.reader.index;this.reader.setIndex(t);var i=this.reader.readString(4)===e;return this.reader.setIndex(r),i},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2);var t=this.reader.readData(this.zipCommentLength),e=o.uint8array?"uint8array":"array",r=n.transformTo(e,t);this.zipComment=this.loadOptions.decodeFileName(r)},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.reader.skip(4),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var t,e,r,i=this.zip64EndOfCentralSize-44;0<i;)t=this.reader.readInt(2),e=this.reader.readInt(4),r=this.reader.readData(e),this.zip64ExtensibleData[t]={id:t,length:e,value:r}},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),1<this.disksCount)throw new Error("Multi-volumes zip are not supported")},readLocalFiles:function(){var t,e;for(t=0;t<this.files.length;t++)e=this.files[t],this.reader.setIndex(e.localHeaderOffset),this.checkSignature(s.LOCAL_FILE_HEADER),e.readLocalPart(this.reader),e.handleUTF8(),e.processAttributes()},readCentralDir:function(){var t;for(this.reader.setIndex(this.centralDirOffset);this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER);)(t=new a({zip64:this.zip64},this.loadOptions)).readCentralPart(this.reader),this.files.push(t);if(this.centralDirRecords!==this.files.length&&0!==this.centralDirRecords&&0===this.files.length)throw new Error("Corrupted zip or bug: expected "+this.centralDirRecords+" records in central dir, got "+this.files.length)},readEndOfCentral:function(){var t=this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);if(t<0)throw!this.isSignature(0,s.LOCAL_FILE_HEADER)?new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html"):new Error("Corrupted zip: can't find end of central directory");this.reader.setIndex(t);var e=t;if(this.checkSignature(s.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===n.MAX_VALUE_16BITS||this.diskWithCentralDirStart===n.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===n.MAX_VALUE_16BITS||this.centralDirRecords===n.MAX_VALUE_16BITS||this.centralDirSize===n.MAX_VALUE_32BITS||this.centralDirOffset===n.MAX_VALUE_32BITS){if(this.zip64=!0,(t=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR))<0)throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");if(this.reader.setIndex(t),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),!this.isSignature(this.relativeOffsetEndOfZip64CentralDir,s.ZIP64_CENTRAL_DIRECTORY_END)&&(this.relativeOffsetEndOfZip64CentralDir=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.relativeOffsetEndOfZip64CentralDir<0))throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral()}var r=this.centralDirOffset+this.centralDirSize;this.zip64&&(r+=20,r+=12+this.zip64EndOfCentralSize);var i=e-r;if(0<i)this.isSignature(e,s.CENTRAL_FILE_HEADER)||(this.reader.zero=i);else if(i<0)throw new Error("Corrupted zip: missing "+Math.abs(i)+" bytes.")},prepareReader:function(t){this.reader=i(t)},load:function(t){this.prepareReader(t),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles()}},e.exports=h},{"./reader/readerFor":22,"./signature":23,"./support":30,"./utf8":31,"./utils":32,"./zipEntry":34}],34:[function(t,e,r){"use strict";var i=t("./reader/readerFor"),s=t("./utils"),n=t("./compressedObject"),a=t("./crc32"),o=t("./utf8"),h=t("./compressions"),u=t("./support");function l(t,e){this.options=t,this.loadOptions=e}l.prototype={isEncrypted:function(){return 1==(1&this.bitFlag)},useUTF8:function(){return 2048==(2048&this.bitFlag)},readLocalPart:function(t){var e,r;if(t.skip(22),this.fileNameLength=t.readInt(2),r=t.readInt(2),this.fileName=t.readData(this.fileNameLength),t.skip(r),-1===this.compressedSize||-1===this.uncompressedSize)throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");if(null===(e=function(t){for(var e in h)if(h.hasOwnProperty(e)&&h[e].magic===t)return h[e];return null}(this.compressionMethod)))throw new Error("Corrupted zip : compression "+s.pretty(this.compressionMethod)+" unknown (inner file : "+s.transformTo("string",this.fileName)+")");this.decompressed=new n(this.compressedSize,this.uncompressedSize,this.crc32,e,t.readData(this.compressedSize))},readCentralPart:function(t){this.versionMadeBy=t.readInt(2),t.skip(2),this.bitFlag=t.readInt(2),this.compressionMethod=t.readString(2),this.date=t.readDate(),this.crc32=t.readInt(4),this.compressedSize=t.readInt(4),this.uncompressedSize=t.readInt(4);var e=t.readInt(2);if(this.extraFieldsLength=t.readInt(2),this.fileCommentLength=t.readInt(2),this.diskNumberStart=t.readInt(2),this.internalFileAttributes=t.readInt(2),this.externalFileAttributes=t.readInt(4),this.localHeaderOffset=t.readInt(4),this.isEncrypted())throw new Error("Encrypted zip are not supported");t.skip(e),this.readExtraFields(t),this.parseZIP64ExtraField(t),this.fileComment=t.readData(this.fileCommentLength)},processAttributes:function(){this.unixPermissions=null,this.dosPermissions=null;var t=this.versionMadeBy>>8;this.dir=!!(16&this.externalFileAttributes),0==t&&(this.dosPermissions=63&this.externalFileAttributes),3==t&&(this.unixPermissions=this.externalFileAttributes>>16&65535),this.dir||"/"!==this.fileNameStr.slice(-1)||(this.dir=!0)},parseZIP64ExtraField:function(t){if(this.extraFields[1]){var e=i(this.extraFields[1].value);this.uncompressedSize===s.MAX_VALUE_32BITS&&(this.uncompressedSize=e.readInt(8)),this.compressedSize===s.MAX_VALUE_32BITS&&(this.compressedSize=e.readInt(8)),this.localHeaderOffset===s.MAX_VALUE_32BITS&&(this.localHeaderOffset=e.readInt(8)),this.diskNumberStart===s.MAX_VALUE_32BITS&&(this.diskNumberStart=e.readInt(4))}},readExtraFields:function(t){var e,r,i,n=t.index+this.extraFieldsLength;for(this.extraFields||(this.extraFields={});t.index<n;)e=t.readInt(2),r=t.readInt(2),i=t.readData(r),this.extraFields[e]={id:e,length:r,value:i}},handleUTF8:function(){var t=u.uint8array?"uint8array":"array";if(this.useUTF8())this.fileNameStr=o.utf8decode(this.fileName),this.fileCommentStr=o.utf8decode(this.fileComment);else{var e=this.findExtraFieldUnicodePath();if(null!==e)this.fileNameStr=e;else{var r=s.transformTo(t,this.fileName);this.fileNameStr=this.loadOptions.decodeFileName(r)}var i=this.findExtraFieldUnicodeComment();if(null!==i)this.fileCommentStr=i;else{var n=s.transformTo(t,this.fileComment);this.fileCommentStr=this.loadOptions.decodeFileName(n)}}},findExtraFieldUnicodePath:function(){var t=this.extraFields[28789];if(t){var e=i(t.value);return 1!==e.readInt(1)?null:a(this.fileName)!==e.readInt(4)?null:o.utf8decode(e.readData(t.length-5))}return null},findExtraFieldUnicodeComment:function(){var t=this.extraFields[25461];if(t){var e=i(t.value);return 1!==e.readInt(1)?null:a(this.fileComment)!==e.readInt(4)?null:o.utf8decode(e.readData(t.length-5))}return null}},e.exports=l},{"./compressedObject":2,"./compressions":3,"./crc32":4,"./reader/readerFor":22,"./support":30,"./utf8":31,"./utils":32}],35:[function(t,e,r){"use strict";function i(t,e,r){this.name=t,this.dir=r.dir,this.date=r.date,this.comment=r.comment,this.unixPermissions=r.unixPermissions,this.dosPermissions=r.dosPermissions,this._data=e,this._dataBinary=r.binary,this.options={compression:r.compression,compressionOptions:r.compressionOptions}}var s=t("./stream/StreamHelper"),n=t("./stream/DataWorker"),a=t("./utf8"),o=t("./compressedObject"),h=t("./stream/GenericWorker");i.prototype={internalStream:function(t){var e=null,r="string";try{if(!t)throw new Error("No output type specified.");var i="string"===(r=t.toLowerCase())||"text"===r;"binarystring"!==r&&"text"!==r||(r="string"),e=this._decompressWorker();var n=!this._dataBinary;n&&!i&&(e=e.pipe(new a.Utf8EncodeWorker)),!n&&i&&(e=e.pipe(new a.Utf8DecodeWorker))}catch(t){(e=new h("error")).error(t)}return new s(e,r,"")},async:function(t,e){return this.internalStream(t).accumulate(e)},nodeStream:function(t,e){return this.internalStream(t||"nodebuffer").toNodejsStream(e)},_compressWorker:function(t,e){if(this._data instanceof o&&this._data.compression.magic===t.magic)return this._data.getCompressedWorker();var r=this._decompressWorker();return this._dataBinary||(r=r.pipe(new a.Utf8EncodeWorker)),o.createWorkerFrom(r,t,e)},_decompressWorker:function(){return this._data instanceof o?this._data.getContentWorker():this._data instanceof h?this._data:new n(this._data)}};for(var u=["asText","asBinary","asNodeBuffer","asUint8Array","asArrayBuffer"],l=function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},f=0;f<u.length;f++)i.prototype[u[f]]=l;e.exports=i},{"./compressedObject":2,"./stream/DataWorker":27,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31}],36:[function(t,l,e){(function(e){"use strict";var r,i,t=e.MutationObserver||e.WebKitMutationObserver;if(t){var n=0,s=new t(u),a=e.document.createTextNode("");s.observe(a,{characterData:!0}),r=function(){a.data=n=++n%2}}else if(e.setImmediate||void 0===e.MessageChannel)r="document"in e&&"onreadystatechange"in e.document.createElement("script")?function(){var t=e.document.createElement("script");t.onreadystatechange=function(){u(),t.onreadystatechange=null,t.parentNode.removeChild(t),t=null},e.document.documentElement.appendChild(t)}:function(){setTimeout(u,0)};else{var o=new e.MessageChannel;o.port1.onmessage=u,r=function(){o.port2.postMessage(0)}}var h=[];function u(){var t,e;i=!0;for(var r=h.length;r;){for(e=h,h=[],t=-1;++t<r;)e[t]();r=h.length}i=!1}l.exports=function(t){1!==h.push(t)||i||r()}}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],37:[function(t,e,r){"use strict";var n=t("immediate");function u(){}var l={},s=["REJECTED"],a=["FULFILLED"],i=["PENDING"];function o(t){if("function"!=typeof t)throw new TypeError("resolver must be a function");this.state=i,this.queue=[],this.outcome=void 0,t!==u&&c(this,t)}function h(t,e,r){this.promise=t,"function"==typeof e&&(this.onFulfilled=e,this.callFulfilled=this.otherCallFulfilled),"function"==typeof r&&(this.onRejected=r,this.callRejected=this.otherCallRejected)}function f(e,r,i){n(function(){var t;try{t=r(i)}catch(t){return l.reject(e,t)}t===e?l.reject(e,new TypeError("Cannot resolve promise with itself")):l.resolve(e,t)})}function d(t){var e=t&&t.then;if(t&&("object"==typeof t||"function"==typeof t)&&"function"==typeof e)return function(){e.apply(t,arguments)}}function c(e,t){var r=!1;function i(t){r||(r=!0,l.reject(e,t))}function n(t){r||(r=!0,l.resolve(e,t))}var s=p(function(){t(n,i)});"error"===s.status&&i(s.value)}function p(t,e){var r={};try{r.value=t(e),r.status="success"}catch(t){r.status="error",r.value=t}return r}(e.exports=o).prototype.finally=function(e){if("function"!=typeof e)return this;var r=this.constructor;return this.then(function(t){return r.resolve(e()).then(function(){return t})},function(t){return r.resolve(e()).then(function(){throw t})})},o.prototype.catch=function(t){return this.then(null,t)},o.prototype.then=function(t,e){if("function"!=typeof t&&this.state===a||"function"!=typeof e&&this.state===s)return this;var r=new this.constructor(u);this.state!==i?f(r,this.state===a?t:e,this.outcome):this.queue.push(new h(r,t,e));return r},h.prototype.callFulfilled=function(t){l.resolve(this.promise,t)},h.prototype.otherCallFulfilled=function(t){f(this.promise,this.onFulfilled,t)},h.prototype.callRejected=function(t){l.reject(this.promise,t)},h.prototype.otherCallRejected=function(t){f(this.promise,this.onRejected,t)},l.resolve=function(t,e){var r=p(d,e);if("error"===r.status)return l.reject(t,r.value);var i=r.value;if(i)c(t,i);else{t.state=a,t.outcome=e;for(var n=-1,s=t.queue.length;++n<s;)t.queue[n].callFulfilled(e)}return t},l.reject=function(t,e){t.state=s,t.outcome=e;for(var r=-1,i=t.queue.length;++r<i;)t.queue[r].callRejected(e);return t},o.resolve=function(t){if(t instanceof this)return t;return l.resolve(new this(u),t)},o.reject=function(t){var e=new this(u);return l.reject(e,t)},o.all=function(t){var r=this;if("[object Array]"!==Object.prototype.toString.call(t))return this.reject(new TypeError("must be an array"));var i=t.length,n=!1;if(!i)return this.resolve([]);var s=new Array(i),a=0,e=-1,o=new this(u);for(;++e<i;)h(t[e],e);return o;function h(t,e){r.resolve(t).then(function(t){s[e]=t,++a!==i||n||(n=!0,l.resolve(o,s))},function(t){n||(n=!0,l.reject(o,t))})}},o.race=function(t){var e=this;if("[object Array]"!==Object.prototype.toString.call(t))return this.reject(new TypeError("must be an array"));var r=t.length,i=!1;if(!r)return this.resolve([]);var n=-1,s=new this(u);for(;++n<r;)a=t[n],e.resolve(a).then(function(t){i||(i=!0,l.resolve(s,t))},function(t){i||(i=!0,l.reject(s,t))});var a;return s}},{immediate:36}],38:[function(t,e,r){"use strict";var i={};(0,t("./lib/utils/common").assign)(i,t("./lib/deflate"),t("./lib/inflate"),t("./lib/zlib/constants")),e.exports=i},{"./lib/deflate":39,"./lib/inflate":40,"./lib/utils/common":41,"./lib/zlib/constants":44}],39:[function(t,e,r){"use strict";var a=t("./zlib/deflate"),o=t("./utils/common"),h=t("./utils/strings"),n=t("./zlib/messages"),s=t("./zlib/zstream"),u=Object.prototype.toString,l=0,f=-1,d=0,c=8;function p(t){if(!(this instanceof p))return new p(t);this.options=o.assign({level:f,method:c,chunkSize:16384,windowBits:15,memLevel:8,strategy:d,to:""},t||{});var e=this.options;e.raw&&0<e.windowBits?e.windowBits=-e.windowBits:e.gzip&&0<e.windowBits&&e.windowBits<16&&(e.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new s,this.strm.avail_out=0;var r=a.deflateInit2(this.strm,e.level,e.method,e.windowBits,e.memLevel,e.strategy);if(r!==l)throw new Error(n[r]);if(e.header&&a.deflateSetHeader(this.strm,e.header),e.dictionary){var i;if(i="string"==typeof e.dictionary?h.string2buf(e.dictionary):"[object ArrayBuffer]"===u.call(e.dictionary)?new Uint8Array(e.dictionary):e.dictionary,(r=a.deflateSetDictionary(this.strm,i))!==l)throw new Error(n[r]);this._dict_set=!0}}function i(t,e){var r=new p(e);if(r.push(t,!0),r.err)throw r.msg||n[r.err];return r.result}p.prototype.push=function(t,e){var r,i,n=this.strm,s=this.options.chunkSize;if(this.ended)return!1;i=e===~~e?e:!0===e?4:0,"string"==typeof t?n.input=h.string2buf(t):"[object ArrayBuffer]"===u.call(t)?n.input=new Uint8Array(t):n.input=t,n.next_in=0,n.avail_in=n.input.length;do{if(0===n.avail_out&&(n.output=new o.Buf8(s),n.next_out=0,n.avail_out=s),1!==(r=a.deflate(n,i))&&r!==l)return this.onEnd(r),!(this.ended=!0);0!==n.avail_out&&(0!==n.avail_in||4!==i&&2!==i)||("string"===this.options.to?this.onData(h.buf2binstring(o.shrinkBuf(n.output,n.next_out))):this.onData(o.shrinkBuf(n.output,n.next_out)))}while((0<n.avail_in||0===n.avail_out)&&1!==r);return 4===i?(r=a.deflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===l):2!==i||(this.onEnd(l),!(n.avail_out=0))},p.prototype.onData=function(t){this.chunks.push(t)},p.prototype.onEnd=function(t){t===l&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=o.flattenChunks(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg},r.Deflate=p,r.deflate=i,r.deflateRaw=function(t,e){return(e=e||{}).raw=!0,i(t,e)},r.gzip=function(t,e){return(e=e||{}).gzip=!0,i(t,e)}},{"./utils/common":41,"./utils/strings":42,"./zlib/deflate":46,"./zlib/messages":51,"./zlib/zstream":53}],40:[function(t,e,r){"use strict";var d=t("./zlib/inflate"),c=t("./utils/common"),p=t("./utils/strings"),m=t("./zlib/constants"),i=t("./zlib/messages"),n=t("./zlib/zstream"),s=t("./zlib/gzheader"),_=Object.prototype.toString;function a(t){if(!(this instanceof a))return new a(t);this.options=c.assign({chunkSize:16384,windowBits:0,to:""},t||{});var e=this.options;e.raw&&0<=e.windowBits&&e.windowBits<16&&(e.windowBits=-e.windowBits,0===e.windowBits&&(e.windowBits=-15)),!(0<=e.windowBits&&e.windowBits<16)||t&&t.windowBits||(e.windowBits+=32),15<e.windowBits&&e.windowBits<48&&0==(15&e.windowBits)&&(e.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new n,this.strm.avail_out=0;var r=d.inflateInit2(this.strm,e.windowBits);if(r!==m.Z_OK)throw new Error(i[r]);this.header=new s,d.inflateGetHeader(this.strm,this.header)}function o(t,e){var r=new a(e);if(r.push(t,!0),r.err)throw r.msg||i[r.err];return r.result}a.prototype.push=function(t,e){var r,i,n,s,a,o,h=this.strm,u=this.options.chunkSize,l=this.options.dictionary,f=!1;if(this.ended)return!1;i=e===~~e?e:!0===e?m.Z_FINISH:m.Z_NO_FLUSH,"string"==typeof t?h.input=p.binstring2buf(t):"[object ArrayBuffer]"===_.call(t)?h.input=new Uint8Array(t):h.input=t,h.next_in=0,h.avail_in=h.input.length;do{if(0===h.avail_out&&(h.output=new c.Buf8(u),h.next_out=0,h.avail_out=u),(r=d.inflate(h,m.Z_NO_FLUSH))===m.Z_NEED_DICT&&l&&(o="string"==typeof l?p.string2buf(l):"[object ArrayBuffer]"===_.call(l)?new Uint8Array(l):l,r=d.inflateSetDictionary(this.strm,o)),r===m.Z_BUF_ERROR&&!0===f&&(r=m.Z_OK,f=!1),r!==m.Z_STREAM_END&&r!==m.Z_OK)return this.onEnd(r),!(this.ended=!0);h.next_out&&(0!==h.avail_out&&r!==m.Z_STREAM_END&&(0!==h.avail_in||i!==m.Z_FINISH&&i!==m.Z_SYNC_FLUSH)||("string"===this.options.to?(n=p.utf8border(h.output,h.next_out),s=h.next_out-n,a=p.buf2string(h.output,n),h.next_out=s,h.avail_out=u-s,s&&c.arraySet(h.output,h.output,n,s,0),this.onData(a)):this.onData(c.shrinkBuf(h.output,h.next_out)))),0===h.avail_in&&0===h.avail_out&&(f=!0)}while((0<h.avail_in||0===h.avail_out)&&r!==m.Z_STREAM_END);return r===m.Z_STREAM_END&&(i=m.Z_FINISH),i===m.Z_FINISH?(r=d.inflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===m.Z_OK):i!==m.Z_SYNC_FLUSH||(this.onEnd(m.Z_OK),!(h.avail_out=0))},a.prototype.onData=function(t){this.chunks.push(t)},a.prototype.onEnd=function(t){t===m.Z_OK&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=c.flattenChunks(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg},r.Inflate=a,r.inflate=o,r.inflateRaw=function(t,e){return(e=e||{}).raw=!0,o(t,e)},r.ungzip=o},{"./utils/common":41,"./utils/strings":42,"./zlib/constants":44,"./zlib/gzheader":47,"./zlib/inflate":49,"./zlib/messages":51,"./zlib/zstream":53}],41:[function(t,e,r){"use strict";var i="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Int32Array;r.assign=function(t){for(var e=Array.prototype.slice.call(arguments,1);e.length;){var r=e.shift();if(r){if("object"!=typeof r)throw new TypeError(r+"must be non-object");for(var i in r)r.hasOwnProperty(i)&&(t[i]=r[i])}}return t},r.shrinkBuf=function(t,e){return t.length===e?t:t.subarray?t.subarray(0,e):(t.length=e,t)};var n={arraySet:function(t,e,r,i,n){if(e.subarray&&t.subarray)t.set(e.subarray(r,r+i),n);else for(var s=0;s<i;s++)t[n+s]=e[r+s]},flattenChunks:function(t){var e,r,i,n,s,a;for(e=i=0,r=t.length;e<r;e++)i+=t[e].length;for(a=new Uint8Array(i),e=n=0,r=t.length;e<r;e++)s=t[e],a.set(s,n),n+=s.length;return a}},s={arraySet:function(t,e,r,i,n){for(var s=0;s<i;s++)t[n+s]=e[r+s]},flattenChunks:function(t){return[].concat.apply([],t)}};r.setTyped=function(t){t?(r.Buf8=Uint8Array,r.Buf16=Uint16Array,r.Buf32=Int32Array,r.assign(r,n)):(r.Buf8=Array,r.Buf16=Array,r.Buf32=Array,r.assign(r,s))},r.setTyped(i)},{}],42:[function(t,e,r){"use strict";var h=t("./common"),n=!0,s=!0;try{String.fromCharCode.apply(null,[0])}catch(t){n=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(t){s=!1}for(var u=new h.Buf8(256),i=0;i<256;i++)u[i]=252<=i?6:248<=i?5:240<=i?4:224<=i?3:192<=i?2:1;function l(t,e){if(e<65537&&(t.subarray&&s||!t.subarray&&n))return String.fromCharCode.apply(null,h.shrinkBuf(t,e));for(var r="",i=0;i<e;i++)r+=String.fromCharCode(t[i]);return r}u[254]=u[254]=1,r.string2buf=function(t){var e,r,i,n,s,a=t.length,o=0;for(n=0;n<a;n++)55296==(64512&(r=t.charCodeAt(n)))&&n+1<a&&56320==(64512&(i=t.charCodeAt(n+1)))&&(r=65536+(r-55296<<10)+(i-56320),n++),o+=r<128?1:r<2048?2:r<65536?3:4;for(e=new h.Buf8(o),n=s=0;s<o;n++)55296==(64512&(r=t.charCodeAt(n)))&&n+1<a&&56320==(64512&(i=t.charCodeAt(n+1)))&&(r=65536+(r-55296<<10)+(i-56320),n++),r<128?e[s++]=r:(r<2048?e[s++]=192|r>>>6:(r<65536?e[s++]=224|r>>>12:(e[s++]=240|r>>>18,e[s++]=128|r>>>12&63),e[s++]=128|r>>>6&63),e[s++]=128|63&r);return e},r.buf2binstring=function(t){return l(t,t.length)},r.binstring2buf=function(t){for(var e=new h.Buf8(t.length),r=0,i=e.length;r<i;r++)e[r]=t.charCodeAt(r);return e},r.buf2string=function(t,e){var r,i,n,s,a=e||t.length,o=new Array(2*a);for(r=i=0;r<a;)if((n=t[r++])<128)o[i++]=n;else if(4<(s=u[n]))o[i++]=65533,r+=s-1;else{for(n&=2===s?31:3===s?15:7;1<s&&r<a;)n=n<<6|63&t[r++],s--;1<s?o[i++]=65533:n<65536?o[i++]=n:(n-=65536,o[i++]=55296|n>>10&1023,o[i++]=56320|1023&n)}return l(o,i)},r.utf8border=function(t,e){var r;for((e=e||t.length)>t.length&&(e=t.length),r=e-1;0<=r&&128==(192&t[r]);)r--;return r<0?e:0===r?e:r+u[t[r]]>e?r:e}},{"./common":41}],43:[function(t,e,r){"use strict";e.exports=function(t,e,r,i){for(var n=65535&t|0,s=t>>>16&65535|0,a=0;0!==r;){for(r-=a=2e3<r?2e3:r;s=s+(n=n+e[i++]|0)|0,--a;);n%=65521,s%=65521}return n|s<<16|0}},{}],44:[function(t,e,r){"use strict";e.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],45:[function(t,e,r){"use strict";var o=function(){for(var t,e=[],r=0;r<256;r++){t=r;for(var i=0;i<8;i++)t=1&t?3988292384^t>>>1:t>>>1;e[r]=t}return e}();e.exports=function(t,e,r,i){var n=o,s=i+r;t^=-1;for(var a=i;a<s;a++)t=t>>>8^n[255&(t^e[a])];return-1^t}},{}],46:[function(t,e,r){"use strict";var h,d=t("../utils/common"),u=t("./trees"),c=t("./adler32"),p=t("./crc32"),i=t("./messages"),l=0,f=4,m=0,_=-2,g=-1,b=4,n=2,v=8,y=9,s=286,a=30,o=19,w=2*s+1,k=15,x=3,S=258,z=S+x+1,C=42,E=113,A=1,I=2,O=3,B=4;function R(t,e){return t.msg=i[e],e}function T(t){return(t<<1)-(4<t?9:0)}function D(t){for(var e=t.length;0<=--e;)t[e]=0}function F(t){var e=t.state,r=e.pending;r>t.avail_out&&(r=t.avail_out),0!==r&&(d.arraySet(t.output,e.pending_buf,e.pending_out,r,t.next_out),t.next_out+=r,e.pending_out+=r,t.total_out+=r,t.avail_out-=r,e.pending-=r,0===e.pending&&(e.pending_out=0))}function N(t,e){u._tr_flush_block(t,0<=t.block_start?t.block_start:-1,t.strstart-t.block_start,e),t.block_start=t.strstart,F(t.strm)}function U(t,e){t.pending_buf[t.pending++]=e}function P(t,e){t.pending_buf[t.pending++]=e>>>8&255,t.pending_buf[t.pending++]=255&e}function L(t,e){var r,i,n=t.max_chain_length,s=t.strstart,a=t.prev_length,o=t.nice_match,h=t.strstart>t.w_size-z?t.strstart-(t.w_size-z):0,u=t.window,l=t.w_mask,f=t.prev,d=t.strstart+S,c=u[s+a-1],p=u[s+a];t.prev_length>=t.good_match&&(n>>=2),o>t.lookahead&&(o=t.lookahead);do{if(u[(r=e)+a]===p&&u[r+a-1]===c&&u[r]===u[s]&&u[++r]===u[s+1]){s+=2,r++;do{}while(u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&s<d);if(i=S-(d-s),s=d-S,a<i){if(t.match_start=e,o<=(a=i))break;c=u[s+a-1],p=u[s+a]}}}while((e=f[e&l])>h&&0!=--n);return a<=t.lookahead?a:t.lookahead}function j(t){var e,r,i,n,s,a,o,h,u,l,f=t.w_size;do{if(n=t.window_size-t.lookahead-t.strstart,t.strstart>=f+(f-z)){for(d.arraySet(t.window,t.window,f,f,0),t.match_start-=f,t.strstart-=f,t.block_start-=f,e=r=t.hash_size;i=t.head[--e],t.head[e]=f<=i?i-f:0,--r;);for(e=r=f;i=t.prev[--e],t.prev[e]=f<=i?i-f:0,--r;);n+=f}if(0===t.strm.avail_in)break;if(a=t.strm,o=t.window,h=t.strstart+t.lookahead,u=n,l=void 0,l=a.avail_in,u<l&&(l=u),r=0===l?0:(a.avail_in-=l,d.arraySet(o,a.input,a.next_in,l,h),1===a.state.wrap?a.adler=c(a.adler,o,l,h):2===a.state.wrap&&(a.adler=p(a.adler,o,l,h)),a.next_in+=l,a.total_in+=l,l),t.lookahead+=r,t.lookahead+t.insert>=x)for(s=t.strstart-t.insert,t.ins_h=t.window[s],t.ins_h=(t.ins_h<<t.hash_shift^t.window[s+1])&t.hash_mask;t.insert&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[s+x-1])&t.hash_mask,t.prev[s&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=s,s++,t.insert--,!(t.lookahead+t.insert<x)););}while(t.lookahead<z&&0!==t.strm.avail_in)}function Z(t,e){for(var r,i;;){if(t.lookahead<z){if(j(t),t.lookahead<z&&e===l)return A;if(0===t.lookahead)break}if(r=0,t.lookahead>=x&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+x-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),0!==r&&t.strstart-r<=t.w_size-z&&(t.match_length=L(t,r)),t.match_length>=x)if(i=u._tr_tally(t,t.strstart-t.match_start,t.match_length-x),t.lookahead-=t.match_length,t.match_length<=t.max_lazy_match&&t.lookahead>=x){for(t.match_length--;t.strstart++,t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+x-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart,0!=--t.match_length;);t.strstart++}else t.strstart+=t.match_length,t.match_length=0,t.ins_h=t.window[t.strstart],t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+1])&t.hash_mask;else i=u._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++;if(i&&(N(t,!1),0===t.strm.avail_out))return A}return t.insert=t.strstart<x-1?t.strstart:x-1,e===f?(N(t,!0),0===t.strm.avail_out?O:B):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?A:I}function W(t,e){for(var r,i,n;;){if(t.lookahead<z){if(j(t),t.lookahead<z&&e===l)return A;if(0===t.lookahead)break}if(r=0,t.lookahead>=x&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+x-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),t.prev_length=t.match_length,t.prev_match=t.match_start,t.match_length=x-1,0!==r&&t.prev_length<t.max_lazy_match&&t.strstart-r<=t.w_size-z&&(t.match_length=L(t,r),t.match_length<=5&&(1===t.strategy||t.match_length===x&&4096<t.strstart-t.match_start)&&(t.match_length=x-1)),t.prev_length>=x&&t.match_length<=t.prev_length){for(n=t.strstart+t.lookahead-x,i=u._tr_tally(t,t.strstart-1-t.prev_match,t.prev_length-x),t.lookahead-=t.prev_length-1,t.prev_length-=2;++t.strstart<=n&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+x-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),0!=--t.prev_length;);if(t.match_available=0,t.match_length=x-1,t.strstart++,i&&(N(t,!1),0===t.strm.avail_out))return A}else if(t.match_available){if((i=u._tr_tally(t,0,t.window[t.strstart-1]))&&N(t,!1),t.strstart++,t.lookahead--,0===t.strm.avail_out)return A}else t.match_available=1,t.strstart++,t.lookahead--}return t.match_available&&(i=u._tr_tally(t,0,t.window[t.strstart-1]),t.match_available=0),t.insert=t.strstart<x-1?t.strstart:x-1,e===f?(N(t,!0),0===t.strm.avail_out?O:B):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?A:I}function M(t,e,r,i,n){this.good_length=t,this.max_lazy=e,this.nice_length=r,this.max_chain=i,this.func=n}function H(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=v,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new d.Buf16(2*w),this.dyn_dtree=new d.Buf16(2*(2*a+1)),this.bl_tree=new d.Buf16(2*(2*o+1)),D(this.dyn_ltree),D(this.dyn_dtree),D(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new d.Buf16(k+1),this.heap=new d.Buf16(2*s+1),D(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new d.Buf16(2*s+1),D(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function G(t){var e;return t&&t.state?(t.total_in=t.total_out=0,t.data_type=n,(e=t.state).pending=0,e.pending_out=0,e.wrap<0&&(e.wrap=-e.wrap),e.status=e.wrap?C:E,t.adler=2===e.wrap?0:1,e.last_flush=l,u._tr_init(e),m):R(t,_)}function K(t){var e=G(t);return e===m&&function(t){t.window_size=2*t.w_size,D(t.head),t.max_lazy_match=h[t.level].max_lazy,t.good_match=h[t.level].good_length,t.nice_match=h[t.level].nice_length,t.max_chain_length=h[t.level].max_chain,t.strstart=0,t.block_start=0,t.lookahead=0,t.insert=0,t.match_length=t.prev_length=x-1,t.match_available=0,t.ins_h=0}(t.state),e}function Y(t,e,r,i,n,s){if(!t)return _;var a=1;if(e===g&&(e=6),i<0?(a=0,i=-i):15<i&&(a=2,i-=16),n<1||y<n||r!==v||i<8||15<i||e<0||9<e||s<0||b<s)return R(t,_);8===i&&(i=9);var o=new H;return(t.state=o).strm=t,o.wrap=a,o.gzhead=null,o.w_bits=i,o.w_size=1<<o.w_bits,o.w_mask=o.w_size-1,o.hash_bits=n+7,o.hash_size=1<<o.hash_bits,o.hash_mask=o.hash_size-1,o.hash_shift=~~((o.hash_bits+x-1)/x),o.window=new d.Buf8(2*o.w_size),o.head=new d.Buf16(o.hash_size),o.prev=new d.Buf16(o.w_size),o.lit_bufsize=1<<n+6,o.pending_buf_size=4*o.lit_bufsize,o.pending_buf=new d.Buf8(o.pending_buf_size),o.d_buf=1*o.lit_bufsize,o.l_buf=3*o.lit_bufsize,o.level=e,o.strategy=s,o.method=r,K(t)}h=[new M(0,0,0,0,function(t,e){var r=65535;for(r>t.pending_buf_size-5&&(r=t.pending_buf_size-5);;){if(t.lookahead<=1){if(j(t),0===t.lookahead&&e===l)return A;if(0===t.lookahead)break}t.strstart+=t.lookahead,t.lookahead=0;var i=t.block_start+r;if((0===t.strstart||t.strstart>=i)&&(t.lookahead=t.strstart-i,t.strstart=i,N(t,!1),0===t.strm.avail_out))return A;if(t.strstart-t.block_start>=t.w_size-z&&(N(t,!1),0===t.strm.avail_out))return A}return t.insert=0,e===f?(N(t,!0),0===t.strm.avail_out?O:B):(t.strstart>t.block_start&&(N(t,!1),t.strm.avail_out),A)}),new M(4,4,8,4,Z),new M(4,5,16,8,Z),new M(4,6,32,32,Z),new M(4,4,16,16,W),new M(8,16,32,32,W),new M(8,16,128,128,W),new M(8,32,128,256,W),new M(32,128,258,1024,W),new M(32,258,258,4096,W)],r.deflateInit=function(t,e){return Y(t,e,v,15,8,0)},r.deflateInit2=Y,r.deflateReset=K,r.deflateResetKeep=G,r.deflateSetHeader=function(t,e){return t&&t.state?2!==t.state.wrap?_:(t.state.gzhead=e,m):_},r.deflate=function(t,e){var r,i,n,s;if(!t||!t.state||5<e||e<0)return t?R(t,_):_;if(i=t.state,!t.output||!t.input&&0!==t.avail_in||666===i.status&&e!==f)return R(t,0===t.avail_out?-5:_);if(i.strm=t,r=i.last_flush,i.last_flush=e,i.status===C)if(2===i.wrap)t.adler=0,U(i,31),U(i,139),U(i,8),i.gzhead?(U(i,(i.gzhead.text?1:0)+(i.gzhead.hcrc?2:0)+(i.gzhead.extra?4:0)+(i.gzhead.name?8:0)+(i.gzhead.comment?16:0)),U(i,255&i.gzhead.time),U(i,i.gzhead.time>>8&255),U(i,i.gzhead.time>>16&255),U(i,i.gzhead.time>>24&255),U(i,9===i.level?2:2<=i.strategy||i.level<2?4:0),U(i,255&i.gzhead.os),i.gzhead.extra&&i.gzhead.extra.length&&(U(i,255&i.gzhead.extra.length),U(i,i.gzhead.extra.length>>8&255)),i.gzhead.hcrc&&(t.adler=p(t.adler,i.pending_buf,i.pending,0)),i.gzindex=0,i.status=69):(U(i,0),U(i,0),U(i,0),U(i,0),U(i,0),U(i,9===i.level?2:2<=i.strategy||i.level<2?4:0),U(i,3),i.status=E);else{var a=v+(i.w_bits-8<<4)<<8;a|=(2<=i.strategy||i.level<2?0:i.level<6?1:6===i.level?2:3)<<6,0!==i.strstart&&(a|=32),a+=31-a%31,i.status=E,P(i,a),0!==i.strstart&&(P(i,t.adler>>>16),P(i,65535&t.adler)),t.adler=1}if(69===i.status)if(i.gzhead.extra){for(n=i.pending;i.gzindex<(65535&i.gzhead.extra.length)&&(i.pending!==i.pending_buf_size||(i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),F(t),n=i.pending,i.pending!==i.pending_buf_size));)U(i,255&i.gzhead.extra[i.gzindex]),i.gzindex++;i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),i.gzindex===i.gzhead.extra.length&&(i.gzindex=0,i.status=73)}else i.status=73;if(73===i.status)if(i.gzhead.name){n=i.pending;do{if(i.pending===i.pending_buf_size&&(i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),F(t),n=i.pending,i.pending===i.pending_buf_size)){s=1;break}s=i.gzindex<i.gzhead.name.length?255&i.gzhead.name.charCodeAt(i.gzindex++):0,U(i,s)}while(0!==s);i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),0===s&&(i.gzindex=0,i.status=91)}else i.status=91;if(91===i.status)if(i.gzhead.comment){n=i.pending;do{if(i.pending===i.pending_buf_size&&(i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),F(t),n=i.pending,i.pending===i.pending_buf_size)){s=1;break}s=i.gzindex<i.gzhead.comment.length?255&i.gzhead.comment.charCodeAt(i.gzindex++):0,U(i,s)}while(0!==s);i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),0===s&&(i.status=103)}else i.status=103;if(103===i.status&&(i.gzhead.hcrc?(i.pending+2>i.pending_buf_size&&F(t),i.pending+2<=i.pending_buf_size&&(U(i,255&t.adler),U(i,t.adler>>8&255),t.adler=0,i.status=E)):i.status=E),0!==i.pending){if(F(t),0===t.avail_out)return i.last_flush=-1,m}else if(0===t.avail_in&&T(e)<=T(r)&&e!==f)return R(t,-5);if(666===i.status&&0!==t.avail_in)return R(t,-5);if(0!==t.avail_in||0!==i.lookahead||e!==l&&666!==i.status){var o=2===i.strategy?function(t,e){for(var r;;){if(0===t.lookahead&&(j(t),0===t.lookahead)){if(e===l)return A;break}if(t.match_length=0,r=u._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++,r&&(N(t,!1),0===t.strm.avail_out))return A}return t.insert=0,e===f?(N(t,!0),0===t.strm.avail_out?O:B):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?A:I}(i,e):3===i.strategy?function(t,e){for(var r,i,n,s,a=t.window;;){if(t.lookahead<=S){if(j(t),t.lookahead<=S&&e===l)return A;if(0===t.lookahead)break}if(t.match_length=0,t.lookahead>=x&&0<t.strstart&&(i=a[n=t.strstart-1])===a[++n]&&i===a[++n]&&i===a[++n]){s=t.strstart+S;do{}while(i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&n<s);t.match_length=S-(s-n),t.match_length>t.lookahead&&(t.match_length=t.lookahead)}if(t.match_length>=x?(r=u._tr_tally(t,1,t.match_length-x),t.lookahead-=t.match_length,t.strstart+=t.match_length,t.match_length=0):(r=u._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++),r&&(N(t,!1),0===t.strm.avail_out))return A}return t.insert=0,e===f?(N(t,!0),0===t.strm.avail_out?O:B):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?A:I}(i,e):h[i.level].func(i,e);if(o!==O&&o!==B||(i.status=666),o===A||o===O)return 0===t.avail_out&&(i.last_flush=-1),m;if(o===I&&(1===e?u._tr_align(i):5!==e&&(u._tr_stored_block(i,0,0,!1),3===e&&(D(i.head),0===i.lookahead&&(i.strstart=0,i.block_start=0,i.insert=0))),F(t),0===t.avail_out))return i.last_flush=-1,m}return e!==f?m:i.wrap<=0?1:(2===i.wrap?(U(i,255&t.adler),U(i,t.adler>>8&255),U(i,t.adler>>16&255),U(i,t.adler>>24&255),U(i,255&t.total_in),U(i,t.total_in>>8&255),U(i,t.total_in>>16&255),U(i,t.total_in>>24&255)):(P(i,t.adler>>>16),P(i,65535&t.adler)),F(t),0<i.wrap&&(i.wrap=-i.wrap),0!==i.pending?m:1)},r.deflateEnd=function(t){var e;return t&&t.state?(e=t.state.status)!==C&&69!==e&&73!==e&&91!==e&&103!==e&&e!==E&&666!==e?R(t,_):(t.state=null,e===E?R(t,-3):m):_},r.deflateSetDictionary=function(t,e){var r,i,n,s,a,o,h,u,l=e.length;if(!t||!t.state)return _;if(2===(s=(r=t.state).wrap)||1===s&&r.status!==C||r.lookahead)return _;for(1===s&&(t.adler=c(t.adler,e,l,0)),r.wrap=0,l>=r.w_size&&(0===s&&(D(r.head),r.strstart=0,r.block_start=0,r.insert=0),u=new d.Buf8(r.w_size),d.arraySet(u,e,l-r.w_size,r.w_size,0),e=u,l=r.w_size),a=t.avail_in,o=t.next_in,h=t.input,t.avail_in=l,t.next_in=0,t.input=e,j(r);r.lookahead>=x;){for(i=r.strstart,n=r.lookahead-(x-1);r.ins_h=(r.ins_h<<r.hash_shift^r.window[i+x-1])&r.hash_mask,r.prev[i&r.w_mask]=r.head[r.ins_h],r.head[r.ins_h]=i,i++,--n;);r.strstart=i,r.lookahead=x-1,j(r)}return r.strstart+=r.lookahead,r.block_start=r.strstart,r.insert=r.lookahead,r.lookahead=0,r.match_length=r.prev_length=x-1,r.match_available=0,t.next_in=o,t.input=h,t.avail_in=a,r.wrap=s,m},r.deflateInfo="pako deflate (from Nodeca project)"},{"../utils/common":41,"./adler32":43,"./crc32":45,"./messages":51,"./trees":52}],47:[function(t,e,r){"use strict";e.exports=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}},{}],48:[function(t,e,r){"use strict";e.exports=function(t,e){var r,i,n,s,a,o,h,u,l,f,d,c,p,m,_,g,b,v,y,w,k,x,S,z,C;r=t.state,i=t.next_in,z=t.input,n=i+(t.avail_in-5),s=t.next_out,C=t.output,a=s-(e-t.avail_out),o=s+(t.avail_out-257),h=r.dmax,u=r.wsize,l=r.whave,f=r.wnext,d=r.window,c=r.hold,p=r.bits,m=r.lencode,_=r.distcode,g=(1<<r.lenbits)-1,b=(1<<r.distbits)-1;t:do{p<15&&(c+=z[i++]<<p,p+=8,c+=z[i++]<<p,p+=8),v=m[c&g];e:for(;;){if(c>>>=y=v>>>24,p-=y,0===(y=v>>>16&255))C[s++]=65535&v;else{if(!(16&y)){if(0==(64&y)){v=m[(65535&v)+(c&(1<<y)-1)];continue e}if(32&y){r.mode=12;break t}t.msg="invalid literal/length code",r.mode=30;break t}w=65535&v,(y&=15)&&(p<y&&(c+=z[i++]<<p,p+=8),w+=c&(1<<y)-1,c>>>=y,p-=y),p<15&&(c+=z[i++]<<p,p+=8,c+=z[i++]<<p,p+=8),v=_[c&b];r:for(;;){if(c>>>=y=v>>>24,p-=y,!(16&(y=v>>>16&255))){if(0==(64&y)){v=_[(65535&v)+(c&(1<<y)-1)];continue r}t.msg="invalid distance code",r.mode=30;break t}if(k=65535&v,p<(y&=15)&&(c+=z[i++]<<p,(p+=8)<y&&(c+=z[i++]<<p,p+=8)),h<(k+=c&(1<<y)-1)){t.msg="invalid distance too far back",r.mode=30;break t}if(c>>>=y,p-=y,(y=s-a)<k){if(l<(y=k-y)&&r.sane){t.msg="invalid distance too far back",r.mode=30;break t}if(S=d,(x=0)===f){if(x+=u-y,y<w){for(w-=y;C[s++]=d[x++],--y;);x=s-k,S=C}}else if(f<y){if(x+=u+f-y,(y-=f)<w){for(w-=y;C[s++]=d[x++],--y;);if(x=0,f<w){for(w-=y=f;C[s++]=d[x++],--y;);x=s-k,S=C}}}else if(x+=f-y,y<w){for(w-=y;C[s++]=d[x++],--y;);x=s-k,S=C}for(;2<w;)C[s++]=S[x++],C[s++]=S[x++],C[s++]=S[x++],w-=3;w&&(C[s++]=S[x++],1<w&&(C[s++]=S[x++]))}else{for(x=s-k;C[s++]=C[x++],C[s++]=C[x++],C[s++]=C[x++],2<(w-=3););w&&(C[s++]=C[x++],1<w&&(C[s++]=C[x++]))}break}}break}}while(i<n&&s<o);i-=w=p>>3,c&=(1<<(p-=w<<3))-1,t.next_in=i,t.next_out=s,t.avail_in=i<n?n-i+5:5-(i-n),t.avail_out=s<o?o-s+257:257-(s-o),r.hold=c,r.bits=p}},{}],49:[function(t,e,r){"use strict";var I=t("../utils/common"),O=t("./adler32"),B=t("./crc32"),R=t("./inffast"),T=t("./inftrees"),D=1,F=2,N=0,U=-2,P=1,i=852,n=592;function L(t){return(t>>>24&255)+(t>>>8&65280)+((65280&t)<<8)+((255&t)<<24)}function s(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new I.Buf16(320),this.work=new I.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function a(t){var e;return t&&t.state?(e=t.state,t.total_in=t.total_out=e.total=0,t.msg="",e.wrap&&(t.adler=1&e.wrap),e.mode=P,e.last=0,e.havedict=0,e.dmax=32768,e.head=null,e.hold=0,e.bits=0,e.lencode=e.lendyn=new I.Buf32(i),e.distcode=e.distdyn=new I.Buf32(n),e.sane=1,e.back=-1,N):U}function o(t){var e;return t&&t.state?((e=t.state).wsize=0,e.whave=0,e.wnext=0,a(t)):U}function h(t,e){var r,i;return t&&t.state?(i=t.state,e<0?(r=0,e=-e):(r=1+(e>>4),e<48&&(e&=15)),e&&(e<8||15<e)?U:(null!==i.window&&i.wbits!==e&&(i.window=null),i.wrap=r,i.wbits=e,o(t))):U}function u(t,e){var r,i;return t?(i=new s,(t.state=i).window=null,(r=h(t,e))!==N&&(t.state=null),r):U}var l,f,d=!0;function j(t){if(d){var e;for(l=new I.Buf32(512),f=new I.Buf32(32),e=0;e<144;)t.lens[e++]=8;for(;e<256;)t.lens[e++]=9;for(;e<280;)t.lens[e++]=7;for(;e<288;)t.lens[e++]=8;for(T(D,t.lens,0,288,l,0,t.work,{bits:9}),e=0;e<32;)t.lens[e++]=5;T(F,t.lens,0,32,f,0,t.work,{bits:5}),d=!1}t.lencode=l,t.lenbits=9,t.distcode=f,t.distbits=5}function Z(t,e,r,i){var n,s=t.state;return null===s.window&&(s.wsize=1<<s.wbits,s.wnext=0,s.whave=0,s.window=new I.Buf8(s.wsize)),i>=s.wsize?(I.arraySet(s.window,e,r-s.wsize,s.wsize,0),s.wnext=0,s.whave=s.wsize):(i<(n=s.wsize-s.wnext)&&(n=i),I.arraySet(s.window,e,r-i,n,s.wnext),(i-=n)?(I.arraySet(s.window,e,r-i,i,0),s.wnext=i,s.whave=s.wsize):(s.wnext+=n,s.wnext===s.wsize&&(s.wnext=0),s.whave<s.wsize&&(s.whave+=n))),0}r.inflateReset=o,r.inflateReset2=h,r.inflateResetKeep=a,r.inflateInit=function(t){return u(t,15)},r.inflateInit2=u,r.inflate=function(t,e){var r,i,n,s,a,o,h,u,l,f,d,c,p,m,_,g,b,v,y,w,k,x,S,z,C=0,E=new I.Buf8(4),A=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!t||!t.state||!t.output||!t.input&&0!==t.avail_in)return U;12===(r=t.state).mode&&(r.mode=13),a=t.next_out,n=t.output,h=t.avail_out,s=t.next_in,i=t.input,o=t.avail_in,u=r.hold,l=r.bits,f=o,d=h,x=N;t:for(;;)switch(r.mode){case P:if(0===r.wrap){r.mode=13;break}for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(2&r.wrap&&35615===u){E[r.check=0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0),l=u=0,r.mode=2;break}if(r.flags=0,r.head&&(r.head.done=!1),!(1&r.wrap)||(((255&u)<<8)+(u>>8))%31){t.msg="incorrect header check",r.mode=30;break}if(8!=(15&u)){t.msg="unknown compression method",r.mode=30;break}if(l-=4,k=8+(15&(u>>>=4)),0===r.wbits)r.wbits=k;else if(k>r.wbits){t.msg="invalid window size",r.mode=30;break}r.dmax=1<<k,t.adler=r.check=1,r.mode=512&u?10:12,l=u=0;break;case 2:for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(r.flags=u,8!=(255&r.flags)){t.msg="unknown compression method",r.mode=30;break}if(57344&r.flags){t.msg="unknown header flags set",r.mode=30;break}r.head&&(r.head.text=u>>8&1),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0,r.mode=3;case 3:for(;l<32;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.head&&(r.head.time=u),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,E[2]=u>>>16&255,E[3]=u>>>24&255,r.check=B(r.check,E,4,0)),l=u=0,r.mode=4;case 4:for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.head&&(r.head.xflags=255&u,r.head.os=u>>8),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0,r.mode=5;case 5:if(1024&r.flags){for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.length=u,r.head&&(r.head.extra_len=u),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0}else r.head&&(r.head.extra=null);r.mode=6;case 6:if(1024&r.flags&&(o<(c=r.length)&&(c=o),c&&(r.head&&(k=r.head.extra_len-r.length,r.head.extra||(r.head.extra=new Array(r.head.extra_len)),I.arraySet(r.head.extra,i,s,c,k)),512&r.flags&&(r.check=B(r.check,i,c,s)),o-=c,s+=c,r.length-=c),r.length))break t;r.length=0,r.mode=7;case 7:if(2048&r.flags){if(0===o)break t;for(c=0;k=i[s+c++],r.head&&k&&r.length<65536&&(r.head.name+=String.fromCharCode(k)),k&&c<o;);if(512&r.flags&&(r.check=B(r.check,i,c,s)),o-=c,s+=c,k)break t}else r.head&&(r.head.name=null);r.length=0,r.mode=8;case 8:if(4096&r.flags){if(0===o)break t;for(c=0;k=i[s+c++],r.head&&k&&r.length<65536&&(r.head.comment+=String.fromCharCode(k)),k&&c<o;);if(512&r.flags&&(r.check=B(r.check,i,c,s)),o-=c,s+=c,k)break t}else r.head&&(r.head.comment=null);r.mode=9;case 9:if(512&r.flags){for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(u!==(65535&r.check)){t.msg="header crc mismatch",r.mode=30;break}l=u=0}r.head&&(r.head.hcrc=r.flags>>9&1,r.head.done=!0),t.adler=r.check=0,r.mode=12;break;case 10:for(;l<32;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}t.adler=r.check=L(u),l=u=0,r.mode=11;case 11:if(0===r.havedict)return t.next_out=a,t.avail_out=h,t.next_in=s,t.avail_in=o,r.hold=u,r.bits=l,2;t.adler=r.check=1,r.mode=12;case 12:if(5===e||6===e)break t;case 13:if(r.last){u>>>=7&l,l-=7&l,r.mode=27;break}for(;l<3;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}switch(r.last=1&u,l-=1,3&(u>>>=1)){case 0:r.mode=14;break;case 1:if(j(r),r.mode=20,6!==e)break;u>>>=2,l-=2;break t;case 2:r.mode=17;break;case 3:t.msg="invalid block type",r.mode=30}u>>>=2,l-=2;break;case 14:for(u>>>=7&l,l-=7&l;l<32;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if((65535&u)!=(u>>>16^65535)){t.msg="invalid stored block lengths",r.mode=30;break}if(r.length=65535&u,l=u=0,r.mode=15,6===e)break t;case 15:r.mode=16;case 16:if(c=r.length){if(o<c&&(c=o),h<c&&(c=h),0===c)break t;I.arraySet(n,i,s,c,a),o-=c,s+=c,h-=c,a+=c,r.length-=c;break}r.mode=12;break;case 17:for(;l<14;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(r.nlen=257+(31&u),u>>>=5,l-=5,r.ndist=1+(31&u),u>>>=5,l-=5,r.ncode=4+(15&u),u>>>=4,l-=4,286<r.nlen||30<r.ndist){t.msg="too many length or distance symbols",r.mode=30;break}r.have=0,r.mode=18;case 18:for(;r.have<r.ncode;){for(;l<3;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.lens[A[r.have++]]=7&u,u>>>=3,l-=3}for(;r.have<19;)r.lens[A[r.have++]]=0;if(r.lencode=r.lendyn,r.lenbits=7,S={bits:r.lenbits},x=T(0,r.lens,0,19,r.lencode,0,r.work,S),r.lenbits=S.bits,x){t.msg="invalid code lengths set",r.mode=30;break}r.have=0,r.mode=19;case 19:for(;r.have<r.nlen+r.ndist;){for(;g=(C=r.lencode[u&(1<<r.lenbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(b<16)u>>>=_,l-=_,r.lens[r.have++]=b;else{if(16===b){for(z=_+2;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(u>>>=_,l-=_,0===r.have){t.msg="invalid bit length repeat",r.mode=30;break}k=r.lens[r.have-1],c=3+(3&u),u>>>=2,l-=2}else if(17===b){for(z=_+3;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}l-=_,k=0,c=3+(7&(u>>>=_)),u>>>=3,l-=3}else{for(z=_+7;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}l-=_,k=0,c=11+(127&(u>>>=_)),u>>>=7,l-=7}if(r.have+c>r.nlen+r.ndist){t.msg="invalid bit length repeat",r.mode=30;break}for(;c--;)r.lens[r.have++]=k}}if(30===r.mode)break;if(0===r.lens[256]){t.msg="invalid code -- missing end-of-block",r.mode=30;break}if(r.lenbits=9,S={bits:r.lenbits},x=T(D,r.lens,0,r.nlen,r.lencode,0,r.work,S),r.lenbits=S.bits,x){t.msg="invalid literal/lengths set",r.mode=30;break}if(r.distbits=6,r.distcode=r.distdyn,S={bits:r.distbits},x=T(F,r.lens,r.nlen,r.ndist,r.distcode,0,r.work,S),r.distbits=S.bits,x){t.msg="invalid distances set",r.mode=30;break}if(r.mode=20,6===e)break t;case 20:r.mode=21;case 21:if(6<=o&&258<=h){t.next_out=a,t.avail_out=h,t.next_in=s,t.avail_in=o,r.hold=u,r.bits=l,R(t,d),a=t.next_out,n=t.output,h=t.avail_out,s=t.next_in,i=t.input,o=t.avail_in,u=r.hold,l=r.bits,12===r.mode&&(r.back=-1);break}for(r.back=0;g=(C=r.lencode[u&(1<<r.lenbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(g&&0==(240&g)){for(v=_,y=g,w=b;g=(C=r.lencode[w+((u&(1<<v+y)-1)>>v)])>>>16&255,b=65535&C,!(v+(_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}u>>>=v,l-=v,r.back+=v}if(u>>>=_,l-=_,r.back+=_,r.length=b,0===g){r.mode=26;break}if(32&g){r.back=-1,r.mode=12;break}if(64&g){t.msg="invalid literal/length code",r.mode=30;break}r.extra=15&g,r.mode=22;case 22:if(r.extra){for(z=r.extra;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.length+=u&(1<<r.extra)-1,u>>>=r.extra,l-=r.extra,r.back+=r.extra}r.was=r.length,r.mode=23;case 23:for(;g=(C=r.distcode[u&(1<<r.distbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(0==(240&g)){for(v=_,y=g,w=b;g=(C=r.distcode[w+((u&(1<<v+y)-1)>>v)])>>>16&255,b=65535&C,!(v+(_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}u>>>=v,l-=v,r.back+=v}if(u>>>=_,l-=_,r.back+=_,64&g){t.msg="invalid distance code",r.mode=30;break}r.offset=b,r.extra=15&g,r.mode=24;case 24:if(r.extra){for(z=r.extra;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.offset+=u&(1<<r.extra)-1,u>>>=r.extra,l-=r.extra,r.back+=r.extra}if(r.offset>r.dmax){t.msg="invalid distance too far back",r.mode=30;break}r.mode=25;case 25:if(0===h)break t;if(c=d-h,r.offset>c){if((c=r.offset-c)>r.whave&&r.sane){t.msg="invalid distance too far back",r.mode=30;break}p=c>r.wnext?(c-=r.wnext,r.wsize-c):r.wnext-c,c>r.length&&(c=r.length),m=r.window}else m=n,p=a-r.offset,c=r.length;for(h<c&&(c=h),h-=c,r.length-=c;n[a++]=m[p++],--c;);0===r.length&&(r.mode=21);break;case 26:if(0===h)break t;n[a++]=r.length,h--,r.mode=21;break;case 27:if(r.wrap){for(;l<32;){if(0===o)break t;o--,u|=i[s++]<<l,l+=8}if(d-=h,t.total_out+=d,r.total+=d,d&&(t.adler=r.check=r.flags?B(r.check,n,d,a-d):O(r.check,n,d,a-d)),d=h,(r.flags?u:L(u))!==r.check){t.msg="incorrect data check",r.mode=30;break}l=u=0}r.mode=28;case 28:if(r.wrap&&r.flags){for(;l<32;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(u!==(4294967295&r.total)){t.msg="incorrect length check",r.mode=30;break}l=u=0}r.mode=29;case 29:x=1;break t;case 30:x=-3;break t;case 31:return-4;case 32:default:return U}return t.next_out=a,t.avail_out=h,t.next_in=s,t.avail_in=o,r.hold=u,r.bits=l,(r.wsize||d!==t.avail_out&&r.mode<30&&(r.mode<27||4!==e))&&Z(t,t.output,t.next_out,d-t.avail_out)?(r.mode=31,-4):(f-=t.avail_in,d-=t.avail_out,t.total_in+=f,t.total_out+=d,r.total+=d,r.wrap&&d&&(t.adler=r.check=r.flags?B(r.check,n,d,t.next_out-d):O(r.check,n,d,t.next_out-d)),t.data_type=r.bits+(r.last?64:0)+(12===r.mode?128:0)+(20===r.mode||15===r.mode?256:0),(0==f&&0===d||4===e)&&x===N&&(x=-5),x)},r.inflateEnd=function(t){if(!t||!t.state)return U;var e=t.state;return e.window&&(e.window=null),t.state=null,N},r.inflateGetHeader=function(t,e){var r;return t&&t.state?0==(2&(r=t.state).wrap)?U:((r.head=e).done=!1,N):U},r.inflateSetDictionary=function(t,e){var r,i=e.length;return t&&t.state?0!==(r=t.state).wrap&&11!==r.mode?U:11===r.mode&&O(1,e,i,0)!==r.check?-3:Z(t,e,i,i)?(r.mode=31,-4):(r.havedict=1,N):U},r.inflateInfo="pako inflate (from Nodeca project)"},{"../utils/common":41,"./adler32":43,"./crc32":45,"./inffast":48,"./inftrees":50}],50:[function(t,e,r){"use strict";var D=t("../utils/common"),F=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],N=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],U=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],P=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];e.exports=function(t,e,r,i,n,s,a,o){var h,u,l,f,d,c,p,m,_,g=o.bits,b=0,v=0,y=0,w=0,k=0,x=0,S=0,z=0,C=0,E=0,A=null,I=0,O=new D.Buf16(16),B=new D.Buf16(16),R=null,T=0;for(b=0;b<=15;b++)O[b]=0;for(v=0;v<i;v++)O[e[r+v]]++;for(k=g,w=15;1<=w&&0===O[w];w--);if(w<k&&(k=w),0===w)return n[s++]=20971520,n[s++]=20971520,o.bits=1,0;for(y=1;y<w&&0===O[y];y++);for(k<y&&(k=y),b=z=1;b<=15;b++)if(z<<=1,(z-=O[b])<0)return-1;if(0<z&&(0===t||1!==w))return-1;for(B[1]=0,b=1;b<15;b++)B[b+1]=B[b]+O[b];for(v=0;v<i;v++)0!==e[r+v]&&(a[B[e[r+v]]++]=v);if(c=0===t?(A=R=a,19):1===t?(A=F,I-=257,R=N,T-=257,256):(A=U,R=P,-1),b=y,d=s,S=v=E=0,l=-1,f=(C=1<<(x=k))-1,1===t&&852<C||2===t&&592<C)return 1;for(;;){for(p=b-S,_=a[v]<c?(m=0,a[v]):a[v]>c?(m=R[T+a[v]],A[I+a[v]]):(m=96,0),h=1<<b-S,y=u=1<<x;n[d+(E>>S)+(u-=h)]=p<<24|m<<16|_|0,0!==u;);for(h=1<<b-1;E&h;)h>>=1;if(0!==h?(E&=h-1,E+=h):E=0,v++,0==--O[b]){if(b===w)break;b=e[r+a[v]]}if(k<b&&(E&f)!==l){for(0===S&&(S=k),d+=y,z=1<<(x=b-S);x+S<w&&!((z-=O[x+S])<=0);)x++,z<<=1;if(C+=1<<x,1===t&&852<C||2===t&&592<C)return 1;n[l=E&f]=k<<24|x<<16|d-s|0}}return 0!==E&&(n[d+E]=b-S<<24|64<<16|0),o.bits=k,0}},{"../utils/common":41}],51:[function(t,e,r){"use strict";e.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}},{}],52:[function(t,e,r){"use strict";var n=t("../utils/common"),o=0,h=1;function i(t){for(var e=t.length;0<=--e;)t[e]=0}var s=0,a=29,u=256,l=u+1+a,f=30,d=19,_=2*l+1,g=15,c=16,p=7,m=256,b=16,v=17,y=18,w=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],k=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],x=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],S=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],z=new Array(2*(l+2));i(z);var C=new Array(2*f);i(C);var E=new Array(512);i(E);var A=new Array(256);i(A);var I=new Array(a);i(I);var O,B,R,T=new Array(f);function D(t,e,r,i,n){this.static_tree=t,this.extra_bits=e,this.extra_base=r,this.elems=i,this.max_length=n,this.has_stree=t&&t.length}function F(t,e){this.dyn_tree=t,this.max_code=0,this.stat_desc=e}function N(t){return t<256?E[t]:E[256+(t>>>7)]}function U(t,e){t.pending_buf[t.pending++]=255&e,t.pending_buf[t.pending++]=e>>>8&255}function P(t,e,r){t.bi_valid>c-r?(t.bi_buf|=e<<t.bi_valid&65535,U(t,t.bi_buf),t.bi_buf=e>>c-t.bi_valid,t.bi_valid+=r-c):(t.bi_buf|=e<<t.bi_valid&65535,t.bi_valid+=r)}function L(t,e,r){P(t,r[2*e],r[2*e+1])}function j(t,e){for(var r=0;r|=1&t,t>>>=1,r<<=1,0<--e;);return r>>>1}function Z(t,e,r){var i,n,s=new Array(g+1),a=0;for(i=1;i<=g;i++)s[i]=a=a+r[i-1]<<1;for(n=0;n<=e;n++){var o=t[2*n+1];0!==o&&(t[2*n]=j(s[o]++,o))}}function W(t){var e;for(e=0;e<l;e++)t.dyn_ltree[2*e]=0;for(e=0;e<f;e++)t.dyn_dtree[2*e]=0;for(e=0;e<d;e++)t.bl_tree[2*e]=0;t.dyn_ltree[2*m]=1,t.opt_len=t.static_len=0,t.last_lit=t.matches=0}function M(t){8<t.bi_valid?U(t,t.bi_buf):0<t.bi_valid&&(t.pending_buf[t.pending++]=t.bi_buf),t.bi_buf=0,t.bi_valid=0}function H(t,e,r,i){var n=2*e,s=2*r;return t[n]<t[s]||t[n]===t[s]&&i[e]<=i[r]}function G(t,e,r){for(var i=t.heap[r],n=r<<1;n<=t.heap_len&&(n<t.heap_len&&H(e,t.heap[n+1],t.heap[n],t.depth)&&n++,!H(e,i,t.heap[n],t.depth));)t.heap[r]=t.heap[n],r=n,n<<=1;t.heap[r]=i}function K(t,e,r){var i,n,s,a,o=0;if(0!==t.last_lit)for(;i=t.pending_buf[t.d_buf+2*o]<<8|t.pending_buf[t.d_buf+2*o+1],n=t.pending_buf[t.l_buf+o],o++,0===i?L(t,n,e):(L(t,(s=A[n])+u+1,e),0!==(a=w[s])&&P(t,n-=I[s],a),L(t,s=N(--i),r),0!==(a=k[s])&&P(t,i-=T[s],a)),o<t.last_lit;);L(t,m,e)}function Y(t,e){var r,i,n,s=e.dyn_tree,a=e.stat_desc.static_tree,o=e.stat_desc.has_stree,h=e.stat_desc.elems,u=-1;for(t.heap_len=0,t.heap_max=_,r=0;r<h;r++)0!==s[2*r]?(t.heap[++t.heap_len]=u=r,t.depth[r]=0):s[2*r+1]=0;for(;t.heap_len<2;)s[2*(n=t.heap[++t.heap_len]=u<2?++u:0)]=1,t.depth[n]=0,t.opt_len--,o&&(t.static_len-=a[2*n+1]);for(e.max_code=u,r=t.heap_len>>1;1<=r;r--)G(t,s,r);for(n=h;r=t.heap[1],t.heap[1]=t.heap[t.heap_len--],G(t,s,1),i=t.heap[1],t.heap[--t.heap_max]=r,t.heap[--t.heap_max]=i,s[2*n]=s[2*r]+s[2*i],t.depth[n]=(t.depth[r]>=t.depth[i]?t.depth[r]:t.depth[i])+1,s[2*r+1]=s[2*i+1]=n,t.heap[1]=n++,G(t,s,1),2<=t.heap_len;);t.heap[--t.heap_max]=t.heap[1],function(t,e){var r,i,n,s,a,o,h=e.dyn_tree,u=e.max_code,l=e.stat_desc.static_tree,f=e.stat_desc.has_stree,d=e.stat_desc.extra_bits,c=e.stat_desc.extra_base,p=e.stat_desc.max_length,m=0;for(s=0;s<=g;s++)t.bl_count[s]=0;for(h[2*t.heap[t.heap_max]+1]=0,r=t.heap_max+1;r<_;r++)p<(s=h[2*h[2*(i=t.heap[r])+1]+1]+1)&&(s=p,m++),h[2*i+1]=s,u<i||(t.bl_count[s]++,a=0,c<=i&&(a=d[i-c]),o=h[2*i],t.opt_len+=o*(s+a),f&&(t.static_len+=o*(l[2*i+1]+a)));if(0!==m){do{for(s=p-1;0===t.bl_count[s];)s--;t.bl_count[s]--,t.bl_count[s+1]+=2,t.bl_count[p]--,m-=2}while(0<m);for(s=p;0!==s;s--)for(i=t.bl_count[s];0!==i;)u<(n=t.heap[--r])||(h[2*n+1]!==s&&(t.opt_len+=(s-h[2*n+1])*h[2*n],h[2*n+1]=s),i--)}}(t,e),Z(s,u,t.bl_count)}function X(t,e,r){var i,n,s=-1,a=e[1],o=0,h=7,u=4;for(0===a&&(h=138,u=3),e[2*(r+1)+1]=65535,i=0;i<=r;i++)n=a,a=e[2*(i+1)+1],++o<h&&n===a||(o<u?t.bl_tree[2*n]+=o:0!==n?(n!==s&&t.bl_tree[2*n]++,t.bl_tree[2*b]++):o<=10?t.bl_tree[2*v]++:t.bl_tree[2*y]++,s=n,u=(o=0)===a?(h=138,3):n===a?(h=6,3):(h=7,4))}function V(t,e,r){var i,n,s=-1,a=e[1],o=0,h=7,u=4;for(0===a&&(h=138,u=3),i=0;i<=r;i++)if(n=a,a=e[2*(i+1)+1],!(++o<h&&n===a)){if(o<u)for(;L(t,n,t.bl_tree),0!=--o;);else 0!==n?(n!==s&&(L(t,n,t.bl_tree),o--),L(t,b,t.bl_tree),P(t,o-3,2)):o<=10?(L(t,v,t.bl_tree),P(t,o-3,3)):(L(t,y,t.bl_tree),P(t,o-11,7));s=n,u=(o=0)===a?(h=138,3):n===a?(h=6,3):(h=7,4)}}i(T);var q=!1;function J(t,e,r,i){P(t,(s<<1)+(i?1:0),3),function(t,e,r,i){M(t),i&&(U(t,r),U(t,~r)),n.arraySet(t.pending_buf,t.window,e,r,t.pending),t.pending+=r}(t,e,r,!0)}r._tr_init=function(t){q||(function(){var t,e,r,i,n,s=new Array(g+1);for(i=r=0;i<a-1;i++)for(I[i]=r,t=0;t<1<<w[i];t++)A[r++]=i;for(A[r-1]=i,i=n=0;i<16;i++)for(T[i]=n,t=0;t<1<<k[i];t++)E[n++]=i;for(n>>=7;i<f;i++)for(T[i]=n<<7,t=0;t<1<<k[i]-7;t++)E[256+n++]=i;for(e=0;e<=g;e++)s[e]=0;for(t=0;t<=143;)z[2*t+1]=8,t++,s[8]++;for(;t<=255;)z[2*t+1]=9,t++,s[9]++;for(;t<=279;)z[2*t+1]=7,t++,s[7]++;for(;t<=287;)z[2*t+1]=8,t++,s[8]++;for(Z(z,l+1,s),t=0;t<f;t++)C[2*t+1]=5,C[2*t]=j(t,5);O=new D(z,w,u+1,l,g),B=new D(C,k,0,f,g),R=new D(new Array(0),x,0,d,p)}(),q=!0),t.l_desc=new F(t.dyn_ltree,O),t.d_desc=new F(t.dyn_dtree,B),t.bl_desc=new F(t.bl_tree,R),t.bi_buf=0,t.bi_valid=0,W(t)},r._tr_stored_block=J,r._tr_flush_block=function(t,e,r,i){var n,s,a=0;0<t.level?(2===t.strm.data_type&&(t.strm.data_type=function(t){var e,r=4093624447;for(e=0;e<=31;e++,r>>>=1)if(1&r&&0!==t.dyn_ltree[2*e])return o;if(0!==t.dyn_ltree[18]||0!==t.dyn_ltree[20]||0!==t.dyn_ltree[26])return h;for(e=32;e<u;e++)if(0!==t.dyn_ltree[2*e])return h;return o}(t)),Y(t,t.l_desc),Y(t,t.d_desc),a=function(t){var e;for(X(t,t.dyn_ltree,t.l_desc.max_code),X(t,t.dyn_dtree,t.d_desc.max_code),Y(t,t.bl_desc),e=d-1;3<=e&&0===t.bl_tree[2*S[e]+1];e--);return t.opt_len+=3*(e+1)+5+5+4,e}(t),n=t.opt_len+3+7>>>3,(s=t.static_len+3+7>>>3)<=n&&(n=s)):n=s=r+5,r+4<=n&&-1!==e?J(t,e,r,i):4===t.strategy||s===n?(P(t,2+(i?1:0),3),K(t,z,C)):(P(t,4+(i?1:0),3),function(t,e,r,i){var n;for(P(t,e-257,5),P(t,r-1,5),P(t,i-4,4),n=0;n<i;n++)P(t,t.bl_tree[2*S[n]+1],3);V(t,t.dyn_ltree,e-1),V(t,t.dyn_dtree,r-1)}(t,t.l_desc.max_code+1,t.d_desc.max_code+1,a+1),K(t,t.dyn_ltree,t.dyn_dtree)),W(t),i&&M(t)},r._tr_tally=function(t,e,r){return t.pending_buf[t.d_buf+2*t.last_lit]=e>>>8&255,t.pending_buf[t.d_buf+2*t.last_lit+1]=255&e,t.pending_buf[t.l_buf+t.last_lit]=255&r,t.last_lit++,0===e?t.dyn_ltree[2*r]++:(t.matches++,e--,t.dyn_ltree[2*(A[r]+u+1)]++,t.dyn_dtree[2*N(e)]++),t.last_lit===t.lit_bufsize-1},r._tr_align=function(t){P(t,2,3),L(t,m,z),function(t){16===t.bi_valid?(U(t,t.bi_buf),t.bi_buf=0,t.bi_valid=0):8<=t.bi_valid&&(t.pending_buf[t.pending++]=255&t.bi_buf,t.bi_buf>>=8,t.bi_valid-=8)}(t)}},{"../utils/common":41}],53:[function(t,e,r){"use strict";e.exports=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}},{}],54:[function(t,e,r){"use strict";e.exports="function"==typeof setImmediate?setImmediate:function(){var t=[].slice.apply(arguments);t.splice(1,0,0),setTimeout.apply(null,t)}},{}]},{},[10])(10)});
}).toString());



EXT_LIB_SCRIPTS.push((function lib_script_2 () {
/*!
    localForage -- Offline Storage, Improved
    Version 1.7.3
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/
!function(a){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=a();else if("function"==typeof define&&define.amd)define([],a);else{var b;b="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,b.localforage=a()}}(function(){return function a(b,c,d){function e(g,h){if(!c[g]){if(!b[g]){var i="function"==typeof require&&require;if(!h&&i)return i(g,!0);if(f)return f(g,!0);var j=new Error("Cannot find module '"+g+"'");throw j.code="MODULE_NOT_FOUND",j}var k=c[g]={exports:{}};b[g][0].call(k.exports,function(a){var c=b[g][1][a];return e(c||a)},k,k.exports,a,b,c,d)}return c[g].exports}for(var f="function"==typeof require&&require,g=0;g<d.length;g++)e(d[g]);return e}({1:[function(a,b,c){(function(a){"use strict";function c(){k=!0;for(var a,b,c=l.length;c;){for(b=l,l=[],a=-1;++a<c;)b[a]();c=l.length}k=!1}function d(a){1!==l.push(a)||k||e()}var e,f=a.MutationObserver||a.WebKitMutationObserver;if(f){var g=0,h=new f(c),i=a.document.createTextNode("");h.observe(i,{characterData:!0}),e=function(){i.data=g=++g%2}}else if(a.setImmediate||void 0===a.MessageChannel)e="document"in a&&"onreadystatechange"in a.document.createElement("script")?function(){var b=a.document.createElement("script");b.onreadystatechange=function(){c(),b.onreadystatechange=null,b.parentNode.removeChild(b),b=null},a.document.documentElement.appendChild(b)}:function(){setTimeout(c,0)};else{var j=new a.MessageChannel;j.port1.onmessage=c,e=function(){j.port2.postMessage(0)}}var k,l=[];b.exports=d}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],2:[function(a,b,c){"use strict";function d(){}function e(a){if("function"!=typeof a)throw new TypeError("resolver must be a function");this.state=s,this.queue=[],this.outcome=void 0,a!==d&&i(this,a)}function f(a,b,c){this.promise=a,"function"==typeof b&&(this.onFulfilled=b,this.callFulfilled=this.otherCallFulfilled),"function"==typeof c&&(this.onRejected=c,this.callRejected=this.otherCallRejected)}function g(a,b,c){o(function(){var d;try{d=b(c)}catch(b){return p.reject(a,b)}d===a?p.reject(a,new TypeError("Cannot resolve promise with itself")):p.resolve(a,d)})}function h(a){var b=a&&a.then;if(a&&("object"==typeof a||"function"==typeof a)&&"function"==typeof b)return function(){b.apply(a,arguments)}}function i(a,b){function c(b){f||(f=!0,p.reject(a,b))}function d(b){f||(f=!0,p.resolve(a,b))}function e(){b(d,c)}var f=!1,g=j(e);"error"===g.status&&c(g.value)}function j(a,b){var c={};try{c.value=a(b),c.status="success"}catch(a){c.status="error",c.value=a}return c}function k(a){return a instanceof this?a:p.resolve(new this(d),a)}function l(a){var b=new this(d);return p.reject(b,a)}function m(a){function b(a,b){function d(a){g[b]=a,++h!==e||f||(f=!0,p.resolve(j,g))}c.resolve(a).then(d,function(a){f||(f=!0,p.reject(j,a))})}var c=this;if("[object Array]"!==Object.prototype.toString.call(a))return this.reject(new TypeError("must be an array"));var e=a.length,f=!1;if(!e)return this.resolve([]);for(var g=new Array(e),h=0,i=-1,j=new this(d);++i<e;)b(a[i],i);return j}function n(a){function b(a){c.resolve(a).then(function(a){f||(f=!0,p.resolve(h,a))},function(a){f||(f=!0,p.reject(h,a))})}var c=this;if("[object Array]"!==Object.prototype.toString.call(a))return this.reject(new TypeError("must be an array"));var e=a.length,f=!1;if(!e)return this.resolve([]);for(var g=-1,h=new this(d);++g<e;)b(a[g]);return h}var o=a(1),p={},q=["REJECTED"],r=["FULFILLED"],s=["PENDING"];b.exports=e,e.prototype.catch=function(a){return this.then(null,a)},e.prototype.then=function(a,b){if("function"!=typeof a&&this.state===r||"function"!=typeof b&&this.state===q)return this;var c=new this.constructor(d);if(this.state!==s){g(c,this.state===r?a:b,this.outcome)}else this.queue.push(new f(c,a,b));return c},f.prototype.callFulfilled=function(a){p.resolve(this.promise,a)},f.prototype.otherCallFulfilled=function(a){g(this.promise,this.onFulfilled,a)},f.prototype.callRejected=function(a){p.reject(this.promise,a)},f.prototype.otherCallRejected=function(a){g(this.promise,this.onRejected,a)},p.resolve=function(a,b){var c=j(h,b);if("error"===c.status)return p.reject(a,c.value);var d=c.value;if(d)i(a,d);else{a.state=r,a.outcome=b;for(var e=-1,f=a.queue.length;++e<f;)a.queue[e].callFulfilled(b)}return a},p.reject=function(a,b){a.state=q,a.outcome=b;for(var c=-1,d=a.queue.length;++c<d;)a.queue[c].callRejected(b);return a},e.resolve=k,e.reject=l,e.all=m,e.race=n},{1:1}],3:[function(a,b,c){(function(b){"use strict";"function"!=typeof b.Promise&&(b.Promise=a(2))}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{2:2}],4:[function(a,b,c){"use strict";function d(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}function e(){try{if("undefined"!=typeof indexedDB)return indexedDB;if("undefined"!=typeof webkitIndexedDB)return webkitIndexedDB;if("undefined"!=typeof mozIndexedDB)return mozIndexedDB;if("undefined"!=typeof OIndexedDB)return OIndexedDB;if("undefined"!=typeof msIndexedDB)return msIndexedDB}catch(a){return}}function f(){try{if(!ua)return!1;var a="undefined"!=typeof openDatabase&&/(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent)&&!/Chrome/.test(navigator.userAgent)&&!/BlackBerry/.test(navigator.platform),b="function"==typeof fetch&&-1!==fetch.toString().indexOf("[native code");return(!a||b)&&"undefined"!=typeof indexedDB&&"undefined"!=typeof IDBKeyRange}catch(a){return!1}}function g(a,b){a=a||[],b=b||{};try{return new Blob(a,b)}catch(f){if("TypeError"!==f.name)throw f;for(var c="undefined"!=typeof BlobBuilder?BlobBuilder:"undefined"!=typeof MSBlobBuilder?MSBlobBuilder:"undefined"!=typeof MozBlobBuilder?MozBlobBuilder:WebKitBlobBuilder,d=new c,e=0;e<a.length;e+=1)d.append(a[e]);return d.getBlob(b.type)}}function h(a,b){b&&a.then(function(a){b(null,a)},function(a){b(a)})}function i(a,b,c){"function"==typeof b&&a.then(b),"function"==typeof c&&a.catch(c)}function j(a){return"string"!=typeof a&&(console.warn(a+" used as a key, but it is not a string."),a=String(a)),a}function k(){if(arguments.length&&"function"==typeof arguments[arguments.length-1])return arguments[arguments.length-1]}function l(a){for(var b=a.length,c=new ArrayBuffer(b),d=new Uint8Array(c),e=0;e<b;e++)d[e]=a.charCodeAt(e);return c}function m(a){return new va(function(b){var c=a.transaction(wa,Ba),d=g([""]);c.objectStore(wa).put(d,"key"),c.onabort=function(a){a.preventDefault(),a.stopPropagation(),b(!1)},c.oncomplete=function(){var a=navigator.userAgent.match(/Chrome\/(\d+)/),c=navigator.userAgent.match(/Edge\//);b(c||!a||parseInt(a[1],10)>=43)}}).catch(function(){return!1})}function n(a){return"boolean"==typeof xa?va.resolve(xa):m(a).then(function(a){return xa=a})}function o(a){var b=ya[a.name],c={};c.promise=new va(function(a,b){c.resolve=a,c.reject=b}),b.deferredOperations.push(c),b.dbReady?b.dbReady=b.dbReady.then(function(){return c.promise}):b.dbReady=c.promise}function p(a){var b=ya[a.name],c=b.deferredOperations.pop();if(c)return c.resolve(),c.promise}function q(a,b){var c=ya[a.name],d=c.deferredOperations.pop();if(d)return d.reject(b),d.promise}function r(a,b){return new va(function(c,d){if(ya[a.name]=ya[a.name]||B(),a.db){if(!b)return c(a.db);o(a),a.db.close()}var e=[a.name];b&&e.push(a.version);var f=ua.open.apply(ua,e);b&&(f.onupgradeneeded=function(b){var c=f.result;try{c.createObjectStore(a.storeName),b.oldVersion<=1&&c.createObjectStore(wa)}catch(c){if("ConstraintError"!==c.name)throw c;console.warn('The database "'+a.name+'" has been upgraded from version '+b.oldVersion+" to version "+b.newVersion+', but the storage "'+a.storeName+'" already exists.')}}),f.onerror=function(a){a.preventDefault(),d(f.error)},f.onsuccess=function(){c(f.result),p(a)}})}function s(a){return r(a,!1)}function t(a){return r(a,!0)}function u(a,b){if(!a.db)return!0;var c=!a.db.objectStoreNames.contains(a.storeName),d=a.version<a.db.version,e=a.version>a.db.version;if(d&&(a.version!==b&&console.warn('The database "'+a.name+"\" can't be downgraded from version "+a.db.version+" to version "+a.version+"."),a.version=a.db.version),e||c){if(c){var f=a.db.version+1;f>a.version&&(a.version=f)}return!0}return!1}function v(a){return new va(function(b,c){var d=new FileReader;d.onerror=c,d.onloadend=function(c){var d=btoa(c.target.result||"");b({__local_forage_encoded_blob:!0,data:d,type:a.type})},d.readAsBinaryString(a)})}function w(a){return g([l(atob(a.data))],{type:a.type})}function x(a){return a&&a.__local_forage_encoded_blob}function y(a){var b=this,c=b._initReady().then(function(){var a=ya[b._dbInfo.name];if(a&&a.dbReady)return a.dbReady});return i(c,a,a),c}function z(a){o(a);for(var b=ya[a.name],c=b.forages,d=0;d<c.length;d++){var e=c[d];e._dbInfo.db&&(e._dbInfo.db.close(),e._dbInfo.db=null)}return a.db=null,s(a).then(function(b){return a.db=b,u(a)?t(a):b}).then(function(d){a.db=b.db=d;for(var e=0;e<c.length;e++)c[e]._dbInfo.db=d}).catch(function(b){throw q(a,b),b})}function A(a,b,c,d){void 0===d&&(d=1);try{var e=a.db.transaction(a.storeName,b);c(null,e)}catch(e){if(d>0&&(!a.db||"InvalidStateError"===e.name||"NotFoundError"===e.name))return va.resolve().then(function(){if(!a.db||"NotFoundError"===e.name&&!a.db.objectStoreNames.contains(a.storeName)&&a.version<=a.db.version)return a.db&&(a.version=a.db.version+1),t(a)}).then(function(){return z(a).then(function(){A(a,b,c,d-1)})}).catch(c);c(e)}}function B(){return{forages:[],db:null,dbReady:null,deferredOperations:[]}}function C(a){function b(){return va.resolve()}var c=this,d={db:null};if(a)for(var e in a)d[e]=a[e];var f=ya[d.name];f||(f=B(),ya[d.name]=f),f.forages.push(c),c._initReady||(c._initReady=c.ready,c.ready=y);for(var g=[],h=0;h<f.forages.length;h++){var i=f.forages[h];i!==c&&g.push(i._initReady().catch(b))}var j=f.forages.slice(0);return va.all(g).then(function(){return d.db=f.db,s(d)}).then(function(a){return d.db=a,u(d,c._defaultConfig.version)?t(d):a}).then(function(a){d.db=f.db=a,c._dbInfo=d;for(var b=0;b<j.length;b++){var e=j[b];e!==c&&(e._dbInfo.db=d.db,e._dbInfo.version=d.version)}})}function D(a,b){var c=this;a=j(a);var d=new va(function(b,d){c.ready().then(function(){A(c._dbInfo,Aa,function(e,f){if(e)return d(e);try{var g=f.objectStore(c._dbInfo.storeName),h=g.get(a);h.onsuccess=function(){var a=h.result;void 0===a&&(a=null),x(a)&&(a=w(a)),b(a)},h.onerror=function(){d(h.error)}}catch(a){d(a)}})}).catch(d)});return h(d,b),d}function E(a,b){var c=this,d=new va(function(b,d){c.ready().then(function(){A(c._dbInfo,Aa,function(e,f){if(e)return d(e);try{var g=f.objectStore(c._dbInfo.storeName),h=g.openCursor(),i=1;h.onsuccess=function(){var c=h.result;if(c){var d=c.value;x(d)&&(d=w(d));var e=a(d,c.key,i++);void 0!==e?b(e):c.continue()}else b()},h.onerror=function(){d(h.error)}}catch(a){d(a)}})}).catch(d)});return h(d,b),d}function F(a,b,c){var d=this;a=j(a);var e=new va(function(c,e){var f;d.ready().then(function(){return f=d._dbInfo,"[object Blob]"===za.call(b)?n(f.db).then(function(a){return a?b:v(b)}):b}).then(function(b){A(d._dbInfo,Ba,function(f,g){if(f)return e(f);try{var h=g.objectStore(d._dbInfo.storeName);null===b&&(b=void 0);var i=h.put(b,a);g.oncomplete=function(){void 0===b&&(b=null),c(b)},g.onabort=g.onerror=function(){var a=i.error?i.error:i.transaction.error;e(a)}}catch(a){e(a)}})}).catch(e)});return h(e,c),e}function G(a,b){var c=this;a=j(a);var d=new va(function(b,d){c.ready().then(function(){A(c._dbInfo,Ba,function(e,f){if(e)return d(e);try{var g=f.objectStore(c._dbInfo.storeName),h=g.delete(a);f.oncomplete=function(){b()},f.onerror=function(){d(h.error)},f.onabort=function(){var a=h.error?h.error:h.transaction.error;d(a)}}catch(a){d(a)}})}).catch(d)});return h(d,b),d}function H(a){var b=this,c=new va(function(a,c){b.ready().then(function(){A(b._dbInfo,Ba,function(d,e){if(d)return c(d);try{var f=e.objectStore(b._dbInfo.storeName),g=f.clear();e.oncomplete=function(){a()},e.onabort=e.onerror=function(){var a=g.error?g.error:g.transaction.error;c(a)}}catch(a){c(a)}})}).catch(c)});return h(c,a),c}function I(a){var b=this,c=new va(function(a,c){b.ready().then(function(){A(b._dbInfo,Aa,function(d,e){if(d)return c(d);try{var f=e.objectStore(b._dbInfo.storeName),g=f.count();g.onsuccess=function(){a(g.result)},g.onerror=function(){c(g.error)}}catch(a){c(a)}})}).catch(c)});return h(c,a),c}function J(a,b){var c=this,d=new va(function(b,d){if(a<0)return void b(null);c.ready().then(function(){A(c._dbInfo,Aa,function(e,f){if(e)return d(e);try{var g=f.objectStore(c._dbInfo.storeName),h=!1,i=g.openCursor();i.onsuccess=function(){var c=i.result;if(!c)return void b(null);0===a?b(c.key):h?b(c.key):(h=!0,c.advance(a))},i.onerror=function(){d(i.error)}}catch(a){d(a)}})}).catch(d)});return h(d,b),d}function K(a){var b=this,c=new va(function(a,c){b.ready().then(function(){A(b._dbInfo,Aa,function(d,e){if(d)return c(d);try{var f=e.objectStore(b._dbInfo.storeName),g=f.openCursor(),h=[];g.onsuccess=function(){var b=g.result;if(!b)return void a(h);h.push(b.key),b.continue()},g.onerror=function(){c(g.error)}}catch(a){c(a)}})}).catch(c)});return h(c,a),c}function L(a,b){b=k.apply(this,arguments);var c=this.config();a="function"!=typeof a&&a||{},a.name||(a.name=a.name||c.name,a.storeName=a.storeName||c.storeName);var d,e=this;if(a.name){var f=a.name===c.name&&e._dbInfo.db,g=f?va.resolve(e._dbInfo.db):s(a).then(function(b){var c=ya[a.name],d=c.forages;c.db=b;for(var e=0;e<d.length;e++)d[e]._dbInfo.db=b;return b});d=a.storeName?g.then(function(b){if(b.objectStoreNames.contains(a.storeName)){var c=b.version+1;o(a);var d=ya[a.name],e=d.forages;b.close();for(var f=0;f<e.length;f++){var g=e[f];g._dbInfo.db=null,g._dbInfo.version=c}return new va(function(b,d){var e=ua.open(a.name,c);e.onerror=function(a){e.result.close(),d(a)},e.onupgradeneeded=function(){e.result.deleteObjectStore(a.storeName)},e.onsuccess=function(){var a=e.result;a.close(),b(a)}}).then(function(a){d.db=a;for(var b=0;b<e.length;b++){var c=e[b];c._dbInfo.db=a,p(c._dbInfo)}}).catch(function(b){throw(q(a,b)||va.resolve()).catch(function(){}),b})}}):g.then(function(b){o(a);var c=ya[a.name],d=c.forages;b.close();for(var e=0;e<d.length;e++){d[e]._dbInfo.db=null}return new va(function(b,c){var d=ua.deleteDatabase(a.name);d.onerror=d.onblocked=function(a){var b=d.result;b&&b.close(),c(a)},d.onsuccess=function(){var a=d.result;a&&a.close(),b(a)}}).then(function(a){c.db=a;for(var b=0;b<d.length;b++)p(d[b]._dbInfo)}).catch(function(b){throw(q(a,b)||va.resolve()).catch(function(){}),b})})}else d=va.reject("Invalid arguments");return h(d,b),d}function M(){return"function"==typeof openDatabase}function N(a){var b,c,d,e,f,g=.75*a.length,h=a.length,i=0;"="===a[a.length-1]&&(g--,"="===a[a.length-2]&&g--);var j=new ArrayBuffer(g),k=new Uint8Array(j);for(b=0;b<h;b+=4)c=Da.indexOf(a[b]),d=Da.indexOf(a[b+1]),e=Da.indexOf(a[b+2]),f=Da.indexOf(a[b+3]),k[i++]=c<<2|d>>4,k[i++]=(15&d)<<4|e>>2,k[i++]=(3&e)<<6|63&f;return j}function O(a){var b,c=new Uint8Array(a),d="";for(b=0;b<c.length;b+=3)d+=Da[c[b]>>2],d+=Da[(3&c[b])<<4|c[b+1]>>4],d+=Da[(15&c[b+1])<<2|c[b+2]>>6],d+=Da[63&c[b+2]];return c.length%3==2?d=d.substring(0,d.length-1)+"=":c.length%3==1&&(d=d.substring(0,d.length-2)+"=="),d}function P(a,b){var c="";if(a&&(c=Ua.call(a)),a&&("[object ArrayBuffer]"===c||a.buffer&&"[object ArrayBuffer]"===Ua.call(a.buffer))){var d,e=Ga;a instanceof ArrayBuffer?(d=a,e+=Ia):(d=a.buffer,"[object Int8Array]"===c?e+=Ka:"[object Uint8Array]"===c?e+=La:"[object Uint8ClampedArray]"===c?e+=Ma:"[object Int16Array]"===c?e+=Na:"[object Uint16Array]"===c?e+=Pa:"[object Int32Array]"===c?e+=Oa:"[object Uint32Array]"===c?e+=Qa:"[object Float32Array]"===c?e+=Ra:"[object Float64Array]"===c?e+=Sa:b(new Error("Failed to get type for BinaryArray"))),b(e+O(d))}else if("[object Blob]"===c){var f=new FileReader;f.onload=function(){var c=Ea+a.type+"~"+O(this.result);b(Ga+Ja+c)},f.readAsArrayBuffer(a)}else try{b(JSON.stringify(a))}catch(c){console.error("Couldn't convert value into a JSON string: ",a),b(null,c)}}function Q(a){if(a.substring(0,Ha)!==Ga)return JSON.parse(a);var b,c=a.substring(Ta),d=a.substring(Ha,Ta);if(d===Ja&&Fa.test(c)){var e=c.match(Fa);b=e[1],c=c.substring(e[0].length)}var f=N(c);switch(d){case Ia:return f;case Ja:return g([f],{type:b});case Ka:return new Int8Array(f);case La:return new Uint8Array(f);case Ma:return new Uint8ClampedArray(f);case Na:return new Int16Array(f);case Pa:return new Uint16Array(f);case Oa:return new Int32Array(f);case Qa:return new Uint32Array(f);case Ra:return new Float32Array(f);case Sa:return new Float64Array(f);default:throw new Error("Unkown type: "+d)}}function R(a,b,c,d){a.executeSql("CREATE TABLE IF NOT EXISTS "+b.storeName+" (id INTEGER PRIMARY KEY, key unique, value)",[],c,d)}function S(a){var b=this,c={db:null};if(a)for(var d in a)c[d]="string"!=typeof a[d]?a[d].toString():a[d];var e=new va(function(a,d){try{c.db=openDatabase(c.name,String(c.version),c.description,c.size)}catch(a){return d(a)}c.db.transaction(function(e){R(e,c,function(){b._dbInfo=c,a()},function(a,b){d(b)})},d)});return c.serializer=Va,e}function T(a,b,c,d,e,f){a.executeSql(c,d,e,function(a,g){g.code===g.SYNTAX_ERR?a.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?",[b.storeName],function(a,h){h.rows.length?f(a,g):R(a,b,function(){a.executeSql(c,d,e,f)},f)},f):f(a,g)},f)}function U(a,b){var c=this;a=j(a);var d=new va(function(b,d){c.ready().then(function(){var e=c._dbInfo;e.db.transaction(function(c){T(c,e,"SELECT * FROM "+e.storeName+" WHERE key = ? LIMIT 1",[a],function(a,c){var d=c.rows.length?c.rows.item(0).value:null;d&&(d=e.serializer.deserialize(d)),b(d)},function(a,b){d(b)})})}).catch(d)});return h(d,b),d}function V(a,b){var c=this,d=new va(function(b,d){c.ready().then(function(){var e=c._dbInfo;e.db.transaction(function(c){T(c,e,"SELECT * FROM "+e.storeName,[],function(c,d){for(var f=d.rows,g=f.length,h=0;h<g;h++){var i=f.item(h),j=i.value;if(j&&(j=e.serializer.deserialize(j)),void 0!==(j=a(j,i.key,h+1)))return void b(j)}b()},function(a,b){d(b)})})}).catch(d)});return h(d,b),d}function W(a,b,c,d){var e=this;a=j(a);var f=new va(function(f,g){e.ready().then(function(){void 0===b&&(b=null);var h=b,i=e._dbInfo;i.serializer.serialize(b,function(b,j){j?g(j):i.db.transaction(function(c){T(c,i,"INSERT OR REPLACE INTO "+i.storeName+" (key, value) VALUES (?, ?)",[a,b],function(){f(h)},function(a,b){g(b)})},function(b){if(b.code===b.QUOTA_ERR){if(d>0)return void f(W.apply(e,[a,h,c,d-1]));g(b)}})})}).catch(g)});return h(f,c),f}function X(a,b,c){return W.apply(this,[a,b,c,1])}function Y(a,b){var c=this;a=j(a);var d=new va(function(b,d){c.ready().then(function(){var e=c._dbInfo;e.db.transaction(function(c){T(c,e,"DELETE FROM "+e.storeName+" WHERE key = ?",[a],function(){b()},function(a,b){d(b)})})}).catch(d)});return h(d,b),d}function Z(a){var b=this,c=new va(function(a,c){b.ready().then(function(){var d=b._dbInfo;d.db.transaction(function(b){T(b,d,"DELETE FROM "+d.storeName,[],function(){a()},function(a,b){c(b)})})}).catch(c)});return h(c,a),c}function $(a){var b=this,c=new va(function(a,c){b.ready().then(function(){var d=b._dbInfo;d.db.transaction(function(b){T(b,d,"SELECT COUNT(key) as c FROM "+d.storeName,[],function(b,c){var d=c.rows.item(0).c;a(d)},function(a,b){c(b)})})}).catch(c)});return h(c,a),c}function _(a,b){var c=this,d=new va(function(b,d){c.ready().then(function(){var e=c._dbInfo;e.db.transaction(function(c){T(c,e,"SELECT key FROM "+e.storeName+" WHERE id = ? LIMIT 1",[a+1],function(a,c){var d=c.rows.length?c.rows.item(0).key:null;b(d)},function(a,b){d(b)})})}).catch(d)});return h(d,b),d}function aa(a){var b=this,c=new va(function(a,c){b.ready().then(function(){var d=b._dbInfo;d.db.transaction(function(b){T(b,d,"SELECT key FROM "+d.storeName,[],function(b,c){for(var d=[],e=0;e<c.rows.length;e++)d.push(c.rows.item(e).key);a(d)},function(a,b){c(b)})})}).catch(c)});return h(c,a),c}function ba(a){return new va(function(b,c){a.transaction(function(d){d.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'",[],function(c,d){for(var e=[],f=0;f<d.rows.length;f++)e.push(d.rows.item(f).name);b({db:a,storeNames:e})},function(a,b){c(b)})},function(a){c(a)})})}function ca(a,b){b=k.apply(this,arguments);var c=this.config();a="function"!=typeof a&&a||{},a.name||(a.name=a.name||c.name,a.storeName=a.storeName||c.storeName);var d,e=this;return d=a.name?new va(function(b){var d;d=a.name===c.name?e._dbInfo.db:openDatabase(a.name,"","",0),b(a.storeName?{db:d,storeNames:[a.storeName]}:ba(d))}).then(function(a){return new va(function(b,c){a.db.transaction(function(d){function e(a){return new va(function(b,c){d.executeSql("DROP TABLE IF EXISTS "+a,[],function(){b()},function(a,b){c(b)})})}for(var f=[],g=0,h=a.storeNames.length;g<h;g++)f.push(e(a.storeNames[g]));va.all(f).then(function(){b()}).catch(function(a){c(a)})},function(a){c(a)})})}):va.reject("Invalid arguments"),h(d,b),d}function da(){try{return"undefined"!=typeof localStorage&&"setItem"in localStorage&&!!localStorage.setItem}catch(a){return!1}}function ea(a,b){var c=a.name+"/";return a.storeName!==b.storeName&&(c+=a.storeName+"/"),c}function fa(){var a="_localforage_support_test";try{return localStorage.setItem(a,!0),localStorage.removeItem(a),!1}catch(a){return!0}}function ga(){return!fa()||localStorage.length>0}function ha(a){var b=this,c={};if(a)for(var d in a)c[d]=a[d];return c.keyPrefix=ea(a,b._defaultConfig),ga()?(b._dbInfo=c,c.serializer=Va,va.resolve()):va.reject()}function ia(a){var b=this,c=b.ready().then(function(){for(var a=b._dbInfo.keyPrefix,c=localStorage.length-1;c>=0;c--){var d=localStorage.key(c);0===d.indexOf(a)&&localStorage.removeItem(d)}});return h(c,a),c}function ja(a,b){var c=this;a=j(a);var d=c.ready().then(function(){var b=c._dbInfo,d=localStorage.getItem(b.keyPrefix+a);return d&&(d=b.serializer.deserialize(d)),d});return h(d,b),d}function ka(a,b){var c=this,d=c.ready().then(function(){for(var b=c._dbInfo,d=b.keyPrefix,e=d.length,f=localStorage.length,g=1,h=0;h<f;h++){var i=localStorage.key(h);if(0===i.indexOf(d)){var j=localStorage.getItem(i);if(j&&(j=b.serializer.deserialize(j)),void 0!==(j=a(j,i.substring(e),g++)))return j}}});return h(d,b),d}function la(a,b){var c=this,d=c.ready().then(function(){var b,d=c._dbInfo;try{b=localStorage.key(a)}catch(a){b=null}return b&&(b=b.substring(d.keyPrefix.length)),b});return h(d,b),d}function ma(a){var b=this,c=b.ready().then(function(){for(var a=b._dbInfo,c=localStorage.length,d=[],e=0;e<c;e++){var f=localStorage.key(e);0===f.indexOf(a.keyPrefix)&&d.push(f.substring(a.keyPrefix.length))}return d});return h(c,a),c}function na(a){var b=this,c=b.keys().then(function(a){return a.length});return h(c,a),c}function oa(a,b){var c=this;a=j(a);var d=c.ready().then(function(){var b=c._dbInfo;localStorage.removeItem(b.keyPrefix+a)});return h(d,b),d}function pa(a,b,c){var d=this;a=j(a);var e=d.ready().then(function(){void 0===b&&(b=null);var c=b;return new va(function(e,f){var g=d._dbInfo;g.serializer.serialize(b,function(b,d){if(d)f(d);else try{localStorage.setItem(g.keyPrefix+a,b),e(c)}catch(a){"QuotaExceededError"!==a.name&&"NS_ERROR_DOM_QUOTA_REACHED"!==a.name||f(a),f(a)}})})});return h(e,c),e}function qa(a,b){if(b=k.apply(this,arguments),a="function"!=typeof a&&a||{},!a.name){var c=this.config();a.name=a.name||c.name,a.storeName=a.storeName||c.storeName}var d,e=this;return d=a.name?new va(function(b){b(a.storeName?ea(a,e._defaultConfig):a.name+"/")}).then(function(a){for(var b=localStorage.length-1;b>=0;b--){var c=localStorage.key(b);0===c.indexOf(a)&&localStorage.removeItem(c)}}):va.reject("Invalid arguments"),h(d,b),d}function ra(a,b){a[b]=function(){var c=arguments;return a.ready().then(function(){return a[b].apply(a,c)})}}function sa(){for(var a=1;a<arguments.length;a++){var b=arguments[a];if(b)for(var c in b)b.hasOwnProperty(c)&&($a(b[c])?arguments[0][c]=b[c].slice():arguments[0][c]=b[c])}return arguments[0]}var ta="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(a){return typeof a}:function(a){return a&&"function"==typeof Symbol&&a.constructor===Symbol&&a!==Symbol.prototype?"symbol":typeof a},ua=e();"undefined"==typeof Promise&&a(3);var va=Promise,wa="local-forage-detect-blob-support",xa=void 0,ya={},za=Object.prototype.toString,Aa="readonly",Ba="readwrite",Ca={_driver:"asyncStorage",_initStorage:C,_support:f(),iterate:E,getItem:D,setItem:F,removeItem:G,clear:H,length:I,key:J,keys:K,dropInstance:L},Da="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",Ea="~~local_forage_type~",Fa=/^~~local_forage_type~([^~]+)~/,Ga="__lfsc__:",Ha=Ga.length,Ia="arbf",Ja="blob",Ka="si08",La="ui08",Ma="uic8",Na="si16",Oa="si32",Pa="ur16",Qa="ui32",Ra="fl32",Sa="fl64",Ta=Ha+Ia.length,Ua=Object.prototype.toString,Va={serialize:P,deserialize:Q,stringToBuffer:N,bufferToString:O},Wa={_driver:"webSQLStorage",_initStorage:S,_support:M(),iterate:V,getItem:U,setItem:X,removeItem:Y,clear:Z,length:$,key:_,keys:aa,dropInstance:ca},Xa={_driver:"localStorageWrapper",_initStorage:ha,_support:da(),iterate:ka,getItem:ja,setItem:pa,removeItem:oa,clear:ia,length:na,key:la,keys:ma,dropInstance:qa},Ya=function(a,b){return a===b||"number"==typeof a&&"number"==typeof b&&isNaN(a)&&isNaN(b)},Za=function(a,b){for(var c=a.length,d=0;d<c;){if(Ya(a[d],b))return!0;d++}return!1},$a=Array.isArray||function(a){return"[object Array]"===Object.prototype.toString.call(a)},_a={},ab={},bb={INDEXEDDB:Ca,WEBSQL:Wa,LOCALSTORAGE:Xa},cb=[bb.INDEXEDDB._driver,bb.WEBSQL._driver,bb.LOCALSTORAGE._driver],db=["dropInstance"],eb=["clear","getItem","iterate","key","keys","length","removeItem","setItem"].concat(db),fb={description:"",driver:cb.slice(),name:"localforage",size:4980736,storeName:"keyvaluepairs",version:1},gb=function(){function a(b){d(this,a);for(var c in bb)if(bb.hasOwnProperty(c)){var e=bb[c],f=e._driver;this[c]=f,_a[f]||this.defineDriver(e)}this._defaultConfig=sa({},fb),this._config=sa({},this._defaultConfig,b),this._driverSet=null,this._initDriver=null,this._ready=!1,this._dbInfo=null,this._wrapLibraryMethodsWithReady(),this.setDriver(this._config.driver).catch(function(){})}return a.prototype.config=function(a){if("object"===(void 0===a?"undefined":ta(a))){if(this._ready)return new Error("Can't call config() after localforage has been used.");for(var b in a){if("storeName"===b&&(a[b]=a[b].replace(/\W/g,"_")),"version"===b&&"number"!=typeof a[b])return new Error("Database version must be a number.");this._config[b]=a[b]}return!("driver"in a&&a.driver)||this.setDriver(this._config.driver)}return"string"==typeof a?this._config[a]:this._config},a.prototype.defineDriver=function(a,b,c){var d=new va(function(b,c){try{var d=a._driver,e=new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");if(!a._driver)return void c(e);for(var f=eb.concat("_initStorage"),g=0,i=f.length;g<i;g++){var j=f[g];if((!Za(db,j)||a[j])&&"function"!=typeof a[j])return void c(e)}(function(){for(var b=function(a){return function(){var b=new Error("Method "+a+" is not implemented by the current driver"),c=va.reject(b);return h(c,arguments[arguments.length-1]),c}},c=0,d=db.length;c<d;c++){var e=db[c];a[e]||(a[e]=b(e))}})();var k=function(c){_a[d]&&console.info("Redefining LocalForage driver: "+d),_a[d]=a,ab[d]=c,b()};"_support"in a?a._support&&"function"==typeof a._support?a._support().then(k,c):k(!!a._support):k(!0)}catch(a){c(a)}});return i(d,b,c),d},a.prototype.driver=function(){return this._driver||null},a.prototype.getDriver=function(a,b,c){var d=_a[a]?va.resolve(_a[a]):va.reject(new Error("Driver not found."));return i(d,b,c),d},a.prototype.getSerializer=function(a){var b=va.resolve(Va);return i(b,a),b},a.prototype.ready=function(a){var b=this,c=b._driverSet.then(function(){return null===b._ready&&(b._ready=b._initDriver()),b._ready});return i(c,a,a),c},a.prototype.setDriver=function(a,b,c){function d(){g._config.driver=g.driver()}function e(a){return g._extend(a),d(),g._ready=g._initStorage(g._config),g._ready}function f(a){return function(){function b(){for(;c<a.length;){var f=a[c];return c++,g._dbInfo=null,g._ready=null,g.getDriver(f).then(e).catch(b)}d();var h=new Error("No available storage method found.");return g._driverSet=va.reject(h),g._driverSet}var c=0;return b()}}var g=this;$a(a)||(a=[a]);var h=this._getSupportedDrivers(a),j=null!==this._driverSet?this._driverSet.catch(function(){return va.resolve()}):va.resolve();return this._driverSet=j.then(function(){var a=h[0];return g._dbInfo=null,g._ready=null,g.getDriver(a).then(function(a){g._driver=a._driver,d(),g._wrapLibraryMethodsWithReady(),g._initDriver=f(h)})}).catch(function(){d();var a=new Error("No available storage method found.");return g._driverSet=va.reject(a),g._driverSet}),i(this._driverSet,b,c),this._driverSet},a.prototype.supports=function(a){return!!ab[a]},a.prototype._extend=function(a){sa(this,a)},a.prototype._getSupportedDrivers=function(a){for(var b=[],c=0,d=a.length;c<d;c++){var e=a[c];this.supports(e)&&b.push(e)}return b},a.prototype._wrapLibraryMethodsWithReady=function(){for(var a=0,b=eb.length;a<b;a++)ra(this,eb[a])},a.prototype.createInstance=function(b){return new a(b)},a}(),hb=new gb;b.exports=hb},{3:3}]},{},[4])(4)});
}).toString());



EXT_LIB_SCRIPTS.push((function lib_script_3 () {
"use strict";

// PARSING =============================================================================================================
globalThis.Parser = {};

Parser._parse_aToB = function (abMap, a, fallback) {
	if (a === undefined || a === null) throw new TypeError("undefined or null object passed to parser");
	if (typeof a === "string") a = a.trim();
	if (abMap[a] !== undefined) return abMap[a];
	return fallback !== undefined ? fallback : a;
};

Parser._parse_bToA = function (abMap, b, fallback) {
	if (b === undefined || b === null) throw new TypeError("undefined or null object passed to parser");
	if (typeof b === "string") b = b.trim();
	for (const v in abMap) {
		if (!abMap.hasOwnProperty(v)) continue;
		if (abMap[v] === b) return v;
	}
	return fallback !== undefined ? fallback : b;
};

Parser.attrChooseToFull = function (attList) {
	if (attList.length === 1) return `${Parser.attAbvToFull(attList[0])} modifier`;
	else {
		const attsTemp = [];
		for (let i = 0; i < attList.length; ++i) {
			attsTemp.push(Parser.attAbvToFull(attList[i]));
		}
		return `${attsTemp.join(" or ")} modifier (your choice)`;
	}
};

Parser.numberToText = function (number) {
	if (number == null) throw new TypeError(`undefined or null object passed to parser`);
	if (Math.abs(number) >= 100) return `${number}`;

	function getAsText (num) {
		const abs = Math.abs(num);
		switch (abs) {
			case 0: return "zero";
			case 1: return "one";
			case 2: return "two";
			case 3: return "three";
			case 4: return "four";
			case 5: return "five";
			case 6: return "six";
			case 7: return "seven";
			case 8: return "eight";
			case 9: return "nine";
			case 10: return "ten";
			case 11: return "eleven";
			case 12: return "twelve";
			case 13: return "thirteen";
			case 14: return "fourteen";
			case 15: return "fifteen";
			case 16: return "sixteen";
			case 17: return "seventeen";
			case 18: return "eighteen";
			case 19: return "nineteen";
			case 20: return "twenty";
			case 30: return "thirty";
			case 40: return "forty";
			case 50: return "fiddy"; // :^)
			case 60: return "sixty";
			case 70: return "seventy";
			case 80: return "eighty";
			case 90: return "ninety";
			default: {
				const str = String(abs);
				return `${getAsText(Number(`${str[0]}0`))}-${getAsText(Number(str[1]))}`;
			}
		}
	}
	return `${number < 0 ? "negative " : ""}${getAsText(number)}`;
};

Parser.textToNumber = function (str) {
	str = str.trim().toLowerCase();
	if (!isNaN(str)) return Number(str);
	switch (str) {
		case "zero": return 0;
		case "one": case "a": case "an": return 1;
		case "two": case "double": return 2;
		case "three": case "triple": return 3;
		case "four": case "quadruple": return 4;
		case "five": return 5;
		case "six": return 6;
		case "seven": return 7;
		case "eight": return 8;
		case "nine": return 9;
		case "ten": return 10;
		case "eleven": return 11;
		case "twelve": return 12;
		case "thirteen": return 13;
		case "fourteen": return 14;
		case "fifteen": return 15;
		case "sixteen": return 16;
		case "seventeen": return 17;
		case "eighteen": return 18;
		case "nineteen": return 19;
		case "twenty": return 20;
		case "thirty": return 30;
		case "forty": return 40;
		case "fifty": case "fiddy": return 50;
		case "sixty": return 60;
		case "seventy": return 70;
		case "eighty": return 80;
		case "ninety": return 90;
	}
	return NaN;
};

Parser.numberToVulgar = function (number, {isFallbackOnFractional = true} = {}) {
	const isNeg = number < 0;
	const spl = `${number}`.replace(/^-/, "").split(".");
	if (spl.length === 1) return number;

	let preDot = spl[0] === "0" ? "" : spl[0];
	if (isNeg) preDot = `-${preDot}`;

	switch (spl[1]) {
		case "125": return `${preDot}⅛`;
		case "2": return `${preDot}⅕`;
		case "25": return `${preDot}¼`;
		case "375": return `${preDot}⅜`;
		case "4": return `${preDot}⅖`;
		case "5": return `${preDot}½`;
		case "6": return `${preDot}⅗`;
		case "625": return `${preDot}⅝`;
		case "75": return `${preDot}¾`;
		case "8": return `${preDot}⅘`;
		case "875": return `${preDot}⅞`;

		default: {
			// Handle recursive
			const asNum = Number(`0.${spl[1]}`);

			if (asNum.toFixed(2) === (1 / 3).toFixed(2)) return `${preDot}⅓`;
			if (asNum.toFixed(2) === (2 / 3).toFixed(2)) return `${preDot}⅔`;

			if (asNum.toFixed(2) === (1 / 6).toFixed(2)) return `${preDot}⅙`;
			if (asNum.toFixed(2) === (5 / 6).toFixed(2)) return `${preDot}⅚`;
		}
	}

	return isFallbackOnFractional ? Parser.numberToFractional(number) : null;
};

Parser.vulgarToNumber = function (str) {
	const [, leading = "0", vulgar = ""] = /^(\d+)?([⅛¼⅜½⅝¾⅞⅓⅔⅙⅚])?$/.exec(str) || [];
	let out = Number(leading);
	switch (vulgar) {
		case "⅛": out += 0.125; break;
		case "¼": out += 0.25; break;
		case "⅜": out += 0.375; break;
		case "½": out += 0.5; break;
		case "⅝": out += 0.625; break;
		case "¾": out += 0.75; break;
		case "⅞": out += 0.875; break;
		case "⅓": out += 1 / 3; break;
		case "⅔": out += 2 / 3; break;
		case "⅙": out += 1 / 6; break;
		case "⅚": out += 5 / 6; break;
		case "": break;
		default: throw new Error(`Unhandled vulgar part "${vulgar}"`);
	}
	return out;
};

Parser.numberToSuperscript = function (number) {
	return `${number}`.split("").map(c => isNaN(c) ? c : Parser._NUMBERS_SUPERSCRIPT[Number(c)]).join("");
};
Parser._NUMBERS_SUPERSCRIPT = "⁰¹²³⁴⁵⁶⁷⁸⁹";

Parser.numberToSubscript = function (number) {
	return `${number}`.split("").map(c => isNaN(c) ? c : Parser._NUMBERS_SUBSCRIPT[Number(c)]).join("");
};
Parser._NUMBERS_SUBSCRIPT = "₀₁₂₃₄₅₆₇₈₉";

Parser._greatestCommonDivisor = function (a, b) {
	if (b < Number.EPSILON) return a;
	return Parser._greatestCommonDivisor(b, Math.floor(a % b));
};
Parser.numberToFractional = function (number) {
	const len = number.toString().length - 2;
	let denominator = 10 ** len;
	let numerator = number * denominator;
	const divisor = Parser._greatestCommonDivisor(numerator, denominator);
	numerator = Math.floor(numerator / divisor);
	denominator = Math.floor(denominator / divisor);

	return denominator === 1 ? String(numerator) : `${Math.floor(numerator)}/${Math.floor(denominator)}`;
};

Parser.ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

Parser.attAbvToFull = function (abv) {
	return Parser._parse_aToB(Parser.ATB_ABV_TO_FULL, abv);
};

Parser.attFullToAbv = function (full) {
	return Parser._parse_bToA(Parser.ATB_ABV_TO_FULL, full);
};

Parser.sizeAbvToFull = function (abv) {
	return Parser._parse_aToB(Parser.SIZE_ABV_TO_FULL, abv);
};

Parser.getAbilityModNumber = function (abilityScore) {
	return Math.floor((abilityScore - 10) / 2);
};

Parser.getAbilityModifier = function (abilityScore) {
	let modifier = Parser.getAbilityModNumber(abilityScore);
	if (modifier >= 0) modifier = `+${modifier}`;
	return `${modifier}`;
};

Parser.getSpeedString = (ent, {isMetric = false, isSkipZeroWalk = false} = {}) => {
	if (ent.speed == null) return "\u2014";

	const unit = isMetric ? Parser.metric.getMetricUnit({originalUnit: "ft.", isShortForm: true}) : "ft.";
	if (typeof ent.speed === "object") {
		const stack = [];
		let joiner = ", ";

		Parser.SPEED_MODES
			.filter(mode => !ent.speed.hidden?.includes(mode))
			.forEach(mode => Parser._getSpeedString_addSpeedMode({ent, prop: mode, stack, isMetric, isSkipZeroWalk, unit}));

		if (ent.speed.choose && !ent.speed.hidden?.includes("choose")) {
			joiner = "; ";
			stack.push(`${ent.speed.choose.from.sort().joinConjunct(", ", " or ")} ${ent.speed.choose.amount} ${unit}${ent.speed.choose.note ? ` ${ent.speed.choose.note}` : ""}`);
		}

		return stack.join(joiner) + (ent.speed.note ? ` ${ent.speed.note}` : "");
	}

	return (isMetric ? Parser.metric.getMetricNumber({originalValue: ent.speed, originalUnit: Parser.UNT_FEET}) : ent.speed)
		+ (ent.speed === "Varies" ? "" : ` ${unit} `);
};
Parser._getSpeedString_addSpeedMode = ({ent, prop, stack, isMetric, isSkipZeroWalk, unit}) => {
	if (ent.speed[prop] || (!isSkipZeroWalk && prop === "walk")) Parser._getSpeedString_addSpeed({prop, speed: ent.speed[prop] || 0, isMetric, unit, stack});
	if (ent.speed.alternate && ent.speed.alternate[prop]) ent.speed.alternate[prop].forEach(speed => Parser._getSpeedString_addSpeed({prop, speed, isMetric, unit, stack}));
};
Parser._getSpeedString_addSpeed = ({prop, speed, isMetric, unit, stack}) => {
	const ptName = prop === "walk" ? "" : `${prop} `;
	const ptValue = Parser._getSpeedString_getVal({prop, speed, isMetric});
	const ptUnit = speed === true ? "" : ` ${unit}`;
	const ptCondition = Parser._getSpeedString_getCondition({speed});
	stack.push([ptName, ptValue, ptUnit, ptCondition].join(""));
};
Parser._getSpeedString_getVal = ({prop, speed, isMetric}) => {
	if (speed === true && prop !== "walk") return "equal to your walking speed";

	const num = speed === true
		? 0
		: speed.number != null ? speed.number : speed;

	return isMetric ? Parser.metric.getMetricNumber({originalValue: num, originalUnit: Parser.UNT_FEET}) : num;
};
Parser._getSpeedString_getCondition = ({speed}) => speed.condition ? ` ${Renderer.get().render(speed.condition)}` : "";

Parser.SPEED_MODES = ["walk", "burrow", "climb", "fly", "swim"];

Parser.SPEED_TO_PROGRESSIVE = {
	"walk": "walking",
	"burrow": "burrowing",
	"climb": "climbing",
	"fly": "flying",
	"swim": "swimming",
};

Parser.speedToProgressive = function (prop) {
	return Parser._parse_aToB(Parser.SPEED_TO_PROGRESSIVE, prop);
};

Parser._addCommas = function (intNum) {
	return `${intNum}`.replace(/(\d)(?=(\d{3})+$)/g, "$1,");
};

Parser.raceCreatureTypesToFull = function (creatureTypes) {
	const hasSubOptions = creatureTypes.some(it => it.choose);
	return creatureTypes
		.map(it => {
			if (!it.choose) return Parser.monTypeToFullObj(it).asText;
			return [...it.choose]
				.sort(SortUtil.ascSortLower)
				.map(sub => Parser.monTypeToFullObj(sub).asText)
				.joinConjunct(", ", " or ");
		})
		.joinConjunct(hasSubOptions ? "; " : ", ", " and ");
};

Parser.crToXp = function (cr, {isDouble = false} = {}) {
	if (cr != null && cr.xp) return Parser._addCommas(`${isDouble ? cr.xp * 2 : cr.xp}`);

	const toConvert = cr ? (cr.cr || cr) : null;
	if (toConvert === "Unknown" || toConvert == null || !Parser.XP_CHART_ALT[toConvert]) return "Unknown";
	if (toConvert === "0") return "0 or 10";
	const xp = Parser.XP_CHART_ALT[toConvert];
	return Parser._addCommas(`${isDouble ? 2 * xp : xp}`);
};

Parser.crToXpNumber = function (cr) {
	if (cr != null && cr.xp) return cr.xp;
	const toConvert = cr ? (cr.cr || cr) : cr;
	if (toConvert === "Unknown" || toConvert == null) return null;
	return Parser.XP_CHART_ALT[toConvert] ?? null;
};

Parser.LEVEL_TO_XP_EASY = [0, 25, 50, 75, 125, 250, 300, 350, 450, 550, 600, 800, 1000, 1100, 1250, 1400, 1600, 2000, 2100, 2400, 2800];
Parser.LEVEL_TO_XP_MEDIUM = [0, 50, 100, 150, 250, 500, 600, 750, 900, 1100, 1200, 1600, 2000, 2200, 2500, 2800, 3200, 3900, 4100, 4900, 5700];
Parser.LEVEL_TO_XP_HARD = [0, 75, 150, 225, 375, 750, 900, 1100, 1400, 1600, 1900, 2400, 3000, 3400, 3800, 4300, 4800, 5900, 6300, 7300, 8500];
Parser.LEVEL_TO_XP_DEADLY = [0, 100, 200, 400, 500, 1100, 1400, 1700, 2100, 2400, 2800, 3600, 4500, 5100, 5700, 6400, 7200, 8800, 9500, 10900, 12700];
Parser.LEVEL_TO_XP_DAILY = [0, 300, 600, 1200, 1700, 3500, 4000, 5000, 6000, 7500, 9000, 10500, 11500, 13500, 15000, 18000, 20000, 25000, 27000, 30000, 40000];

Parser.LEVEL_XP_REQUIRED = [0, 300, 900, 2700, 6500, 14000, 23000, 34000, 48000, 64000, 85000, 100000, 120000, 140000, 165000, 195000, 225000, 265000, 305000, 355000];

Parser.CRS = ["0", "1/8", "1/4", "1/2", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30"];

Parser.levelToXpThreshold = function (level) {
	return [Parser.LEVEL_TO_XP_EASY[level], Parser.LEVEL_TO_XP_MEDIUM[level], Parser.LEVEL_TO_XP_HARD[level], Parser.LEVEL_TO_XP_DEADLY[level]];
};

Parser.isValidCr = function (cr) {
	return Parser.CRS.includes(cr);
};

Parser.crToNumber = function (cr) {
	if (cr === "Unknown" || cr === "\u2014" || cr == null) return VeCt.CR_UNKNOWN;
	if (cr.cr) return Parser.crToNumber(cr.cr);

	const parts = cr.trim().split("/");

	if (parts.length === 1) {
		if (isNaN(parts[0])) return VeCt.CR_CUSTOM;
		return Number(parts[0]);
	} else if (parts.length === 2) {
		if (isNaN(parts[0]) || isNaN(Number(parts[1]))) return VeCt.CR_CUSTOM;
		return Number(parts[0]) / Number(parts[1]);
	} else return 0;
};

Parser.numberToCr = function (number, safe) {
	// avoid dying if already-converted number is passed in
	if (safe && typeof number === "string" && Parser.CRS.includes(number)) return number;

	if (number == null) return "Unknown";

	return Parser.numberToFractional(number);
};

Parser.crToPb = function (cr) {
	if (cr === "Unknown" || cr == null) return 0;
	cr = cr.cr || cr;
	if (Parser.crToNumber(cr) < 5) return 2;
	return Math.ceil(cr / 4) + 1;
};

Parser.levelToPb = function (level) {
	if (!level) return 2;
	return Math.ceil(level / 4) + 1;
};

Parser.SKILL_TO_ATB_ABV = {
	"athletics": "str",
	"acrobatics": "dex",
	"sleight of hand": "dex",
	"stealth": "dex",
	"arcana": "int",
	"history": "int",
	"investigation": "int",
	"nature": "int",
	"religion": "int",
	"animal handling": "wis",
	"insight": "wis",
	"medicine": "wis",
	"perception": "wis",
	"survival": "wis",
	"deception": "cha",
	"intimidation": "cha",
	"performance": "cha",
	"persuasion": "cha",
};

Parser.skillToAbilityAbv = function (skill) {
	return Parser._parse_aToB(Parser.SKILL_TO_ATB_ABV, skill);
};

Parser.SKILL_TO_SHORT = {
	"athletics": "ath",
	"acrobatics": "acro",
	"sleight of hand": "soh",
	"stealth": "slth",
	"arcana": "arc",
	"history": "hist",
	"investigation": "invn",
	"nature": "natr",
	"religion": "reli",
	"animal handling": "hndl",
	"insight": "ins",
	"medicine": "med",
	"perception": "perp",
	"survival": "surv",
	"deception": "decp",
	"intimidation": "intm",
	"performance": "perf",
	"persuasion": "pers",
};

Parser.skillToShort = function (skill) {
	return Parser._parse_aToB(Parser.SKILL_TO_SHORT, skill);
};

Parser.LANGUAGES_STANDARD = [
	"Common",
	"Dwarvish",
	"Elvish",
	"Giant",
	"Gnomish",
	"Goblin",
	"Halfling",
	"Orc",
];

Parser.LANGUAGES_EXOTIC = [
	"Abyssal",
	"Aquan",
	"Auran",
	"Celestial",
	"Draconic",
	"Deep Speech",
	"Ignan",
	"Infernal",
	"Primordial",
	"Sylvan",
	"Terran",
	"Undercommon",
];

Parser.LANGUAGES_SECRET = [
	"Druidic",
	"Thieves' cant",
];

Parser.LANGUAGES_ALL = [
	...Parser.LANGUAGES_STANDARD,
	...Parser.LANGUAGES_EXOTIC,
	...Parser.LANGUAGES_SECRET,
].sort();

Parser.acToFull = function (ac, renderer) {
	if (typeof ac === "string") return ac; // handle classic format

	renderer = renderer || Renderer.get();

	let stack = "";
	let inBraces = false;
	for (let i = 0; i < ac.length; ++i) {
		const cur = ac[i];
		const nxt = ac[i + 1];

		if (cur.special != null) {
			if (inBraces) inBraces = false;

			stack += cur.special;
		} else if (cur.ac) {
			const isNxtBraces = nxt && nxt.braces;

			if (!inBraces && cur.braces) {
				stack += "(";
				inBraces = true;
			}

			stack += cur.ac;

			if (cur.from) {
				// always brace nested braces
				if (cur.braces) {
					stack += " (";
				} else {
					stack += inBraces ? "; " : " (";
				}

				inBraces = true;

				stack += cur.from.map(it => renderer.render(it)).join(", ");

				if (cur.braces) {
					stack += ")";
				} else if (!isNxtBraces) {
					stack += ")";
					inBraces = false;
				}
			}

			if (cur.condition) stack += ` ${renderer.render(cur.condition)}`;

			if (inBraces && !isNxtBraces) {
				stack += ")";
				inBraces = false;
			}
		} else {
			stack += cur;
		}

		if (nxt) {
			if (nxt.braces) {
				stack += inBraces ? "; " : " (";
				inBraces = true;
			} else stack += ", ";
		}
	}
	if (inBraces) stack += ")";

	return stack.trim();
};

Parser.MONSTER_COUNT_TO_XP_MULTIPLIER = [1, 1.5, 2, 2, 2, 2, 2.5, 2.5, 2.5, 2.5, 3, 3, 3, 3, 4];
Parser.numMonstersToXpMult = function (num, playerCount = 3) {
	const baseVal = (() => {
		if (num >= Parser.MONSTER_COUNT_TO_XP_MULTIPLIER.length) return 4;
		return Parser.MONSTER_COUNT_TO_XP_MULTIPLIER[num - 1];
	})();

	if (playerCount < 3) return baseVal >= 3 ? baseVal + 1 : baseVal + 0.5;
	else if (playerCount > 5) {
		return baseVal === 4 ? 3 : baseVal - 0.5;
	} else return baseVal;
};

Parser.armorFullToAbv = function (armor) {
	return Parser._parse_bToA(Parser.ARMOR_ABV_TO_FULL, armor);
};

Parser.weaponFullToAbv = function (weapon) {
	return Parser._parse_bToA(Parser.WEAPON_ABV_TO_FULL, weapon);
};

Parser._getSourceStringFromSource = function (source) {
	if (source && source.source) return source.source;
	return source;
};
Parser._buildSourceCache = function (dict) {
	const out = {};
	Object.entries(dict).forEach(([k, v]) => out[k.toLowerCase()] = v);
	return out;
};
Parser._sourceJsonCache = null;
Parser.hasSourceJson = function (source) {
	Parser._sourceJsonCache = Parser._sourceJsonCache || Parser._buildSourceCache(Object.keys(Parser.SOURCE_JSON_TO_FULL).mergeMap(k => ({[k]: k})));
	return !!Parser._sourceJsonCache[source.toLowerCase()];
};
Parser._sourceFullCache = null;
Parser.hasSourceFull = function (source) {
	Parser._sourceFullCache = Parser._sourceFullCache || Parser._buildSourceCache(Parser.SOURCE_JSON_TO_FULL);
	return !!Parser._sourceFullCache[source.toLowerCase()];
};
Parser._sourceAbvCache = null;
Parser.hasSourceAbv = function (source) {
	Parser._sourceAbvCache = Parser._sourceAbvCache || Parser._buildSourceCache(Parser.SOURCE_JSON_TO_ABV);
	return !!Parser._sourceAbvCache[source.toLowerCase()];
};
Parser._sourceDateCache = null;
Parser.hasSourceDate = function (source) {
	Parser._sourceDateCache = Parser._sourceDateCache || Parser._buildSourceCache(Parser.SOURCE_JSON_TO_DATE);
	return !!Parser._sourceDateCache[source.toLowerCase()];
};
Parser.sourceJsonToJson = function (source) {
	source = Parser._getSourceStringFromSource(source);
	if (Parser.hasSourceJson(source)) return Parser._sourceJsonCache[source.toLowerCase()];
	if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source)) return PrereleaseUtil.sourceJsonToSource(source).json;
	if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(source)) return BrewUtil2.sourceJsonToSource(source).json;
	return source;
};
Parser.sourceJsonToFull = function (source) {
	source = Parser._getSourceStringFromSource(source);
	if (Parser.hasSourceFull(source)) return Parser._sourceFullCache[source.toLowerCase()].replace(/'/g, "\u2019");
	if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source)) return PrereleaseUtil.sourceJsonToFull(source).replace(/'/g, "\u2019");
	if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(source)) return BrewUtil2.sourceJsonToFull(source).replace(/'/g, "\u2019");
	return Parser._parse_aToB(Parser.SOURCE_JSON_TO_FULL, source).replace(/'/g, "\u2019");
};
Parser.sourceJsonToFullCompactPrefix = function (source) {
	return Parser.sourceJsonToFull(source)
		.replace(Parser.UA_PREFIX, Parser.UA_PREFIX_SHORT)
		.replace(/^Unearthed Arcana (\d+): /, "UA$1: ")
		.replace(Parser.AL_PREFIX, Parser.AL_PREFIX_SHORT)
		.replace(Parser.PS_PREFIX, Parser.PS_PREFIX_SHORT);
};
Parser.sourceJsonToAbv = function (source) {
	source = Parser._getSourceStringFromSource(source);
	if (Parser.hasSourceAbv(source)) return Parser._sourceAbvCache[source.toLowerCase()];
	if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source)) return PrereleaseUtil.sourceJsonToAbv(source);
	if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(source)) return BrewUtil2.sourceJsonToAbv(source);
	return Parser._parse_aToB(Parser.SOURCE_JSON_TO_ABV, source);
};
Parser.sourceJsonToDate = function (source) {
	source = Parser._getSourceStringFromSource(source);
	if (Parser.hasSourceDate(source)) return Parser._sourceDateCache[source.toLowerCase()];
	if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source)) return PrereleaseUtil.sourceJsonToDate(source);
	if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(source)) return BrewUtil2.sourceJsonToDate(source);
	return Parser._parse_aToB(Parser.SOURCE_JSON_TO_DATE, source, null);
};

Parser.sourceJsonToColor = function (source) {
	return `source${Parser.sourceJsonToAbv(source)}`;
};

Parser.sourceJsonToStyle = function (source) {
	source = Parser._getSourceStringFromSource(source);
	if (Parser.hasSourceJson(source)) return "";
	if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source)) return PrereleaseUtil.sourceJsonToStyle(source);
	if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(source)) return BrewUtil2.sourceJsonToStyle(source);
	return "";
};

Parser.sourceJsonToStylePart = function (source) {
	source = Parser._getSourceStringFromSource(source);
	if (Parser.hasSourceJson(source)) return "";
	if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source)) return PrereleaseUtil.sourceJsonToStylePart(source);
	if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(source)) return BrewUtil2.sourceJsonToStylePart(source);
	return "";
};

Parser.stringToSlug = function (str) {
	return str.trim().toLowerCase().toAscii().replace(/[^\w ]+/g, "").replace(/ +/g, "-");
};

Parser.stringToCasedSlug = function (str) {
	return str.toAscii().replace(/[^\w ]+/g, "").replace(/ +/g, "-");
};

Parser.ITEM_SPELLCASTING_FOCUS_CLASSES = ["Artificer", "Bard", "Cleric", "Druid", "Paladin", "Ranger", "Sorcerer", "Warlock", "Wizard"];

Parser.itemValueToFull = function (item, opts = {isShortForm: false, isSmallUnits: false}) {
	return Parser._moneyToFull(item, "value", "valueMult", opts);
};

Parser.itemValueToFullMultiCurrency = function (item, opts = {isShortForm: false, isSmallUnits: false}) {
	return Parser._moneyToFullMultiCurrency(item, "value", "valueMult", opts);
};

Parser.itemVehicleCostsToFull = function (item, isShortForm) {
	return {
		travelCostFull: Parser._moneyToFull(item, "travelCost", "travelCostMult", {isShortForm}),
		shippingCostFull: Parser._moneyToFull(item, "shippingCost", "shippingCostMult", {isShortForm}),
	};
};

Parser.spellComponentCostToFull = function (item, isShortForm) {
	return Parser._moneyToFull(item, "cost", "costMult", {isShortForm});
};

Parser.vehicleCostToFull = function (item, isShortForm) {
	return Parser._moneyToFull(item, "cost", "costMult", {isShortForm});
};

Parser._moneyToFull = function (it, prop, propMult, opts = {isShortForm: false, isSmallUnits: false}) {
	if (it[prop] == null && it[propMult] == null) return "";
	if (it[prop] != null) {
		const {coin, mult} = Parser.getCurrencyAndMultiplier(it[prop], it.currencyConversion);
		return `${(it[prop] * mult).toLocaleString(undefined, {maximumFractionDigits: 5})}${opts.isSmallUnits ? `<span class="small ml-1">${coin}</span>` : ` ${coin}`}`;
	} else if (it[propMult] != null) return opts.isShortForm ? `×${it[propMult]}` : `base value ×${it[propMult]}`;
	return "";
};

Parser._moneyToFullMultiCurrency = function (it, prop, propMult, {isShortForm, multiplier} = {}) {
	if (it[prop]) {
		const conversionTable = Parser.getCurrencyConversionTable(it.currencyConversion);

		const simplified = it.currencyConversion
			? CurrencyUtil.doSimplifyCoins(
				{
					// Assume the e.g. item's value is in the lowest available denomination
					[conversionTable[0]?.coin || "cp"]: it[prop] * (multiplier ?? conversionTable[0]?.mult ?? 1),
				},
				{
					currencyConversionId: it.currencyConversion,
				},
			)
			: CurrencyUtil.doSimplifyCoins({
				cp: it[prop] * (multiplier ?? 1),
			});

		return [...conversionTable]
			.reverse()
			.filter(meta => simplified[meta.coin])
			.map(meta => `${simplified[meta.coin].toLocaleString(undefined, {maximumFractionDigits: 5})} ${meta.coin}`)
			.join(", ");
	}

	if (it[propMult]) return isShortForm ? `×${it[propMult]}` : `base value ×${it[propMult]}`;

	return "";
};

Parser.DEFAULT_CURRENCY_CONVERSION_TABLE = [
	{
		coin: "cp",
		mult: 1,
	},
	{
		coin: "sp",
		mult: 0.1,
	},
	{
		coin: "gp",
		mult: 0.01,
		isFallback: true,
	},
];
Parser.FULL_CURRENCY_CONVERSION_TABLE = [
	{
		coin: "cp",
		mult: 1,
	},
	{
		coin: "sp",
		mult: 0.1,
	},
	{
		coin: "ep",
		mult: 0.02,
	},
	{
		coin: "gp",
		mult: 0.01,
		isFallback: true,
	},
	{
		coin: "pp",
		mult: 0.001,
	},
];
Parser.getCurrencyConversionTable = function (currencyConversionId) {
	const fromPrerelease = currencyConversionId ? PrereleaseUtil.getMetaLookup("currencyConversions")?.[currencyConversionId] : null;
	const fromBrew = currencyConversionId ? BrewUtil2.getMetaLookup("currencyConversions")?.[currencyConversionId] : null;
	const conversionTable = fromPrerelease?.length
		? fromPrerelease
		: fromBrew?.length
			? fromBrew
			: Parser.DEFAULT_CURRENCY_CONVERSION_TABLE;
	if (conversionTable !== Parser.DEFAULT_CURRENCY_CONVERSION_TABLE) conversionTable.sort((a, b) => SortUtil.ascSort(b.mult, a.mult));
	return conversionTable;
};
Parser.getCurrencyAndMultiplier = function (value, currencyConversionId) {
	const conversionTable = Parser.getCurrencyConversionTable(currencyConversionId);

	if (!value) return conversionTable.find(it => it.isFallback) || conversionTable[0];
	if (conversionTable.length === 1) return conversionTable[0];
	if (!Number.isInteger(value) && value < conversionTable[0].mult) return conversionTable[0];

	for (let i = conversionTable.length - 1; i >= 0; --i) {
		if (Number.isInteger(value * conversionTable[i].mult)) return conversionTable[i];
	}

	return conversionTable.last();
};

Parser.COIN_ABVS = ["cp", "sp", "ep", "gp", "pp"];
Parser.COIN_ABV_TO_FULL = {
	"cp": "copper pieces",
	"sp": "silver pieces",
	"ep": "electrum pieces",
	"gp": "gold pieces",
	"pp": "platinum pieces",
};
Parser.COIN_CONVERSIONS = [1, 10, 50, 100, 1000];

Parser.coinAbvToFull = function (coin) {
	return Parser._parse_aToB(Parser.COIN_ABV_TO_FULL, coin);
};

/**
 * @param currency Object of the form `{pp: <n>, gp: <m>, ... }`.
 * @param isDisplayEmpty If "empty" values (i.e., those which are 0) should be displayed.
 */
Parser.getDisplayCurrency = function (currency, {isDisplayEmpty = false} = {}) {
	return [...Parser.COIN_ABVS]
		.reverse()
		.filter(abv => isDisplayEmpty ? currency[abv] != null : currency[abv])
		.map(abv => `${currency[abv].toLocaleString()} ${abv}`)
		.join(", ");
};

Parser.itemWeightToFull = function (item, isShortForm) {
	if (item.weight) {
		// Handle pure integers
		if (Math.round(item.weight) === item.weight) return `${item.weight} lb.${(item.weightNote ? ` ${item.weightNote}` : "")}`;

		const integerPart = Math.floor(item.weight);

		// Attempt to render the amount as (a number +) a vulgar
		const vulgarGlyph = Parser.numberToVulgar(item.weight - integerPart, {isFallbackOnFractional: false});
		if (vulgarGlyph) return `${integerPart || ""}${vulgarGlyph} lb.${(item.weightNote ? ` ${item.weightNote}` : "")}`;

		// Fall back on decimal pounds or ounces
		return `${(item.weight < 1 ? item.weight * 16 : item.weight).toLocaleString(undefined, {maximumFractionDigits: 5})} ${item.weight < 1 ? "oz" : "lb"}.${(item.weightNote ? ` ${item.weightNote}` : "")}`;
	}
	if (item.weightMult) return isShortForm ? `×${item.weightMult}` : `base weight ×${item.weightMult}`;
	return "";
};

Parser.ITEM_RECHARGE_TO_FULL = {
	round: "Every Round",
	restShort: "Short Rest",
	restLong: "Long Rest",
	dawn: "Dawn",
	dusk: "Dusk",
	midnight: "Midnight",
	special: "Special",
};
Parser.itemRechargeToFull = function (recharge) {
	return Parser._parse_aToB(Parser.ITEM_RECHARGE_TO_FULL, recharge);
};

Parser.ITEM_MISC_TAG_TO_FULL = {
	"CF/W": "Creates Food/Water",
};
Parser.itemMiscTagToFull = function (type) {
	return Parser._parse_aToB(Parser.ITEM_MISC_TAG_TO_FULL, type);
};

Parser._decimalSeparator = (0.1).toLocaleString().substring(1, 2);
Parser._numberCleanRegexp = Parser._decimalSeparator === "." ? new RegExp(/[\s,]*/g, "g") : new RegExp(/[\s.]*/g, "g");
Parser._costSplitRegexp = Parser._decimalSeparator === "." ? new RegExp(/(\d+(\.\d+)?)([csegp]p)/) : new RegExp(/(\d+(,\d+)?)([csegp]p)/);

/** input e.g. "25 gp", "1,000pp" */
Parser.coinValueToNumber = function (value) {
	if (!value) return 0;
	// handle oddities
	if (value === "Varies") return 0;

	value = value
		.replace(/\s*/, "")
		.replace(Parser._numberCleanRegexp, "")
		.toLowerCase();
	const m = Parser._costSplitRegexp.exec(value);
	if (!m) throw new Error(`Badly formatted value "${value}"`);
	const ixCoin = Parser.COIN_ABVS.indexOf(m[3]);
	if (!~ixCoin) throw new Error(`Unknown coin type "${m[3]}"`);
	return Number(m[1]) * Parser.COIN_CONVERSIONS[ixCoin];
};

Parser.weightValueToNumber = function (value) {
	if (!value) return 0;

	if (Number(value)) return Number(value);
	else throw new Error(`Badly formatted value ${value}`);
};

Parser.dmgTypeToFull = function (dmgType) {
	return Parser._parse_aToB(Parser.DMGTYPE_JSON_TO_FULL, dmgType);
};

Parser.skillProficienciesToFull = function (skillProficiencies) {
	function renderSingle (skProf) {
		if (skProf.any) {
			skProf = MiscUtil.copyFast(skProf);
			skProf.choose = {"from": Object.keys(Parser.SKILL_TO_ATB_ABV), "count": skProf.any};
			delete skProf.any;
		}

		const keys = Object.keys(skProf).sort(SortUtil.ascSortLower);

		const ixChoose = keys.indexOf("choose");
		if (~ixChoose) keys.splice(ixChoose, 1);

		const baseStack = [];
		keys.filter(k => skProf[k]).forEach(k => baseStack.push(Renderer.get().render(`{@skill ${k.toTitleCase()}}`)));

		const chooseStack = [];
		if (~ixChoose) {
			const chObj = skProf.choose;
			if (chObj.from.length === 18) {
				chooseStack.push(`choose any ${!chObj.count || chObj.count === 1 ? "skill" : chObj.count}`);
			} else {
				chooseStack.push(`choose ${chObj.count || 1} from ${chObj.from.map(it => Renderer.get().render(`{@skill ${it.toTitleCase()}}`)).joinConjunct(", ", " and ")}`);
			}
		}

		const base = baseStack.joinConjunct(", ", " and ");
		const choose = chooseStack.join(""); // this should currently only ever be 1-length

		if (baseStack.length && chooseStack.length) return `${base}; and ${choose}`;
		else if (baseStack.length) return base;
		else if (chooseStack.length) return choose;
	}

	return skillProficiencies.map(renderSingle).join(" <i>or</i> ");
};

// sp-prefix functions are for parsing spell data, and shared with the roll20 script
Parser.spSchoolAndSubschoolsAbvsToFull = function (school, subschools) {
	if (!subschools || !subschools.length) return Parser.spSchoolAbvToFull(school);
	else return `${Parser.spSchoolAbvToFull(school)} (${subschools.map(sub => Parser.spSchoolAbvToFull(sub)).join(", ")})`;
};

Parser.spSchoolAbvToFull = function (schoolOrSubschool) {
	const out = Parser._parse_aToB(Parser.SP_SCHOOL_ABV_TO_FULL, schoolOrSubschool);
	if (Parser.SP_SCHOOL_ABV_TO_FULL[schoolOrSubschool]) return out;
	if (PrereleaseUtil.getMetaLookup("spellSchools")?.[schoolOrSubschool]) return PrereleaseUtil.getMetaLookup("spellSchools")?.[schoolOrSubschool].full;
	if (BrewUtil2.getMetaLookup("spellSchools")?.[schoolOrSubschool]) return BrewUtil2.getMetaLookup("spellSchools")?.[schoolOrSubschool].full;
	return out;
};

Parser.spSchoolAndSubschoolsAbvsShort = function (school, subschools) {
	if (!subschools || !subschools.length) return Parser.spSchoolAbvToShort(school);
	else return `${Parser.spSchoolAbvToShort(school)} (${subschools.map(sub => Parser.spSchoolAbvToShort(sub)).join(", ")})`;
};

Parser.spSchoolAbvToShort = function (school) {
	const out = Parser._parse_aToB(Parser.SP_SCHOOL_ABV_TO_SHORT, school);
	if (Parser.SP_SCHOOL_ABV_TO_SHORT[school]) return out;
	if (PrereleaseUtil.getMetaLookup("spellSchools")?.[school]) return PrereleaseUtil.getMetaLookup("spellSchools")?.[school].short;
	if (BrewUtil2.getMetaLookup("spellSchools")?.[school]) return BrewUtil2.getMetaLookup("spellSchools")?.[school].short;
	return out;
};

Parser.spSchoolAbvToStyle = function (school) { // For prerelease/homebrew
	const stylePart = Parser.spSchoolAbvToStylePart(school);
	if (!stylePart) return stylePart;
	return `style="${stylePart}"`;
};

Parser.spSchoolAbvToStylePart = function (school) { // For prerelease/homebrew
	return Parser._spSchoolAbvToStylePart_prereleaseBrew({school, brewUtil: PrereleaseUtil})
		|| Parser._spSchoolAbvToStylePart_prereleaseBrew({school, brewUtil: BrewUtil2})
		|| "";
};

Parser._spSchoolAbvToStylePart_prereleaseBrew = function ({school, brewUtil}) {
	const rawColor = brewUtil.getMetaLookup("spellSchools")?.[school]?.color;
	if (!rawColor || !rawColor.trim()) return "";
	const validColor = BrewUtilShared.getValidColor(rawColor);
	if (validColor.length) return `color: #${validColor};`;
};

Parser.getOrdinalForm = function (i) {
	i = Number(i);
	if (isNaN(i)) return "";
	const j = i % 10; const k = i % 100;
	if (j === 1 && k !== 11) return `${i}st`;
	if (j === 2 && k !== 12) return `${i}nd`;
	if (j === 3 && k !== 13) return `${i}rd`;
	return `${i}th`;
};

Parser.spLevelToFull = function (level) {
	if (level === 0) return "Cantrip";
	else return Parser.getOrdinalForm(level);
};

Parser.getArticle = function (str) {
	str = `${str}`;
	str = str.replace(/\d+/g, (...m) => Parser.numberToText(m[0]));
	return /^[aeiou]/i.test(str) ? "an" : "a";
};

Parser.spLevelToFullLevelText = function (level, dash) {
	return `${Parser.spLevelToFull(level)}${(level === 0 ? "s" : `${dash ? "-" : " "}level`)}`;
};

Parser.spLevelToSpellPoints = function (lvl) {
	lvl = Number(lvl);
	if (isNaN(lvl) || lvl === 0) return 0;
	return Math.ceil(1.34 * lvl);
};

Parser.spMetaToArr = function (meta) {
	if (!meta) return [];
	return Object.entries(meta)
		.filter(([_, v]) => v)
		.sort(SortUtil.ascSort)
		.map(([k]) => k);
};

Parser.spMetaToFull = function (meta) {
	if (!meta) return "";
	const metaTags = Parser.spMetaToArr(meta);
	if (metaTags.length) return ` (${metaTags.join(", ")})`;
	return "";
};

Parser.spLevelSchoolMetaToFull = function (level, school, meta, subschools) {
	const levelPart = level === 0 ? Parser.spLevelToFull(level).toLowerCase() : `${Parser.spLevelToFull(level)}-level`;
	const levelSchoolStr = level === 0 ? `${Parser.spSchoolAbvToFull(school)} ${levelPart}` : `${levelPart} ${Parser.spSchoolAbvToFull(school).toLowerCase()}`;

	const metaArr = Parser.spMetaToArr(meta);
	if (metaArr.length || (subschools && subschools.length)) {
		const metaAndSubschoolPart = [
			(subschools || []).map(sub => Parser.spSchoolAbvToFull(sub)).join(", "),
			metaArr.join(", "),
		].filter(Boolean).join("; ").toLowerCase();
		return `${levelSchoolStr} (${metaAndSubschoolPart})`;
	}
	return levelSchoolStr;
};

Parser.spTimeListToFull = function (times, isStripTags) {
	return times.map(t => `${Parser.getTimeToFull(t)}${t.condition ? `, ${isStripTags ? Renderer.stripTags(t.condition) : Renderer.get().render(t.condition)}` : ""}`).join(" or ");
};

Parser.getTimeToFull = function (time) {
	return `${time.number ? `${time.number} ` : ""}${time.unit === "bonus" ? "bonus action" : time.unit}${time.number > 1 ? "s" : ""}`;
};

Parser.RNG_SPECIAL = "special";
Parser.RNG_POINT = "point";
Parser.RNG_LINE = "line";
Parser.RNG_CUBE = "cube";
Parser.RNG_CONE = "cone";
Parser.RNG_RADIUS = "radius";
Parser.RNG_SPHERE = "sphere";
Parser.RNG_HEMISPHERE = "hemisphere";
Parser.RNG_CYLINDER = "cylinder"; // homebrew only
Parser.RNG_SELF = "self";
Parser.RNG_SIGHT = "sight";
Parser.RNG_UNLIMITED = "unlimited";
Parser.RNG_UNLIMITED_SAME_PLANE = "plane";
Parser.RNG_TOUCH = "touch";
Parser.SP_RANGE_TYPE_TO_FULL = {
	[Parser.RNG_SPECIAL]: "Special",
	[Parser.RNG_POINT]: "Point",
	[Parser.RNG_LINE]: "Line",
	[Parser.RNG_CUBE]: "Cube",
	[Parser.RNG_CONE]: "Cone",
	[Parser.RNG_RADIUS]: "Radius",
	[Parser.RNG_SPHERE]: "Sphere",
	[Parser.RNG_HEMISPHERE]: "Hemisphere",
	[Parser.RNG_CYLINDER]: "Cylinder",
	[Parser.RNG_SELF]: "Self",
	[Parser.RNG_SIGHT]: "Sight",
	[Parser.RNG_UNLIMITED]: "Unlimited",
	[Parser.RNG_UNLIMITED_SAME_PLANE]: "Unlimited on the same plane",
	[Parser.RNG_TOUCH]: "Touch",
};

Parser.spRangeTypeToFull = function (range) {
	return Parser._parse_aToB(Parser.SP_RANGE_TYPE_TO_FULL, range);
};

Parser.UNT_FEET = "feet";
Parser.UNT_YARDS = "yards";
Parser.UNT_MILES = "miles";
Parser.SP_DIST_TYPE_TO_FULL = {
	[Parser.UNT_FEET]: "Feet",
	[Parser.UNT_YARDS]: "Yards",
	[Parser.UNT_MILES]: "Miles",
	[Parser.RNG_SELF]: Parser.SP_RANGE_TYPE_TO_FULL[Parser.RNG_SELF],
	[Parser.RNG_TOUCH]: Parser.SP_RANGE_TYPE_TO_FULL[Parser.RNG_TOUCH],
	[Parser.RNG_SIGHT]: Parser.SP_RANGE_TYPE_TO_FULL[Parser.RNG_SIGHT],
	[Parser.RNG_UNLIMITED]: Parser.SP_RANGE_TYPE_TO_FULL[Parser.RNG_UNLIMITED],
	[Parser.RNG_UNLIMITED_SAME_PLANE]: Parser.SP_RANGE_TYPE_TO_FULL[Parser.RNG_UNLIMITED_SAME_PLANE],
};

Parser.spDistanceTypeToFull = function (range) {
	return Parser._parse_aToB(Parser.SP_DIST_TYPE_TO_FULL, range);
};

Parser.SP_RANGE_TO_ICON = {
	[Parser.RNG_SPECIAL]: "fa-star",
	[Parser.RNG_POINT]: "",
	[Parser.RNG_LINE]: "fa-grip-lines-vertical",
	[Parser.RNG_CUBE]: "fa-cube",
	[Parser.RNG_CONE]: "fa-traffic-cone",
	[Parser.RNG_RADIUS]: "fa-hockey-puck",
	[Parser.RNG_SPHERE]: "fa-globe",
	[Parser.RNG_HEMISPHERE]: "fa-globe",
	[Parser.RNG_CYLINDER]: "fa-database",
	[Parser.RNG_SELF]: "fa-street-view",
	[Parser.RNG_SIGHT]: "fa-eye",
	[Parser.RNG_UNLIMITED_SAME_PLANE]: "fa-globe-americas",
	[Parser.RNG_UNLIMITED]: "fa-infinity",
	[Parser.RNG_TOUCH]: "fa-hand-paper",
};

Parser.spRangeTypeToIcon = function (range) {
	return Parser._parse_aToB(Parser.SP_RANGE_TO_ICON, range);
};

Parser.spRangeToShortHtml = function (range) {
	switch (range.type) {
		case Parser.RNG_SPECIAL: return `<span class="fas fa-fw ${Parser.spRangeTypeToIcon(range.type)} help-subtle" title="Special"></span>`;
		case Parser.RNG_POINT: return Parser.spRangeToShortHtml._renderPoint(range);
		case Parser.RNG_LINE:
		case Parser.RNG_CUBE:
		case Parser.RNG_CONE:
		case Parser.RNG_RADIUS:
		case Parser.RNG_SPHERE:
		case Parser.RNG_HEMISPHERE:
		case Parser.RNG_CYLINDER:
			return Parser.spRangeToShortHtml._renderArea(range);
	}
};
Parser.spRangeToShortHtml._renderPoint = function (range) {
	const dist = range.distance;
	switch (dist.type) {
		case Parser.RNG_SELF:
		case Parser.RNG_SIGHT:
		case Parser.RNG_UNLIMITED:
		case Parser.RNG_UNLIMITED_SAME_PLANE:
		case Parser.RNG_SPECIAL:
		case Parser.RNG_TOUCH: return `<span class="fas fa-fw ${Parser.spRangeTypeToIcon(dist.type)} help-subtle" title="${Parser.spRangeTypeToFull(dist.type)}"></span>`;
		case Parser.UNT_FEET:
		case Parser.UNT_YARDS:
		case Parser.UNT_MILES:
		default:
			return `${dist.amount} <span class="ve-small">${Parser.getSingletonUnit(dist.type, true)}</span>`;
	}
};
Parser.spRangeToShortHtml._renderArea = function (range) {
	const size = range.distance;
	return `<span class="fas fa-fw ${Parser.spRangeTypeToIcon(Parser.RNG_SELF)} help-subtle" title="Self"></span> ${size.amount}<span class="ve-small">-${Parser.getSingletonUnit(size.type, true)}</span> ${Parser.spRangeToShortHtml._getAreaStyleString(range)}`;
};
Parser.spRangeToShortHtml._getAreaStyleString = function (range) {
	return `<span class="fas fa-fw ${Parser.spRangeTypeToIcon(range.type)} help-subtle" title="${Parser.spRangeTypeToFull(range.type)}"></span>`;
};

Parser.spRangeToFull = function (range) {
	switch (range.type) {
		case Parser.RNG_SPECIAL: return Parser.spRangeTypeToFull(range.type);
		case Parser.RNG_POINT: return Parser.spRangeToFull._renderPoint(range);
		case Parser.RNG_LINE:
		case Parser.RNG_CUBE:
		case Parser.RNG_CONE:
		case Parser.RNG_RADIUS:
		case Parser.RNG_SPHERE:
		case Parser.RNG_HEMISPHERE:
		case Parser.RNG_CYLINDER:
			return Parser.spRangeToFull._renderArea(range);
	}
};
Parser.spRangeToFull._renderPoint = function (range) {
	const dist = range.distance;
	switch (dist.type) {
		case Parser.RNG_SELF:
		case Parser.RNG_SIGHT:
		case Parser.RNG_UNLIMITED:
		case Parser.RNG_UNLIMITED_SAME_PLANE:
		case Parser.RNG_SPECIAL:
		case Parser.RNG_TOUCH: return Parser.spRangeTypeToFull(dist.type);
		case Parser.UNT_FEET:
		case Parser.UNT_YARDS:
		case Parser.UNT_MILES:
		default:
			return `${dist.amount} ${dist.amount === 1 ? Parser.getSingletonUnit(dist.type) : dist.type}`;
	}
};
Parser.spRangeToFull._renderArea = function (range) {
	const size = range.distance;
	return `Self (${size.amount}-${Parser.getSingletonUnit(size.type)}${Parser.spRangeToFull._getAreaStyleString(range)}${range.type === Parser.RNG_CYLINDER ? `${size.amountSecondary != null && size.typeSecondary != null ? `, ${size.amountSecondary}-${Parser.getSingletonUnit(size.typeSecondary)}-high` : ""} cylinder` : ""})`;
};
Parser.spRangeToFull._getAreaStyleString = function (range) {
	switch (range.type) {
		case Parser.RNG_SPHERE: return " radius";
		case Parser.RNG_HEMISPHERE: return `-radius ${range.type}`;
		case Parser.RNG_CYLINDER: return "-radius";
		default: return ` ${range.type}`;
	}
};

Parser.getSingletonUnit = function (unit, isShort) {
	switch (unit) {
		case Parser.UNT_FEET:
			return isShort ? "ft." : "foot";
		case Parser.UNT_YARDS:
			return isShort ? "yd." : "yard";
		case Parser.UNT_MILES:
			return isShort ? "mi." : "mile";
		default: {
			const fromPrerelease = Parser._getSingletonUnit_prereleaseBrew({unit, isShort, brewUtil: PrereleaseUtil});
			if (fromPrerelease) return fromPrerelease;

			const fromBrew = Parser._getSingletonUnit_prereleaseBrew({unit, isShort, brewUtil: BrewUtil2});
			if (fromBrew) return fromBrew;

			if (unit.charAt(unit.length - 1) === "s") return unit.slice(0, -1);
			return unit;
		}
	}
};

Parser._getSingletonUnit_prereleaseBrew = function ({unit, isShort, brewUtil}) {
	const fromBrew = brewUtil.getMetaLookup("spellDistanceUnits")?.[unit]?.["singular"];
	if (fromBrew) return fromBrew;
};

Parser.RANGE_TYPES = [
	{type: Parser.RNG_POINT, hasDistance: true, isRequireAmount: false},

	{type: Parser.RNG_LINE, hasDistance: true, isRequireAmount: true},
	{type: Parser.RNG_CUBE, hasDistance: true, isRequireAmount: true},
	{type: Parser.RNG_CONE, hasDistance: true, isRequireAmount: true},
	{type: Parser.RNG_RADIUS, hasDistance: true, isRequireAmount: true},
	{type: Parser.RNG_SPHERE, hasDistance: true, isRequireAmount: true},
	{type: Parser.RNG_HEMISPHERE, hasDistance: true, isRequireAmount: true},
	{type: Parser.RNG_CYLINDER, hasDistance: true, isRequireAmount: true},

	{type: Parser.RNG_SPECIAL, hasDistance: false, isRequireAmount: false},
];

Parser.DIST_TYPES = [
	{type: Parser.RNG_SELF, hasAmount: false},
	{type: Parser.RNG_TOUCH, hasAmount: false},

	{type: Parser.UNT_FEET, hasAmount: true},
	{type: Parser.UNT_YARDS, hasAmount: true},
	{type: Parser.UNT_MILES, hasAmount: true},

	{type: Parser.RNG_SIGHT, hasAmount: false},
	{type: Parser.RNG_UNLIMITED_SAME_PLANE, hasAmount: false},
	{type: Parser.RNG_UNLIMITED, hasAmount: false},
];

Parser.spComponentsToFull = function (comp, level, {isPlainText = false} = {}) {
	if (!comp) return "None";
	const out = [];
	if (comp.v) out.push("V");
	if (comp.s) out.push("S");
	if (comp.m != null) {
		const fnRender = isPlainText ? Renderer.stripTags.bind(Renderer) : Renderer.get().render.bind(Renderer.get());
		out.push(`M${comp.m !== true ? ` (${fnRender(comp.m.text != null ? comp.m.text : comp.m)})` : ""}`);
	}
	if (comp.r) out.push(`R (${level} gp)`);
	return out.join(", ") || "None";
};

Parser.SP_END_TYPE_TO_FULL = {
	"dispel": "dispelled",
	"trigger": "triggered",
	"discharge": "discharged",
};
Parser.spEndTypeToFull = function (type) {
	return Parser._parse_aToB(Parser.SP_END_TYPE_TO_FULL, type);
};

Parser.spDurationToFull = function (dur) {
	let hasSubOr = false;
	const outParts = dur.map(d => {
		switch (d.type) {
			case "special":
				return "Special";
			case "instant":
				return `Instantaneous${d.condition ? ` (${d.condition})` : ""}`;
			case "timed":
				return `${d.concentration ? "Concentration, " : ""}${d.concentration ? "u" : d.duration.upTo ? "U" : ""}${d.concentration || d.duration.upTo ? "p to " : ""}${d.duration.amount} ${d.duration.amount === 1 ? d.duration.type : `${d.duration.type}s`}`;
			case "permanent": {
				if (d.ends) {
					const endsToJoin = d.ends.map(m => Parser.spEndTypeToFull(m));
					hasSubOr = hasSubOr || endsToJoin.length > 1;
					return `Until ${endsToJoin.joinConjunct(", ", " or ")}`;
				} else {
					return "Permanent";
				}
			}
		}
	});
	return `${outParts.joinConjunct(hasSubOr ? "; " : ", ", " or ")}${dur.length > 1 ? " (see below)" : ""}`;
};

Parser.DURATION_TYPES = [
	{type: "instant", full: "Instantaneous"},
	{type: "timed", hasAmount: true},
	{type: "permanent", hasEnds: true},
	{type: "special"},
];

Parser.DURATION_AMOUNT_TYPES = [
	"turn",
	"round",
	"minute",
	"hour",
	"day",
	"week",
	"year",
];

Parser.spClassesToFull = function (sp, {isTextOnly = false, subclassLookup = {}} = {}) {
	const fromSubclassList = Renderer.spell.getCombinedClasses(sp, "fromSubclass");
	const fromSubclasses = Parser.spSubclassesToFull(fromSubclassList, {isTextOnly, subclassLookup});
	const fromClassList = Renderer.spell.getCombinedClasses(sp, "fromClassList");
	return `${Parser.spMainClassesToFull(fromClassList, {isTextOnly})}${fromSubclasses ? `, ${fromSubclasses}` : ""}`;
};

Parser.spMainClassesToFull = function (fromClassList, {isTextOnly = false} = {}) {
	return fromClassList
		.map(c => ({hash: UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES](c), c}))
		.filter(it => !ExcludeUtil.isInitialised || !ExcludeUtil.isExcluded(it.hash, "class", it.c.source))
		.sort((a, b) => SortUtil.ascSort(a.c.name, b.c.name))
		.map(it => {
			if (isTextOnly) return it.c.name;

			return `<span title="${it.c.definedInSource ? `Class source` : "Source"}: ${Parser.sourceJsonToFull(it.c.source)}${it.c.definedInSource ? `. Spell list defined in: ${Parser.sourceJsonToFull(it.c.definedInSource)}.` : ""}">${Renderer.get().render(`{@class ${it.c.name}|${it.c.source}}`)}</span>`;
		})
		.join(", ") || "";
};

Parser.spSubclassesToFull = function (fromSubclassList, {isTextOnly = false, subclassLookup = {}} = {}) {
	return fromSubclassList
		.filter(mt => {
			if (!ExcludeUtil.isInitialised) return true;
			const excludeClass = ExcludeUtil.isExcluded(UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES](mt.class), "class", mt.class.source);
			if (excludeClass) return false;

			return !ExcludeUtil.isExcluded(
				UrlUtil.URL_TO_HASH_BUILDER["subclass"]({
					shortName: mt.subclass.name,
					source: mt.subclass.source,
					className: mt.class.name,
					classSource: mt.class.source,
				}),
				"subclass",
				mt.subclass.source,
				{isNoCount: true},
			);
		})
		.sort((a, b) => {
			const byName = SortUtil.ascSort(a.class.name, b.class.name);
			return byName || SortUtil.ascSort(a.subclass.name, b.subclass.name);
		})
		.map(c => Parser._spSubclassItem({fromSubclass: c, isTextOnly}))
		.join(", ") || "";
};

Parser._spSubclassItem = function ({fromSubclass, isTextOnly}) {
	const c = fromSubclass.class;
	const sc = fromSubclass.subclass;
	const text = `${sc.shortName}${sc.subSubclass ? ` (${sc.subSubclass})` : ""}`;
	if (isTextOnly) return text;

	const classPart = `<span title="Source: ${Parser.sourceJsonToFull(c.source)}${c.definedInSource ? ` From a class spell list defined in: ${Parser.sourceJsonToFull(c.definedInSource)}` : ""}">${Renderer.get().render(`{@class ${c.name}|${c.source}}`)}</span>`;

	return `<span class="italic" title="Source: ${Parser.sourceJsonToFull(fromSubclass.subclass.source)}">${Renderer.get().render(`{@class ${c.name}|${c.source}|${text}|${sc.shortName}|${sc.source}}`)}</span> ${classPart}`;
};

Parser.SPELL_ATTACK_TYPE_TO_FULL = {};
Parser.SPELL_ATTACK_TYPE_TO_FULL["M"] = "Melee";
Parser.SPELL_ATTACK_TYPE_TO_FULL["R"] = "Ranged";
Parser.SPELL_ATTACK_TYPE_TO_FULL["O"] = "Other/Unknown";

Parser.spAttackTypeToFull = function (type) {
	return Parser._parse_aToB(Parser.SPELL_ATTACK_TYPE_TO_FULL, type);
};

Parser.SPELL_AREA_TYPE_TO_FULL = {
	ST: "Single Target",
	MT: "Multiple Targets",
	C: "Cube",
	N: "Cone",
	Y: "Cylinder",
	S: "Sphere",
	R: "Circle",
	Q: "Square",
	L: "Line",
	H: "Hemisphere",
	W: "Wall",
};
Parser.spAreaTypeToFull = function (type) {
	return Parser._parse_aToB(Parser.SPELL_AREA_TYPE_TO_FULL, type);
};

Parser.SP_MISC_TAG_TO_FULL = {
	HL: "Healing",
	THP: "Grants Temporary Hit Points",
	SGT: "Requires Sight",
	PRM: "Permanent Effects",
	SCL: "Scaling Effects",
	SMN: "Summons Creature",
	MAC: "Modifies AC",
	TP: "Teleportation",
	FMV: "Forced Movement",
	RO: "Rollable Effects",
	LGTS: "Creates Sunlight",
	LGT: "Creates Light",
	UBA: "Uses Bonus Action",
	PS: "Plane Shifting",
	OBS: "Obscures Vision",
	DFT: "Difficult Terrain",
	AAD: "Additional Attack Damage",
	OBJ: "Affects Objects",
};
Parser.spMiscTagToFull = function (type) {
	return Parser._parse_aToB(Parser.SP_MISC_TAG_TO_FULL, type);
};

Parser.SP_CASTER_PROGRESSION_TO_FULL = {
	full: "Full",
	"1/2": "Half",
	"1/3": "One-Third",
	"pact": "Pact Magic",
};
Parser.spCasterProgressionToFull = function (type) {
	return Parser._parse_aToB(Parser.SP_CASTER_PROGRESSION_TO_FULL, type);
};

// mon-prefix functions are for parsing monster data, and shared with the roll20 script
Parser.monTypeToFullObj = function (type) {
	const out = {
		types: [],
		tags: [],
		asText: "",
		asTextShort: "",

		typeSidekick: null,
		tagsSidekick: [],
		asTextSidekick: null,
	};

	// handles e.g. "fey"
	if (typeof type === "string") {
		out.types = [type];
		out.asText = type.toTitleCase();
		out.asTextShort = out.asText;
		return out;
	}

	if (type.type?.choose) {
		out.types = type.type.choose;
	} else {
		out.types = [type.type];
	}

	if (type.swarmSize) {
		out.tags.push("swarm");
		out.asText = `swarm of ${Parser.sizeAbvToFull(type.swarmSize)} ${out.types.map(typ => Parser.monTypeToPlural(typ).toTitleCase()).joinConjunct(", ", " or ")}`;
		out.asTextShort = out.asText;
		out.swarmSize = type.swarmSize;
	} else {
		out.asText = out.types.map(typ => typ.toTitleCase()).joinConjunct(", ", " or ");
		out.asTextShort = out.asText;
	}

	const tagMetas = Parser.monTypeToFullObj._getTagMetas(type.tags);
	if (tagMetas.length) {
		out.tags.push(...tagMetas.map(({filterTag}) => filterTag));
		const ptTags = ` (${tagMetas.map(({displayTag}) => displayTag).join(", ")})`;
		out.asText += ptTags;
		out.asTextShort += ptTags;
	}

	if (type.note) out.asText += ` ${type.note}`;

	// region Sidekick
	if (type.sidekickType) {
		out.typeSidekick = type.sidekickType;
		if (!type.sidekickHidden) out.asTextSidekick = `${type.sidekickType}`;

		const tagMetas = Parser.monTypeToFullObj._getTagMetas(type.sidekickTags);
		if (tagMetas.length) {
			out.tagsSidekick.push(...tagMetas.map(({filterTag}) => filterTag));
			if (!type.sidekickHidden) out.asTextSidekick += ` (${tagMetas.map(({displayTag}) => displayTag).join(", ")})`;
		}
	}
	// endregion

	return out;
};

Parser.monTypeToFullObj._getTagMetas = (tags) => {
	return tags
		? tags.map(tag => {
			if (typeof tag === "string") { // handles e.g. "Fiend (Devil)"
				return {
					filterTag: tag.toLowerCase(),
					displayTag: tag.toTitleCase(),
				};
			} else { // handles e.g. "Humanoid (Chondathan Human)"
				return {
					filterTag: tag.tag.toLowerCase(),
					displayTag: `${tag.prefix} ${tag.tag}`.toTitleCase(),
				};
			}
		})
		: [];
};

Parser.monTypeToPlural = function (type) {
	return Parser._parse_aToB(Parser.MON_TYPE_TO_PLURAL, type);
};

Parser.monTypeFromPlural = function (type) {
	return Parser._parse_bToA(Parser.MON_TYPE_TO_PLURAL, type);
};

Parser.monCrToFull = function (cr, {xp = null, isMythic = false} = {}) {
	if (cr == null) return "";

	if (typeof cr === "string") {
		if (Parser.crToNumber(cr) >= VeCt.CR_CUSTOM) return `${cr}${xp != null ? ` (${xp} XP)` : ""}`;

		xp = xp != null ? Parser._addCommas(xp) : Parser.crToXp(cr);
		return `${cr} (${xp} XP${isMythic ? `, or ${Parser.crToXp(cr, {isDouble: true})} XP as a mythic encounter` : ""})`;
	} else {
		const stack = [Parser.monCrToFull(cr.cr, {xp: cr.xp, isMythic})];
		if (cr.lair) stack.push(`${Parser.monCrToFull(cr.lair)} when encountered in lair`);
		if (cr.coven) stack.push(`${Parser.monCrToFull(cr.coven)} when part of a coven`);
		return stack.joinConjunct(", ", " or ");
	}
};

Parser.getFullImmRes = function (toParse) {
	if (!toParse?.length) return "";

	let maxDepth = 0;

	function toString (it, depth = 0) {
		maxDepth = Math.max(maxDepth, depth);
		if (typeof it === "string") {
			return it;
		} else if (it.special) {
			return it.special;
		} else {
			const stack = [];

			if (it.preNote) stack.push(it.preNote);

			const prop = it.immune ? "immune" : it.resist ? "resist" : it.vulnerable ? "vulnerable" : null;
			if (prop) {
				const toJoin = it[prop].map(nxt => toString(nxt, depth + 1));
				stack.push(depth ? toJoin.join(maxDepth ? "; " : ", ") : toJoin.joinConjunct(", ", " and "));
			}

			if (it.note) stack.push(it.note);

			return stack.join(" ");
		}
	}

	const arr = toParse.map(it => toString(it));

	if (arr.length <= 1) return arr.join("");

	let out = "";
	for (let i = 0; i < arr.length - 1; ++i) {
		const it = arr[i];
		const nxt = arr[i + 1];

		const orig = toParse[i];
		const origNxt = toParse[i + 1];

		out += it;
		out += (it.includes(",") || nxt.includes(",") || (orig && orig.cond) || (origNxt && origNxt.cond)) ? "; " : ", ";
	}
	out += arr.last();
	return out;
};

Parser.getFullCondImm = function (condImm, isPlainText) {
	if (!condImm?.length) return "";
	function render (condition) {
		return isPlainText ? condition : Renderer.get().render(`{@condition ${condition}}`);
	}
	return condImm.map(it => {
		if (it.special) return it.special;
		if (it.conditionImmune) return `${it.preNote ? `${it.preNote} ` : ""}${it.conditionImmune.map(render).join(", ")}${it.note ? ` ${it.note}` : ""}`;
		return render(it);
	}).sort(SortUtil.ascSortLower).join(", ");
};

Parser.MON_SENSE_TAG_TO_FULL = {
	"B": "blindsight",
	"D": "darkvision",
	"SD": "superior darkvision",
	"T": "tremorsense",
	"U": "truesight",
};
Parser.monSenseTagToFull = function (tag) {
	return Parser._parse_aToB(Parser.MON_SENSE_TAG_TO_FULL, tag);
};

Parser.MON_SPELLCASTING_TAG_TO_FULL = {
	"P": "Psionics",
	"I": "Innate",
	"F": "Form Only",
	"S": "Shared",
	"O": "Other",
	"CA": "Class, Artificer",
	"CB": "Class, Bard",
	"CC": "Class, Cleric",
	"CD": "Class, Druid",
	"CP": "Class, Paladin",
	"CR": "Class, Ranger",
	"CS": "Class, Sorcerer",
	"CL": "Class, Warlock",
	"CW": "Class, Wizard",
};
Parser.monSpellcastingTagToFull = function (tag) {
	return Parser._parse_aToB(Parser.MON_SPELLCASTING_TAG_TO_FULL, tag);
};

Parser.MON_MISC_TAG_TO_FULL = {
	"AOE": "Has Areas of Effect",
	"HPR": "Has HP Reduction",
	"MW": "Has Weapon Attacks, Melee",
	"RW": "Has Weapon Attacks, Ranged",
	"RNG": "Has Ranged Weapons",
	"RCH": "Has Reach Attacks",
	"THW": "Has Thrown Weapons",
};
Parser.monMiscTagToFull = function (tag) {
	return Parser._parse_aToB(Parser.MON_MISC_TAG_TO_FULL, tag);
};

Parser.MON_LANGUAGE_TAG_TO_FULL = {
	"AB": "Abyssal",
	"AQ": "Aquan",
	"AU": "Auran",
	"C": "Common",
	"CE": "Celestial",
	"CS": "Can't Speak Known Languages",
	"D": "Dwarvish",
	"DR": "Draconic",
	"DS": "Deep Speech",
	"DU": "Druidic",
	"E": "Elvish",
	"G": "Gnomish",
	"GI": "Giant",
	"GO": "Goblin",
	"GTH": "Gith",
	"H": "Halfling",
	"I": "Infernal",
	"IG": "Ignan",
	"LF": "Languages Known in Life",
	"O": "Orc",
	"OTH": "Other",
	"P": "Primordial",
	"S": "Sylvan",
	"T": "Terran",
	"TC": "Thieves' cant",
	"TP": "Telepathy",
	"U": "Undercommon",
	"X": "Any (Choose)",
	"XX": "All",
};
Parser.monLanguageTagToFull = function (tag) {
	return Parser._parse_aToB(Parser.MON_LANGUAGE_TAG_TO_FULL, tag);
};

Parser.ENVIRONMENTS = ["arctic", "coastal", "desert", "forest", "grassland", "hill", "mountain", "swamp", "underdark", "underwater", "urban"];

// psi-prefix functions are for parsing psionic data, and shared with the roll20 script
Parser.PSI_ABV_TYPE_TALENT = "T";
Parser.PSI_ABV_TYPE_DISCIPLINE = "D";
Parser.PSI_ORDER_NONE = "None";
Parser.psiTypeToFull = type => Parser.psiTypeToMeta(type).full;

Parser.psiTypeToMeta = type => {
	let out = {};
	if (type === Parser.PSI_ABV_TYPE_TALENT) out = {hasOrder: false, full: "Talent"};
	else if (type === Parser.PSI_ABV_TYPE_DISCIPLINE) out = {hasOrder: true, full: "Discipline"};
	else if (PrereleaseUtil.getMetaLookup("psionicTypes")?.[type]) out = MiscUtil.copyFast(PrereleaseUtil.getMetaLookup("psionicTypes")[type]);
	else if (BrewUtil2.getMetaLookup("psionicTypes")?.[type]) out = MiscUtil.copyFast(BrewUtil2.getMetaLookup("psionicTypes")[type]);
	out.full = out.full || "Unknown";
	out.short = out.short || out.full;
	return out;
};

Parser.psiOrderToFull = (order) => {
	return order === undefined ? Parser.PSI_ORDER_NONE : order;
};

Parser.prereqSpellToFull = function (spell, {isTextOnly = false} = {}) {
	if (spell) {
		const [text, suffix] = spell.split("#");
		if (!suffix) return isTextOnly ? spell : Renderer.get().render(`{@spell ${spell}}`);
		else if (suffix === "c") return (isTextOnly ? Renderer.stripTags : Renderer.get().render.bind(Renderer.get()))(`{@spell ${text}} cantrip`);
		else if (suffix === "x") return (isTextOnly ? Renderer.stripTags : Renderer.get().render.bind(Renderer.get()))("{@spell hex} spell or a warlock feature that curses");
	} else return VeCt.STR_NONE;
};

Parser.prereqPactToFull = function (pact) {
	if (pact === "Chain") return "Pact of the Chain";
	if (pact === "Tome") return "Pact of the Tome";
	if (pact === "Blade") return "Pact of the Blade";
	if (pact === "Talisman") return "Pact of the Talisman";
	return pact;
};

Parser.prereqPatronToShort = function (patron) {
	if (patron === "Any") return patron;
	const mThe = /^The (.*?)$/.exec(patron);
	if (mThe) return mThe[1];
	return patron;
};

// NOTE: These need to be reflected in omnidexer.js to be indexed
Parser.OPT_FEATURE_TYPE_TO_FULL = {
	AI: "Artificer Infusion",
	ED: "Elemental Discipline",
	EI: "Eldritch Invocation",
	MM: "Metamagic",
	"MV": "Maneuver",
	"MV:B": "Maneuver, Battle Master",
	"MV:C2-UA": "Maneuver, Cavalier V2 (UA)",
	"AS:V1-UA": "Arcane Shot, V1 (UA)",
	"AS:V2-UA": "Arcane Shot, V2 (UA)",
	"AS": "Arcane Shot",
	OTH: "Other",
	"FS:F": "Fighting Style; Fighter",
	"FS:B": "Fighting Style; Bard",
	"FS:P": "Fighting Style; Paladin",
	"FS:R": "Fighting Style; Ranger",
	"PB": "Pact Boon",
	"OR": "Onomancy Resonant",
	"RN": "Rune Knight Rune",
	"AF": "Alchemical Formula",
};

Parser.optFeatureTypeToFull = function (type) {
	if (Parser.OPT_FEATURE_TYPE_TO_FULL[type]) return Parser.OPT_FEATURE_TYPE_TO_FULL[type];
	if (PrereleaseUtil.getMetaLookup("optionalFeatureTypes")?.[type]) return PrereleaseUtil.getMetaLookup("optionalFeatureTypes")[type];
	if (BrewUtil2.getMetaLookup("optionalFeatureTypes")?.[type]) return BrewUtil2.getMetaLookup("optionalFeatureTypes")[type];
	return type;
};

Parser.CHAR_OPTIONAL_FEATURE_TYPE_TO_FULL = {
	"SG": "Supernatural Gift",
	"OF": "Optional Feature",
	"DG": "Dark Gift",
	"RF:B": "Replacement Feature: Background",
	"CS": "Character Secret", // Specific to IDRotF (rules on page 14)
};

Parser.charCreationOptionTypeToFull = function (type) {
	if (Parser.CHAR_OPTIONAL_FEATURE_TYPE_TO_FULL[type]) return Parser.CHAR_OPTIONAL_FEATURE_TYPE_TO_FULL[type];
	if (PrereleaseUtil.getMetaLookup("charOption")?.[type]) return PrereleaseUtil.getMetaLookup("charOption")[type];
	if (BrewUtil2.getMetaLookup("charOption")?.[type]) return BrewUtil2.getMetaLookup("charOption")[type];
	return type;
};

Parser.alignmentAbvToFull = function (alignment) {
	if (!alignment) return null; // used in sidekicks
	if (typeof alignment === "object") {
		if (alignment.special != null) {
			// use in MTF Sacred Statue
			return alignment.special;
		} else {
			// e.g. `{alignment: ["N", "G"], chance: 50}` or `{alignment: ["N", "G"]}`
			return `${alignment.alignment.map(a => Parser.alignmentAbvToFull(a)).join(" ")}${alignment.chance ? ` (${alignment.chance}%)` : ""}${alignment.note ? ` (${alignment.note})` : ""}`;
		}
	} else {
		alignment = alignment.toUpperCase();
		switch (alignment) {
			case "L":
				return "lawful";
			case "N":
				return "neutral";
			case "NX":
				return "neutral (law/chaos axis)";
			case "NY":
				return "neutral (good/evil axis)";
			case "C":
				return "chaotic";
			case "G":
				return "good";
			case "E":
				return "evil";
			// "special" values
			case "U":
				return "unaligned";
			case "A":
				return "any alignment";
		}
		return alignment;
	}
};

Parser.alignmentListToFull = function (alignList) {
	if (!alignList) return "";
	if (alignList.some(it => typeof it !== "string")) {
		if (alignList.some(it => typeof it === "string")) throw new Error(`Mixed alignment types: ${JSON.stringify(alignList)}`);
		// filter out any nonexistent alignments, as we don't care about "alignment does not exist" if there are other alignments
		alignList = alignList.filter(it => it.alignment === undefined || it.alignment != null);
		return alignList.map(it => it.special != null || it.chance != null || it.note != null ? Parser.alignmentAbvToFull(it) : Parser.alignmentListToFull(it.alignment)).join(" or ");
	} else {
		// assume all single-length arrays can be simply parsed
		if (alignList.length === 1) return Parser.alignmentAbvToFull(alignList[0]);
		// a pair of abv's, e.g. "L" "G"
		if (alignList.length === 2) {
			return alignList.map(a => Parser.alignmentAbvToFull(a)).join(" ");
		}
		if (alignList.length === 3) {
			if (alignList.includes("NX") && alignList.includes("NY") && alignList.includes("N")) return "any neutral alignment";
		}
		// longer arrays should have a custom mapping
		if (alignList.length === 5) {
			if (!alignList.includes("G")) return "any non-good alignment";
			if (!alignList.includes("E")) return "any non-evil alignment";
			if (!alignList.includes("L")) return "any non-lawful alignment";
			if (!alignList.includes("C")) return "any non-chaotic alignment";
		}
		if (alignList.length === 4) {
			if (!alignList.includes("L") && !alignList.includes("NX")) return "any chaotic alignment";
			if (!alignList.includes("G") && !alignList.includes("NY")) return "any evil alignment";
			if (!alignList.includes("C") && !alignList.includes("NX")) return "any lawful alignment";
			if (!alignList.includes("E") && !alignList.includes("NY")) return "any good alignment";
		}
		throw new Error(`Unmapped alignment: ${JSON.stringify(alignList)}`);
	}
};

Parser.weightToFull = function (lbs, isSmallUnit) {
	const tons = Math.floor(lbs / 2000);
	lbs = lbs - (2000 * tons);
	return [
		tons ? `${tons}${isSmallUnit ? `<span class="ve-small ml-1">` : " "}ton${tons === 1 ? "" : "s"}${isSmallUnit ? `</span>` : ""}` : null,
		lbs ? `${lbs}${isSmallUnit ? `<span class="ve-small ml-1">` : " "}lb.${isSmallUnit ? `</span>` : ""}` : null,
	].filter(Boolean).join(", ");
};

Parser.RARITIES = ["common", "uncommon", "rare", "very rare", "legendary", "artifact"];
Parser.ITEM_RARITIES = ["none", ...Parser.RARITIES, "unknown", "unknown (magic)", "other"];

Parser.CAT_ID_CREATURE = 1;
Parser.CAT_ID_SPELL = 2;
Parser.CAT_ID_BACKGROUND = 3;
Parser.CAT_ID_ITEM = 4;
Parser.CAT_ID_CLASS = 5;
Parser.CAT_ID_CONDITION = 6;
Parser.CAT_ID_FEAT = 7;
Parser.CAT_ID_ELDRITCH_INVOCATION = 8;
Parser.CAT_ID_PSIONIC = 9;
Parser.CAT_ID_RACE = 10;
Parser.CAT_ID_OTHER_REWARD = 11;
Parser.CAT_ID_VARIANT_OPTIONAL_RULE = 12;
Parser.CAT_ID_ADVENTURE = 13;
Parser.CAT_ID_DEITY = 14;
Parser.CAT_ID_OBJECT = 15;
Parser.CAT_ID_TRAP = 16;
Parser.CAT_ID_HAZARD = 17;
Parser.CAT_ID_QUICKREF = 18;
Parser.CAT_ID_CULT = 19;
Parser.CAT_ID_BOON = 20;
Parser.CAT_ID_DISEASE = 21;
Parser.CAT_ID_METAMAGIC = 22;
Parser.CAT_ID_MANEUVER_BATTLEMASTER = 23;
Parser.CAT_ID_TABLE = 24;
Parser.CAT_ID_TABLE_GROUP = 25;
Parser.CAT_ID_MANEUVER_CAVALIER = 26;
Parser.CAT_ID_ARCANE_SHOT = 27;
Parser.CAT_ID_OPTIONAL_FEATURE_OTHER = 28;
Parser.CAT_ID_FIGHTING_STYLE = 29;
Parser.CAT_ID_CLASS_FEATURE = 30;
Parser.CAT_ID_VEHICLE = 31;
Parser.CAT_ID_PACT_BOON = 32;
Parser.CAT_ID_ELEMENTAL_DISCIPLINE = 33;
Parser.CAT_ID_ARTIFICER_INFUSION = 34;
Parser.CAT_ID_SHIP_UPGRADE = 35;
Parser.CAT_ID_INFERNAL_WAR_MACHINE_UPGRADE = 36;
Parser.CAT_ID_ONOMANCY_RESONANT = 37;
Parser.CAT_ID_RUNE_KNIGHT_RUNE = 37;
Parser.CAT_ID_ALCHEMICAL_FORMULA = 38;
Parser.CAT_ID_MANEUVER = 39;
Parser.CAT_ID_SUBCLASS = 40;
Parser.CAT_ID_SUBCLASS_FEATURE = 41;
Parser.CAT_ID_ACTION = 42;
Parser.CAT_ID_LANGUAGE = 43;
Parser.CAT_ID_BOOK = 44;
Parser.CAT_ID_PAGE = 45;
Parser.CAT_ID_LEGENDARY_GROUP = 46;
Parser.CAT_ID_CHAR_CREATION_OPTIONS = 47;
Parser.CAT_ID_RECIPES = 48;
Parser.CAT_ID_STATUS = 49;
Parser.CAT_ID_SKILLS = 50;
Parser.CAT_ID_SENSES = 51;
Parser.CAT_ID_DECK = 52;
Parser.CAT_ID_CARD = 53;

Parser.CAT_ID_TO_FULL = {};
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CREATURE] = "Bestiary";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_SPELL] = "Spell";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_BACKGROUND] = "Background";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ITEM] = "Item";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CLASS] = "Class";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CONDITION] = "Condition";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_FEAT] = "Feat";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ELDRITCH_INVOCATION] = "Eldritch Invocation";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_PSIONIC] = "Psionic";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_RACE] = "Race";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_OTHER_REWARD] = "Other Reward";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_VARIANT_OPTIONAL_RULE] = "Variant/Optional Rule";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ADVENTURE] = "Adventure";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_DEITY] = "Deity";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_OBJECT] = "Object";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_TRAP] = "Trap";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_HAZARD] = "Hazard";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_QUICKREF] = "Quick Reference";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CULT] = "Cult";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_BOON] = "Boon";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_DISEASE] = "Disease";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_METAMAGIC] = "Metamagic";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_MANEUVER_BATTLEMASTER] = "Maneuver; Battlemaster";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_TABLE] = "Table";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_TABLE_GROUP] = "Table";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_MANEUVER_CAVALIER] = "Maneuver; Cavalier";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ARCANE_SHOT] = "Arcane Shot";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_OPTIONAL_FEATURE_OTHER] = "Optional Feature";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_FIGHTING_STYLE] = "Fighting Style";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CLASS_FEATURE] = "Class Feature";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_VEHICLE] = "Vehicle";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_PACT_BOON] = "Pact Boon";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ELEMENTAL_DISCIPLINE] = "Elemental Discipline";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ARTIFICER_INFUSION] = "Infusion";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_SHIP_UPGRADE] = "Ship Upgrade";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_INFERNAL_WAR_MACHINE_UPGRADE] = "Infernal War Machine Upgrade";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ONOMANCY_RESONANT] = "Onomancy Resonant";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_RUNE_KNIGHT_RUNE] = "Rune Knight Rune";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ALCHEMICAL_FORMULA] = "Alchemical Formula";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_MANEUVER] = "Maneuver";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_SUBCLASS] = "Subclass";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_SUBCLASS_FEATURE] = "Subclass Feature";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ACTION] = "Action";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_LANGUAGE] = "Language";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_BOOK] = "Book";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_PAGE] = "Page";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_LEGENDARY_GROUP] = "Legendary Group";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CHAR_CREATION_OPTIONS] = "Character Creation Option";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_RECIPES] = "Recipe";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_STATUS] = "Status";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_DECK] = "Deck";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CARD] = "Card";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_SKILLS] = "Skill";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_SENSES] = "Sense";

Parser.pageCategoryToFull = function (catId) {
	return Parser._parse_aToB(Parser.CAT_ID_TO_FULL, catId);
};

Parser.CAT_ID_TO_PROP = {};
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CREATURE] = "monster";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_SPELL] = "spell";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_BACKGROUND] = "background";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ITEM] = "item";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CLASS] = "class";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CONDITION] = "condition";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_FEAT] = "feat";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_PSIONIC] = "psionic";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_RACE] = "race";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_OTHER_REWARD] = "reward";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_VARIANT_OPTIONAL_RULE] = "variantrule";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ADVENTURE] = "adventure";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_DEITY] = "deity";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_OBJECT] = "object";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_TRAP] = "trap";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_HAZARD] = "hazard";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CULT] = "cult";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_BOON] = "boon";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_DISEASE] = "condition";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_TABLE] = "table";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_TABLE_GROUP] = "tableGroup";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_VEHICLE] = "vehicle";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ELDRITCH_INVOCATION] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_MANEUVER_CAVALIER] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ARCANE_SHOT] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_OPTIONAL_FEATURE_OTHER] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_FIGHTING_STYLE] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_METAMAGIC] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_MANEUVER_BATTLEMASTER] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_PACT_BOON] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ELEMENTAL_DISCIPLINE] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ARTIFICER_INFUSION] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_SHIP_UPGRADE] = "vehicleUpgrade";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_INFERNAL_WAR_MACHINE_UPGRADE] = "vehicleUpgrade";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ONOMANCY_RESONANT] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_RUNE_KNIGHT_RUNE] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ALCHEMICAL_FORMULA] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_MANEUVER] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_QUICKREF] = null;
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CLASS_FEATURE] = "classFeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_SUBCLASS] = "subclass";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_SUBCLASS_FEATURE] = "subclassFeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ACTION] = "action";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_LANGUAGE] = "language";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_BOOK] = "book";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_PAGE] = null;
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_LEGENDARY_GROUP] = "legendaryGroup";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CHAR_CREATION_OPTIONS] = "charoption";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_RECIPES] = "recipe";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_STATUS] = "status";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_DECK] = "deck";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CARD] = "card";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_SKILLS] = "skill";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_SENSES] = "sense";

Parser.pageCategoryToProp = function (catId) {
	return Parser._parse_aToB(Parser.CAT_ID_TO_PROP, catId);
};

Parser.ABIL_ABVS = ["str", "dex", "con", "int", "wis", "cha"];

Parser.spClassesToCurrentAndLegacy = function (fromClassList) {
	const current = [];
	const legacy = [];
	fromClassList.forEach(cls => {
		if ((cls.name === "Artificer" && cls.source === "UAArtificer") || (cls.name === "Artificer (Revisited)" && cls.source === "UAArtificerRevisited")) legacy.push(cls);
		else current.push(cls);
	});
	return [current, legacy];
};

/**
 * Build a pair of strings; one with all current subclasses, one with all legacy subclasses
 *
 * @param sp a spell
 * @param subclassLookup Data loaded from `generated/gendata-subclass-lookup.json`. Of the form: `{PHB: {Barbarian: {PHB: {Berserker: "Path of the Berserker"}}}}`
 * @returns {*[]} A two-element array. First item is a string of all the current subclasses, second item a string of
 * all the legacy/superseded subclasses
 */
Parser.spSubclassesToCurrentAndLegacyFull = function (sp, subclassLookup) {
	return Parser._spSubclassesToCurrentAndLegacyFull({sp, subclassLookup, prop: "fromSubclass"});
};

Parser.spVariantSubclassesToCurrentAndLegacyFull = function (sp, subclassLookup) {
	return Parser._spSubclassesToCurrentAndLegacyFull({sp, subclassLookup, prop: "fromSubclassVariant"});
};

Parser._spSubclassesToCurrentAndLegacyFull = ({sp, subclassLookup, prop}) => {
	const fromSubclass = Renderer.spell.getCombinedClasses(sp, prop);
	if (!fromSubclass.length) return ["", ""];

	const current = [];
	const legacy = [];
	const curNames = new Set();
	const toCheck = [];
	fromSubclass
		.filter(c => {
			const excludeClass = ExcludeUtil.isExcluded(
				UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES]({name: c.class.name, source: c.class.source}),
				"class",
				c.class.source,
				{isNoCount: true},
			);
			if (excludeClass) return false;

			const excludeSubclass = ExcludeUtil.isExcluded(
				UrlUtil.URL_TO_HASH_BUILDER["subclass"]({
					shortName: c.subclass.shortName,
					source: c.subclass.source,
					className: c.class.name,
					classSource: c.class.source,
				}),
				"subclass",
				c.subclass.source,
				{isNoCount: true},
			);
			if (excludeSubclass) return false;

			return !Renderer.spell.isExcludedSubclassVariantSource({classDefinedInSource: c.class.definedInSource});
		})
		.sort((a, b) => {
			const byName = SortUtil.ascSort(a.subclass.name, b.subclass.name);
			return byName || SortUtil.ascSort(a.class.name, b.class.name);
		})
		.forEach(c => {
			const nm = c.subclass.name;
			const src = c.subclass.source;

			const toAdd = Parser._spSubclassItem({fromSubclass: c, isTextOnly: false});

			const fromLookup = MiscUtil.get(
				subclassLookup,
				c.class.source,
				c.class.name,
				c.subclass.source,
				c.subclass.name,
			);

			if (fromLookup && fromLookup.isReprinted) {
				legacy.push(toAdd);
			} else if (SourceUtil.isNonstandardSource(src)) {
				const cleanName = Parser._spSubclassesToCurrentAndLegacyFull.mapClassShortNameToMostRecent(
					nm.split("(")[0].trim().split(/v\d+/)[0].trim(),
				);
				toCheck.push({"name": cleanName, "ele": toAdd});
			} else {
				current.push(toAdd);
				curNames.add(nm);
			}
		});

	toCheck.forEach(n => {
		if (curNames.has(n.name)) {
			legacy.push(n.ele);
		} else {
			current.push(n.ele);
		}
	});

	return [current.join(", "), legacy.join(", ")];
};

/**
 * Get the most recent iteration of a subclass name.
 */
Parser._spSubclassesToCurrentAndLegacyFull.mapClassShortNameToMostRecent = (shortName) => {
	switch (shortName) {
		case "Favored Soul": return "Divine Soul";
		case "Undying Light": return "Celestial";
		case "Deep Stalker": return "Gloom Stalker";
	}
	return shortName;
};

Parser.spVariantClassesToCurrentAndLegacy = function (fromVariantClassList) {
	const current = [];
	const legacy = [];
	fromVariantClassList.forEach(cls => {
		if (cls.definedInSource === Parser.SRC_UACFV) legacy.push(cls);
		else current.push(cls);
	});
	return [current, legacy];
};

Parser.attackTypeToFull = function (attackType) {
	return Parser._parse_aToB(Parser.ATK_TYPE_TO_FULL, attackType);
};

Parser.trapHazTypeToFull = function (type) {
	return Parser._parse_aToB(Parser.TRAP_HAZARD_TYPE_TO_FULL, type);
};

Parser.TRAP_HAZARD_TYPE_TO_FULL = {
	MECH: "Mechanical trap",
	MAG: "Magical trap",
	SMPL: "Simple trap",
	CMPX: "Complex trap",
	HAZ: "Hazard",
	WTH: "Weather",
	ENV: "Environmental Hazard",
	WLD: "Wilderness Hazard",
	GEN: "Generic",
	EST: "Eldritch Storm",
};

Parser.tierToFullLevel = function (tier) {
	return Parser._parse_aToB(Parser.TIER_TO_FULL_LEVEL, tier);
};

Parser.TIER_TO_FULL_LEVEL = {};
Parser.TIER_TO_FULL_LEVEL[1] = "level 1\u20134";
Parser.TIER_TO_FULL_LEVEL[2] = "level 5\u201310";
Parser.TIER_TO_FULL_LEVEL[3] = "level 11\u201316";
Parser.TIER_TO_FULL_LEVEL[4] = "level 17\u201320";

Parser.trapInitToFull = function (init) {
	return Parser._parse_aToB(Parser.TRAP_INIT_TO_FULL, init);
};

Parser.TRAP_INIT_TO_FULL = {};
Parser.TRAP_INIT_TO_FULL[1] = "initiative count 10";
Parser.TRAP_INIT_TO_FULL[2] = "initiative count 20";
Parser.TRAP_INIT_TO_FULL[3] = "initiative count 20 and initiative count 10";

Parser.ATK_TYPE_TO_FULL = {};
Parser.ATK_TYPE_TO_FULL["MW"] = "Melee Weapon Attack";
Parser.ATK_TYPE_TO_FULL["RW"] = "Ranged Weapon Attack";

Parser.bookOrdinalToAbv = (ordinal, preNoSuff) => {
	if (ordinal === undefined) return "";
	switch (ordinal.type) {
		case "part": return `${preNoSuff ? " " : ""}Part ${ordinal.identifier}${preNoSuff ? "" : " \u2014 "}`;
		case "chapter": return `${preNoSuff ? " " : ""}Ch. ${ordinal.identifier}${preNoSuff ? "" : ": "}`;
		case "episode": return `${preNoSuff ? " " : ""}Ep. ${ordinal.identifier}${preNoSuff ? "" : ": "}`;
		case "appendix": return `${preNoSuff ? " " : ""}App.${ordinal.identifier != null ? ` ${ordinal.identifier}` : ""}${preNoSuff ? "" : ": "}`;
		case "level": return `${preNoSuff ? " " : ""}Level ${ordinal.identifier}${preNoSuff ? "" : ": "}`;
		default: throw new Error(`Unhandled ordinal type "${ordinal.type}"`);
	}
};

Parser.IMAGE_TYPE_TO_FULL = {
	"map": "Map",
	"mapPlayer": "Map (Player)",
};
Parser.imageTypeToFull = function (imageType) {
	return Parser._parse_aToB(Parser.IMAGE_TYPE_TO_FULL, imageType, "Other");
};

Parser.nameToTokenName = function (name) {
	return name
		.toAscii()
		.replace(/"/g, "");
};

Parser.bytesToHumanReadable = function (bytes, {fixedDigits = 2} = {}) {
	if (bytes == null) return "";
	if (!bytes) return "0 B";
	const e = Math.floor(Math.log(bytes) / Math.log(1024));
	return `${(bytes / Math.pow(1024, e)).toFixed(fixedDigits)} ${`\u200bKMGTP`.charAt(e)}B`;
};

Parser.SKL_ABV_ABJ = "A";
Parser.SKL_ABV_EVO = "V";
Parser.SKL_ABV_ENC = "E";
Parser.SKL_ABV_ILL = "I";
Parser.SKL_ABV_DIV = "D";
Parser.SKL_ABV_NEC = "N";
Parser.SKL_ABV_TRA = "T";
Parser.SKL_ABV_CON = "C";
Parser.SKL_ABV_PSI = "P";
Parser.SKL_ABVS = [
	Parser.SKL_ABV_ABJ,
	Parser.SKL_ABV_CON,
	Parser.SKL_ABV_DIV,
	Parser.SKL_ABV_ENC,
	Parser.SKL_ABV_EVO,
	Parser.SKL_ABV_ILL,
	Parser.SKL_ABV_NEC,
	Parser.SKL_ABV_PSI,
	Parser.SKL_ABV_TRA,
];

Parser.SP_TM_ACTION = "action";
Parser.SP_TM_B_ACTION = "bonus";
Parser.SP_TM_REACTION = "reaction";
Parser.SP_TM_ROUND = "round";
Parser.SP_TM_MINS = "minute";
Parser.SP_TM_HRS = "hour";
Parser.SP_TIME_SINGLETONS = [Parser.SP_TM_ACTION, Parser.SP_TM_B_ACTION, Parser.SP_TM_REACTION, Parser.SP_TM_ROUND];
Parser.SP_TIME_TO_FULL = {
	[Parser.SP_TM_ACTION]: "Action",
	[Parser.SP_TM_B_ACTION]: "Bonus Action",
	[Parser.SP_TM_REACTION]: "Reaction",
	[Parser.SP_TM_ROUND]: "Rounds",
	[Parser.SP_TM_MINS]: "Minutes",
	[Parser.SP_TM_HRS]: "Hours",
};
Parser.spTimeUnitToFull = function (timeUnit) {
	return Parser._parse_aToB(Parser.SP_TIME_TO_FULL, timeUnit);
};

Parser.SP_TIME_TO_SHORT = {
	[Parser.SP_TM_ROUND]: "Rnd.",
	[Parser.SP_TM_MINS]: "Min.",
	[Parser.SP_TM_HRS]: "Hr.",
};
Parser.spTimeUnitToShort = function (timeUnit) {
	return Parser._parse_aToB(Parser.SP_TIME_TO_SHORT, timeUnit);
};

Parser.SP_TIME_TO_ABV = {
	[Parser.SP_TM_ACTION]: "A",
	[Parser.SP_TM_B_ACTION]: "BA",
	[Parser.SP_TM_REACTION]: "R",
	[Parser.SP_TM_ROUND]: "rnd",
	[Parser.SP_TM_MINS]: "min",
	[Parser.SP_TM_HRS]: "hr",
};
Parser.spTimeUnitToAbv = function (timeUnit) {
	return Parser._parse_aToB(Parser.SP_TIME_TO_ABV, timeUnit);
};

Parser.spTimeToShort = function (time, isHtml) {
	if (!time) return "";
	return (time.number === 1 && Parser.SP_TIME_SINGLETONS.includes(time.unit))
		? `${Parser.spTimeUnitToAbv(time.unit).uppercaseFirst()}${time.condition ? "*" : ""}`
		: `${time.number} ${isHtml ? `<span class="ve-small">` : ""}${Parser.spTimeUnitToAbv(time.unit)}${isHtml ? `</span>` : ""}${time.condition ? "*" : ""}`;
};

Parser.SKL_ABJ = "Abjuration";
Parser.SKL_EVO = "Evocation";
Parser.SKL_ENC = "Enchantment";
Parser.SKL_ILL = "Illusion";
Parser.SKL_DIV = "Divination";
Parser.SKL_NEC = "Necromancy";
Parser.SKL_TRA = "Transmutation";
Parser.SKL_CON = "Conjuration";
Parser.SKL_PSI = "Psionic";

Parser.SP_SCHOOL_ABV_TO_FULL = {};
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_ABJ] = Parser.SKL_ABJ;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_EVO] = Parser.SKL_EVO;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_ENC] = Parser.SKL_ENC;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_ILL] = Parser.SKL_ILL;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_DIV] = Parser.SKL_DIV;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_NEC] = Parser.SKL_NEC;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_TRA] = Parser.SKL_TRA;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_CON] = Parser.SKL_CON;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_PSI] = Parser.SKL_PSI;

Parser.SP_SCHOOL_ABV_TO_SHORT = {};
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_ABJ] = "Abj.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_EVO] = "Evoc.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_ENC] = "Ench.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_ILL] = "Illu.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_DIV] = "Divin.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_NEC] = "Necro.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_TRA] = "Trans.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_CON] = "Conj.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_PSI] = "Psi.";

Parser.ATB_ABV_TO_FULL = {
	"str": "Strength",
	"dex": "Dexterity",
	"con": "Constitution",
	"int": "Intelligence",
	"wis": "Wisdom",
	"cha": "Charisma",
};

Parser.TP_ABERRATION = "aberration";
Parser.TP_BEAST = "beast";
Parser.TP_CELESTIAL = "celestial";
Parser.TP_CONSTRUCT = "construct";
Parser.TP_DRAGON = "dragon";
Parser.TP_ELEMENTAL = "elemental";
Parser.TP_FEY = "fey";
Parser.TP_FIEND = "fiend";
Parser.TP_GIANT = "giant";
Parser.TP_HUMANOID = "humanoid";
Parser.TP_MONSTROSITY = "monstrosity";
Parser.TP_OOZE = "ooze";
Parser.TP_PLANT = "plant";
Parser.TP_UNDEAD = "undead";
Parser.MON_TYPES = [Parser.TP_ABERRATION, Parser.TP_BEAST, Parser.TP_CELESTIAL, Parser.TP_CONSTRUCT, Parser.TP_DRAGON, Parser.TP_ELEMENTAL, Parser.TP_FEY, Parser.TP_FIEND, Parser.TP_GIANT, Parser.TP_HUMANOID, Parser.TP_MONSTROSITY, Parser.TP_OOZE, Parser.TP_PLANT, Parser.TP_UNDEAD];
Parser.MON_TYPE_TO_PLURAL = {};
Parser.MON_TYPE_TO_PLURAL[Parser.TP_ABERRATION] = "aberrations";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_BEAST] = "beasts";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_CELESTIAL] = "celestials";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_CONSTRUCT] = "constructs";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_DRAGON] = "dragons";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_ELEMENTAL] = "elementals";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_FEY] = "fey";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_FIEND] = "fiends";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_GIANT] = "giants";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_HUMANOID] = "humanoids";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_MONSTROSITY] = "monstrosities";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_OOZE] = "oozes";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_PLANT] = "plants";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_UNDEAD] = "undead";

Parser.SZ_FINE = "F";
Parser.SZ_DIMINUTIVE = "D";
Parser.SZ_TINY = "T";
Parser.SZ_SMALL = "S";
Parser.SZ_MEDIUM = "M";
Parser.SZ_LARGE = "L";
Parser.SZ_HUGE = "H";
Parser.SZ_GARGANTUAN = "G";
Parser.SZ_COLOSSAL = "C";
Parser.SZ_VARIES = "V";
Parser.SIZE_ABVS = [Parser.SZ_TINY, Parser.SZ_SMALL, Parser.SZ_MEDIUM, Parser.SZ_LARGE, Parser.SZ_HUGE, Parser.SZ_GARGANTUAN, Parser.SZ_VARIES];
Parser.SIZE_ABV_TO_FULL = {};
Parser.SIZE_ABV_TO_FULL[Parser.SZ_FINE] = "Fine";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_DIMINUTIVE] = "Diminutive";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_TINY] = "Tiny";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_SMALL] = "Small";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_MEDIUM] = "Medium";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_LARGE] = "Large";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_HUGE] = "Huge";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_GARGANTUAN] = "Gargantuan";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_COLOSSAL] = "Colossal";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_VARIES] = "Varies";

Parser.XP_CHART_ALT = {
	"0": 10,
	"1/8": 25,
	"1/4": 50,
	"1/2": 100,
	"1": 200,
	"2": 450,
	"3": 700,
	"4": 1100,
	"5": 1800,
	"6": 2300,
	"7": 2900,
	"8": 3900,
	"9": 5000,
	"10": 5900,
	"11": 7200,
	"12": 8400,
	"13": 10000,
	"14": 11500,
	"15": 13000,
	"16": 15000,
	"17": 18000,
	"18": 20000,
	"19": 22000,
	"20": 25000,
	"21": 33000,
	"22": 41000,
	"23": 50000,
	"24": 62000,
	"25": 75000,
	"26": 90000,
	"27": 105000,
	"28": 120000,
	"29": 135000,
	"30": 155000,
};

Parser.ARMOR_ABV_TO_FULL = {
	"l.": "light",
	"m.": "medium",
	"h.": "heavy",
};

Parser.WEAPON_ABV_TO_FULL = {
	"s.": "simple",
	"m.": "martial",
};

Parser.CONDITION_TO_COLOR = {
	"Blinded": "#525252",
	"Charmed": "#f01789",
	"Deafened": "#ababab",
	"Exhausted": "#947a47",
	"Frightened": "#c9ca18",
	"Grappled": "#8784a0",
	"Incapacitated": "#3165a0",
	"Invisible": "#7ad2d6",
	"Paralyzed": "#c00900",
	"Petrified": "#a0a0a0",
	"Poisoned": "#4dc200",
	"Prone": "#5e60a0",
	"Restrained": "#d98000",
	"Stunned": "#a23bcb",
	"Unconscious": "#3a40ad",

	"Concentration": "#009f7a",
};

Parser.RULE_TYPE_TO_FULL = {
	"O": "Optional",
	"V": "Variant",
	"VO": "Variant Optional",
	"VV": "Variant Variant",
	"U": "Unknown",
};

Parser.ruleTypeToFull = function (ruleType) {
	return Parser._parse_aToB(Parser.RULE_TYPE_TO_FULL, ruleType);
};

Parser.VEHICLE_TYPE_TO_FULL = {
	"SHIP": "Ship",
	"SPELLJAMMER": "Spelljammer Ship",
	"INFWAR": "Infernal War Machine",
	"CREATURE": "Creature",
	"OBJECT": "Object",
	"SHP:H": "Ship Upgrade, Hull",
	"SHP:M": "Ship Upgrade, Movement",
	"SHP:W": "Ship Upgrade, Weapon",
	"SHP:F": "Ship Upgrade, Figurehead",
	"SHP:O": "Ship Upgrade, Miscellaneous",
	"IWM:W": "Infernal War Machine Variant, Weapon",
	"IWM:A": "Infernal War Machine Upgrade, Armor",
	"IWM:G": "Infernal War Machine Upgrade, Gadget",
};

Parser.vehicleTypeToFull = function (vehicleType) {
	return Parser._parse_aToB(Parser.VEHICLE_TYPE_TO_FULL, vehicleType);
};

// SOURCES =============================================================================================================

Parser.SRC_5ETOOLS_TMP = "Parser.SRC_5ETOOLS_TMP"; // Temp source, used as a placeholder value

Parser.SRC_CoS = "CoS";
Parser.SRC_DMG = "DMG";
Parser.SRC_EEPC = "EEPC";
Parser.SRC_EET = "EET";
Parser.SRC_HotDQ = "HotDQ";
Parser.SRC_LMoP = "LMoP";
Parser.SRC_MM = "MM";
Parser.SRC_OotA = "OotA";
Parser.SRC_PHB = "PHB";
Parser.SRC_PotA = "PotA";
Parser.SRC_RoT = "RoT";
Parser.SRC_RoTOS = "RoTOS";
Parser.SRC_SCAG = "SCAG";
Parser.SRC_SKT = "SKT";
Parser.SRC_ToA = "ToA";
Parser.SRC_TLK = "TLK";
Parser.SRC_ToD = "ToD";
Parser.SRC_TTP = "TTP";
Parser.SRC_TYP = "TftYP";
Parser.SRC_TYP_AtG = "TftYP-AtG";
Parser.SRC_TYP_DiT = "TftYP-DiT";
Parser.SRC_TYP_TFoF = "TftYP-TFoF";
Parser.SRC_TYP_THSoT = "TftYP-THSoT";
Parser.SRC_TYP_TSC = "TftYP-TSC";
Parser.SRC_TYP_ToH = "TftYP-ToH";
Parser.SRC_TYP_WPM = "TftYP-WPM";
Parser.SRC_VGM = "VGM";
Parser.SRC_XGE = "XGE";
Parser.SRC_OGA = "OGA";
Parser.SRC_MTF = "MTF";
Parser.SRC_WDH = "WDH";
Parser.SRC_WDMM = "WDMM";
Parser.SRC_GGR = "GGR";
Parser.SRC_KKW = "KKW";
Parser.SRC_LLK = "LLK";
Parser.SRC_AZfyT = "AZfyT";
Parser.SRC_GoS = "GoS";
Parser.SRC_AI = "AI";
Parser.SRC_OoW = "OoW";
Parser.SRC_ESK = "ESK";
Parser.SRC_DIP = "DIP";
Parser.SRC_HftT = "HftT";
Parser.SRC_DC = "DC";
Parser.SRC_SLW = "SLW";
Parser.SRC_SDW = "SDW";
Parser.SRC_BGDIA = "BGDIA";
Parser.SRC_LR = "LR";
Parser.SRC_AL = "AL";
Parser.SRC_SAC = "SAC";
Parser.SRC_ERLW = "ERLW";
Parser.SRC_EFR = "EFR";
Parser.SRC_RMBRE = "RMBRE";
Parser.SRC_RMR = "RMR";
Parser.SRC_MFF = "MFF";
Parser.SRC_AWM = "AWM";
Parser.SRC_IMR = "IMR";
Parser.SRC_SADS = "SADS";
Parser.SRC_EGW = "EGW";
Parser.SRC_EGW_ToR = "ToR";
Parser.SRC_EGW_DD = "DD";
Parser.SRC_EGW_FS = "FS";
Parser.SRC_EGW_US = "US";
Parser.SRC_MOT = "MOT";
Parser.SRC_IDRotF = "IDRotF";
Parser.SRC_TCE = "TCE";
Parser.SRC_VRGR = "VRGR";
Parser.SRC_HoL = "HoL";
Parser.SRC_XMtS = "XMtS";
Parser.SRC_RtG = "RtG";
Parser.SRC_AitFR = "AitFR";
Parser.SRC_AitFR_ISF = "AitFR-ISF";
Parser.SRC_AitFR_THP = "AitFR-THP";
Parser.SRC_AitFR_AVT = "AitFR-AVT";
Parser.SRC_AitFR_DN = "AitFR-DN";
Parser.SRC_AitFR_FCD = "AitFR-FCD";
Parser.SRC_WBtW = "WBtW";
Parser.SRC_DoD = "DoD";
Parser.SRC_MaBJoV = "MaBJoV";
Parser.SRC_FTD = "FTD";
Parser.SRC_SCC = "SCC";
Parser.SRC_SCC_CK = "SCC-CK";
Parser.SRC_SCC_HfMT = "SCC-HfMT";
Parser.SRC_SCC_TMM = "SCC-TMM";
Parser.SRC_SCC_ARiR = "SCC-ARiR";
Parser.SRC_MPMM = "MPMM";
Parser.SRC_CRCotN = "CRCotN";
Parser.SRC_JttRC = "JttRC";
Parser.SRC_SAiS = "SAiS";
Parser.SRC_AAG = "AAG";
Parser.SRC_BAM = "BAM";
Parser.SRC_LoX = "LoX";
Parser.SRC_DoSI = "DoSI";
Parser.SRC_DSotDQ = "DSotDQ";
Parser.SRC_KftGV = "KftGV";
Parser.SRC_SCREEN = "Screen";
Parser.SRC_SCREEN_WILDERNESS_KIT = "ScreenWildernessKit";
Parser.SRC_SCREEN_DUNGEON_KIT = "ScreenDungeonKit";
Parser.SRC_SCREEN_SPELLJAMMER = "ScreenSpelljammer";
Parser.SRC_HEROES_FEAST = "HF";
Parser.SRC_CM = "CM";
Parser.SRC_NRH = "NRH";
Parser.SRC_NRH_TCMC = "NRH-TCMC";
Parser.SRC_NRH_AVitW = "NRH-AVitW";
Parser.SRC_NRH_ASS = "NRH-ASS"; // lmao
Parser.SRC_NRH_CoI = "NRH-CoI";
Parser.SRC_NRH_TLT = "NRH-TLT";
Parser.SRC_NRH_AWoL = "NRH-AWoL";
Parser.SRC_NRH_AT = "NRH-AT";
Parser.SRC_MGELFT = "MGELFT";
Parser.SRC_VD = "VD";
Parser.SRC_SjA = "SjA";
Parser.SRC_HAT_TG = "HAT-TG";
Parser.SRC_HAT_LMI = "HAT-LMI";

Parser.SRC_AL_PREFIX = "AL";

Parser.SRC_ALCoS = `${Parser.SRC_AL_PREFIX}CurseOfStrahd`;
Parser.SRC_ALEE = `${Parser.SRC_AL_PREFIX}ElementalEvil`;
Parser.SRC_ALRoD = `${Parser.SRC_AL_PREFIX}RageOfDemons`;

Parser.SRC_PS_PREFIX = "PS";

Parser.SRC_PSA = `${Parser.SRC_PS_PREFIX}A`;
Parser.SRC_PSI = `${Parser.SRC_PS_PREFIX}I`;
Parser.SRC_PSK = `${Parser.SRC_PS_PREFIX}K`;
Parser.SRC_PSZ = `${Parser.SRC_PS_PREFIX}Z`;
Parser.SRC_PSX = `${Parser.SRC_PS_PREFIX}X`;
Parser.SRC_PSD = `${Parser.SRC_PS_PREFIX}D`;

Parser.SRC_UA_PREFIX = "UA";
Parser.SRC_UA_ONE_PREFIX = "XUA";
Parser.SRC_MCVX_PREFIX = "MCV";

Parser.SRC_UAA = `${Parser.SRC_UA_PREFIX}Artificer`;
Parser.SRC_UAEAG = `${Parser.SRC_UA_PREFIX}EladrinAndGith`;
Parser.SRC_UAEBB = `${Parser.SRC_UA_PREFIX}Eberron`;
Parser.SRC_UAFFR = `${Parser.SRC_UA_PREFIX}FeatsForRaces`;
Parser.SRC_UAFFS = `${Parser.SRC_UA_PREFIX}FeatsForSkills`;
Parser.SRC_UAFO = `${Parser.SRC_UA_PREFIX}FiendishOptions`;
Parser.SRC_UAFT = `${Parser.SRC_UA_PREFIX}Feats`;
Parser.SRC_UAGH = `${Parser.SRC_UA_PREFIX}GothicHeroes`;
Parser.SRC_UAMDM = `${Parser.SRC_UA_PREFIX}ModernMagic`;
Parser.SRC_UASSP = `${Parser.SRC_UA_PREFIX}StarterSpells`;
Parser.SRC_UATMC = `${Parser.SRC_UA_PREFIX}TheMysticClass`;
Parser.SRC_UATOBM = `${Parser.SRC_UA_PREFIX}ThatOldBlackMagic`;
Parser.SRC_UATRR = `${Parser.SRC_UA_PREFIX}TheRangerRevised`;
Parser.SRC_UAWA = `${Parser.SRC_UA_PREFIX}WaterborneAdventures`;
Parser.SRC_UAVR = `${Parser.SRC_UA_PREFIX}VariantRules`;
Parser.SRC_UALDR = `${Parser.SRC_UA_PREFIX}LightDarkUnderdark`;
Parser.SRC_UARAR = `${Parser.SRC_UA_PREFIX}RangerAndRogue`;
Parser.SRC_UAATOSC = `${Parser.SRC_UA_PREFIX}ATrioOfSubclasses`;
Parser.SRC_UABPP = `${Parser.SRC_UA_PREFIX}BarbarianPrimalPaths`;
Parser.SRC_UARSC = `${Parser.SRC_UA_PREFIX}RevisedSubclasses`;
Parser.SRC_UAKOO = `${Parser.SRC_UA_PREFIX}KitsOfOld`;
Parser.SRC_UABBC = `${Parser.SRC_UA_PREFIX}BardBardColleges`;
Parser.SRC_UACDD = `${Parser.SRC_UA_PREFIX}ClericDivineDomains`;
Parser.SRC_UAD = `${Parser.SRC_UA_PREFIX}Druid`;
Parser.SRC_UARCO = `${Parser.SRC_UA_PREFIX}RevisedClassOptions`;
Parser.SRC_UAF = `${Parser.SRC_UA_PREFIX}Fighter`;
Parser.SRC_UAM = `${Parser.SRC_UA_PREFIX}Monk`;
Parser.SRC_UAP = `${Parser.SRC_UA_PREFIX}Paladin`;
Parser.SRC_UAMC = `${Parser.SRC_UA_PREFIX}ModifyingClasses`;
Parser.SRC_UAS = `${Parser.SRC_UA_PREFIX}Sorcerer`;
Parser.SRC_UAWAW = `${Parser.SRC_UA_PREFIX}WarlockAndWizard`;
Parser.SRC_UATF = `${Parser.SRC_UA_PREFIX}TheFaithful`;
Parser.SRC_UAWR = `${Parser.SRC_UA_PREFIX}WizardRevisited`;
Parser.SRC_UAESR = `${Parser.SRC_UA_PREFIX}ElfSubraces`;
Parser.SRC_UAMAC = `${Parser.SRC_UA_PREFIX}MassCombat`;
Parser.SRC_UA3PE = `${Parser.SRC_UA_PREFIX}ThreePillarExperience`;
Parser.SRC_UAGHI = `${Parser.SRC_UA_PREFIX}GreyhawkInitiative`;
Parser.SRC_UATSC = `${Parser.SRC_UA_PREFIX}ThreeSubclasses`;
Parser.SRC_UAOD = `${Parser.SRC_UA_PREFIX}OrderDomain`;
Parser.SRC_UACAM = `${Parser.SRC_UA_PREFIX}CentaursMinotaurs`;
Parser.SRC_UAGSS = `${Parser.SRC_UA_PREFIX}GiantSoulSorcerer`;
Parser.SRC_UARoE = `${Parser.SRC_UA_PREFIX}RacesOfEberron`;
Parser.SRC_UARoR = `${Parser.SRC_UA_PREFIX}RacesOfRavnica`;
Parser.SRC_UAWGE = `${Parser.SRC_UA_PREFIX}WGE`;
Parser.SRC_UAOSS = `${Parser.SRC_UA_PREFIX}OfShipsAndSea`;
Parser.SRC_UASIK = `${Parser.SRC_UA_PREFIX}Sidekicks`;
Parser.SRC_UAAR = `${Parser.SRC_UA_PREFIX}ArtificerRevisited`;
Parser.SRC_UABAM = `${Parser.SRC_UA_PREFIX}BarbarianAndMonk`;
Parser.SRC_UASAW = `${Parser.SRC_UA_PREFIX}SorcererAndWarlock`;
Parser.SRC_UABAP = `${Parser.SRC_UA_PREFIX}BardAndPaladin`;
Parser.SRC_UACDW = `${Parser.SRC_UA_PREFIX}ClericDruidWizard`;
Parser.SRC_UAFRR = `${Parser.SRC_UA_PREFIX}FighterRangerRogue`;
Parser.SRC_UACFV = `${Parser.SRC_UA_PREFIX}ClassFeatureVariants`;
Parser.SRC_UAFRW = `${Parser.SRC_UA_PREFIX}FighterRogueWizard`;
Parser.SRC_UAPCRM = `${Parser.SRC_UA_PREFIX}PrestigeClassesRunMagic`;
Parser.SRC_UAR = `${Parser.SRC_UA_PREFIX}Ranger`;
Parser.SRC_UA2020SC1 = `${Parser.SRC_UA_PREFIX}2020SubclassesPt1`;
Parser.SRC_UA2020SC2 = `${Parser.SRC_UA_PREFIX}2020SubclassesPt2`;
Parser.SRC_UA2020SC3 = `${Parser.SRC_UA_PREFIX}2020SubclassesPt3`;
Parser.SRC_UA2020SC4 = `${Parser.SRC_UA_PREFIX}2020SubclassesPt4`;
Parser.SRC_UA2020SC5 = `${Parser.SRC_UA_PREFIX}2020SubclassesPt5`;
Parser.SRC_UA2020SMT = `${Parser.SRC_UA_PREFIX}2020SpellsAndMagicTattoos`;
Parser.SRC_UA2020POR = `${Parser.SRC_UA_PREFIX}2020PsionicOptionsRevisited`;
Parser.SRC_UA2020SCR = `${Parser.SRC_UA_PREFIX}2020SubclassesRevisited`;
Parser.SRC_UA2020F = `${Parser.SRC_UA_PREFIX}2020Feats`;
Parser.SRC_UA2021GL = `${Parser.SRC_UA_PREFIX}2021GothicLineages`;
Parser.SRC_UA2021FF = `${Parser.SRC_UA_PREFIX}2021FolkOfTheFeywild`;
Parser.SRC_UA2021DO = `${Parser.SRC_UA_PREFIX}2021DraconicOptions`;
Parser.SRC_UA2021MoS = `${Parser.SRC_UA_PREFIX}2021MagesOfStrixhaven`;
Parser.SRC_UA2021TotM = `${Parser.SRC_UA_PREFIX}2021TravelersOfTheMultiverse`;
Parser.SRC_UA2022HoK = `${Parser.SRC_UA_PREFIX}2022HeroesOfKrynn`;
Parser.SRC_UA2022HoKR = `${Parser.SRC_UA_PREFIX}2022HeroesOfKrynnRevisited`;
Parser.SRC_UA2022GO = `${Parser.SRC_UA_PREFIX}2022GiantOptions`;
Parser.SRC_UA2022WotM = `${Parser.SRC_UA_PREFIX}2022WondersOfTheMultiverse`;
Parser.SRC_MCV1SC = `${Parser.SRC_MCVX_PREFIX}1SC`;
Parser.SRC_MCV2DC = `${Parser.SRC_MCVX_PREFIX}2DC`;
Parser.SRC_MCV3MC = `${Parser.SRC_MCVX_PREFIX}3MC`;

Parser.AL_PREFIX = "Adventurers League: ";
Parser.AL_PREFIX_SHORT = "AL: ";
Parser.PS_PREFIX = "Plane Shift: ";
Parser.PS_PREFIX_SHORT = "PS: ";
Parser.UA_PREFIX = "Unearthed Arcana: ";
Parser.UA_PREFIX_SHORT = "UA: ";
Parser.TftYP_NAME = "Tales from the Yawning Portal";
Parser.AitFR_NAME = "Adventures in the Forgotten Realms";
Parser.NRH_NAME = "NERDS Restoring Harmony";
Parser.MCVX_PREFIX = "Monstrous Compendium Volume ";

Parser.SOURCE_JSON_TO_FULL = {};
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_CoS] = "Curse of Strahd";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_DMG] = "Dungeon Master's Guide";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EEPC] = "Elemental Evil Player's Companion";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EET] = "Elemental Evil: Trinkets";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_HotDQ] = "Hoard of the Dragon Queen";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_LMoP] = "Lost Mine of Phandelver";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MM] = "Monster Manual";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_OotA] = "Out of the Abyss";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PHB] = "Player's Handbook";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PotA] = "Princes of the Apocalypse";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_RoT] = "The Rise of Tiamat";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_RoTOS] = "The Rise of Tiamat Online Supplement";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCAG] = "Sword Coast Adventurer's Guide";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SKT] = "Storm King's Thunder";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ToA] = "Tomb of Annihilation";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TLK] = "The Lost Kenku";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ToD] = "Tyranny of Dragons";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TTP] = "The Tortle Package";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP] = Parser.TftYP_NAME;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP_AtG] = `${Parser.TftYP_NAME}: Against the Giants`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP_DiT] = `${Parser.TftYP_NAME}: Dead in Thay`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP_TFoF] = `${Parser.TftYP_NAME}: The Forge of Fury`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP_THSoT] = `${Parser.TftYP_NAME}: The Hidden Shrine of Tamoachan`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP_TSC] = `${Parser.TftYP_NAME}: The Sunless Citadel`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP_ToH] = `${Parser.TftYP_NAME}: Tomb of Horrors`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP_WPM] = `${Parser.TftYP_NAME}: White Plume Mountain`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_VGM] = "Volo's Guide to Monsters";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_XGE] = "Xanathar's Guide to Everything";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_OGA] = "One Grung Above";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MTF] = "Mordenkainen's Tome of Foes";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_WDH] = "Waterdeep: Dragon Heist";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_WDMM] = "Waterdeep: Dungeon of the Mad Mage";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_GGR] = "Guildmasters' Guide to Ravnica";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_KKW] = "Krenko's Way";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_LLK] = "Lost Laboratory of Kwalish";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AZfyT] = "A Zib for your Thoughts";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_GoS] = "Ghosts of Saltmarsh";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AI] = "Acquisitions Incorporated";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_OoW] = "The Orrery of the Wanderer";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ESK] = "Essentials Kit";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_DIP] = "Dragon of Icespire Peak";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_HftT] = "Hunt for the Thessalhydra";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_DC] = "Divine Contention";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SLW] = "Storm Lord's Wrath";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SDW] = "Sleeping Dragon's Wake";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_BGDIA] = "Baldur's Gate: Descent Into Avernus";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_LR] = "Locathah Rising";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AL] = "Adventurers' League";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SAC] = "Sage Advice Compendium";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ERLW] = "Eberron: Rising from the Last War";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EFR] = "Eberron: Forgotten Relics";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_RMBRE] = "The Lost Dungeon of Rickedness: Big Rick Energy";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_RMR] = "Dungeons & Dragons vs. Rick and Morty: Basic Rules";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MFF] = "Mordenkainen's Fiendish Folio";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AWM] = "Adventure with Muk";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_IMR] = "Infernal Machine Rebuild";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SADS] = "Sapphire Anniversary Dice Set";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EGW] = "Explorer's Guide to Wildemount";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EGW_ToR] = "Tide of Retribution";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EGW_DD] = "Dangerous Designs";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EGW_FS] = "Frozen Sick";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EGW_US] = "Unwelcome Spirits";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MOT] = "Mythic Odysseys of Theros";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_IDRotF] = "Icewind Dale: Rime of the Frostmaiden";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TCE] = "Tasha's Cauldron of Everything";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_VRGR] = "Van Richten's Guide to Ravenloft";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_HoL] = "The House of Lament";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_RtG] = "Return to Glory";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AitFR] = Parser.AitFR_NAME;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AitFR_ISF] = `${Parser.AitFR_NAME}: In Scarlet Flames`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AitFR_THP] = `${Parser.AitFR_NAME}: The Hidden Page`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AitFR_AVT] = `${Parser.AitFR_NAME}: A Verdant Tomb`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AitFR_DN] = `${Parser.AitFR_NAME}: Deepest Night`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AitFR_FCD] = `${Parser.AitFR_NAME}: From Cyan Depths`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_WBtW] = "The Wild Beyond the Witchlight";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_DoD] = "Domains of Delight";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MaBJoV] = "Minsc and Boo's Journal of Villainy";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_FTD] = "Fizban's Treasury of Dragons";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCC] = "Strixhaven: A Curriculum of Chaos";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCC_CK] = "Campus Kerfuffle";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCC_HfMT] = "Hunt for Mage Tower";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCC_TMM] = "The Magister's Masquerade";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCC_ARiR] = "A Reckoning in Ruins";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MPMM] = "Mordenkainen Presents: Monsters of the Multiverse";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_CRCotN] = "Critical Role: Call of the Netherdeep";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_JttRC] = "Journeys through the Radiant Citadel";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SAiS] = "Spelljammer: Adventures in Space";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AAG] = "Astral Adventurer's Guide";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_BAM] = "Boo's Astral Menagerie";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_LoX] = "Light of Xaryxis";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_DoSI] = "Dragons of Stormwreck Isle";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_DSotDQ] = "Dragonlance: Shadow of the Dragon Queen";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_KftGV] = "Keys from the Golden Vault";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCREEN] = "Dungeon Master's Screen";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCREEN_WILDERNESS_KIT] = "Dungeon Master's Screen: Wilderness Kit";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCREEN_DUNGEON_KIT] = "Dungeon Master's Screen: Dungeon Kit";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCREEN_SPELLJAMMER] = "Dungeon Master's Screen: Spelljammer";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_HEROES_FEAST] = "Heroes' Feast";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_CM] = "Candlekeep Mysteries";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH] = Parser.NRH_NAME;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH_TCMC] = `${Parser.NRH_NAME}: The Candy Mountain Caper`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH_AVitW] = `${Parser.NRH_NAME}: A Voice in the Wilderness`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH_ASS] = `${Parser.NRH_NAME}: A Sticky Situation`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH_CoI] = `${Parser.NRH_NAME}: Circus of Illusions`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH_TLT] = `${Parser.NRH_NAME}: The Lost Tomb`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH_AWoL] = `${Parser.NRH_NAME}: A Web of Lies`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH_AT] = `${Parser.NRH_NAME}: Adventure Together`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MGELFT] = "Muk's Guide To Everything He Learned From Tasha";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_VD] = "Vecna Dossier";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SjA] = "Spelljammer Academy";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_HAT_TG] = "Honor Among Thieves: Thieves' Gallery";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_HAT_LMI] = "Honor Among Thieves: Legendary Magic Items";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ALCoS] = `${Parser.AL_PREFIX}Curse of Strahd`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ALEE] = `${Parser.AL_PREFIX}Elemental Evil`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ALRoD] = `${Parser.AL_PREFIX}Rage of Demons`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PSA] = `${Parser.PS_PREFIX}Amonkhet`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PSI] = `${Parser.PS_PREFIX}Innistrad`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PSK] = `${Parser.PS_PREFIX}Kaladesh`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PSZ] = `${Parser.PS_PREFIX}Zendikar`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PSX] = `${Parser.PS_PREFIX}Ixalan`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PSD] = `${Parser.PS_PREFIX}Dominaria`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_XMtS] = `X Marks the Spot`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAA] = `${Parser.UA_PREFIX}Artificer`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAEAG] = `${Parser.UA_PREFIX}Eladrin and Gith`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAEBB] = `${Parser.UA_PREFIX}Eberron`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAFFR] = `${Parser.UA_PREFIX}Feats for Races`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAFFS] = `${Parser.UA_PREFIX}Feats for Skills`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAFO] = `${Parser.UA_PREFIX}Fiendish Options`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAFT] = `${Parser.UA_PREFIX}Feats`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAGH] = `${Parser.UA_PREFIX}Gothic Heroes`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAMDM] = `${Parser.UA_PREFIX}Modern Magic`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UASSP] = `${Parser.UA_PREFIX}Starter Spells`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UATMC] = `${Parser.UA_PREFIX}The Mystic Class`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UATOBM] = `${Parser.UA_PREFIX}That Old Black Magic`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UATRR] = `${Parser.UA_PREFIX}The Ranger, Revised`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAWA] = `${Parser.UA_PREFIX}Waterborne Adventures`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAVR] = `${Parser.UA_PREFIX}Variant Rules`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UALDR] = `${Parser.UA_PREFIX}Light, Dark, Underdark!`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UARAR] = `${Parser.UA_PREFIX}Ranger and Rogue`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAATOSC] = `${Parser.UA_PREFIX}A Trio of Subclasses`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UABPP] = `${Parser.UA_PREFIX}Barbarian Primal Paths`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UARSC] = `${Parser.UA_PREFIX}Revised Subclasses`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAKOO] = `${Parser.UA_PREFIX}Kits of Old`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UABBC] = `${Parser.UA_PREFIX}Bard: Bard Colleges`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UACDD] = `${Parser.UA_PREFIX}Cleric: Divine Domains`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAD] = `${Parser.UA_PREFIX}Druid`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UARCO] = `${Parser.UA_PREFIX}Revised Class Options`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAF] = `${Parser.UA_PREFIX}Fighter`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAM] = `${Parser.UA_PREFIX}Monk`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAP] = `${Parser.UA_PREFIX}Paladin`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAMC] = `${Parser.UA_PREFIX}Modifying Classes`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAS] = `${Parser.UA_PREFIX}Sorcerer`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAWAW] = `${Parser.UA_PREFIX}Warlock and Wizard`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UATF] = `${Parser.UA_PREFIX}The Faithful`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAWR] = `${Parser.UA_PREFIX}Wizard Revisited`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAESR] = `${Parser.UA_PREFIX}Elf Subraces`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAMAC] = `${Parser.UA_PREFIX}Mass Combat`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA3PE] = `${Parser.UA_PREFIX}Three-Pillar Experience`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAGHI] = `${Parser.UA_PREFIX}Greyhawk Initiative`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UATSC] = `${Parser.UA_PREFIX}Three Subclasses`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAOD] = `${Parser.UA_PREFIX}Order Domain`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UACAM] = `${Parser.UA_PREFIX}Centaurs and Minotaurs`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAGSS] = `${Parser.UA_PREFIX}Giant Soul Sorcerer`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UARoE] = `${Parser.UA_PREFIX}Races of Eberron`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UARoR] = `${Parser.UA_PREFIX}Races of Ravnica`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAWGE] = "Wayfinder's Guide to Eberron";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAOSS] = `${Parser.UA_PREFIX}Of Ships and the Sea`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UASIK] = `${Parser.UA_PREFIX}Sidekicks`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAAR] = `${Parser.UA_PREFIX}Artificer Revisited`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UABAM] = `${Parser.UA_PREFIX}Barbarian and Monk`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UASAW] = `${Parser.UA_PREFIX}Sorcerer and Warlock`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UABAP] = `${Parser.UA_PREFIX}Bard and Paladin`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UACDW] = `${Parser.UA_PREFIX}Cleric, Druid, and Wizard`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAFRR] = `${Parser.UA_PREFIX}Fighter, Ranger, and Rogue`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UACFV] = `${Parser.UA_PREFIX}Class Feature Variants`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAFRW] = `${Parser.UA_PREFIX}Fighter, Rogue, and Wizard`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAPCRM] = `${Parser.UA_PREFIX}Prestige Classes and Rune Magic`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAR] = `${Parser.UA_PREFIX}Ranger`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA2020SC1] = `${Parser.UA_PREFIX}2020 Subclasses, Part 1`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA2020SC2] = `${Parser.UA_PREFIX}2020 Subclasses, Part 2`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA2020SC3] = `${Parser.UA_PREFIX}2020 Subclasses, Part 3`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA2020SC4] = `${Parser.UA_PREFIX}2020 Subclasses, Part 4`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA2020SC5] = `${Parser.UA_PREFIX}2020 Subclasses, Part 5`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA2020SMT] = `${Parser.UA_PREFIX}2020 Spells and Magic Tattoos`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA2020POR] = `${Parser.UA_PREFIX}2020 Psionic Options Revisited`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA2020SCR] = `${Parser.UA_PREFIX}2020 Subclasses Revisited`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA2020F] = `${Parser.UA_PREFIX}2020 Feats`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA2021GL] = `${Parser.UA_PREFIX}2021 Gothic Lineages`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA2021FF] = `${Parser.UA_PREFIX}2021 Folk of the Feywild`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA2021DO] = `${Parser.UA_PREFIX}2021 Draconic Options`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA2021MoS] = `${Parser.UA_PREFIX}2021 Mages of Strixhaven`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA2021TotM] = `${Parser.UA_PREFIX}2021 Travelers of the Multiverse`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA2022HoK] = `${Parser.UA_PREFIX}2022 Heroes of Krynn`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA2022HoKR] = `${Parser.UA_PREFIX}2022 Heroes of Krynn Revisited`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA2022GO] = `${Parser.UA_PREFIX}2022 Giant Options`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA2022WotM] = `${Parser.UA_PREFIX}2022 Wonders of the Multiverse`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MCV1SC] = `${Parser.MCVX_PREFIX}1: Spelljammer Creatures`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MCV2DC] = `${Parser.MCVX_PREFIX}2: Dragonlance Creatures`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MCV3MC] = `${Parser.MCVX_PREFIX}3: Minecraft Creatures`;

Parser.SOURCE_JSON_TO_ABV = {};
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_CoS] = "CoS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_DMG] = "DMG";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EEPC] = "EEPC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EET] = "EET";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_HotDQ] = "HotDQ";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_LMoP] = "LMoP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MM] = "MM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_OotA] = "OotA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PHB] = "PHB";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PotA] = "PotA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_RoT] = "RoT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_RoTOS] = "RoTOS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCAG] = "SCAG";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SKT] = "SKT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ToA] = "ToA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TLK] = "TLK";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ToD] = "ToD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TTP] = "TTP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP_AtG] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP_DiT] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP_TFoF] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP_THSoT] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP_TSC] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP_ToH] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP_WPM] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_VGM] = "VGM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_XGE] = "XGE";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_OGA] = "OGA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MTF] = "MTF";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_WDH] = "WDH";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_WDMM] = "WDMM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_GGR] = "GGR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_KKW] = "KKW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_LLK] = "LLK";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AZfyT] = "AZfyT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_GoS] = "GoS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AI] = "AI";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_OoW] = "OoW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ESK] = "ESK";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_DIP] = "DIP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_HftT] = "HftT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_DC] = "DC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SLW] = "SLW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SDW] = "SDW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_BGDIA] = "BGDIA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_LR] = "LR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AL] = "AL";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SAC] = "SAC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ERLW] = "ERLW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EFR] = "EFR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_RMBRE] = "RMBRE";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_RMR] = "RMR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MFF] = "MFF";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AWM] = "AWM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_IMR] = "IMR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SADS] = "SADS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EGW] = "EGW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EGW_ToR] = "ToR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EGW_DD] = "DD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EGW_FS] = "FS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EGW_US] = "US";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MOT] = "MOT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_IDRotF] = "IDRotF";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TCE] = "TCE";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_VRGR] = "VRGR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_HoL] = "HoL";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_RtG] = "RtG";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AitFR] = "AitFR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AitFR_ISF] = "AitFR-ISF";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AitFR_THP] = "AitFR-THP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AitFR_AVT] = "AitFR-AVT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AitFR_DN] = "AitFR-DN";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AitFR_FCD] = "AitFR-FCD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_WBtW] = "WBtW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_DoD] = "DoD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MaBJoV] = "MaBJoV";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_FTD] = "FTD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCC] = "SCC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCC_CK] = "SCC-CK";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCC_HfMT] = "SCC-HfMT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCC_TMM] = "SCC-TMM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCC_ARiR] = "SCC-ARiR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MPMM] = "MPMM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_CRCotN] = "CRCotN";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_JttRC] = "JttRC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SAiS] = "SAiS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AAG] = "AAG";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_BAM] = "BAM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_LoX] = "LoX";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_DoSI] = "DoSI";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_DSotDQ] = "DSotDQ";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_KftGV] = "KftGV";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCREEN] = "Screen";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCREEN_WILDERNESS_KIT] = "ScWild";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCREEN_DUNGEON_KIT] = "ScDun";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCREEN_SPELLJAMMER] = "ScSJ";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_HEROES_FEAST] = "HF";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_CM] = "CM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH] = "NRH";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH_TCMC] = "NRH-TCMC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH_AVitW] = "NRH-AVitW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH_ASS] = "NRH-ASS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH_CoI] = "NRH-CoI";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH_TLT] = "NRH-TLT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH_AWoL] = "NRH-AWoL";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH_AT] = "NRH-AT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MGELFT] = "MGELFT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_VD] = "VD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SjA] = "SjA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_HAT_TG] = "HAT-TG";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_HAT_LMI] = "HAT-LMI";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ALCoS] = "ALCoS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ALEE] = "ALEE";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ALRoD] = "ALRoD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PSA] = "PSA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PSI] = "PSI";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PSK] = "PSK";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PSZ] = "PSZ";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PSX] = "PSX";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PSD] = "PSD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_XMtS] = "XMtS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAA] = "UAA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAEAG] = "UAEaG";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAEBB] = "UAEB";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAFFR] = "UAFFR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAFFS] = "UAFFS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAFO] = "UAFO";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAFT] = "UAFT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAGH] = "UAGH";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAMDM] = "UAMM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UASSP] = "UASS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UATMC] = "UAMy";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UATOBM] = "UAOBM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UATRR] = "UATRR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAWA] = "UAWA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAVR] = "UAVR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UALDR] = "UALDU";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UARAR] = "UARAR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAATOSC] = "UAATOSC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UABPP] = "UABPP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UARSC] = "UARSC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAKOO] = "UAKoO";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UABBC] = "UABBC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UACDD] = "UACDD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAD] = "UAD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UARCO] = "UARCO";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAF] = "UAF";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAM] = "UAMk";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAP] = "UAP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAMC] = "UAMC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAS] = "UAS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAWAW] = "UAWAW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UATF] = "UATF";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAWR] = "UAWR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAESR] = "UAESR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAMAC] = "UAMAC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA3PE] = "UA3PE";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAGHI] = "UAGHI";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UATSC] = "UATSC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAOD] = "UAOD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UACAM] = "UACAM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAGSS] = "UAGSS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UARoE] = "UARoE";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UARoR] = "UARoR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAWGE] = "WGE";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAOSS] = "UAOSS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UASIK] = "UASIK";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAAR] = "UAAR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UABAM] = "UABAM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UASAW] = "UASAW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UABAP] = "UABAP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UACDW] = "UACDW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAFRR] = "UAFRR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UACFV] = "UACFV";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAFRW] = "UAFRW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAPCRM] = "UAPCRM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAR] = "UAR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA2020SC1] = "UA20S1";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA2020SC2] = "UA20S2";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA2020SC3] = "UA20S3";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA2020SC4] = "UA20S4";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA2020SC5] = "UA20S5";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA2020SMT] = "UA20SMT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA2020POR] = "UA20POR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA2020SCR] = "UA20SCR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA2020F] = "UA20F";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA2021GL] = "UA21GL";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA2021FF] = "UA21FF";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA2021DO] = "UA21DO";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA2021MoS] = "UA21MoS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA2021TotM] = "UA21TotM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA2022HoK] = "UA22HoK";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA2022HoKR] = "UA22HoKR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA2022GO] = "UA22GO";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA2022WotM] = "UA22WotM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MCV1SC] = "MCV1SC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MCV2DC] = "MCV2DC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MCV3MC] = "MCV3MC";

Parser.SOURCE_JSON_TO_DATE = {};
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_CoS] = "2016-03-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_DMG] = "2014-12-09";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EEPC] = "2015-03-10";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EET] = "2015-03-10";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_HotDQ] = "2014-08-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_LMoP] = "2014-07-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MM] = "2014-09-30";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_OotA] = "2015-09-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PHB] = "2014-08-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PotA] = "2015-04-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_RoT] = "2014-11-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_RoTOS] = "2014-11-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCAG] = "2015-11-03";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SKT] = "2016-09-06";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ToA] = "2017-09-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TLK] = "2017-11-28";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ToD] = "2019-10-22";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TTP] = "2017-09-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP_AtG] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP_DiT] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP_TFoF] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP_THSoT] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP_TSC] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP_ToH] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP_WPM] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_VGM] = "2016-11-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_XGE] = "2017-11-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_OGA] = "2017-10-11";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MTF] = "2018-05-29";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_WDH] = "2018-09-18";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_WDMM] = "2018-11-20";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_GGR] = "2018-11-20";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_KKW] = "2018-11-20";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_LLK] = "2018-11-10";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AZfyT] = "2019-03-05";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_GoS] = "2019-05-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AI] = "2019-06-18";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_OoW] = "2019-06-18";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ESK] = "2019-06-24";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_DIP] = "2019-06-24";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_HftT] = "2019-05-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_DC] = "2019-06-24";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SLW] = "2019-06-24";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SDW] = "2019-06-24";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_BGDIA] = "2019-09-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_LR] = "2019-09-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SAC] = "2019-01-31";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ERLW] = "2019-11-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EFR] = "2019-11-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_RMBRE] = "2019-11-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_RMR] = "2019-11-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MFF] = "2019-11-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AWM] = "2019-11-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_IMR] = "2019-11-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SADS] = "2019-12-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EGW] = "2020-03-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EGW_ToR] = "2020-03-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EGW_DD] = "2020-03-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EGW_FS] = "2020-03-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EGW_US] = "2020-03-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MOT] = "2020-06-02";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_IDRotF] = "2020-09-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TCE] = "2020-11-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_VRGR] = "2021-05-18";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_HoL] = "2021-05-18";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_RtG] = "2021-05-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AitFR] = "2021-06-30";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AitFR_ISF] = "2021-06-30";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AitFR_THP] = "2021-07-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AitFR_AVT] = "2021-07-14";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AitFR_DN] = "2021-07-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AitFR_FCD] = "2021-07-28";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_WBtW] = "2021-09-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_DoD] = "2021-09-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MaBJoV] = "2021-10-05";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_FTD] = "2021-11-26";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCC] = "2021-12-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCC_CK] = "2021-12-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCC_HfMT] = "2021-12-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCC_TMM] = "2021-12-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCC_ARiR] = "2021-12-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MPMM] = "2022-01-25";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_CRCotN] = "2022-03-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_JttRC] = "2022-07-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SAiS] = "2022-08-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AAG] = "2022-08-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_BAM] = "2022-08-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_LoX] = "2022-08-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_DoSI] = "2022-07-31";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_DSotDQ] = "2022-11-22";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_KftGV] = "2023-02-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCREEN] = "2015-01-20";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCREEN_WILDERNESS_KIT] = "2020-11-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCREEN_DUNGEON_KIT] = "2020-09-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCREEN_SPELLJAMMER] = "2022-08-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_HEROES_FEAST] = "2020-10-27";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_CM] = "2021-03-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH_TCMC] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH_AVitW] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH_ASS] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH_CoI] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH_TLT] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH_AWoL] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH_AT] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MGELFT] = "2020-12-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_VD] = "2022-06-09";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SjA] = "2022-07-11"; // pt1; pt2 2022-07-18; pt3 2022-07-25; pt4 2022-08-01
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_HAT_TG] = "2023-03-06";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_HAT_LMI] = "2023-03-31";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ALCoS] = "2016-03-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ALEE] = "2015-04-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ALRoD] = "2015-09-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PSA] = "2017-07-06";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PSI] = "2016-07-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PSK] = "2017-02-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PSZ] = "2016-04-27";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PSX] = "2018-01-09";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PSD] = "2018-07-31";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_XMtS] = "2017-12-11";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAEBB] = "2015-02-02";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAA] = "2017-01-09";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAEAG] = "2017-09-11";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAFFR] = "2017-04-24";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAFFS] = "2017-04-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAFO] = "2017-10-09";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAFT] = "2016-06-06";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAGH] = "2016-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAMDM] = "2015-08-03";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UASSP] = "2017-04-03";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UATMC] = "2017-03-13";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UATOBM] = "2015-12-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UATRR] = "2016-09-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAWA] = "2015-05-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAVR] = "2015-06-08";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UALDR] = "2015-11-02";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UARAR] = "2017-01-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAATOSC] = "2017-03-27";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UABPP] = "2016-11-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UARSC] = "2017-05-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAKOO] = "2016-01-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UABBC] = "2016-11-14";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UACDD] = "2016-11-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAD] = "2016-11-28";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UARCO] = "2017-06-05";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAF] = "2016-12-5";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAM] = "2016-12-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAP] = "2016-12-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAMC] = "2015-04-06";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAS] = "2017-02-06";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAWAW] = "2017-02-13";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UATF] = "2016-08-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAWR] = "2017-03-20";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAESR] = "2017-11-13";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAMAC] = "2017-02-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA3PE] = "2017-08-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAGHI] = "2017-07-10";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UATSC] = "2018-01-08";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAOD] = "2018-04-09";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UACAM] = "2018-05-14";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAGSS] = "2018-06-11";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UARoE] = "2018-07-23";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UARoR] = "2018-08-13";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAWGE] = "2018-07-23";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAOSS] = "2018-11-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UASIK] = "2018-12-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAAR] = "2019-02-28";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UABAM] = "2019-08-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UASAW] = "2019-09-05";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UABAP] = "2019-09-18";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UACDW] = "2019-10-03";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAFRR] = "2019-10-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UACFV] = "2019-11-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAFRW] = "2019-11-25";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAPCRM] = "2015-10-05";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAR] = "2015-09-09";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA2020SC1] = "2020-01-14";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA2020SC2] = "2020-02-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA2020SC3] = "2020-02-24";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA2020SC4] = "2020-08-05";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA2020SC5] = "2020-10-26";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA2020SMT] = "2020-03-26";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA2020POR] = "2020-04-14";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA2020SCR] = "2020-05-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA2020F] = "2020-07-13";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA2021GL] = "2020-01-26";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA2021FF] = "2020-03-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA2021DO] = "2021-04-14";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA2021MoS] = "2021-06-08";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA2021TotM] = "2021-10-08";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA2022HoK] = "2022-03-08";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA2022HoKR] = "2022-04-25";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA2022GO] = "2022-05-26";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA2022WotM] = "2022-07-18";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MCV1SC] = "2022-04-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MCV2DC] = "2022-12-05";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MCV3MC] = "2023-03-28";

Parser.SOURCES_ADVENTURES = new Set([
	Parser.SRC_LMoP,
	Parser.SRC_HotDQ,
	Parser.SRC_RoT,
	Parser.SRC_RoTOS,
	Parser.SRC_PotA,
	Parser.SRC_OotA,
	Parser.SRC_CoS,
	Parser.SRC_SKT,
	Parser.SRC_TYP,
	Parser.SRC_TYP_AtG,
	Parser.SRC_TYP_DiT,
	Parser.SRC_TYP_TFoF,
	Parser.SRC_TYP_THSoT,
	Parser.SRC_TYP_TSC,
	Parser.SRC_TYP_ToH,
	Parser.SRC_TYP_WPM,
	Parser.SRC_ToA,
	Parser.SRC_TLK,
	Parser.SRC_TTP,
	Parser.SRC_WDH,
	Parser.SRC_LLK,
	Parser.SRC_WDMM,
	Parser.SRC_KKW,
	Parser.SRC_AZfyT,
	Parser.SRC_GoS,
	Parser.SRC_HftT,
	Parser.SRC_OoW,
	Parser.SRC_DIP,
	Parser.SRC_SLW,
	Parser.SRC_SDW,
	Parser.SRC_DC,
	Parser.SRC_BGDIA,
	Parser.SRC_LR,
	Parser.SRC_EFR,
	Parser.SRC_RMBRE,
	Parser.SRC_IMR,
	Parser.SRC_EGW_ToR,
	Parser.SRC_EGW_DD,
	Parser.SRC_EGW_FS,
	Parser.SRC_EGW_US,
	Parser.SRC_IDRotF,
	Parser.SRC_CM,
	Parser.SRC_HoL,
	Parser.SRC_XMtS,
	Parser.SRC_RtG,
	Parser.SRC_AitFR,
	Parser.SRC_AitFR_ISF,
	Parser.SRC_AitFR_THP,
	Parser.SRC_AitFR_AVT,
	Parser.SRC_AitFR_DN,
	Parser.SRC_AitFR_FCD,
	Parser.SRC_WBtW,
	Parser.SRC_NRH,
	Parser.SRC_NRH_TCMC,
	Parser.SRC_NRH_AVitW,
	Parser.SRC_NRH_ASS,
	Parser.SRC_NRH_CoI,
	Parser.SRC_NRH_TLT,
	Parser.SRC_NRH_AWoL,
	Parser.SRC_NRH_AT,
	Parser.SRC_SCC,
	Parser.SRC_SCC_CK,
	Parser.SRC_SCC_HfMT,
	Parser.SRC_SCC_TMM,
	Parser.SRC_SCC_ARiR,
	Parser.SRC_CRCotN,
	Parser.SRC_JttRC,
	Parser.SRC_SjA,
	Parser.SRC_LoX,
	Parser.SRC_DoSI,
	Parser.SRC_DSotDQ,
	Parser.SRC_KftGV,

	Parser.SRC_AWM,
]);
Parser.SOURCES_CORE_SUPPLEMENTS = new Set(Object.keys(Parser.SOURCE_JSON_TO_FULL).filter(it => !Parser.SOURCES_ADVENTURES.has(it)));
Parser.SOURCES_NON_STANDARD_WOTC = new Set([
	Parser.SRC_OGA,
	Parser.SRC_LLK,
	Parser.SRC_AZfyT,
	Parser.SRC_LR,
	Parser.SRC_TLK,
	Parser.SRC_TTP,
	Parser.SRC_AWM,
	Parser.SRC_IMR,
	Parser.SRC_SADS,
	Parser.SRC_MFF,
	Parser.SRC_XMtS,
	Parser.SRC_RtG,
	Parser.SRC_AitFR,
	Parser.SRC_AitFR_ISF,
	Parser.SRC_AitFR_THP,
	Parser.SRC_AitFR_AVT,
	Parser.SRC_AitFR_DN,
	Parser.SRC_AitFR_FCD,
	Parser.SRC_DoD,
	Parser.SRC_MaBJoV,
	Parser.SRC_NRH,
	Parser.SRC_NRH_TCMC,
	Parser.SRC_NRH_AVitW,
	Parser.SRC_NRH_ASS,
	Parser.SRC_NRH_CoI,
	Parser.SRC_NRH_TLT,
	Parser.SRC_NRH_AWoL,
	Parser.SRC_NRH_AT,
	Parser.SRC_MGELFT,
	Parser.SRC_VD,
	Parser.SRC_SjA,
	Parser.SRC_HAT_TG,
	Parser.SRC_HAT_LMI,
	Parser.SRC_MCV3MC,
]);
// region Source categories

// An opinionated set of source that could be considered "core-core"
Parser.SOURCES_VANILLA = new Set([
	Parser.SRC_DMG,
	Parser.SRC_MM,
	Parser.SRC_PHB,
	Parser.SRC_SCAG,
	// Parser.SRC_TTP, // "Legacy" source, removed in favor of MPMM
	// Parser.SRC_VGM, // "Legacy" source, removed in favor of MPMM
	Parser.SRC_XGE,
	// Parser.SRC_MTF, // "Legacy" source, removed in favor of MPMM
	Parser.SRC_SAC,
	Parser.SRC_MFF,
	Parser.SRC_SADS,
	Parser.SRC_TCE,
	Parser.SRC_FTD,
	Parser.SRC_MPMM,
	Parser.SRC_SCREEN,
	Parser.SRC_SCREEN_WILDERNESS_KIT,
	Parser.SRC_SCREEN_DUNGEON_KIT,
	Parser.SRC_VD,
]);

// Any opinionated set of sources that are """hilarious, dude"""
Parser.SOURCES_COMEDY = new Set([
	Parser.SRC_AI,
	Parser.SRC_OoW,
	Parser.SRC_RMR,
	Parser.SRC_RMBRE,
	Parser.SRC_HftT,
	Parser.SRC_AWM,
	Parser.SRC_MGELFT,
	Parser.SRC_HAT_TG,
	Parser.SRC_HAT_LMI,
	Parser.SRC_MCV3MC,
]);

// Any opinionated set of sources that are "other settings"
Parser.SOURCES_NON_FR = new Set([
	Parser.SRC_GGR,
	Parser.SRC_KKW,
	Parser.SRC_ERLW,
	Parser.SRC_EFR,
	Parser.SRC_UAWGE,
	Parser.SRC_EGW,
	Parser.SRC_EGW_ToR,
	Parser.SRC_EGW_DD,
	Parser.SRC_EGW_FS,
	Parser.SRC_EGW_US,
	Parser.SRC_MOT,
	Parser.SRC_XMtS,
	Parser.SRC_AZfyT,
	Parser.SRC_SCC,
	Parser.SRC_SCC_CK,
	Parser.SRC_SCC_HfMT,
	Parser.SRC_SCC_TMM,
	Parser.SRC_SCC_ARiR,
	Parser.SRC_CRCotN,
	Parser.SRC_SjA,
	Parser.SRC_SAiS,
	Parser.SRC_AAG,
	Parser.SRC_BAM,
	Parser.SRC_LoX,
	Parser.SRC_DSotDQ,
]);

// endregion
Parser.SOURCES_AVAILABLE_DOCS_BOOK = {};
[
	Parser.SRC_PHB,
	Parser.SRC_MM,
	Parser.SRC_DMG,
	Parser.SRC_SCAG,
	Parser.SRC_VGM,
	Parser.SRC_OGA,
	Parser.SRC_XGE,
	Parser.SRC_MTF,
	Parser.SRC_GGR,
	Parser.SRC_AI,
	Parser.SRC_ERLW,
	Parser.SRC_RMR,
	Parser.SRC_EGW,
	Parser.SRC_MOT,
	Parser.SRC_TCE,
	Parser.SRC_VRGR,
	Parser.SRC_DoD,
	Parser.SRC_MaBJoV,
	Parser.SRC_FTD,
	Parser.SRC_SCC,
	Parser.SRC_MPMM,
	Parser.SRC_AAG,
	Parser.SRC_BAM,
	Parser.SRC_HAT_TG,
	Parser.SRC_SCREEN,
	Parser.SRC_SCREEN_WILDERNESS_KIT,
	Parser.SRC_SCREEN_DUNGEON_KIT,
	Parser.SRC_SCREEN_SPELLJAMMER,
].forEach(src => {
	Parser.SOURCES_AVAILABLE_DOCS_BOOK[src] = src;
	Parser.SOURCES_AVAILABLE_DOCS_BOOK[src.toLowerCase()] = src;
});
[
	{src: Parser.SRC_PSA, id: "PS-A"},
	{src: Parser.SRC_PSI, id: "PS-I"},
	{src: Parser.SRC_PSK, id: "PS-K"},
	{src: Parser.SRC_PSZ, id: "PS-Z"},
	{src: Parser.SRC_PSX, id: "PS-X"},
	{src: Parser.SRC_PSD, id: "PS-D"},
].forEach(({src, id}) => {
	Parser.SOURCES_AVAILABLE_DOCS_BOOK[src] = id;
	Parser.SOURCES_AVAILABLE_DOCS_BOOK[src.toLowerCase()] = id;
});
Parser.SOURCES_AVAILABLE_DOCS_ADVENTURE = {};
[
	Parser.SRC_LMoP,
	Parser.SRC_HotDQ,
	Parser.SRC_RoT,
	Parser.SRC_PotA,
	Parser.SRC_OotA,
	Parser.SRC_CoS,
	Parser.SRC_SKT,
	Parser.SRC_TYP_AtG,
	Parser.SRC_TYP_DiT,
	Parser.SRC_TYP_TFoF,
	Parser.SRC_TYP_THSoT,
	Parser.SRC_TYP_TSC,
	Parser.SRC_TYP_ToH,
	Parser.SRC_TYP_WPM,
	Parser.SRC_ToA,
	Parser.SRC_TLK,
	Parser.SRC_TTP,
	Parser.SRC_WDH,
	Parser.SRC_LLK,
	Parser.SRC_WDMM,
	Parser.SRC_KKW,
	Parser.SRC_AZfyT,
	Parser.SRC_GoS,
	Parser.SRC_HftT,
	Parser.SRC_OoW,
	Parser.SRC_DIP,
	Parser.SRC_SLW,
	Parser.SRC_SDW,
	Parser.SRC_DC,
	Parser.SRC_BGDIA,
	Parser.SRC_LR,
	Parser.SRC_EFR,
	Parser.SRC_RMBRE,
	Parser.SRC_IMR,
	Parser.SRC_EGW_ToR,
	Parser.SRC_EGW_DD,
	Parser.SRC_EGW_FS,
	Parser.SRC_EGW_US,
	Parser.SRC_IDRotF,
	Parser.SRC_CM,
	Parser.SRC_HoL,
	Parser.SRC_XMtS,
	Parser.SRC_RtG,
	Parser.SRC_AitFR_ISF,
	Parser.SRC_AitFR_THP,
	Parser.SRC_AitFR_AVT,
	Parser.SRC_AitFR_DN,
	Parser.SRC_AitFR_FCD,
	Parser.SRC_WBtW,
	Parser.SRC_NRH,
	Parser.SRC_NRH_TCMC,
	Parser.SRC_NRH_AVitW,
	Parser.SRC_NRH_ASS,
	Parser.SRC_NRH_CoI,
	Parser.SRC_NRH_TLT,
	Parser.SRC_NRH_AWoL,
	Parser.SRC_NRH_AT,
	Parser.SRC_SCC_CK,
	Parser.SRC_SCC_HfMT,
	Parser.SRC_SCC_TMM,
	Parser.SRC_SCC_ARiR,
	Parser.SRC_CRCotN,
	Parser.SRC_JttRC,
	Parser.SRC_LoX,
	Parser.SRC_DoSI,
	Parser.SRC_DSotDQ,
	Parser.SRC_KftGV,
].forEach(src => {
	Parser.SOURCES_AVAILABLE_DOCS_ADVENTURE[src] = src;
	Parser.SOURCES_AVAILABLE_DOCS_ADVENTURE[src.toLowerCase()] = src;
});

Parser.getTagSource = function (tag, source) {
	if (source && source.trim()) return source;

	tag = tag.trim();

	const tagMeta = Renderer.tag.TAG_LOOKUP[tag];

	if (!tagMeta) throw new Error(`Unhandled tag "${tag}"`);
	return tagMeta.defaultSource;
};

Parser.PROP_TO_TAG = {
	"monster": "creature",
	"optionalfeature": "optfeature",
	"tableGroup": "table",
	"vehicleUpgrade": "vehupgrade",
	"baseitem": "item",
	"itemGroup": "item",
	"magicvariant": "item",
};
Parser.getPropTag = function (prop) {
	if (Parser.PROP_TO_TAG[prop]) return Parser.PROP_TO_TAG[prop];
	return prop;
};

Parser.PROP_TO_DISPLAY_NAME = {
	"variantrule": "Variant Rule",
	"optionalfeature": "Option/Feature",
	"magicvariant": "Magic Item Variant",
	"baseitem": "Item (Base)",
	"item": "Item",
	"adventure": "Adventure",
	"adventureData": "Adventure Text",
	"book": "Book",
	"bookData": "Book Text",
	"makebrewCreatureTrait": "Homebrew Builder Creature Trait",
	"charoption": "Other Character Creation Option",

	"bonus": "Bonus Action",
	"legendary": "Legendary Action",
	"mythic": "Mythic Action",
	"lairActions": "Lair Action",
	"regionalEffects": "Regional Effect",
};
Parser.getPropDisplayName = function (prop, {suffix = ""} = {}) {
	if (Parser.PROP_TO_DISPLAY_NAME[prop]) return `${Parser.PROP_TO_DISPLAY_NAME[prop]}${suffix}`;

	const mFluff = /Fluff$/.exec(prop);
	if (mFluff) return Parser.getPropDisplayName(prop.slice(0, -mFluff[0].length), {suffix: " Fluff"});

	const mFoundry = /^foundry(?<prop>[A-Z].*)$/.exec(prop);
	if (mFoundry) return Parser.getPropDisplayName(mFoundry.groups.prop.lowercaseFirst(), {suffix: " Foundry Data"});

	return `${prop.split(/([A-Z][a-z]+)/g).join(" ").uppercaseFirst()}${suffix}`;
};

Parser.ITEM_TYPE_JSON_TO_ABV = {
	"A": "ammunition",
	"AF": "ammunition",
	"AT": "artisan's tools",
	"EM": "eldritch machine",
	"EXP": "explosive",
	"FD": "food and drink",
	"G": "adventuring gear",
	"GS": "gaming set",
	"HA": "heavy armor",
	"INS": "instrument",
	"LA": "light armor",
	"M": "melee weapon",
	"MA": "medium armor",
	"MNT": "mount",
	"MR": "master rune",
	"GV": "generic variant",
	"P": "potion",
	"R": "ranged weapon",
	"RD": "rod",
	"RG": "ring",
	"S": "shield",
	"SC": "scroll",
	"SCF": "spellcasting focus",
	"OTH": "other",
	"T": "tools",
	"TAH": "tack and harness",
	"TG": "trade good",
	"$": "treasure",
	"VEH": "vehicle (land)",
	"SHP": "vehicle (water)",
	"AIR": "vehicle (air)",
	"SPC": "vehicle (space)",
	"WD": "wand",
};

Parser.DMGTYPE_JSON_TO_FULL = {
	"A": "acid",
	"B": "bludgeoning",
	"C": "cold",
	"F": "fire",
	"O": "force",
	"L": "lightning",
	"N": "necrotic",
	"P": "piercing",
	"I": "poison",
	"Y": "psychic",
	"R": "radiant",
	"S": "slashing",
	"T": "thunder",
};

Parser.DMG_TYPES = ["acid", "bludgeoning", "cold", "fire", "force", "lightning", "necrotic", "piercing", "poison", "psychic", "radiant", "slashing", "thunder"];
Parser.CONDITIONS = ["blinded", "charmed", "deafened", "exhaustion", "frightened", "grappled", "incapacitated", "invisible", "paralyzed", "petrified", "poisoned", "prone", "restrained", "stunned", "unconscious"];

Parser.SENSES = [
	{"name": "blindsight", "source": Parser.SRC_PHB},
	{"name": "darkvision", "source": Parser.SRC_PHB},
	{"name": "tremorsense", "source": Parser.SRC_MM},
	{"name": "truesight", "source": Parser.SRC_PHB},
];

Parser.NUMBERS_ONES = ["", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"];
Parser.NUMBERS_TENS = ["", "", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"];
Parser.NUMBERS_TEENS = ["ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen"];

// region Metric conversion
Parser.metric = {
	// See MPMB's breakdown: https://old.reddit.com/r/dndnext/comments/6gkuec
	MILES_TO_KILOMETRES: 1.6,
	FEET_TO_METRES: 0.3, // 5 ft = 1.5 m
	YARDS_TO_METRES: 0.9, // (as above)
	POUNDS_TO_KILOGRAMS: 0.5, // 2 lb = 1 kg

	getMetricNumber ({originalValue, originalUnit, toFixed = null}) {
		if (isNaN(originalValue)) return originalValue;
		originalValue = Number(originalValue);
		if (!originalValue) return originalValue;

		let out = null;
		switch (originalUnit) {
			case "ft.": case "ft": case Parser.UNT_FEET: out = originalValue * Parser.metric.FEET_TO_METRES; break;
			case "yd.": case "yd": case Parser.UNT_YARDS: out = originalValue * Parser.metric.YARDS_TO_METRES; break;
			case "mi.": case "mi": case Parser.UNT_MILES: out = originalValue * Parser.metric.MILES_TO_KILOMETRES; break;
			case "lb.": case "lb": case "lbs": out = originalValue * Parser.metric.POUNDS_TO_KILOGRAMS; break;
			default: return originalValue;
		}
		if (toFixed != null) return Number(out.toFixed(toFixed));
		return out;
	},

	getMetricUnit ({originalUnit, isShortForm = false, isPlural = true}) {
		switch (originalUnit) {
			case "ft.": case "ft": case Parser.UNT_FEET: return isShortForm ? "m" : `meter${isPlural ? "s" : ""}`;
			case "yd.": case "yd": case Parser.UNT_YARDS: return isShortForm ? "m" : `meter${isPlural ? "s" : ""}`;
			case "mi.": case "mi": case Parser.UNT_MILES: return isShortForm ? "km" : `kilometre${isPlural ? "s" : ""}`;
			case "lb.": case "lb": case "lbs": return isShortForm ? "kg" : `kilogram${isPlural ? "s" : ""}`;
			default: return originalUnit;
		}
	},
};
// endregion
// region Map grids

Parser.MAP_GRID_TYPE_TO_FULL = {};
Parser.MAP_GRID_TYPE_TO_FULL["none"] = "None";
Parser.MAP_GRID_TYPE_TO_FULL["square"] = "Square";
Parser.MAP_GRID_TYPE_TO_FULL["hexRowsOdd"] = "Hex Rows (Odd)";
Parser.MAP_GRID_TYPE_TO_FULL["hexRowsEven"] = "Hex Rows (Even)";
Parser.MAP_GRID_TYPE_TO_FULL["hexColsOdd"] = "Hex Columns (Odd)";
Parser.MAP_GRID_TYPE_TO_FULL["hexColsEven"] = "Hex Columns (Even)";

Parser.mapGridTypeToFull = function (gridType) {
	return Parser._parse_aToB(Parser.MAP_GRID_TYPE_TO_FULL, gridType);
};
// endregion

}).toString());



EXT_LIB_SCRIPTS.push((function lib_script_4 () {
"use strict";

// in deployment, `IS_DEPLOYED = "<version number>";` should be set below.
globalThis.IS_DEPLOYED = undefined;
globalThis.VERSION_NUMBER = /* 5ETOOLS_VERSION__OPEN */"1.179.0"/* 5ETOOLS_VERSION__CLOSE */;
globalThis.DEPLOYED_STATIC_ROOT = ""; // "https://static.5etools.com/"; // FIXME re-enable this when we have a CDN again
globalThis.DEPLOYED_IMG_ROOT = undefined;
// for the roll20 script to set
globalThis.IS_VTT = false;

globalThis.IMGUR_CLIENT_ID = `abdea4de492d3b0`;

// TODO refactor into VeCt
globalThis.HASH_PART_SEP = ",";
globalThis.HASH_LIST_SEP = "_";
globalThis.HASH_SUB_LIST_SEP = "~";
globalThis.HASH_SUB_KV_SEP = ":";
globalThis.HASH_BLANK = "blankhash";
globalThis.HASH_SUB_NONE = "null";

globalThis.VeCt = {
	STR_NONE: "None",
	STR_SEE_CONSOLE: "See the console (CTRL+SHIFT+J) for details.",

	HASH_SCALED: "scaled",
	HASH_SCALED_SPELL_SUMMON: "scaledspellsummon",
	HASH_SCALED_CLASS_SUMMON: "scaledclasssummon",

	FILTER_BOX_SUB_HASH_SEARCH_PREFIX: "fbsr",

	JSON_PRERELEASE_INDEX: `prerelease/index.json`,
	JSON_BREW_INDEX: `homebrew/index.json`,

	STORAGE_HOMEBREW: "HOMEBREW_STORAGE",
	STORAGE_HOMEBREW_META: "HOMEBREW_META_STORAGE",
	STORAGE_EXCLUDES: "EXCLUDES_STORAGE",
	STORAGE_DMSCREEN: "DMSCREEN_STORAGE",
	STORAGE_DMSCREEN_TEMP_SUBLIST: "DMSCREEN_TEMP_SUBLIST",
	STORAGE_ROLLER_MACRO: "ROLLER_MACRO_STORAGE",
	STORAGE_ENCOUNTER: "ENCOUNTER_STORAGE",
	STORAGE_POINTBUY: "POINTBUY_STORAGE",
	STORAGE_GLOBAL_COMPONENT_STATE: "GLOBAL_COMPONENT_STATE",

	DUR_INLINE_NOTIFY: 500,

	PG_NONE: "NO_PAGE",
	STR_GENERIC: "Generic",

	SYM_UI_SKIP: Symbol("uiSkip"),

	SYM_WALKER_BREAK: Symbol("walkerBreak"),

	SYM_UTIL_TIMEOUT: Symbol("timeout"),

	LOC_ORIGIN_CANCER: "https://5e.tools",

	URL_BREW: `https://github.com/TheGiddyLimit/homebrew`,
	URL_ROOT_BREW: `https://raw.githubusercontent.com/TheGiddyLimit/homebrew/master/`, // N.b. must end with a slash
	URL_PRERELEASE: `https://github.com/TheGiddyLimit/unearthed-arcana`,
	URL_ROOT_PRERELEASE: `https://raw.githubusercontent.com/TheGiddyLimit/unearthed-arcana/master/`, // As above

	STR_NO_ATTUNEMENT: "No Attunement Required",

	CR_UNKNOWN: 100001,
	CR_CUSTOM: 100000,

	SPELL_LEVEL_MAX: 9,
	LEVEL_MAX: 20,

	ENTDATA_TABLE_INCLUDE: "tableInclude",
	ENTDATA_ITEM_MERGED_ENTRY_TAG: "item__mergedEntryTag",

	DRAG_TYPE_IMPORT: "ve-Import",
	DRAG_TYPE_LOOT: "ve-Loot",

	Z_INDEX_BENEATH_HOVER: 199,
};

// STRING ==============================================================================================================
String.prototype.uppercaseFirst = String.prototype.uppercaseFirst || function () {
	const str = this.toString();
	if (str.length === 0) return str;
	if (str.length === 1) return str.charAt(0).toUpperCase();
	return str.charAt(0).toUpperCase() + str.slice(1);
};

String.prototype.lowercaseFirst = String.prototype.lowercaseFirst || function () {
	const str = this.toString();
	if (str.length === 0) return str;
	if (str.length === 1) return str.charAt(0).toLowerCase();
	return str.charAt(0).toLowerCase() + str.slice(1);
};

String.prototype.toTitleCase = String.prototype.toTitleCase || function () {
	let str = this.replace(/([^\W_]+[^-\u2014\s/]*) */g, m0 => m0.charAt(0).toUpperCase() + m0.substr(1).toLowerCase());

	// Require space surrounded, as title-case requires a full word on either side
	StrUtil._TITLE_LOWER_WORDS_RE = StrUtil._TITLE_LOWER_WORDS_RE || StrUtil.TITLE_LOWER_WORDS.map(it => new RegExp(`\\s${it}\\s`, "gi"));
	StrUtil._TITLE_UPPER_WORDS_RE = StrUtil._TITLE_UPPER_WORDS_RE || StrUtil.TITLE_UPPER_WORDS.map(it => new RegExp(`\\b${it}\\b`, "g"));
	StrUtil._TITLE_UPPER_WORDS_PLURAL_RE = StrUtil._TITLE_UPPER_WORDS_PLURAL_RE || StrUtil.TITLE_UPPER_WORDS.map(it => new RegExp(`\\b${it}s\\b`, "g"));

	const len = StrUtil.TITLE_LOWER_WORDS.length;
	for (let i = 0; i < len; i++) {
		str = str.replace(
			StrUtil._TITLE_LOWER_WORDS_RE[i],
			txt => txt.toLowerCase(),
		);
	}

	const len1 = StrUtil.TITLE_UPPER_WORDS.length;
	for (let i = 0; i < len1; i++) {
		str = str.replace(
			StrUtil._TITLE_UPPER_WORDS_RE[i],
			StrUtil.TITLE_UPPER_WORDS[i].toUpperCase(),
		);
	}

	for (let i = 0; i < len1; i++) {
		str = str.replace(
			StrUtil._TITLE_UPPER_WORDS_PLURAL_RE[i],
			`${StrUtil.TITLE_UPPER_WORDS[i].toUpperCase()}s`,
		);
	}

	str = str
		.split(/([;:?!.])/g)
		.map(pt => pt.replace(/^(\s*)([^\s])/, (...m) => `${m[1]}${m[2].toUpperCase()}`))
		.join("");

	return str;
};

String.prototype.toSentenceCase = String.prototype.toSentenceCase || function () {
	const out = [];
	const re = /([^.!?]+)([.!?]\s*|$)/gi;
	let m;
	do {
		m = re.exec(this);
		if (m) {
			out.push(m[0].toLowerCase().uppercaseFirst());
		}
	} while (m);
	return out.join("");
};

String.prototype.toSpellCase = String.prototype.toSpellCase || function () {
	return this.toLowerCase().replace(/(^|of )(bigby|otiluke|mordenkainen|evard|hadar|agathys|abi-dalzim|aganazzar|drawmij|leomund|maximilian|melf|nystul|otto|rary|snilloc|tasha|tenser|jim)('s|$| )/g, (...m) => `${m[1]}${m[2].toTitleCase()}${m[3]}`);
};

String.prototype.toCamelCase = String.prototype.toCamelCase || function () {
	return this.split(" ").map((word, index) => {
		if (index === 0) return word.toLowerCase();
		return `${word.charAt(0).toUpperCase()}${word.slice(1).toLowerCase()}`;
	}).join("");
};

String.prototype.escapeQuotes = String.prototype.escapeQuotes || function () {
	return this.replace(/'/g, `&apos;`).replace(/"/g, `&quot;`).replace(/</g, `&lt;`).replace(/>/g, `&gt;`);
};

String.prototype.qq = String.prototype.qq || function () {
	return this.escapeQuotes();
};

String.prototype.unescapeQuotes = String.prototype.unescapeQuotes || function () {
	return this.replace(/&apos;/g, `'`).replace(/&quot;/g, `"`).replace(/&lt;/g, `<`).replace(/&gt;/g, `>`);
};

String.prototype.uq = String.prototype.uq || function () {
	return this.unescapeQuotes();
};

String.prototype.encodeApos = String.prototype.encodeApos || function () {
	return this.replace(/'/g, `%27`);
};

/**
 * Calculates the Damerau-Levenshtein distance between two strings.
 * https://gist.github.com/IceCreamYou/8396172
 */
String.prototype.distance = String.prototype.distance || function (target) {
	let source = this; let i; let j;
	if (!source) return target ? target.length : 0;
	else if (!target) return source.length;

	const m = source.length; const n = target.length; const INF = m + n; const score = new Array(m + 2); const sd = {};
	for (i = 0; i < m + 2; i++) score[i] = new Array(n + 2);
	score[0][0] = INF;
	for (i = 0; i <= m; i++) {
		score[i + 1][1] = i;
		score[i + 1][0] = INF;
		sd[source[i]] = 0;
	}
	for (j = 0; j <= n; j++) {
		score[1][j + 1] = j;
		score[0][j + 1] = INF;
		sd[target[j]] = 0;
	}

	for (i = 1; i <= m; i++) {
		let DB = 0;
		for (j = 1; j <= n; j++) {
			const i1 = sd[target[j - 1]]; const j1 = DB;
			if (source[i - 1] === target[j - 1]) {
				score[i + 1][j + 1] = score[i][j];
				DB = j;
			} else {
				score[i + 1][j + 1] = Math.min(score[i][j], Math.min(score[i + 1][j], score[i][j + 1])) + 1;
			}
			score[i + 1][j + 1] = Math.min(score[i + 1][j + 1], score[i1] ? score[i1][j1] + (i - i1 - 1) + 1 + (j - j1 - 1) : Infinity);
		}
		sd[source[i - 1]] = i;
	}
	return score[m + 1][n + 1];
};

String.prototype.isNumeric = String.prototype.isNumeric || function () {
	return !isNaN(parseFloat(this)) && isFinite(this);
};

String.prototype.last = String.prototype.last || function () {
	return this[this.length - 1];
};

String.prototype.escapeRegexp = String.prototype.escapeRegexp || function () {
	return this.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
};

String.prototype.toUrlified = String.prototype.toUrlified || function () {
	return encodeURIComponent(this.toLowerCase()).toLowerCase();
};

String.prototype.toChunks = String.prototype.toChunks || function (size) {
	// https://stackoverflow.com/a/29202760/5987433
	const numChunks = Math.ceil(this.length / size);
	const chunks = new Array(numChunks);
	for (let i = 0, o = 0; i < numChunks; ++i, o += size) chunks[i] = this.substr(o, size);
	return chunks;
};

String.prototype.toAscii = String.prototype.toAscii || function () {
	return this
		.normalize("NFD") // replace diacritics with their individual graphemes
		.replace(/[\u0300-\u036f]/g, "") // remove accent graphemes
		.replace(/Æ/g, "AE").replace(/æ/g, "ae");
};

String.prototype.trimChar = String.prototype.trimChar || function (ch) {
	let start = 0; let end = this.length;
	while (start < end && this[start] === ch) ++start;
	while (end > start && this[end - 1] === ch) --end;
	return (start > 0 || end < this.length) ? this.substring(start, end) : this;
};

String.prototype.trimAnyChar = String.prototype.trimAnyChar || function (chars) {
	let start = 0; let end = this.length;
	while (start < end && chars.indexOf(this[start]) >= 0) ++start;
	while (end > start && chars.indexOf(this[end - 1]) >= 0) --end;
	return (start > 0 || end < this.length) ? this.substring(start, end) : this;
};

Array.prototype.joinConjunct || Object.defineProperty(Array.prototype, "joinConjunct", {
	enumerable: false,
	writable: true,
	value: function (joiner, lastJoiner, nonOxford) {
		if (this.length === 0) return "";
		if (this.length === 1) return this[0];
		if (this.length === 2) return this.join(lastJoiner);
		else {
			let outStr = "";
			for (let i = 0; i < this.length; ++i) {
				outStr += this[i];
				if (i < this.length - 2) outStr += joiner;
				else if (i === this.length - 2) outStr += `${(!nonOxford && this.length > 2 ? joiner.trim() : "")}${lastJoiner}`;
			}
			return outStr;
		}
	},
});

globalThis.StrUtil = {
	COMMAS_NOT_IN_PARENTHESES_REGEX: /,\s?(?![^(]*\))/g,
	COMMA_SPACE_NOT_IN_PARENTHESES_REGEX: /, (?![^(]*\))/g,

	uppercaseFirst: function (string) {
		return string.uppercaseFirst();
	},
	// Certain minor words should be left lowercase unless they are the first or last words in the string
	TITLE_LOWER_WORDS: ["a", "an", "the", "and", "but", "or", "for", "nor", "as", "at", "by", "for", "from", "in", "into", "near", "of", "on", "onto", "to", "with", "over", "von"],
	// Certain words such as initialisms or acronyms should be left uppercase
	TITLE_UPPER_WORDS: ["Id", "Tv", "Dm", "Ok", "Npc", "Pc", "Tpk", "Wip"],

	padNumber: (n, len, padder) => {
		return String(n).padStart(len, padder);
	},

	elipsisTruncate (str, atLeastPre = 5, atLeastSuff = 0, maxLen = 20) {
		if (maxLen >= str.length) return str;

		maxLen = Math.max(atLeastPre + atLeastSuff + 3, maxLen);
		let out = "";
		let remain = maxLen - (3 + atLeastPre + atLeastSuff);
		for (let i = 0; i < str.length - atLeastSuff; ++i) {
			const c = str[i];
			if (i < atLeastPre) out += c;
			else if ((remain--) > 0) out += c;
		}
		if (remain < 0) out += "...";
		out += str.substring(str.length - atLeastSuff, str.length);
		return out;
	},

	toTitleCase (str) { return str.toTitleCase(); },
	qq (str) { return (str = str || "").qq(); },
};

globalThis.CleanUtil = {
	getCleanJson (data, {isMinify = false, isFast = true} = {}) {
		data = MiscUtil.copy(data);
		data = MiscUtil.getWalker().walk(data, {string: (str) => CleanUtil.getCleanString(str, {isFast})});
		let str = isMinify ? JSON.stringify(data) : `${JSON.stringify(data, null, "\t")}\n`;
		return str.replace(CleanUtil.STR_REPLACEMENTS_REGEX, (match) => CleanUtil.STR_REPLACEMENTS[match]);
	},

	getCleanString (str, {isFast = true} = {}) {
		str = str
			.replace(CleanUtil.SHARED_REPLACEMENTS_REGEX, (match) => CleanUtil.SHARED_REPLACEMENTS[match])
			.replace(CleanUtil._SOFT_HYPHEN_REMOVE_REGEX, "")
		;

		if (isFast) return str;

		const ptrStack = {_: ""};
		CleanUtil._getCleanString_walkerStringHandler(ptrStack, 0, str);
		return ptrStack._;
	},

	_getCleanString_walkerStringHandler (ptrStack, tagCount, str) {
		const tagSplit = Renderer.splitByTags(str);
		const len = tagSplit.length;
		for (let i = 0; i < len; ++i) {
			const s = tagSplit[i];
			if (!s) continue;
			if (s.startsWith("{@")) {
				const [tag, text] = Renderer.splitFirstSpace(s.slice(1, -1));

				ptrStack._ += `{${tag}${text.length ? " " : ""}`;
				this._getCleanString_walkerStringHandler(ptrStack, tagCount + 1, text);
				ptrStack._ += `}`;
			} else {
				// avoid tagging things wrapped in existing tags
				if (tagCount) {
					ptrStack._ += s;
				} else {
					ptrStack._ += s
						.replace(CleanUtil._DASH_COLLAPSE_REGEX, "$1")
						.replace(CleanUtil._ELLIPSIS_COLLAPSE_REGEX, "$1");
				}
			}
		}
	},
};
CleanUtil.SHARED_REPLACEMENTS = {
	"’": "'",
	"‘": "'",
	"": "'",
	"…": "...",
	"\u200B": ``, // zero-width space
	"ﬀ": "ff",
	"ﬃ": "ffi",
	"ﬄ": "ffl",
	"ﬁ": "fi",
	"ﬂ": "fl",
	"Ĳ": "IJ",
	"ĳ": "ij",
	"Ǉ": "LJ",
	"ǈ": "Lj",
	"ǉ": "lj",
	"Ǌ": "NJ",
	"ǋ": "Nj",
	"ǌ": "nj",
	"ﬅ": "ft",
	"“": `"`,
	"”": `"`,
};
CleanUtil.STR_REPLACEMENTS = {
	"—": "\\u2014",
	"–": "\\u2013",
	"−": "\\u2212",
	" ": "\\u00A0",
};
CleanUtil.SHARED_REPLACEMENTS_REGEX = new RegExp(Object.keys(CleanUtil.SHARED_REPLACEMENTS).join("|"), "g");
CleanUtil.STR_REPLACEMENTS_REGEX = new RegExp(Object.keys(CleanUtil.STR_REPLACEMENTS).join("|"), "g");
CleanUtil._SOFT_HYPHEN_REMOVE_REGEX = /\u00AD *\r?\n?\r?/g;
CleanUtil._ELLIPSIS_COLLAPSE_REGEX = /\s*(\.\s*\.\s*\.)/g;
CleanUtil._DASH_COLLAPSE_REGEX = /[ ]*([\u2014\u2013])[ ]*/g;

// SOURCES =============================================================================================================
globalThis.SourceUtil = {
	ADV_BOOK_GROUPS: [
		{group: "core", displayName: "Core"},
		{group: "supplement", displayName: "Supplements"},
		{group: "setting", displayName: "Settings"},
		{group: "supplement-alt", displayName: "Extras"},
		{group: "prerelease", displayName: "Prerelease"},
		{group: "homebrew", displayName: "Homebrew"},
		{group: "screen", displayName: "Screens"},
		{group: "other", displayName: "Miscellaneous"},
	],

	_subclassReprintLookup: {},
	async pInitSubclassReprintLookup () {
		SourceUtil._subclassReprintLookup = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/generated/gendata-subclass-lookup.json`);
	},

	isSubclassReprinted (className, classSource, subclassShortName, subclassSource) {
		const fromLookup = MiscUtil.get(SourceUtil._subclassReprintLookup, classSource, className, subclassSource, subclassShortName);
		return fromLookup ? fromLookup.isReprinted : false;
	},

	/** I.e., not homebrew. */
	isSiteSource (source) { return !!Parser.SOURCE_JSON_TO_FULL[source]; },

	isAdventure (source) {
		if (source instanceof FilterItem) source = source.item;
		return Parser.SOURCES_ADVENTURES.has(source);
	},

	isCoreOrSupplement (source) {
		if (source instanceof FilterItem) source = source.item;
		return Parser.SOURCES_CORE_SUPPLEMENTS.has(source);
	},

	isNonstandardSource (source) {
		if (source == null) return false;
		return (
			(typeof BrewUtil2 === "undefined" || !BrewUtil2.hasSourceJson(source))
				&& SourceUtil.isNonstandardSourceWotc(source)
		)
			|| SourceUtil.isPrereleaseSource(source);
	},

	// TODO(Future) remove this in favor of simply checking existence in `PrereleaseUtil`
	// TODO(Future) cleanup uses of `PrereleaseUtil.hasSourceJson` to match
	isPrereleaseSource (source) {
		if (source == null) return false;
		if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source)) return true;
		return source.startsWith(Parser.SRC_UA_PREFIX)
			|| source.startsWith(Parser.SRC_UA_ONE_PREFIX);
	},

	isNonstandardSourceWotc (source) {
		return source.startsWith(Parser.SRC_UA_PREFIX) || source.startsWith(Parser.SRC_UA_ONE_PREFIX) || source.startsWith(Parser.SRC_PS_PREFIX) || source.startsWith(Parser.SRC_AL_PREFIX) || source.startsWith(Parser.SRC_MCVX_PREFIX) || Parser.SOURCES_NON_STANDARD_WOTC.has(source);
	},

	getFilterGroup (source) {
		if (source instanceof FilterItem) source = source.item;
		if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source)) return 1;
		if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(source)) return 2;
		return Number(SourceUtil.isNonstandardSource(source));
	},

	getAdventureBookSourceHref (source, page) {
		if (!source) return null;
		source = source.toLowerCase();

		// TODO this could be made to work with homebrew
		let docPage, mappedSource;
		if (Parser.SOURCES_AVAILABLE_DOCS_BOOK[source]) {
			docPage = UrlUtil.PG_BOOK;
			mappedSource = Parser.SOURCES_AVAILABLE_DOCS_BOOK[source];
		} else if (Parser.SOURCES_AVAILABLE_DOCS_ADVENTURE[source]) {
			docPage = UrlUtil.PG_ADVENTURE;
			mappedSource = Parser.SOURCES_AVAILABLE_DOCS_ADVENTURE[source];
		}
		if (!docPage) return null;

		mappedSource = mappedSource.toLowerCase();

		return `${docPage}#${[mappedSource, page ? `page:${page}` : null].filter(Boolean).join(HASH_PART_SEP)}`;
	},

	getEntitySource (it) { return it.source || it.inherits?.source; },
};

// CURRENCY ============================================================================================================
globalThis.CurrencyUtil = {
	/**
	 * Convert 10 gold -> 1 platinum, etc.
	 * @param obj Object of the form {cp: 123, sp: 456, ...} (values optional)
	 * @param [opts]
	 * @param [opts.currencyConversionId] Currency conversion table ID.
	 * @param [opts.currencyConversionTable] Currency conversion table.
	 * @param [opts.originalCurrency] Original currency object, if the current currency object is after spending coin.
	 * @param [opts.isPopulateAllValues] If all currency properties should be be populated, even if no currency of that
	 * type is being returned (i.e. zero out unused coins).
	 */
	doSimplifyCoins (obj, opts) {
		opts = opts || {};

		const conversionTable = opts.currencyConversionTable || Parser.getCurrencyConversionTable(opts.currencyConversionId);
		if (!conversionTable.length) return obj;

		const normalized = conversionTable
			.map(it => {
				return {
					...it,
					normalizedMult: 1 / it.mult,
				};
			})
			.sort((a, b) => SortUtil.ascSort(a.normalizedMult, b.normalizedMult));

		// Simplify currencies
		for (let i = 0; i < normalized.length - 1; ++i) {
			const coinCur = normalized[i].coin;
			const coinNxt = normalized[i + 1].coin;
			const coinRatio = normalized[i + 1].normalizedMult / normalized[i].normalizedMult;

			if (obj[coinCur] && Math.abs(obj[coinCur]) >= coinRatio) {
				const nxtVal = obj[coinCur] >= 0 ? Math.floor(obj[coinCur] / coinRatio) : Math.ceil(obj[coinCur] / coinRatio);
				obj[coinCur] = obj[coinCur] % coinRatio;
				obj[coinNxt] = (obj[coinNxt] || 0) + nxtVal;
			}
		}

		// Note: this assumes that we, overall, lost money.
		if (opts.originalCurrency) {
			const normalizedHighToLow = MiscUtil.copyFast(normalized).reverse();

			// For each currency, look at the previous coin's diff. Say, for gp, that it is -1pp. That means we could have
			//   gained up to 10gp as change. So we can have <original gold or 0> + <10gp> max gold; the rest is converted
			//   to sp. Repeat to the end.
			// Never allow more highest-value currency (i.e. pp) than we originally had.
			normalizedHighToLow
				.forEach((coinMeta, i) => {
					const valOld = opts.originalCurrency[coinMeta.coin] || 0;
					const valNew = obj[coinMeta.coin] || 0;

					const prevCoinMeta = normalizedHighToLow[i - 1];
					const nxtCoinMeta = normalizedHighToLow[i + 1];

					if (!prevCoinMeta) { // Handle the biggest currency, e.g. platinum--never allow it to increase
						if (nxtCoinMeta) {
							const diff = valNew - valOld;
							if (diff > 0) {
								obj[coinMeta.coin] = valOld;
								const coinRatio = coinMeta.normalizedMult / nxtCoinMeta.normalizedMult;
								obj[nxtCoinMeta.coin] = (obj[nxtCoinMeta.coin] || 0) + (diff * coinRatio);
							}
						}
					} else {
						if (nxtCoinMeta) {
							const diffPrevCoin = (opts.originalCurrency[prevCoinMeta.coin] || 0) - (obj[prevCoinMeta.coin] || 0);
							const coinRatio = prevCoinMeta.normalizedMult / coinMeta.normalizedMult;
							const capFromOld = valOld + (diffPrevCoin > 0 ? diffPrevCoin * coinRatio : 0);
							const diff = valNew - capFromOld;
							if (diff > 0) {
								obj[coinMeta.coin] = capFromOld;
								const coinRatio = coinMeta.normalizedMult / nxtCoinMeta.normalizedMult;
								obj[nxtCoinMeta.coin] = (obj[nxtCoinMeta.coin] || 0) + (diff * coinRatio);
							}
						}
					}
				});
		}

		normalized
			.filter(coinMeta => obj[coinMeta.coin] === 0 || obj[coinMeta.coin] == null)
			.forEach(coinMeta => {
				// First set the value to null, in case we're dealing with a class instance that has setters
				obj[coinMeta.coin] = null;
				delete obj[coinMeta.coin];
			});

		if (opts.isPopulateAllValues) normalized.forEach(coinMeta => obj[coinMeta.coin] = obj[coinMeta.coin] || 0);

		return obj;
	},

	/**
	 * Convert a collection of coins into an equivalent value in copper.
	 * @param obj Object of the form {cp: 123, sp: 456, ...} (values optional)
	 */
	getAsCopper (obj) {
		return Parser.FULL_CURRENCY_CONVERSION_TABLE
			.map(currencyMeta => (obj[currencyMeta.coin] || 0) * (1 / currencyMeta.mult))
			.reduce((a, b) => a + b, 0);
	},

	/**
	 * Convert a collection of coins into an equivalent number of coins of the highest denomination.
	 * @param obj Object of the form {cp: 123, sp: 456, ...} (values optional)
	 */
	getAsSingleCurrency (obj) {
		const simplified = CurrencyUtil.doSimplifyCoins({...obj});

		if (Object.keys(simplified).length === 1) return simplified;

		const out = {};

		const targetDemonination = Parser.FULL_CURRENCY_CONVERSION_TABLE.find(it => simplified[it.coin]);

		out[targetDemonination.coin] = simplified[targetDemonination.coin];
		delete simplified[targetDemonination.coin];

		Object.entries(simplified)
			.forEach(([coin, amt]) => {
				const denom = Parser.FULL_CURRENCY_CONVERSION_TABLE.find(it => it.coin === coin);
				out[targetDemonination.coin] = (out[targetDemonination.coin] || 0) + (amt / denom.mult) * targetDemonination.mult;
			});

		return out;
	},
};

// CONVENIENCE/ELEMENTS ================================================================================================
Math.seed = Math.seed || function (s) {
	return function () {
		s = Math.sin(s) * 10000;
		return s - Math.floor(s);
	};
};

globalThis.JqueryUtil = {
	_isEnhancementsInit: false,
	initEnhancements () {
		if (JqueryUtil._isEnhancementsInit) return;
		JqueryUtil._isEnhancementsInit = true;

		JqueryUtil.addSelectors();

		/**
		 * Template strings which can contain jQuery objects.
		 * Usage: $$`<div>Press this button: ${$btn}</div>`
		 * @return JQuery
		 */
		window.$$ = function (parts, ...args) {
			if (parts instanceof jQuery || parts instanceof HTMLElement) {
				return (...passed) => {
					const parts2 = [...passed[0]];
					const args2 = passed.slice(1);
					parts2[0] = `<div>${parts2[0]}`;
					parts2.last(`${parts2.last()}</div>`);

					const $temp = $$(parts2, ...args2);
					$temp.children().each((i, e) => $(e).appendTo(parts));
					return parts;
				};
			} else {
				const $eles = [];
				let ixArg = 0;

				const handleArg = (arg) => {
					if (arg instanceof $) {
						$eles.push(arg);
						return `<${arg.tag()} data-r="true"></${arg.tag()}>`;
					} else if (arg instanceof HTMLElement) {
						return handleArg($(arg));
					} else return arg;
				};

				const raw = parts.reduce((html, p) => {
					const myIxArg = ixArg++;
					if (args[myIxArg] == null) return `${html}${p}`;
					if (args[myIxArg] instanceof Array) return `${html}${args[myIxArg].map(arg => handleArg(arg)).join("")}${p}`;
					else return `${html}${handleArg(args[myIxArg])}${p}`;
				});
				const $res = $(raw);

				if ($res.length === 1) {
					if ($res.attr("data-r") === "true") return $eles[0];
					else $res.find(`[data-r=true]`).replaceWith(i => $eles[i]);
				} else {
					// Handle case where user has passed in a bunch of elements with no outer wrapper
					const $tmp = $(`<div></div>`);
					$tmp.append($res);
					$tmp.find(`[data-r=true]`).replaceWith(i => $eles[i]);
					return $tmp.children();
				}

				return $res;
			}
		};

		$.fn.extend({
			// avoid setting input type to "search" as it visually offsets the contents of the input
			disableSpellcheck: function () { return this.attr("autocomplete", "new-password").attr("autocapitalize", "off").attr("spellcheck", "false"); },
			tag: function () { return this.prop("tagName").toLowerCase(); },
			title: function (...args) { return this.attr("title", ...args); },
			placeholder: function (...args) { return this.attr("placeholder", ...args); },
			disable: function () { return this.attr("disabled", true); },

			/**
			 * Quickly set the innerHTML of the innermost element, without parsing the whole thing with jQuery.
			 * Useful for populating e.g. a table row.
			 */
			fastSetHtml: function (html) {
				if (!this.length) return this;
				let tgt = this[0];
				while (tgt.children.length) {
					tgt = tgt.children[0];
				}
				tgt.innerHTML = html;
				return this;
			},

			blurOnEsc: function () {
				return this.keydown(evt => {
					if (evt.which === 27) this.blur(); // escape
				});
			},

			hideVe: function () { return this.addClass("ve-hidden"); },
			showVe: function () { return this.removeClass("ve-hidden"); },
			toggleVe: function (val) {
				if (val === undefined) return this.toggleClass("ve-hidden", !this.hasClass("ve-hidden"));
				else return this.toggleClass("ve-hidden", !val);
			},
		});

		$.event.special.destroyed = {
			remove: function (o) {
				if (o.handler) o.handler();
			},
		};
	},

	addSelectors () {
		// Add a selector to match exact text (case insensitive) to jQuery's arsenal
		//   Note that the search text should be `trim().toLowerCase()`'d before being passed in
		$.expr[":"].textEquals = (el, i, m) => $(el).text().toLowerCase().trim() === m[3].unescapeQuotes();

		// Add a selector to match contained text (case insensitive)
		$.expr[":"].containsInsensitive = (el, i, m) => {
			const searchText = m[3];
			const textNode = $(el).contents().filter((i, e) => e.nodeType === 3)[0];
			if (!textNode) return false;
			const match = textNode.nodeValue.toLowerCase().trim().match(`${searchText.toLowerCase().trim().escapeRegexp()}`);
			return match && match.length > 0;
		};
	},

	showCopiedEffect (eleOr$Ele, text = "Copied!", bubble) {
		const $ele = eleOr$Ele instanceof $ ? eleOr$Ele : $(eleOr$Ele);

		const top = $(window).scrollTop();
		const pos = $ele.offset();

		const animationOptions = {
			top: "-=8",
			opacity: 0,
		};
		if (bubble) {
			animationOptions.left = `${Math.random() > 0.5 ? "-" : "+"}=${~~(Math.random() * 17)}`;
		}
		const seed = Math.random();
		const duration = bubble ? 250 + seed * 200 : 250;
		const offsetY = bubble ? 16 : 0;

		const $dispCopied = $(`<div class="clp__disp-copied ve-flex-vh-center py-2 px-4"></div>`);
		$dispCopied
			.html(text)
			.css({
				top: (pos.top - 24) + offsetY - top,
				left: pos.left + ($ele.width() / 2),
			})
			.appendTo(document.body)
			.animate(
				animationOptions,
				{
					duration,
					complete: () => $dispCopied.remove(),
					progress: (_, progress) => { // progress is 0..1
						if (bubble) {
							const diffProgress = 0.5 - progress;
							animationOptions.top = `${diffProgress > 0 ? "-" : "+"}=40`;
							$dispCopied.css("transform", `rotate(${seed > 0.5 ? "-" : ""}${seed * 500 * progress}deg)`);
						}
					},
				},
			);
	},

	_dropdownInit: false,
	bindDropdownButton ($ele) {
		if (!JqueryUtil._dropdownInit) {
			JqueryUtil._dropdownInit = true;
			document.addEventListener("click", () => [...document.querySelectorAll(`.open`)].filter(ele => !(ele.className || "").split(" ").includes(`dropdown--navbar`)).forEach(ele => ele.classList.remove("open")));
		}
		$ele.click(() => setTimeout(() => $ele.parent().addClass("open"), 1)); // defer to allow the above to complete
	},

	_WRP_TOAST: null,
	_ACTIVE_TOAST: [],
	/**
	 * @param {{content: jQuery|string, type?: string, autoHideTime?: boolean} | string} options The options for the toast.
	 * @param {(jQuery|string)} options.content Toast contents. Supports jQuery objects.
	 * @param {string} options.type Toast type. Can be any Bootstrap alert type ("success", "info", "warning", or "danger").
	 * @param {number} options.autoHideTime The time in ms before the toast will be automatically hidden.
	 * Defaults to 5000 ms.
	 * @param {boolean} options.isAutoHide
	 */
	doToast (options) {
		if (typeof window === "undefined") return;

		if (JqueryUtil._WRP_TOAST == null) {
			JqueryUtil._WRP_TOAST = e_({
				tag: "div",
				clazz: "toast__container no-events w-100 overflow-y-hidden ve-flex-col",
			});
			document.body.appendChild(JqueryUtil._WRP_TOAST);
		}

		if (typeof options === "string") {
			options = {
				content: options,
				type: "info",
			};
		}
		options.type = options.type || "info";

		options.isAutoHide = options.isAutoHide ?? true;
		options.autoHideTime = options.autoHideTime ?? 5000;

		const eleToast = e_({
			tag: "div",
			clazz: `toast toast--type-${options.type} events-initial relative my-2 mx-auto`,
			children: [
				e_({
					tag: "div",
					clazz: "toast__wrp-content",
					children: [
						options.content instanceof $ ? options.content[0] : options.content,
					],
				}),
				e_({
					tag: "div",
					clazz: "toast__wrp-control",
					children: [
						e_({
							tag: "button",
							clazz: "btn toast__btn-close",
							children: [
								e_({
									tag: "span",
									clazz: "glyphicon glyphicon-remove",
								}),
							],
						}),
					],
				}),
			],
			mousedown: evt => {
				evt.preventDefault();
			},
			click: evt => {
				evt.preventDefault();
				JqueryUtil._doToastCleanup(toastMeta);

				// Close all on SHIFT-click
				if (!evt.shiftKey) return;
				[...JqueryUtil._ACTIVE_TOAST].forEach(toastMeta => JqueryUtil._doToastCleanup(toastMeta));
			},
		});

		// FIXME(future) this could be smoother; when stacking multiple tooltips, the incoming tooltip bumps old tooltips
		//   down instantly (should be animated).
		//   See e.g.:
		//   `[...new Array(10)].forEach((_, i) => MiscUtil.pDelay(i * 50).then(() => JqueryUtil.doToast(`test ${i}`)))`
		eleToast.prependTo(JqueryUtil._WRP_TOAST);

		const toastMeta = {isAutoHide: !!options.isAutoHide, eleToast};
		JqueryUtil._ACTIVE_TOAST.push(toastMeta);

		AnimationUtil.pRecomputeStyles()
			.then(() => {
				eleToast.addClass(`toast--animate`);

				if (options.isAutoHide) {
					setTimeout(() => {
						JqueryUtil._doToastCleanup(toastMeta);
					}, options.autoHideTime);
				}

				if (JqueryUtil._ACTIVE_TOAST.length >= 3) {
					JqueryUtil._ACTIVE_TOAST
						.filter(({isAutoHide}) => !isAutoHide)
						.forEach(toastMeta => {
							JqueryUtil._doToastCleanup(toastMeta);
						});
				}
			});
	},

	_doToastCleanup (toastMeta) {
		toastMeta.eleToast.removeClass("toast--animate");
		JqueryUtil._ACTIVE_TOAST.splice(JqueryUtil._ACTIVE_TOAST.indexOf(toastMeta), 1);
		setTimeout(() => toastMeta.eleToast.parentElement && toastMeta.eleToast.remove(), 85);
	},

	isMobile () {
		if (navigator?.userAgentData?.mobile) return true;
		// Equivalent to `$width-screen-sm`
		return window.matchMedia("(max-width: 768px)").matches;
	},
};

if (typeof window !== "undefined") window.addEventListener("load", JqueryUtil.initEnhancements);

globalThis.ElementUtil = {
	_ATTRS_NO_FALSY: new Set([
		"checked",
		"disabled",
	]),

	getOrModify ({
		tag,
		clazz,
		style,
		click,
		contextmenu,
		change,
		mousedown,
		mouseup,
		mousemove,
		keydown,
		html,
		text,
		txt,
		ele,
		children,
		outer,

		id,
		name,
		title,
		val,
		href,
		type,
		attrs,
		data,
	}) {
		ele = ele || (outer ? (new DOMParser()).parseFromString(outer, "text/html").body.childNodes[0] : document.createElement(tag));

		if (clazz) ele.className = clazz;
		if (style) ele.setAttribute("style", style);
		if (click) ele.addEventListener("click", click);
		if (contextmenu) ele.addEventListener("contextmenu", contextmenu);
		if (change) ele.addEventListener("change", change);
		if (mousedown) ele.addEventListener("mousedown", mousedown);
		if (mouseup) ele.addEventListener("mouseup", mouseup);
		if (mousemove) ele.addEventListener("mousemove", mousemove);
		if (keydown) ele.addEventListener("keydown", keydown);
		if (html != null) ele.innerHTML = html;
		if (text != null || txt != null) ele.textContent = text;
		if (id != null) ele.setAttribute("id", id);
		if (name != null) ele.setAttribute("name", name);
		if (title != null) ele.setAttribute("title", title);
		if (href != null) ele.setAttribute("href", href);
		if (val != null) ele.setAttribute("value", val);
		if (type != null) ele.setAttribute("type", type);

		if (attrs != null) {
			for (const k in attrs) {
				if (attrs[k] === undefined) continue;
				if (!attrs[k] && ElementUtil._ATTRS_NO_FALSY.has(k)) continue;
				ele.setAttribute(k, attrs[k]);
			}
		}

		if (data != null) { for (const k in data) { if (data[k] === undefined) continue; ele.dataset[k] = data[k]; } }

		if (children) for (let i = 0, len = children.length; i < len; ++i) if (children[i] != null) ele.append(children[i]);

		ele.appends = ele.appends || ElementUtil._appends.bind(ele);
		ele.appendTo = ele.appendTo || ElementUtil._appendTo.bind(ele);
		ele.prependTo = ele.prependTo || ElementUtil._prependTo.bind(ele);
		ele.addClass = ele.addClass || ElementUtil._addClass.bind(ele);
		ele.removeClass = ele.removeClass || ElementUtil._removeClass.bind(ele);
		ele.toggleClass = ele.toggleClass || ElementUtil._toggleClass.bind(ele);
		ele.showVe = ele.showVe || ElementUtil._showVe.bind(ele);
		ele.hideVe = ele.hideVe || ElementUtil._hideVe.bind(ele);
		ele.toggleVe = ele.toggleVe || ElementUtil._toggleVe.bind(ele);
		ele.empty = ele.empty || ElementUtil._empty.bind(ele);
		ele.detach = ele.detach || ElementUtil._detach.bind(ele);
		ele.attr = ele.attr || ElementUtil._attr.bind(ele);
		ele.val = ele.val || ElementUtil._val.bind(ele);
		ele.html = ele.html || ElementUtil._html.bind(ele);
		ele.txt = ele.txt || ElementUtil._txt.bind(ele);
		ele.tooltip = ele.tooltip || ElementUtil._tooltip.bind(ele);
		ele.onClick = ele.onClick || ElementUtil._onClick.bind(ele);
		ele.onContextmenu = ele.onContextmenu || ElementUtil._onContextmenu.bind(ele);
		ele.onChange = ele.onChange || ElementUtil._onChange.bind(ele);

		return ele;
	},

	_appends (child) {
		this.appendChild(child);
		return this;
	},

	_appendTo (parent) {
		parent.appendChild(this);
		return this;
	},

	_prependTo (parent) {
		parent.prepend(this);
		return this;
	},

	_addClass (clazz) {
		this.classList.add(clazz);
		return this;
	},

	_removeClass (clazz) {
		this.classList.remove(clazz);
		return this;
	},

	_toggleClass (clazz, isActive) {
		if (isActive == null) this.classList.toggle(clazz);
		else if (isActive) this.classList.add(clazz);
		else this.classList.remove(clazz);
		return this;
	},

	_showVe () {
		this.classList.remove("ve-hidden");
		return this;
	},

	_hideVe () {
		this.classList.add("ve-hidden");
		return this;
	},

	_toggleVe (isActive) {
		this.toggleClass("ve-hidden", isActive == null ? isActive : !isActive);
		return this;
	},

	_empty () {
		this.innerHTML = "";
		return this;
	},

	_detach () {
		if (this.parentElement) this.parentElement.removeChild(this);
		return this;
	},

	_attr (name, value) {
		this.setAttribute(name, value);
		return this;
	},

	_html (html) {
		if (html === undefined) return this.innerHTML;
		this.innerHTML = html;
		return this;
	},

	_txt (txt) {
		if (txt === undefined) return this.innerText;
		this.innerText = txt;
		return this;
	},

	_tooltip (title) {
		return this.attr("title", title);
	},

	_onClick (fn) { return ElementUtil._onX(this, "click", fn); },
	_onContextmenu (fn) { return ElementUtil._onX(this, "contextmenu", fn); },
	_onChange (fn) { return ElementUtil._onX(this, "change", fn); },

	_onX (ele, evtName, fn) { ele.addEventListener(evtName, fn); return ele; },

	_val (val) {
		if (val !== undefined) {
			switch (this.tagName) {
				case "SELECT": {
					let selectedIndexNxt = -1;
					for (let i = 0, len = this.options.length; i < len; ++i) {
						if (this.options[i]?.value === val) { selectedIndexNxt = i; break; }
					}
					this.selectedIndex = selectedIndexNxt;
					return this;
				}

				default: {
					this.value = val;
					return this;
				}
			}
		}

		switch (this.tagName) {
			case "SELECT": return this.options[this.selectedIndex]?.value;

			default: return this.value;
		}
	},

	// region "Static"
	getIndexPathToParent (parent, child) {
		if (!parent.contains(child)) return null;

		const path = [];

		while (child !== parent) {
			if (!child.parentElement) return null;

			const ix = [...child.parentElement.children].indexOf(child);
			if (!~ix) return null;

			path.push(ix);

			child = child.parentElement;
		}

		return path.reverse();
	},

	getChildByIndexPath (parent, indexPath) {
		for (let i = 0; i < indexPath.length; ++i) {
			const ix = indexPath[i];
			parent = parent.children[ix];
			if (!parent) return null;
		}
		return parent;
	},
	// endregion
};

if (typeof window !== "undefined") window.e_ = ElementUtil.getOrModify;

globalThis.ObjUtil = {
	async pForEachDeep (source, pCallback, options = {depth: Infinity, callEachLevel: false}) {
		const path = [];
		const pDiveDeep = async function (val, path, depth = 0) {
			if (options.callEachLevel || typeof val !== "object" || options.depth === depth) {
				await pCallback(val, path, depth);
			}
			if (options.depth !== depth && typeof val === "object") {
				for (const key of Object.keys(val)) {
					path.push(key);
					await pDiveDeep(val[key], path, depth + 1);
				}
			}
			path.pop();
		};
		await pDiveDeep(source, path);
	},
};

// TODO refactor other misc utils into this
globalThis.MiscUtil = {
	COLOR_HEALTHY: "#00bb20",
	COLOR_HURT: "#c5ca00",
	COLOR_BLOODIED: "#f7a100",
	COLOR_DEFEATED: "#cc0000",

	/**
	 * @param obj
	 * @param isSafe
	 * @param isPreserveUndefinedValueKeys Otherwise, drops the keys of `undefined` values
	 * (e.g. `{a: undefined}` -> `{}`).
	 */
	copy (obj, {isSafe = false, isPreserveUndefinedValueKeys = false} = {}) {
		if (isSafe && obj === undefined) return undefined; // Generally use "unsafe," as this helps identify bugs.
		return JSON.parse(JSON.stringify(obj));
	},

	copyFast (obj) {
		if ((typeof obj !== "object") || obj == null) return obj;

		if (obj instanceof Array) return obj.map(MiscUtil.copyFast);

		const cpy = {};
		for (const k of Object.keys(obj)) cpy[k] = MiscUtil.copyFast(obj[k]);
		return cpy;
	},

	async pCopyTextToClipboard (text) {
		function doCompatibilityCopy () {
			const $iptTemp = $(`<textarea class="clp__wrp-temp"></textarea>`)
				.appendTo(document.body)
				.val(text)
				.select();
			document.execCommand("Copy");
			$iptTemp.remove();
		}

		if (navigator && navigator.permissions) {
			try {
				const access = await navigator.permissions.query({name: "clipboard-write"});
				if (access.state === "granted" || access.state === "prompt") {
					await navigator.clipboard.writeText(text);
				} else doCompatibilityCopy();
			} catch (e) { doCompatibilityCopy(); }
		} else doCompatibilityCopy();
	},

	checkProperty (object, ...path) {
		for (let i = 0; i < path.length; ++i) {
			object = object[path[i]];
			if (object == null) return false;
		}
		return true;
	},

	get (object, ...path) {
		if (object == null) return null;
		for (let i = 0; i < path.length; ++i) {
			object = object[path[i]];
			if (object == null) return object;
		}
		return object;
	},

	set (object, ...pathAndVal) {
		if (object == null) return null;

		const val = pathAndVal.pop();
		if (!pathAndVal.length) return null;

		const len = pathAndVal.length;
		for (let i = 0; i < len; ++i) {
			const pathPart = pathAndVal[i];
			if (i === len - 1) object[pathPart] = val;
			else object = (object[pathPart] = object[pathPart] || {});
		}

		return val;
	},

	getOrSet (object, ...pathAndVal) {
		if (pathAndVal.length < 2) return null;
		const existing = MiscUtil.get(object, ...pathAndVal.slice(0, -1));
		return existing || MiscUtil.set(object, ...pathAndVal);
	},

	getThenSetCopy (object1, object2, ...path) {
		const val = MiscUtil.get(object1, ...path);
		return MiscUtil.set(object2, ...path, MiscUtil.copyFast(val, {isSafe: true}));
	},

	delete (object, ...path) {
		if (object == null) return object;
		for (let i = 0; i < path.length - 1; ++i) {
			object = object[path[i]];
			if (object == null) return object;
		}
		return delete object[path.last()];
	},

	/** Delete a prop from a nested object, then all now-empty objects backwards from that point. */
	deleteObjectPath (object, ...path) {
		const stack = [object];

		if (object == null) return object;
		for (let i = 0; i < path.length - 1; ++i) {
			object = object[path[i]];
			stack.push(object);
			if (object === undefined) return object;
		}
		const out = delete object[path.last()];

		for (let i = path.length - 1; i > 0; --i) {
			if (!Object.keys(stack[i]).length) delete stack[i - 1][path[i - 1]];
		}

		return out;
	},

	merge (obj1, obj2) {
		obj2 = MiscUtil.copyFast(obj2);

		Object.entries(obj2)
			.forEach(([k, v]) => {
				if (obj1[k] == null) {
					obj1[k] = v;
					return;
				}

				if (
					typeof obj1[k] === "object"
					&& typeof v === "object"
					&& !(obj1[k] instanceof Array)
					&& !(v instanceof Array)
				) {
					MiscUtil.merge(obj1[k], v);
					return;
				}

				obj1[k] = v;
			});

		return obj1;
	},

	/**
	 * @deprecated
	 */
	mix: (superclass) => new MiscUtil._MixinBuilder(superclass),
	_MixinBuilder: function (superclass) {
		this.superclass = superclass;

		this.with = function (...mixins) {
			return mixins.reduce((c, mixin) => mixin(c), this.superclass);
		};
	},

	clearSelection () {
		if (document.getSelection) {
			document.getSelection().removeAllRanges();
			document.getSelection().addRange(document.createRange());
		} else if (window.getSelection) {
			if (window.getSelection().removeAllRanges) {
				window.getSelection().removeAllRanges();
				window.getSelection().addRange(document.createRange());
			} else if (window.getSelection().empty) {
				window.getSelection().empty();
			}
		} else if (document.selection) {
			document.selection.empty();
		}
	},

	randomColor () {
		let r; let g; let b;
		const h = RollerUtil.randomise(30, 0) / 30;
		const i = ~~(h * 6);
		const f = h * 6 - i;
		const q = 1 - f;
		switch (i % 6) {
			case 0: r = 1; g = f; b = 0; break;
			case 1: r = q; g = 1; b = 0; break;
			case 2: r = 0; g = 1; b = f; break;
			case 3: r = 0; g = q; b = 1; break;
			case 4: r = f; g = 0; b = 1; break;
			case 5: r = 1; g = 0; b = q; break;
		}
		return `#${`00${(~~(r * 255)).toString(16)}`.slice(-2)}${`00${(~~(g * 255)).toString(16)}`.slice(-2)}${`00${(~~(b * 255)).toString(16)}`.slice(-2)}`;
	},

	/**
	 * @param hex Original hex color.
	 * @param [opts] Options object.
	 * @param [opts.bw] True if the color should be returnes as black/white depending on contrast ratio.
	 * @param [opts.dark] Color to return if a "dark" color would contrast best.
	 * @param [opts.light] Color to return if a "light" color would contrast best.
	 */
	invertColor (hex, opts) {
		opts = opts || {};

		hex = hex.slice(1); // remove #

		let r = parseInt(hex.slice(0, 2), 16);
		let g = parseInt(hex.slice(2, 4), 16);
		let b = parseInt(hex.slice(4, 6), 16);

		// http://stackoverflow.com/a/3943023/112731
		const isDark = (r * 0.299 + g * 0.587 + b * 0.114) > 186;
		if (opts.dark && opts.light) return isDark ? opts.dark : opts.light;
		else if (opts.bw) return isDark ? "#000000" : "#FFFFFF";

		r = (255 - r).toString(16); g = (255 - g).toString(16); b = (255 - b).toString(16);
		return `#${[r, g, b].map(it => it.padStart(2, "0")).join("")}`;
	},

	scrollPageTop () {
		document.body.scrollTop = document.documentElement.scrollTop = 0;
	},

	expEval (str) {
		// eslint-disable-next-line no-new-func
		return new Function(`return ${str.replace(/[^-()\d/*+.]/g, "")}`)();
	},

	parseNumberRange (input, min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER) {
		if (!input || !input.trim()) return null;

		const errInvalid = input => { throw new Error(`Could not parse range input "${input}"`); };

		const errOutOfRange = () => { throw new Error(`Number was out of range! Range was ${min}-${max} (inclusive).`); };

		const isOutOfRange = (num) => num < min || num > max;

		const addToRangeVal = (range, num) => range.add(num);

		const addToRangeLoHi = (range, lo, hi) => {
			for (let i = lo; i <= hi; ++i) range.add(i);
		};

		const clean = input.replace(/\s*/g, "");
		if (!/^((\d+-\d+|\d+),)*(\d+-\d+|\d+)$/.exec(clean)) errInvalid();

		const parts = clean.split(",");
		const out = new Set();

		for (const part of parts) {
			if (part.includes("-")) {
				const spl = part.split("-");
				const numLo = Number(spl[0]);
				const numHi = Number(spl[1]);

				if (isNaN(numLo) || isNaN(numHi) || numLo === 0 || numHi === 0 || numLo > numHi) errInvalid();

				if (isOutOfRange(numLo) || isOutOfRange(numHi)) errOutOfRange();

				if (numLo === numHi) addToRangeVal(out, numLo);
				else addToRangeLoHi(out, numLo, numHi);
				continue;
			}

			const num = Number(part);
			if (isNaN(num) || num === 0) errInvalid();

			if (isOutOfRange(num)) errOutOfRange();
			addToRangeVal(out, num);
		}

		return out;
	},

	findCommonPrefix (strArr, {isRespectWordBoundaries} = {}) {
		if (isRespectWordBoundaries) {
			let prefixTks = null;
			strArr
				.map(str => str.split(" "))
				.forEach(tks => {
					if (prefixTks == null) {
						prefixTks = tks;
						return;
					}

					const minLen = Math.min(tks.length, prefixTks.length);
					for (let i = 0; i < minLen; ++i) {
						const cp = prefixTks[i];
						const cs = tks[i];
						if (cp !== cs) {
							prefixTks = prefixTks.slice(0, i);
							break;
						}
					}
				});

			if (!prefixTks.length) return "";
			return `${prefixTks.join(" ")} `;
		}

		let prefix = null;
		strArr.forEach(s => {
			if (prefix == null) {
				prefix = s;
				return;
			}

			const minLen = Math.min(s.length, prefix.length);
			for (let i = 0; i < minLen; ++i) {
				const cp = prefix[i];
				const cs = s[i];
				if (cp !== cs) {
					prefix = prefix.substring(0, i);
					break;
				}
			}
		});
		return prefix;
	},

	/**
	 * @param fgHexTarget Target/resultant color for the foreground item
	 * @param fgOpacity Desired foreground transparency (0-1 inclusive)
	 * @param bgHex Background color
	 */
	calculateBlendedColor (fgHexTarget, fgOpacity, bgHex) {
		const fgDcTarget = CryptUtil.hex2Dec(fgHexTarget);
		const bgDc = CryptUtil.hex2Dec(bgHex);
		return ((fgDcTarget - ((1 - fgOpacity) * bgDc)) / fgOpacity).toString(16);
	},

	/**
	 * Borrowed from lodash.
	 *
	 * @param func The function to debounce.
	 * @param wait Minimum duration between calls.
	 * @param options Options object.
	 * @return {Function} The debounced function.
	 */
	debounce (func, wait, options) {
		let lastArgs; let lastThis; let maxWait; let result; let timerId; let lastCallTime; let lastInvokeTime = 0; let leading = false; let maxing = false; let trailing = true;

		wait = Number(wait) || 0;
		if (typeof options === "object") {
			leading = !!options.leading;
			maxing = "maxWait" in options;
			maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : maxWait;
			trailing = "trailing" in options ? !!options.trailing : trailing;
		}

		function invokeFunc (time) {
			let args = lastArgs; let thisArg = lastThis;

			lastArgs = lastThis = undefined;
			lastInvokeTime = time;
			result = func.apply(thisArg, args);
			return result;
		}

		function leadingEdge (time) {
			lastInvokeTime = time;
			timerId = setTimeout(timerExpired, wait);
			return leading ? invokeFunc(time) : result;
		}

		function remainingWait (time) {
			let timeSinceLastCall = time - lastCallTime; let timeSinceLastInvoke = time - lastInvokeTime; let result = wait - timeSinceLastCall;
			return maxing ? Math.min(result, maxWait - timeSinceLastInvoke) : result;
		}

		function shouldInvoke (time) {
			let timeSinceLastCall = time - lastCallTime; let timeSinceLastInvoke = time - lastInvokeTime;

			return (lastCallTime === undefined || (timeSinceLastCall >= wait) || (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
		}

		function timerExpired () {
			const time = Date.now();
			if (shouldInvoke(time)) {
				return trailingEdge(time);
			}
			// Restart the timer.
			timerId = setTimeout(timerExpired, remainingWait(time));
		}

		function trailingEdge (time) {
			timerId = undefined;

			if (trailing && lastArgs) return invokeFunc(time);
			lastArgs = lastThis = undefined;
			return result;
		}

		function cancel () {
			if (timerId !== undefined) clearTimeout(timerId);
			lastInvokeTime = 0;
			lastArgs = lastCallTime = lastThis = timerId = undefined;
		}

		function flush () {
			return timerId === undefined ? result : trailingEdge(Date.now());
		}

		function debounced () {
			let time = Date.now(); let isInvoking = shouldInvoke(time);
			lastArgs = arguments;
			lastThis = this;
			lastCallTime = time;

			if (isInvoking) {
				if (timerId === undefined) return leadingEdge(lastCallTime);
				if (maxing) {
					// Handle invocations in a tight loop.
					timerId = setTimeout(timerExpired, wait);
					return invokeFunc(lastCallTime);
				}
			}
			if (timerId === undefined) timerId = setTimeout(timerExpired, wait);
			return result;
		}

		debounced.cancel = cancel;
		debounced.flush = flush;
		return debounced;
	},

	// from lodash
	throttle (func, wait, options) {
		let leading = true; let trailing = true;

		if (typeof options === "object") {
			leading = "leading" in options ? !!options.leading : leading;
			trailing = "trailing" in options ? !!options.trailing : trailing;
		}

		return this.debounce(func, wait, {leading, maxWait: wait, trailing});
	},

	pDelay (msecs, resolveAs) {
		return new Promise(resolve => setTimeout(() => resolve(resolveAs), msecs));
	},

	GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST: new Set(["caption", "type", "colLabels", "name", "colStyles", "style", "shortName", "subclassShortName", "id", "path"]),

	/**
	 * @param [opts]
	 * @param [opts.keyBlocklist]
	 * @param [opts.isAllowDeleteObjects] If returning `undefined` from an object handler should be treated as a delete.
	 * @param [opts.isAllowDeleteArrays] If returning `undefined` from an array handler should be treated as a delete.
	 * @param [opts.isAllowDeleteBooleans] (Unimplemented) // TODO
	 * @param [opts.isAllowDeleteNumbers] (Unimplemented) // TODO
	 * @param [opts.isAllowDeleteStrings] (Unimplemented) // TODO
	 * @param [opts.isDepthFirst] If array/object recursion should occur before array/object primitive handling.
	 * @param [opts.isNoModification] If the walker should not attempt to modify the data.
	 * @param [opts.isBreakOnReturn] If the walker should fast-exist on any handler returning a value.
	 */
	getWalker (opts) {
		opts = opts || {};

		if (opts.isBreakOnReturn && !opts.isNoModification) throw new Error(`"isBreakOnReturn" may only be used in "isNoModification" mode!`);

		const keyBlocklist = opts.keyBlocklist || new Set();

		const getMappedPrimitive = (obj, primitiveHandlers, lastKey, stack, prop, propPre, propPost) => {
			if (primitiveHandlers[propPre]) MiscUtil._getWalker_runHandlers({handlers: primitiveHandlers[propPre], obj, lastKey, stack});
			if (primitiveHandlers[prop]) {
				const out = MiscUtil._getWalker_applyHandlers({opts, handlers: primitiveHandlers[prop], obj, lastKey, stack});
				if (out === VeCt.SYM_WALKER_BREAK) return out;
				if (!opts.isNoModification) obj = out;
			}
			if (primitiveHandlers[propPost]) MiscUtil._getWalker_runHandlers({handlers: primitiveHandlers[propPost], obj, lastKey, stack});
			return obj;
		};

		const doObjectRecurse = (obj, primitiveHandlers, stack) => {
			for (const k of Object.keys(obj)) {
				if (keyBlocklist.has(k)) continue;

				const out = fn(obj[k], primitiveHandlers, k, stack);
				if (out === VeCt.SYM_WALKER_BREAK) return VeCt.SYM_WALKER_BREAK;
				if (!opts.isNoModification) obj[k] = out;
			}
		};

		const fn = (obj, primitiveHandlers, lastKey, stack) => {
			if (obj === null) return getMappedPrimitive(obj, primitiveHandlers, lastKey, stack, "null", "preNull", "postNull");

			switch (typeof obj) {
				case "undefined": return getMappedPrimitive(obj, primitiveHandlers, lastKey, stack, "undefined", "preUndefined", "postUndefined");
				case "boolean": return getMappedPrimitive(obj, primitiveHandlers, lastKey, stack, "boolean", "preBoolean", "postBoolean");
				case "number": return getMappedPrimitive(obj, primitiveHandlers, lastKey, stack, "number", "preNumber", "postNumber");
				case "string": return getMappedPrimitive(obj, primitiveHandlers, lastKey, stack, "string", "preString", "postString");
				case "object": {
					// region Array
					if (obj instanceof Array) {
						if (primitiveHandlers.preArray) MiscUtil._getWalker_runHandlers({handlers: primitiveHandlers.preArray, obj, lastKey, stack});
						if (opts.isDepthFirst) {
							if (stack) stack.push(obj);
							const out = new Array(obj.length);
							for (let i = 0, len = out.length; i < len; ++i) {
								out[i] = fn(obj[i], primitiveHandlers, lastKey, stack);
								if (out[i] === VeCt.SYM_WALKER_BREAK) return out[i];
							}
							if (!opts.isNoModification) obj = out;
							if (stack) stack.pop();

							if (primitiveHandlers.array) {
								const out = MiscUtil._getWalker_applyHandlers({opts, handlers: primitiveHandlers.array, obj, lastKey, stack});
								if (out === VeCt.SYM_WALKER_BREAK) return out;
								if (!opts.isNoModification) obj = out;
							}
							if (obj == null) {
								if (!opts.isAllowDeleteArrays) throw new Error(`Array handler(s) returned null!`);
							}
						} else {
							if (primitiveHandlers.array) {
								const out = MiscUtil._getWalker_applyHandlers({opts, handlers: primitiveHandlers.array, obj, lastKey, stack});
								if (out === VeCt.SYM_WALKER_BREAK) return out;
								if (!opts.isNoModification) obj = out;
							}
							if (obj != null) {
								const out = new Array(obj.length);
								for (let i = 0, len = out.length; i < len; ++i) {
									if (stack) stack.push(obj);
									out[i] = fn(obj[i], primitiveHandlers, lastKey, stack);
									if (stack) stack.pop();
									if (out[i] === VeCt.SYM_WALKER_BREAK) return out[i];
								}
								if (!opts.isNoModification) obj = out;
							} else {
								if (!opts.isAllowDeleteArrays) throw new Error(`Array handler(s) returned null!`);
							}
						}
						if (primitiveHandlers.postArray) MiscUtil._getWalker_runHandlers({handlers: primitiveHandlers.postArray, obj, lastKey, stack});
						return obj;
					}
					// endregion

					// region Object
					if (primitiveHandlers.preObject) MiscUtil._getWalker_runHandlers({handlers: primitiveHandlers.preObject, obj, lastKey, stack});
					if (opts.isDepthFirst) {
						if (stack) stack.push(obj);
						const flag = doObjectRecurse(obj, primitiveHandlers, stack);
						if (stack) stack.pop();
						if (flag === VeCt.SYM_WALKER_BREAK) return flag;

						if (primitiveHandlers.object) {
							const out = MiscUtil._getWalker_applyHandlers({opts, handlers: primitiveHandlers.object, obj, lastKey, stack});
							if (out === VeCt.SYM_WALKER_BREAK) return out;
							if (!opts.isNoModification) obj = out;
						}
						if (obj == null) {
							if (!opts.isAllowDeleteObjects) throw new Error(`Object handler(s) returned null!`);
						}
					} else {
						if (primitiveHandlers.object) {
							const out = MiscUtil._getWalker_applyHandlers({opts, handlers: primitiveHandlers.object, obj, lastKey, stack});
							if (out === VeCt.SYM_WALKER_BREAK) return out;
							if (!opts.isNoModification) obj = out;
						}
						if (obj == null) {
							if (!opts.isAllowDeleteObjects) throw new Error(`Object handler(s) returned null!`);
						} else {
							if (stack) stack.push(obj);
							const flag = doObjectRecurse(obj, primitiveHandlers, stack);
							if (stack) stack.pop();
							if (flag === VeCt.SYM_WALKER_BREAK) return flag;
						}
					}
					if (primitiveHandlers.postObject) MiscUtil._getWalker_runHandlers({handlers: primitiveHandlers.postObject, obj, lastKey, stack});
					return obj;
					// endregion
				}
				default: throw new Error(`Unhandled type "${typeof obj}"`);
			}
		};

		return {walk: fn};
	},

	_getWalker_applyHandlers ({opts, handlers, obj, lastKey, stack}) {
		handlers = handlers instanceof Array ? handlers : [handlers];
		const didBreak = handlers.some(h => {
			const out = h(obj, lastKey, stack);
			if (opts.isBreakOnReturn && out) return true;
			if (!opts.isNoModification) obj = out;
		});
		if (didBreak) return VeCt.SYM_WALKER_BREAK;
		return obj;
	},

	_getWalker_runHandlers ({handlers, obj, lastKey, stack}) {
		handlers = handlers instanceof Array ? handlers : [handlers];
		handlers.forEach(h => h(obj, lastKey, stack));
	},

	/**
	 * TODO refresh to match sync version
	 * @param [opts]
	 * @param [opts.keyBlocklist]
	 * @param [opts.isAllowDeleteObjects] If returning `undefined` from an object handler should be treated as a delete.
	 * @param [opts.isAllowDeleteArrays] If returning `undefined` from an array handler should be treated as a delete.
	 * @param [opts.isAllowDeleteBooleans] (Unimplemented) // TODO
	 * @param [opts.isAllowDeleteNumbers] (Unimplemented) // TODO
	 * @param [opts.isAllowDeleteStrings] (Unimplemented) // TODO
	 * @param [opts.isDepthFirst] If array/object recursion should occur before array/object primitive handling.
	 * @param [opts.isNoModification] If the walker should not attempt to modify the data.
	 */
	getAsyncWalker (opts) {
		opts = opts || {};
		const keyBlocklist = opts.keyBlocklist || new Set();

		const pFn = async (obj, primitiveHandlers, lastKey, stack) => {
			if (obj == null) {
				if (primitiveHandlers.null) return MiscUtil._getAsyncWalker_pApplyHandlers({opts, handlers: primitiveHandlers.null, obj, lastKey, stack});
				return obj;
			}

			const pDoObjectRecurse = async () => {
				await Object.keys(obj).pSerialAwaitMap(async k => {
					const v = obj[k];
					if (keyBlocklist.has(k)) return;
					const out = await pFn(v, primitiveHandlers, k, stack);
					if (!opts.isNoModification) obj[k] = out;
				});
			};

			const to = typeof obj;
			switch (to) {
				case undefined:
					if (primitiveHandlers.preUndefined) await MiscUtil._getAsyncWalker_pRunHandlers({handlers: primitiveHandlers.preUndefined, obj, lastKey, stack});
					if (primitiveHandlers.undefined) {
						const out = await MiscUtil._getAsyncWalker_pApplyHandlers({opts, handlers: primitiveHandlers.undefined, obj, lastKey, stack});
						if (!opts.isNoModification) obj = out;
					}
					if (primitiveHandlers.postUndefined) await MiscUtil._getAsyncWalker_pRunHandlers({handlers: primitiveHandlers.postUndefined, obj, lastKey, stack});
					return obj;
				case "boolean":
					if (primitiveHandlers.preBoolean) await MiscUtil._getAsyncWalker_pRunHandlers({handlers: primitiveHandlers.preBoolean, obj, lastKey, stack});
					if (primitiveHandlers.boolean) {
						const out = await MiscUtil._getAsyncWalker_pApplyHandlers({opts, handlers: primitiveHandlers.boolean, obj, lastKey, stack});
						if (!opts.isNoModification) obj = out;
					}
					if (primitiveHandlers.postBoolean) await MiscUtil._getAsyncWalker_pRunHandlers({handlers: primitiveHandlers.postBoolean, obj, lastKey, stack});
					return obj;
				case "number":
					if (primitiveHandlers.preNumber) await MiscUtil._getAsyncWalker_pRunHandlers({handlers: primitiveHandlers.preNumber, obj, lastKey, stack});
					if (primitiveHandlers.number) {
						const out = await MiscUtil._getAsyncWalker_pApplyHandlers({opts, handlers: primitiveHandlers.number, obj, lastKey, stack});
						if (!opts.isNoModification) obj = out;
					}
					if (primitiveHandlers.postNumber) await MiscUtil._getAsyncWalker_pRunHandlers({handlers: primitiveHandlers.postNumber, obj, lastKey, stack});
					return obj;
				case "string":
					if (primitiveHandlers.preString) await MiscUtil._getAsyncWalker_pRunHandlers({handlers: primitiveHandlers.preString, obj, lastKey, stack});
					if (primitiveHandlers.string) {
						const out = await MiscUtil._getAsyncWalker_pApplyHandlers({opts, handlers: primitiveHandlers.string, obj, lastKey, stack});
						if (!opts.isNoModification) obj = out;
					}
					if (primitiveHandlers.postString) await MiscUtil._getAsyncWalker_pRunHandlers({handlers: primitiveHandlers.postString, obj, lastKey, stack});
					return obj;
				case "object": {
					if (obj instanceof Array) {
						if (primitiveHandlers.preArray) await MiscUtil._getAsyncWalker_pRunHandlers({handlers: primitiveHandlers.preArray, obj, lastKey, stack});
						if (opts.isDepthFirst) {
							if (stack) stack.push(obj);
							const out = await obj.pSerialAwaitMap(it => pFn(it, primitiveHandlers, lastKey, stack));
							if (!opts.isNoModification) obj = out;
							if (stack) stack.pop();

							if (primitiveHandlers.array) {
								const out = await MiscUtil._getAsyncWalker_pApplyHandlers({opts, handlers: primitiveHandlers.array, obj, lastKey, stack});
								if (!opts.isNoModification) obj = out;
							}
							if (obj == null) {
								if (!opts.isAllowDeleteArrays) throw new Error(`Array handler(s) returned null!`);
							}
						} else {
							if (primitiveHandlers.array) {
								const out = await MiscUtil._getAsyncWalker_pApplyHandlers({opts, handlers: primitiveHandlers.array, obj, lastKey, stack});
								if (!opts.isNoModification) obj = out;
							}
							if (obj != null) {
								const out = await obj.pSerialAwaitMap(it => pFn(it, primitiveHandlers, lastKey, stack));
								if (!opts.isNoModification) obj = out;
							} else {
								if (!opts.isAllowDeleteArrays) throw new Error(`Array handler(s) returned null!`);
							}
						}
						if (primitiveHandlers.postArray) await MiscUtil._getAsyncWalker_pRunHandlers({handlers: primitiveHandlers.postArray, obj, lastKey, stack});
						return obj;
					} else {
						if (primitiveHandlers.preObject) await MiscUtil._getAsyncWalker_pRunHandlers({handlers: primitiveHandlers.preObject, obj, lastKey, stack});
						if (opts.isDepthFirst) {
							if (stack) stack.push(obj);
							await pDoObjectRecurse();
							if (stack) stack.pop();

							if (primitiveHandlers.object) {
								const out = await MiscUtil._getAsyncWalker_pApplyHandlers({opts, handlers: primitiveHandlers.object, obj, lastKey, stack});
								if (!opts.isNoModification) obj = out;
							}
							if (obj == null) {
								if (!opts.isAllowDeleteObjects) throw new Error(`Object handler(s) returned null!`);
							}
						} else {
							if (primitiveHandlers.object) {
								const out = await MiscUtil._getAsyncWalker_pApplyHandlers({opts, handlers: primitiveHandlers.object, obj, lastKey, stack});
								if (!opts.isNoModification) obj = out;
							}
							if (obj == null) {
								if (!opts.isAllowDeleteObjects) throw new Error(`Object handler(s) returned null!`);
							} else {
								await pDoObjectRecurse();
							}
						}
						if (primitiveHandlers.postObject) await MiscUtil._getAsyncWalker_pRunHandlers({handlers: primitiveHandlers.postObject, obj, lastKey, stack});
						return obj;
					}
				}
				default: throw new Error(`Unhandled type "${to}"`);
			}
		};

		return {pWalk: pFn};
	},

	async _getAsyncWalker_pApplyHandlers ({opts, handlers, obj, lastKey, stack}) {
		handlers = handlers instanceof Array ? handlers : [handlers];
		await handlers.pSerialAwaitMap(async pH => {
			const out = await pH(obj, lastKey, stack);
			if (!opts.isNoModification) obj = out;
		});
		return obj;
	},

	async _getAsyncWalker_pRunHandlers ({handlers, obj, lastKey, stack}) {
		handlers = handlers instanceof Array ? handlers : [handlers];
		await handlers.pSerialAwaitMap(pH => pH(obj, lastKey, stack));
	},

	pDefer (fn) {
		return (async () => fn())();
	},
};

// EVENT HANDLERS ======================================================================================================
globalThis.EventUtil = {
	_mouseX: 0,
	_mouseY: 0,
	_isUsingTouch: false,
	_isSetCssVars: false,

	init () {
		document.addEventListener("mousemove", evt => {
			EventUtil._mouseX = evt.clientX;
			EventUtil._mouseY = evt.clientY;
			EventUtil._onMouseMove_setCssVars();
		});
		document.addEventListener("touchstart", () => {
			EventUtil._isUsingTouch = true;
		});
	},

	_eleDocRoot: null,
	_onMouseMove_setCssVars () {
		if (!EventUtil._isSetCssVars) return;

		EventUtil._eleDocRoot = EventUtil._eleDocRoot || document.querySelector(":root");

		EventUtil._eleDocRoot.style.setProperty("--mouse-position-x", EventUtil._mouseX);
		EventUtil._eleDocRoot.style.setProperty("--mouse-position-y", EventUtil._mouseY);
	},

	getClientX (evt) { return evt.touches && evt.touches.length ? evt.touches[0].clientX : evt.clientX; },
	getClientY (evt) { return evt.touches && evt.touches.length ? evt.touches[0].clientY : evt.clientY; },

	getOffsetY (evt) {
		if (!evt.touches?.length) return evt.offsetY;

		const bounds = evt.target.getBoundingClientRect();
		return evt.targetTouches[0].clientY - bounds.y;
	},

	getMousePos () {
		return {x: EventUtil._mouseX, y: EventUtil._mouseY};
	},

	isUsingTouch () { return !!EventUtil._isUsingTouch; },

	isInInput (evt) {
		return evt.target.nodeName === "INPUT" || evt.target.nodeName === "TEXTAREA"
			|| evt.target.getAttribute("contenteditable") === "true";
	},

	noModifierKeys (evt) { return !evt.ctrlKey && !evt.altKey && !evt.metaKey; },

	getKeyIgnoreCapsLock (evt) {
		if (!evt.key) return null;
		if (evt.key.length !== 1) return evt.key;
		const isCaps = (evt.originalEvent || evt).getModifierState("CapsLock");
		if (!isCaps) return evt.key;
		const asciiCode = evt.key.charCodeAt(0);
		const isUpperCase = asciiCode >= 65 && asciiCode <= 90;
		const isLowerCase = asciiCode >= 97 && asciiCode <= 122;
		if (!isUpperCase && !isLowerCase) return evt.key;
		return isUpperCase ? evt.key.toLowerCase() : evt.key.toUpperCase();
	},
};

if (typeof window !== "undefined") window.addEventListener("load", EventUtil.init);

// ANIMATIONS ==========================================================================================================
globalThis.AnimationUtil = class {
	/**
	 * See: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations/Tips
	 *
	 * requestAnimationFrame() [...] gets executed just before the next repaint of the document. [...] because it's
	 * before the repaint, the style recomputation hasn't actually happened yet!
	 * [...] calls requestAnimationFrame() a second time! This time, the callback is run before the next repaint,
	 * which is after the style recomputation has occurred.
	 */
	static async pRecomputeStyles () {
		return new Promise(resolve => {
			requestAnimationFrame(() => {
				requestAnimationFrame(() => {
					resolve();
				});
			});
		});
	}

	static pLoadImage (uri) {
		return new Promise((resolve, reject) => {
			const img = new Image();
			img.onerror = err => reject(err);
			img.onload = () => resolve(img);
			img.src = uri;
		});
	}
};

// CONTEXT MENUS =======================================================================================================
globalThis.ContextUtil = {
	_isInit: false,
	_menus: [],

	_init () {
		if (ContextUtil._isInit) return;
		ContextUtil._isInit = true;

		$(document.body).click(() => ContextUtil._menus.forEach(menu => menu.close()));
	},

	getMenu (actions) {
		ContextUtil._init();

		const menu = new ContextUtil.Menu(actions);
		ContextUtil._menus.push(menu);
		return menu;
	},

	deleteMenu (menu) {
		if (!menu) return;

		menu.remove();
		const ix = ContextUtil._menus.findIndex(it => it === menu);
		if (~ix) ContextUtil._menus.splice(ix, 1);
	},

	pOpenMenu (evt, menu, userData) {
		evt.preventDefault();
		evt.stopPropagation();

		ContextUtil._init();

		// Close any other open menus
		ContextUtil._menus.filter(it => it !== menu).forEach(it => it.close());

		return menu.pOpen(evt, userData);
	},

	Menu: function (actions) {
		this._actions = actions;
		this._pResult = null;
		this.resolveResult_ = null;

		this.userData = null;

		this._$ele = null;
		this._metasActions = [];

		this.remove = function () { if (this._$ele) this._$ele.remove(); };

		this.width = function () { return this._$ele ? this._$ele.width() : undefined; };
		this.height = function () { return this._$ele ? this._$ele.height() : undefined; };

		this.pOpen = function (evt, userData) {
			evt.stopPropagation();
			evt.preventDefault();

			this._initLazy();

			if (this.resolveResult_) this.resolveResult_(null);
			this._pResult = new Promise(resolve => {
				this.resolveResult_ = resolve;
			});
			this.userData = userData;

			this._$ele
				// Show as transparent/non-clickable first, so we can get an accurate width/height
				.css({
					left: 0,
					top: 0,
					opacity: 0,
					pointerEvents: "none",
				})
				.showVe()
				// Use the accurate width/height to set the final position, and remove our temp styling
				.css({
					left: this._getMenuPosition(evt, "x"),
					top: this._getMenuPosition(evt, "y"),
					opacity: "",
					pointerEvents: "",
				});

			this._metasActions[0].$eleRow.focus();

			return this._pResult;
		};
		this.close = function () { if (this._$ele) this._$ele.hideVe(); };

		this._initLazy = function () {
			if (this._$ele) {
				this._metasActions.forEach(meta => meta.action.update());
				return;
			}

			const $elesAction = this._actions.map(it => {
				if (it == null) return $(`<div class="my-1 w-100 ui-ctx__divider"></div>`);

				const rdMeta = it.render({menu: this});
				this._metasActions.push(rdMeta);
				return rdMeta.$eleRow;
			});

			this._$ele = $$`<div class="ve-flex-col ui-ctx__wrp py-2 absolute">${$elesAction}</div>`
				.hideVe()
				.appendTo(document.body);
		};

		this._getMenuPosition = function (evt, axis) {
			const {fnMenuSize, fnGetEventPos, fnWindowSize, fnScrollDir} = axis === "x"
				? {fnMenuSize: "width", fnGetEventPos: "getClientX", fnWindowSize: "width", fnScrollDir: "scrollLeft"}
				: {fnMenuSize: "height", fnGetEventPos: "getClientY", fnWindowSize: "height", fnScrollDir: "scrollTop"};

			const posMouse = EventUtil[fnGetEventPos](evt);
			const szWin = $(window)[fnWindowSize]();
			const posScroll = $(window)[fnScrollDir]();
			let position = posMouse + posScroll;
			const szMenu = this[fnMenuSize]();
			// opening menu would pass the side of the page
			if (posMouse + szMenu > szWin && szMenu < posMouse) position -= szMenu;
			return position;
		};
	},

	/**
	 * @param text
	 * @param fnAction Action, which is passed its triggering click event as an argument.
	 * @param [opts] Options object.
	 * @param [opts.isDisabled] If this action is disabled.
	 * @param [opts.title] Help (title) text.
	 * @param [opts.style] Additional CSS classes to add (e.g. `ctx-danger`).
	 * @param [opts.fnActionAlt] Alternate action, which can be accessed by clicking a secondary "settings"-esque button.
	 * @param [opts.textAlt] Text for the alt-action button
	 * @param [opts.titleAlt] Title for the alt-action button
	 */
	Action: function (text, fnAction, opts) {
		opts = opts || {};

		this.text = text;
		this.fnAction = fnAction;

		this.isDisabled = opts.isDisabled;
		this.title = opts.title;
		this.style = opts.style;

		this.fnActionAlt = opts.fnActionAlt;
		this.textAlt = opts.textAlt;
		this.titleAlt = opts.titleAlt;

		this.render = function ({menu}) {
			const $btnAction = this._render_$btnAction({menu});
			const $btnActionAlt = this._render_$btnActionAlt({menu});

			return {
				action: this,
				$eleRow: $$`<div class="ui-ctx__row ve-flex-v-center ${this.style || ""}">${$btnAction}${$btnActionAlt}</div>`,
				$eleBtn: $btnAction,
			};
		};

		this._render_$btnAction = function ({menu}) {
			const $btnAction = $(`<div class="w-100 min-w-0 ui-ctx__btn py-1 pl-5 ${this.fnActionAlt ? "" : "pr-5"}" ${this.isDisabled ? "disabled" : ""} tabindex="0">${this.text}</div>`)
				.click(async evt => {
					if (this.isDisabled) return;

					evt.preventDefault();
					evt.stopPropagation();

					menu.close();

					const result = await this.fnAction(evt, menu.userData);
					if (menu.resolveResult_) menu.resolveResult_(result);
				})
				.keydown(evt => {
					if (evt.key !== "Enter") return;
					$btnAction.click();
				});
			if (this.title) $btnAction.title(this.title);

			return $btnAction;
		};

		this._render_$btnActionAlt = function ({menu}) {
			if (!this.fnActionAlt) return null;

			const $btnActionAlt = $(`<div class="ui-ctx__btn ml-1 bl-1 py-1 px-4" ${this.isDisabled ? "disabled" : ""}>${this.textAlt ?? `<span class="glyphicon glyphicon-cog"></span>`}</div>`)
				.click(async evt => {
					if (this.isDisabled) return;

					evt.preventDefault();
					evt.stopPropagation();

					menu.close();

					const result = await this.fnActionAlt(evt, menu.userData);
					if (menu.resolveResult_) menu.resolveResult_(result);
				});
			if (this.titleAlt) $btnActionAlt.title(this.titleAlt);

			return $btnActionAlt;
		};

		this.update = function () { /* Implement as required */ };
	},

	ActionLink: function (text, fnHref, opts) {
		ContextUtil.Action.call(this, text, null, opts);

		this.fnHref = fnHref;
		this._$btnAction = null;

		this._render_$btnAction = function () {
			this._$btnAction = $(`<a href="${this.fnHref()}" class="w-100 min-w-0 ui-ctx__btn py-1 pl-5 ${this.fnActionAlt ? "" : "pr-5"}" ${this.isDisabled ? "disabled" : ""} tabindex="0">${this.text}</a>`);
			if (this.title) this._$btnAction.title(this.title);

			return this._$btnAction;
		};

		this.update = function () {
			this._$btnAction.attr("href", this.fnHref());
		};
	},
};

// LIST AND SEARCH =====================================================================================================
globalThis.SearchUtil = {
	removeStemmer (elasticSearch) {
		const stemmer = elasticlunr.Pipeline.getRegisteredFunction("stemmer");
		elasticSearch.pipeline.remove(stemmer);
	},
};

// ENCODING/DECODING ===================================================================================================
globalThis.UrlUtil = {
	encodeForHash (toEncode) {
		if (toEncode instanceof Array) return toEncode.map(it => `${it}`.toUrlified()).join(HASH_LIST_SEP);
		else return `${toEncode}`.toUrlified();
	},

	encodeArrayForHash (...toEncodes) {
		return toEncodes.map(UrlUtil.encodeForHash).join(HASH_LIST_SEP);
	},

	autoEncodeHash (obj) {
		const curPage = UrlUtil.getCurrentPage();
		const encoder = UrlUtil.URL_TO_HASH_BUILDER[curPage];
		if (!encoder) throw new Error(`No encoder found for page ${curPage}`);
		return encoder(obj);
	},

	decodeHash (hash) {
		return hash.split(HASH_LIST_SEP).map(it => decodeURIComponent(it));
	},

	getSluggedHash (hash) {
		return Parser.stringToSlug(decodeURIComponent(hash)).replace(/_/g, "-");
	},

	getCurrentPage () {
		if (typeof window === "undefined") return VeCt.PG_NONE;
		const pSplit = window.location.pathname.split("/");
		let out = pSplit[pSplit.length - 1];
		if (!out.toLowerCase().endsWith(".html")) out += ".html";
		return out;
	},

	/**
	 * All internal URL construction should pass through here, to ensure `static.5etools.com` is used when required.
	 *
	 * @param href the link
	 * @param isBustCache If a cache-busting parameter should always be added.
	 */
	link (href, {isBustCache = false} = {}) {
		if (isBustCache) return UrlUtil._link_getWithParam(href, {param: `t=${Date.now()}`});
		return href;
	},

	_link_getWithParam (href, {param = `v=${VERSION_NUMBER}`} = {}) {
		if (href.includes("?")) return `${href}&${param}`;
		return `${href}?${param}`;
	},

	unpackSubHash (subHash, unencode) {
		// format is "key:value~list~sep~with~tilde"
		if (subHash.includes(HASH_SUB_KV_SEP)) {
			const keyValArr = subHash.split(HASH_SUB_KV_SEP).map(s => s.trim());
			const out = {};
			let k = keyValArr[0].toLowerCase();
			if (unencode) k = decodeURIComponent(k);
			let v = keyValArr[1].toLowerCase();
			if (unencode) v = decodeURIComponent(v);
			out[k] = v.split(HASH_SUB_LIST_SEP).map(s => s.trim());
			if (out[k].length === 1 && out[k] === HASH_SUB_NONE) out[k] = [];
			return out;
		} else {
			throw new Error(`Badly formatted subhash ${subHash}`);
		}
	},

	/**
	 * @param key The subhash key.
	 * @param values The subhash values.
	 * @param [opts] Options object.
	 * @param [opts.isEncodeBoth] If both the key and values should be URl encoded.
	 * @param [opts.isEncodeKey] If the key should be URL encoded.
	 * @param [opts.isEncodeValues] If the values should be URL encoded.
	 * @returns {string}
	 */
	packSubHash (key, values, opts) {
		opts = opts || {};
		if (opts.isEncodeBoth || opts.isEncodeKey) key = key.toUrlified();
		if (opts.isEncodeBoth || opts.isEncodeValues) values = values.map(it => it.toUrlified());
		return `${key}${HASH_SUB_KV_SEP}${values.join(HASH_SUB_LIST_SEP)}`;
	},

	categoryToPage (category) { return UrlUtil.CAT_TO_PAGE[category]; },
	categoryToHoverPage (category) { return UrlUtil.CAT_TO_HOVER_PAGE[category] || UrlUtil.categoryToPage(category); },

	pageToDisplayPage (page) { return UrlUtil.PG_TO_NAME[page] || page; },

	getFilename (url) { return url.slice(url.lastIndexOf("/") + 1); },

	isFullUrl (url) { return url && /^.*?:\/\//.test(url); },

	mini: {
		compress (primitive) {
			const type = typeof primitive;
			if (primitive == null) return `x`;
			switch (type) {
				case "boolean": return `b${Number(primitive)}`;
				case "number": return `n${primitive}`;
				case "string": return `s${primitive.toUrlified()}`;
				default: throw new Error(`Unhandled type "${type}"`);
			}
		},

		decompress (raw) {
			const [type, data] = [raw.slice(0, 1), raw.slice(1)];
			switch (type) {
				case "x": return null;
				case "b": return !!Number(data);
				case "n": return Number(data);
				case "s": return decodeURIComponent(String(data));
				default: throw new Error(`Unhandled type "${type}"`);
			}
		},
	},

	class: {
		getIndexedClassEntries (cls) {
			const out = [];

			(cls.classFeatures || []).forEach((lvlFeatureList, ixLvl) => {
				lvlFeatureList
					// don't add "you gain a subclass feature" or ASI's
					.filter(feature => (!feature.gainSubclassFeature || feature.gainSubclassFeatureHasContent)
						&& feature.name !== "Ability Score Improvement"
						&& feature.name !== "Proficiency Versatility")
					.forEach((feature, ixFeature) => {
						const name = Renderer.findName(feature);
						if (!name) { // tolerate missing names in homebrew
							if (BrewUtil2.hasSourceJson(cls.source)) return;
							else throw new Error("Class feature had no name!");
						}
						out.push({
							_type: "classFeature",
							source: cls.source.source || cls.source,
							name,
							hash: `${UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES](cls)}${HASH_PART_SEP}${UrlUtil.getClassesPageStatePart({feature: {ixLevel: ixLvl, ixFeature: ixFeature}})}`,
							entry: feature,
							level: ixLvl + 1,
						});
					});
			});

			return out;
		},

		getIndexedSubclassEntries (sc) {
			const out = [];

			const lvlFeatures = sc.subclassFeatures || [];
			sc.source = sc.source || sc.classSource; // default to class source if required

			lvlFeatures.forEach(lvlFeature => {
				lvlFeature.forEach((feature, ixFeature) => {
					const subclassFeatureHash = `${UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES]({name: sc.className, source: sc.classSource})}${HASH_PART_SEP}${UrlUtil.getClassesPageStatePart({subclass: sc, feature: {ixLevel: feature.level - 1, ixFeature: ixFeature}})}`;

					const name = Renderer.findName(feature);
					if (!name) { // tolerate missing names in homebrew
						if (BrewUtil2.hasSourceJson(sc.source)) return;
						else throw new Error("Subclass feature had no name!");
					}
					out.push({
						_type: "subclassFeature",
						name,
						subclassName: sc.name,
						subclassShortName: sc.shortName,
						source: sc.source.source || sc.source,
						hash: subclassFeatureHash,
						entry: feature,
						level: feature.level,
					});

					if (feature.entries) {
						const namedFeatureParts = feature.entries.filter(it => it.name);
						namedFeatureParts.forEach(it => {
							if (out.find(existing => it.name === existing.name && feature.level === existing.level)) return;
							out.push({
								_type: "subclassFeaturePart",
								name: it.name,
								subclassName: sc.name,
								subclassShortName: sc.shortName,
								source: sc.source.source || sc.source,
								hash: subclassFeatureHash,
								entry: feature,
								level: feature.level,
							});
						});
					}
				});
			});

			return out;
		},
	},

	getStateKeySubclass (sc) { return Parser.stringToSlug(`sub ${sc.shortName || sc.name} ${sc.source}`); },

	/**
	 * @param opts Options object.
	 * @param [opts.subclass] Subclass (or object of the form `{shortName: "str", source: "str"}`)
	 * @param [opts.feature] Object of the form `{ixLevel: 0, ixFeature: 0}`
	 */
	getClassesPageStatePart (opts) {
		if (!opts.subclass && !opts.feature) return "";

		if (!opts.feature) return UrlUtil.packSubHash("state", [UrlUtil._getClassesPageStatePart_subclass(opts.subclass)]);
		if (!opts.subclass) return UrlUtil.packSubHash("state", [UrlUtil._getClassesPageStatePart_feature(opts.feature)]);

		return UrlUtil.packSubHash(
			"state",
			[
				UrlUtil._getClassesPageStatePart_subclass(opts.subclass),
				UrlUtil._getClassesPageStatePart_feature(opts.feature),
			],
		);
	},

	_getClassesPageStatePart_subclass (sc) { return `${UrlUtil.getStateKeySubclass(sc)}=${UrlUtil.mini.compress(true)}`; },
	_getClassesPageStatePart_feature (feature) { return `feature=${UrlUtil.mini.compress(`${feature.ixLevel}-${feature.ixFeature}`)}`; },
};

UrlUtil.PG_BESTIARY = "bestiary.html";
UrlUtil.PG_SPELLS = "spells.html";
UrlUtil.PG_BACKGROUNDS = "backgrounds.html";
UrlUtil.PG_ITEMS = "items.html";
UrlUtil.PG_CLASSES = "classes.html";
UrlUtil.PG_CONDITIONS_DISEASES = "conditionsdiseases.html";
UrlUtil.PG_FEATS = "feats.html";
UrlUtil.PG_OPT_FEATURES = "optionalfeatures.html";
UrlUtil.PG_PSIONICS = "psionics.html";
UrlUtil.PG_RACES = "races.html";
UrlUtil.PG_REWARDS = "rewards.html";
UrlUtil.PG_VARIANTRULES = "variantrules.html";
UrlUtil.PG_ADVENTURE = "adventure.html";
UrlUtil.PG_ADVENTURES = "adventures.html";
UrlUtil.PG_BOOK = "book.html";
UrlUtil.PG_BOOKS = "books.html";
UrlUtil.PG_DEITIES = "deities.html";
UrlUtil.PG_CULTS_BOONS = "cultsboons.html";
UrlUtil.PG_OBJECTS = "objects.html";
UrlUtil.PG_TRAPS_HAZARDS = "trapshazards.html";
UrlUtil.PG_QUICKREF = "quickreference.html";
UrlUtil.PG_MANAGE_BREW = "managebrew.html";
UrlUtil.PG_MANAGE_PRERELEASE = "manageprerelease.html";
UrlUtil.PG_MAKE_BREW = "makebrew.html";
UrlUtil.PG_DEMO_RENDER = "renderdemo.html";
UrlUtil.PG_TABLES = "tables.html";
UrlUtil.PG_VEHICLES = "vehicles.html";
UrlUtil.PG_CHARACTERS = "characters.html";
UrlUtil.PG_ACTIONS = "actions.html";
UrlUtil.PG_LANGUAGES = "languages.html";
UrlUtil.PG_STATGEN = "statgen.html";
UrlUtil.PG_LIFEGEN = "lifegen.html";
UrlUtil.PG_NAMES = "names.html";
UrlUtil.PG_DM_SCREEN = "dmscreen.html";
UrlUtil.PG_CR_CALCULATOR = "crcalculator.html";
UrlUtil.PG_ENCOUNTERGEN = "encountergen.html";
UrlUtil.PG_LOOTGEN = "lootgen.html";
UrlUtil.PG_TEXT_CONVERTER = "converter.html";
UrlUtil.PG_CHANGELOG = "changelog.html";
UrlUtil.PG_CHAR_CREATION_OPTIONS = "charcreationoptions.html";
UrlUtil.PG_RECIPES = "recipes.html";
UrlUtil.PG_CLASS_SUBCLASS_FEATURES = "classfeatures.html";
UrlUtil.PG_MAPS = "maps.html";
UrlUtil.PG_SEARCH = "search.html";
UrlUtil.PG_DECKS = "decks.html";

UrlUtil.URL_TO_HASH_GENERIC = (it) => UrlUtil.encodeArrayForHash(it.name, it.source);

UrlUtil.URL_TO_HASH_BUILDER = {};
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BESTIARY] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_SPELLS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BACKGROUNDS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CONDITIONS_DISEASES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_FEATS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OPT_FEATURES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_PSIONICS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_RACES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_REWARDS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VARIANTRULES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ADVENTURE] = (it) => UrlUtil.encodeForHash(it.id);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ADVENTURES] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ADVENTURE];
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BOOK] = (it) => UrlUtil.encodeForHash(it.id);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BOOKS] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BOOK];
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_DEITIES] = (it) => UrlUtil.encodeArrayForHash(it.name, it.pantheon, it.source);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CULTS_BOONS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OBJECTS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TRAPS_HAZARDS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TABLES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VEHICLES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ACTIONS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_LANGUAGES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CHAR_CREATION_OPTIONS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_RECIPES] = (it) => `${UrlUtil.encodeArrayForHash(it.name, it.source)}${it._scaleFactor ? `${HASH_PART_SEP}${VeCt.HASH_SCALED}${HASH_SUB_KV_SEP}${it._scaleFactor}` : ""}`;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_DECKS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASS_SUBCLASS_FEATURES] = (it) => (it.__prop === "subclassFeature" || it.subclassSource) ? UrlUtil.URL_TO_HASH_BUILDER["subclassFeature"](it) : UrlUtil.URL_TO_HASH_BUILDER["classFeature"](it);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_QUICKREF] = ({name, ixChapter, ixHeader}) => {
	const hashParts = ["bookref-quick", ixChapter, UrlUtil.encodeForHash(name.toLowerCase())];
	if (ixHeader) hashParts.push(ixHeader);
	return hashParts.join(HASH_PART_SEP);
};

// region Fake pages (props)
UrlUtil.URL_TO_HASH_BUILDER["monster"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BESTIARY];
UrlUtil.URL_TO_HASH_BUILDER["spell"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_SPELLS];
UrlUtil.URL_TO_HASH_BUILDER["background"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BACKGROUNDS];
UrlUtil.URL_TO_HASH_BUILDER["item"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS];
UrlUtil.URL_TO_HASH_BUILDER["itemGroup"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS];
UrlUtil.URL_TO_HASH_BUILDER["baseitem"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS];
UrlUtil.URL_TO_HASH_BUILDER["magicvariant"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS];
UrlUtil.URL_TO_HASH_BUILDER["class"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES];
UrlUtil.URL_TO_HASH_BUILDER["condition"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CONDITIONS_DISEASES];
UrlUtil.URL_TO_HASH_BUILDER["disease"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CONDITIONS_DISEASES];
UrlUtil.URL_TO_HASH_BUILDER["status"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CONDITIONS_DISEASES];
UrlUtil.URL_TO_HASH_BUILDER["feat"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_FEATS];
UrlUtil.URL_TO_HASH_BUILDER["optionalfeature"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OPT_FEATURES];
UrlUtil.URL_TO_HASH_BUILDER["psionic"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_PSIONICS];
UrlUtil.URL_TO_HASH_BUILDER["race"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_RACES];
UrlUtil.URL_TO_HASH_BUILDER["subrace"] = (it) => UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_RACES]({name: `${it.name} (${it.raceName})`, source: it.source});
UrlUtil.URL_TO_HASH_BUILDER["reward"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_REWARDS];
UrlUtil.URL_TO_HASH_BUILDER["variantrule"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VARIANTRULES];
UrlUtil.URL_TO_HASH_BUILDER["adventure"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ADVENTURES];
UrlUtil.URL_TO_HASH_BUILDER["adventureData"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ADVENTURES];
UrlUtil.URL_TO_HASH_BUILDER["book"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BOOKS];
UrlUtil.URL_TO_HASH_BUILDER["bookData"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BOOKS];
UrlUtil.URL_TO_HASH_BUILDER["deity"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_DEITIES];
UrlUtil.URL_TO_HASH_BUILDER["cult"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CULTS_BOONS];
UrlUtil.URL_TO_HASH_BUILDER["boon"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CULTS_BOONS];
UrlUtil.URL_TO_HASH_BUILDER["object"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OBJECTS];
UrlUtil.URL_TO_HASH_BUILDER["trap"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TRAPS_HAZARDS];
UrlUtil.URL_TO_HASH_BUILDER["hazard"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TRAPS_HAZARDS];
UrlUtil.URL_TO_HASH_BUILDER["table"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TABLES];
UrlUtil.URL_TO_HASH_BUILDER["tableGroup"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TABLES];
UrlUtil.URL_TO_HASH_BUILDER["vehicle"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VEHICLES];
UrlUtil.URL_TO_HASH_BUILDER["vehicleUpgrade"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VEHICLES];
UrlUtil.URL_TO_HASH_BUILDER["action"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ACTIONS];
UrlUtil.URL_TO_HASH_BUILDER["language"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_LANGUAGES];
UrlUtil.URL_TO_HASH_BUILDER["charoption"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CHAR_CREATION_OPTIONS];
UrlUtil.URL_TO_HASH_BUILDER["recipe"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_RECIPES];
UrlUtil.URL_TO_HASH_BUILDER["deck"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_DECKS];

UrlUtil.URL_TO_HASH_BUILDER["subclass"] = it => {
	return Hist.util.getCleanHash(
		`${UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES]({name: it.className, source: it.classSource})}${HASH_PART_SEP}${UrlUtil.getClassesPageStatePart({subclass: it})}`,
	);
};
UrlUtil.URL_TO_HASH_BUILDER["classFeature"] = (it) => UrlUtil.encodeArrayForHash(it.name, it.className, it.classSource, it.level, it.source);
UrlUtil.URL_TO_HASH_BUILDER["subclassFeature"] = (it) => UrlUtil.encodeArrayForHash(it.name, it.className, it.classSource, it.subclassShortName, it.subclassSource, it.level, it.source);
UrlUtil.URL_TO_HASH_BUILDER["card"] = (it) => UrlUtil.encodeArrayForHash(it.name, it.set, it.source);
UrlUtil.URL_TO_HASH_BUILDER["legendaryGroup"] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER["itemEntry"] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER["itemProperty"] = (it) => UrlUtil.encodeArrayForHash(it.abbreviation, it.source);
UrlUtil.URL_TO_HASH_BUILDER["itemType"] = (it) => UrlUtil.encodeArrayForHash(it.abbreviation, it.source);
UrlUtil.URL_TO_HASH_BUILDER["itemTypeAdditionalEntries"] = (it) => UrlUtil.encodeArrayForHash(it.appliesTo, it.source);
UrlUtil.URL_TO_HASH_BUILDER["skill"] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER["sense"] = UrlUtil.URL_TO_HASH_GENERIC;

// Add lowercase aliases
Object.keys(UrlUtil.URL_TO_HASH_BUILDER)
	.filter(k => !k.endsWith(".html") && k.toLowerCase() !== k)
	.forEach(k => UrlUtil.URL_TO_HASH_BUILDER[k.toLowerCase()] = UrlUtil.URL_TO_HASH_BUILDER[k]);

// Add raw aliases
Object.keys(UrlUtil.URL_TO_HASH_BUILDER)
	.filter(k => !k.endsWith(".html"))
	.forEach(k => UrlUtil.URL_TO_HASH_BUILDER[`raw_${k}`] = UrlUtil.URL_TO_HASH_BUILDER[k]);

// Add fluff aliases
Object.keys(UrlUtil.URL_TO_HASH_BUILDER)
	.filter(k => !k.endsWith(".html"))
	.forEach(k => UrlUtil.URL_TO_HASH_BUILDER[`${k}Fluff`] = UrlUtil.URL_TO_HASH_BUILDER[k]);
// endregion

UrlUtil.PG_TO_NAME = {};
UrlUtil.PG_TO_NAME[UrlUtil.PG_BESTIARY] = "Bestiary";
UrlUtil.PG_TO_NAME[UrlUtil.PG_SPELLS] = "Spells";
UrlUtil.PG_TO_NAME[UrlUtil.PG_BACKGROUNDS] = "Backgrounds";
UrlUtil.PG_TO_NAME[UrlUtil.PG_ITEMS] = "Items";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CLASSES] = "Classes";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CONDITIONS_DISEASES] = "Conditions & Diseases";
UrlUtil.PG_TO_NAME[UrlUtil.PG_FEATS] = "Feats";
UrlUtil.PG_TO_NAME[UrlUtil.PG_OPT_FEATURES] = "Other Options and Features";
UrlUtil.PG_TO_NAME[UrlUtil.PG_PSIONICS] = "Psionics";
UrlUtil.PG_TO_NAME[UrlUtil.PG_RACES] = "Races";
UrlUtil.PG_TO_NAME[UrlUtil.PG_REWARDS] = "Supernatural Gifts & Rewards";
UrlUtil.PG_TO_NAME[UrlUtil.PG_VARIANTRULES] = "Optional, Variant, and Expanded Rules";
UrlUtil.PG_TO_NAME[UrlUtil.PG_ADVENTURES] = "Adventures";
UrlUtil.PG_TO_NAME[UrlUtil.PG_BOOKS] = "Books";
UrlUtil.PG_TO_NAME[UrlUtil.PG_DEITIES] = "Deities";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CULTS_BOONS] = "Cults & Supernatural Boons";
UrlUtil.PG_TO_NAME[UrlUtil.PG_OBJECTS] = "Objects";
UrlUtil.PG_TO_NAME[UrlUtil.PG_TRAPS_HAZARDS] = "Traps & Hazards";
UrlUtil.PG_TO_NAME[UrlUtil.PG_QUICKREF] = "Quick Reference";
UrlUtil.PG_TO_NAME[UrlUtil.PG_MANAGE_BREW] = "Homebrew Manager";
UrlUtil.PG_TO_NAME[UrlUtil.PG_MANAGE_PRERELEASE] = "Prerelease Content Manager";
UrlUtil.PG_TO_NAME[UrlUtil.PG_MAKE_BREW] = "Homebrew Builder";
UrlUtil.PG_TO_NAME[UrlUtil.PG_DEMO_RENDER] = "Renderer Demo";
UrlUtil.PG_TO_NAME[UrlUtil.PG_TABLES] = "Tables";
UrlUtil.PG_TO_NAME[UrlUtil.PG_VEHICLES] = "Vehicles";
// UrlUtil.PG_TO_NAME[UrlUtil.PG_CHARACTERS] = "";
UrlUtil.PG_TO_NAME[UrlUtil.PG_ACTIONS] = "Actions";
UrlUtil.PG_TO_NAME[UrlUtil.PG_LANGUAGES] = "Languages";
UrlUtil.PG_TO_NAME[UrlUtil.PG_STATGEN] = "Stat Generator";
UrlUtil.PG_TO_NAME[UrlUtil.PG_LIFEGEN] = "This Is Your Life";
UrlUtil.PG_TO_NAME[UrlUtil.PG_NAMES] = "Names";
UrlUtil.PG_TO_NAME[UrlUtil.PG_DM_SCREEN] = "DM Screen";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CR_CALCULATOR] = "CR Calculator";
UrlUtil.PG_TO_NAME[UrlUtil.PG_ENCOUNTERGEN] = "Encounter Generator";
UrlUtil.PG_TO_NAME[UrlUtil.PG_LOOTGEN] = "Loot Generator";
UrlUtil.PG_TO_NAME[UrlUtil.PG_TEXT_CONVERTER] = "Text Converter";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CHANGELOG] = "Changelog";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CHAR_CREATION_OPTIONS] = "Other Character Creation Options";
UrlUtil.PG_TO_NAME[UrlUtil.PG_RECIPES] = "Recipes";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CLASS_SUBCLASS_FEATURES] = "Class & Subclass Features";
UrlUtil.PG_TO_NAME[UrlUtil.PG_MAPS] = "Maps";
UrlUtil.PG_TO_NAME[UrlUtil.PG_DECKS] = "Decks";

UrlUtil.CAT_TO_PAGE = {};
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CREATURE] = UrlUtil.PG_BESTIARY;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_SPELL] = UrlUtil.PG_SPELLS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_BACKGROUND] = UrlUtil.PG_BACKGROUNDS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ITEM] = UrlUtil.PG_ITEMS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CLASS] = UrlUtil.PG_CLASSES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CLASS_FEATURE] = UrlUtil.PG_CLASSES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_SUBCLASS] = UrlUtil.PG_CLASSES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_SUBCLASS_FEATURE] = UrlUtil.PG_CLASSES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CONDITION] = UrlUtil.PG_CONDITIONS_DISEASES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_FEAT] = UrlUtil.PG_FEATS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ELDRITCH_INVOCATION] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_METAMAGIC] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_MANEUVER_BATTLEMASTER] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_MANEUVER_CAVALIER] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ARCANE_SHOT] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_OPTIONAL_FEATURE_OTHER] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_FIGHTING_STYLE] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_PSIONIC] = UrlUtil.PG_PSIONICS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_RACE] = UrlUtil.PG_RACES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_OTHER_REWARD] = UrlUtil.PG_REWARDS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_VARIANT_OPTIONAL_RULE] = UrlUtil.PG_VARIANTRULES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ADVENTURE] = UrlUtil.PG_ADVENTURE;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_DEITY] = UrlUtil.PG_DEITIES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_OBJECT] = UrlUtil.PG_OBJECTS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_TRAP] = UrlUtil.PG_TRAPS_HAZARDS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_HAZARD] = UrlUtil.PG_TRAPS_HAZARDS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_QUICKREF] = UrlUtil.PG_QUICKREF;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CULT] = UrlUtil.PG_CULTS_BOONS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_BOON] = UrlUtil.PG_CULTS_BOONS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_DISEASE] = UrlUtil.PG_CONDITIONS_DISEASES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_TABLE] = UrlUtil.PG_TABLES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_TABLE_GROUP] = UrlUtil.PG_TABLES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_VEHICLE] = UrlUtil.PG_VEHICLES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_PACT_BOON] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ELEMENTAL_DISCIPLINE] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ARTIFICER_INFUSION] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_SHIP_UPGRADE] = UrlUtil.PG_VEHICLES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_INFERNAL_WAR_MACHINE_UPGRADE] = UrlUtil.PG_VEHICLES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ONOMANCY_RESONANT] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_RUNE_KNIGHT_RUNE] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ALCHEMICAL_FORMULA] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_MANEUVER] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ACTION] = UrlUtil.PG_ACTIONS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_LANGUAGE] = UrlUtil.PG_LANGUAGES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_BOOK] = UrlUtil.PG_BOOK;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_PAGE] = null;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_LEGENDARY_GROUP] = null;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CHAR_CREATION_OPTIONS] = UrlUtil.PG_CHAR_CREATION_OPTIONS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_RECIPES] = UrlUtil.PG_RECIPES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_STATUS] = UrlUtil.PG_CONDITIONS_DISEASES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_DECK] = UrlUtil.PG_DECKS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CARD] = "card";
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_SKILLS] = "skill";
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_SENSES] = "sense";
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_LEGENDARY_GROUP] = "legendaryGroup";

UrlUtil.CAT_TO_HOVER_PAGE = {};
UrlUtil.CAT_TO_HOVER_PAGE[Parser.CAT_ID_CLASS_FEATURE] = "classfeature";
UrlUtil.CAT_TO_HOVER_PAGE[Parser.CAT_ID_SUBCLASS_FEATURE] = "subclassfeature";
UrlUtil.CAT_TO_HOVER_PAGE[Parser.CAT_ID_CARD] = "card";
UrlUtil.CAT_TO_HOVER_PAGE[Parser.CAT_ID_SKILLS] = "skill";
UrlUtil.CAT_TO_HOVER_PAGE[Parser.CAT_ID_SENSES] = "sense";
UrlUtil.CAT_TO_HOVER_PAGE[Parser.CAT_ID_LEGENDARY_GROUP] = "legendaryGroup";

UrlUtil.HASH_START_CREATURE_SCALED = `${VeCt.HASH_SCALED}${HASH_SUB_KV_SEP}`;
UrlUtil.HASH_START_CREATURE_SCALED_SPELL_SUMMON = `${VeCt.HASH_SCALED_SPELL_SUMMON}${HASH_SUB_KV_SEP}`;
UrlUtil.HASH_START_CREATURE_SCALED_CLASS_SUMMON = `${VeCt.HASH_SCALED_CLASS_SUMMON}${HASH_SUB_KV_SEP}`;

UrlUtil.SUBLIST_PAGES = {
	[UrlUtil.PG_BESTIARY]: true,
	[UrlUtil.PG_SPELLS]: true,
	[UrlUtil.PG_BACKGROUNDS]: true,
	[UrlUtil.PG_ITEMS]: true,
	[UrlUtil.PG_CONDITIONS_DISEASES]: true,
	[UrlUtil.PG_FEATS]: true,
	[UrlUtil.PG_OPT_FEATURES]: true,
	[UrlUtil.PG_PSIONICS]: true,
	[UrlUtil.PG_RACES]: true,
	[UrlUtil.PG_REWARDS]: true,
	[UrlUtil.PG_VARIANTRULES]: true,
	[UrlUtil.PG_DEITIES]: true,
	[UrlUtil.PG_CULTS_BOONS]: true,
	[UrlUtil.PG_OBJECTS]: true,
	[UrlUtil.PG_TRAPS_HAZARDS]: true,
	[UrlUtil.PG_TABLES]: true,
	[UrlUtil.PG_VEHICLES]: true,
	[UrlUtil.PG_ACTIONS]: true,
	[UrlUtil.PG_LANGUAGES]: true,
	[UrlUtil.PG_CHAR_CREATION_OPTIONS]: true,
	[UrlUtil.PG_RECIPES]: true,
	[UrlUtil.PG_DECKS]: true,
};

UrlUtil.PAGE_TO_PROPS = {};
UrlUtil.PAGE_TO_PROPS[UrlUtil.PG_SPELLS] = ["spell"];
UrlUtil.PAGE_TO_PROPS[UrlUtil.PG_ITEMS] = ["item", "itemGroup", "itemType", "itemEntry", "itemProperty", "itemTypeAdditionalEntries", "baseitem", "magicvariant"];

if (!IS_DEPLOYED && !IS_VTT && typeof window !== "undefined") {
	// for local testing, hotkey to get a link to the current page on the main site
	window.addEventListener("keypress", (e) => {
		if (EventUtil.noModifierKeys(e) && typeof d20 === "undefined") {
			if (e.key === "#") {
				const spl = window.location.href.split("/");
				window.prompt("Copy to clipboard: Ctrl+C, Enter", `https://5etools-mirror-1.github.io/${spl[spl.length - 1]}`);
			}
		}
	});
}

// SORTING =============================================================================================================
globalThis.SortUtil = {
	ascSort: (a, b) => {
		if (typeof FilterItem !== "undefined") {
			if (a instanceof FilterItem) a = a.item;
			if (b instanceof FilterItem) b = b.item;
		}

		return SortUtil._ascSort(a, b);
	},

	ascSortProp: (prop, a, b) => { return SortUtil.ascSort(a[prop], b[prop]); },

	ascSortLower: (a, b) => {
		if (typeof FilterItem !== "undefined") {
			if (a instanceof FilterItem) a = a.item;
			if (b instanceof FilterItem) b = b.item;
		}

		a = a ? a.toLowerCase() : a;
		b = b ? b.toLowerCase() : b;

		return SortUtil._ascSort(a, b);
	},

	ascSortLowerProp: (prop, a, b) => { return SortUtil.ascSortLower(a[prop], b[prop]); },

	// warning: slow
	ascSortNumericalSuffix (a, b) {
		if (typeof FilterItem !== "undefined") {
			if (a instanceof FilterItem) a = a.item;
			if (b instanceof FilterItem) b = b.item;
		}

		function popEndNumber (str) {
			const spl = str.split(" ");
			return spl.last().isNumeric() ? [spl.slice(0, -1).join(" "), Number(spl.last().replace(Parser._numberCleanRegexp, ""))] : [spl.join(" "), 0];
		}

		const [aStr, aNum] = popEndNumber(a.item || a);
		const [bStr, bNum] = popEndNumber(b.item || b);
		const initialSort = SortUtil.ascSort(aStr, bStr);
		if (initialSort) return initialSort;
		return SortUtil.ascSort(aNum, bNum);
	},

	_ascSort: (a, b) => {
		if (b === a) return 0;
		return b < a ? 1 : -1;
	},

	ascSortDate (a, b) {
		return b.getTime() - a.getTime();
	},

	ascSortDateString (a, b) {
		return SortUtil.ascSortDate(new Date(a || "1970-01-0"), new Date(b || "1970-01-0"));
	},

	compareListNames (a, b) { return SortUtil._ascSort(a.name.toLowerCase(), b.name.toLowerCase()); },

	listSort (a, b, opts) {
		opts = opts || {sortBy: "name"};
		if (opts.sortBy === "name") return SortUtil.compareListNames(a, b);
		else return SortUtil._compareByOrDefault_compareByOrDefault(a, b, opts.sortBy);
	},

	_listSort_compareBy (a, b, sortBy) {
		const aValue = typeof a.values[sortBy] === "string" ? a.values[sortBy].toLowerCase() : a.values[sortBy];
		const bValue = typeof b.values[sortBy] === "string" ? b.values[sortBy].toLowerCase() : b.values[sortBy];

		return SortUtil._ascSort(aValue, bValue);
	},

	_compareByOrDefault_compareByOrDefault (a, b, sortBy) {
		return SortUtil._listSort_compareBy(a, b, sortBy) || SortUtil.compareListNames(a, b);
	},

	/**
	 * "Special Equipment" first, then alphabetical
	 */
	_MON_TRAIT_ORDER: [
		"special equipment",
		"shapechanger",
	],
	monTraitSort: (a, b) => {
		if (a.sort != null && b.sort != null) return a.sort - b.sort;
		if (a.sort != null && b.sort == null) return -1;
		if (a.sort == null && b.sort != null) return 1;

		if (!a.name && !b.name) return 0;
		const aClean = Renderer.stripTags(a.name).toLowerCase().trim();
		const bClean = Renderer.stripTags(b.name).toLowerCase().trim();

		const isOnlyA = a.name.endsWith(" Only)");
		const isOnlyB = b.name.endsWith(" Only)");
		if (!isOnlyA && isOnlyB) return -1;
		if (isOnlyA && !isOnlyB) return 1;

		const ixA = SortUtil._MON_TRAIT_ORDER.indexOf(aClean);
		const ixB = SortUtil._MON_TRAIT_ORDER.indexOf(bClean);
		if (~ixA && ~ixB) return ixA - ixB;
		else if (~ixA) return -1;
		else if (~ixB) return 1;
		else return SortUtil.ascSort(aClean, bClean);
	},

	_alignFirst: ["L", "C"],
	_alignSecond: ["G", "E"],
	alignmentSort: (a, b) => {
		if (a === b) return 0;
		if (SortUtil._alignFirst.includes(a)) return -1;
		if (SortUtil._alignSecond.includes(a)) return 1;
		if (SortUtil._alignFirst.includes(b)) return 1;
		if (SortUtil._alignSecond.includes(b)) return -1;
		return 0;
	},

	ascSortCr (a, b) {
		if (typeof FilterItem !== "undefined") {
			if (a instanceof FilterItem) a = a.item;
			if (b instanceof FilterItem) b = b.item;
		}
		// always put unknown values last
		if (a === "Unknown") a = "998";
		if (b === "Unknown") b = "998";
		if (a === "\u2014" || a == null) a = "999";
		if (b === "\u2014" || b == null) b = "999";
		return SortUtil.ascSort(Parser.crToNumber(a), Parser.crToNumber(b));
	},

	ascSortAtts (a, b) {
		const aSpecial = a === "special";
		const bSpecial = b === "special";
		return aSpecial && bSpecial ? 0 : aSpecial ? 1 : bSpecial ? -1 : Parser.ABIL_ABVS.indexOf(a) - Parser.ABIL_ABVS.indexOf(b);
	},

	ascSortSize (a, b) { return Parser.SIZE_ABVS.indexOf(a) - Parser.SIZE_ABVS.indexOf(b); },

	initBtnSortHandlers ($wrpBtnsSort, list) {
		let dispCaretInitial = null;

		const dispCarets = [...$wrpBtnsSort[0].querySelectorAll(`[data-sort]`)]
			.map(btnSort => {
				const dispCaret = e_({
					tag: "span",
					clazz: "lst__caret",
				})
					.appendTo(btnSort);

				const btnSortField = btnSort.dataset.sort;

				if (btnSortField === list.sortBy) dispCaretInitial = dispCaret;

				e_({
					ele: btnSort,
					click: evt => {
						evt.stopPropagation();
						const direction = list.sortDir === "asc" ? "desc" : "asc";
						SortUtil._initBtnSortHandlers_showCaret({dispCarets, dispCaret, direction});
						list.sort(btnSortField, direction);
					},
				});

				return dispCaret;
			});

		dispCaretInitial = dispCaretInitial || dispCarets[0]; // Fall back on displaying the first caret

		SortUtil._initBtnSortHandlers_showCaret({dispCaret: dispCaretInitial, dispCarets, direction: list.sortDir});
	},

	_initBtnSortHandlers_showCaret (
		{
			dispCaret,
			dispCarets,
			direction,
		},
	) {
		dispCarets.forEach($it => $it.removeClass("lst__caret--active"));
		dispCaret.addClass("lst__caret--active").toggleClass("lst__caret--reverse", direction === "asc");
	},

	/** Add more list sort on-clicks to existing sort buttons. */
	initBtnSortHandlersAdditional ($wrpBtnsSort, list) {
		[...$wrpBtnsSort[0].querySelectorAll(".sort")]
			.map(btnSort => {
				const btnSortField = btnSort.dataset.sort;

				e_({
					ele: btnSort,
					click: evt => {
						evt.stopPropagation();
						const direction = list.sortDir === "asc" ? "desc" : "asc";
						list.sort(btnSortField, direction);
					},
				});
			});
	},

	ascSortSourceGroup (a, b) {
		const grpA = a.group || "other";
		const grpB = b.group || "other";
		const ixA = SourceUtil.ADV_BOOK_GROUPS.findIndex(it => it.group === grpA);
		const ixB = SourceUtil.ADV_BOOK_GROUPS.findIndex(it => it.group === grpB);
		return SortUtil.ascSort(ixA, ixB);
	},

	ascSortAdventure (a, b) {
		return SortUtil.ascSortDateString(b.published, a.published)
			|| SortUtil.ascSortLower(a.parentSource || "", b.parentSource || "")
			|| SortUtil.ascSort(a.publishedOrder ?? 0, b.publishedOrder ?? 0)
			|| SortUtil.ascSortLower(a.storyline, b.storyline)
			|| SortUtil.ascSort(a.level?.start ?? 20, b.level?.start ?? 20)
			|| SortUtil.ascSortLower(a.name, b.name);
	},

	ascSortBook (a, b) {
		return SortUtil.ascSortDateString(b.published, a.published)
			|| SortUtil.ascSortLower(a.parentSource || "", b.parentSource || "")
			|| SortUtil.ascSortLower(a.name, b.name);
	},

	ascSortGenericEntity (a, b) {
		return SortUtil.ascSortLower(a.name, b.name) || SortUtil.ascSortLower(a.source, b.source);
	},

	ascSortDeity (a, b) {
		return SortUtil.ascSortLower(a.name, b.name) || SortUtil.ascSortLower(a.source, b.source) || SortUtil.ascSortLower(a.pantheon, b.pantheon);
	},

	ascSortCard (a, b) {
		return SortUtil.ascSortLower(a.set, b.set) || SortUtil.ascSortLower(a.source, b.source) || SortUtil.ascSortLower(a.name, b.name);
	},

	_ITEM_RARITY_ORDER: ["none", "common", "uncommon", "rare", "very rare", "legendary", "artifact", "varies", "unknown (magic)", "unknown"],
	ascSortItemRarity (a, b) {
		const ixA = SortUtil._ITEM_RARITY_ORDER.indexOf(a);
		const ixB = SortUtil._ITEM_RARITY_ORDER.indexOf(b);
		return (~ixA ? ixA : Number.MAX_SAFE_INTEGER) - (~ixB ? ixB : Number.MAX_SAFE_INTEGER);
	},
};

// JSON LOADING ========================================================================================================
class _DataUtilPropConfig {
	static _MERGE_REQUIRES_PRESERVE = {};
	static _PAGE = null;

	static get PAGE () { return this._PAGE; }

	static async pMergeCopy (lst, ent, options) {
		return DataUtil.generic._pMergeCopy(this, this._PAGE, lst, ent, options);
	}
}

class _DataUtilPropConfigSingleSource extends _DataUtilPropConfig {
	static _FILENAME = null;

	static getDataUrl () { return `${Renderer.get().baseUrl}data/${this._FILENAME}`; }

	static async loadJSON () { return this.loadRawJSON(); }
	static async loadRawJSON () { return DataUtil.loadJSON(this.getDataUrl()); }
	static async loadUnmergedJSON () { return DataUtil.loadRawJSON(this.getDataUrl()); }
}

class _DataUtilPropConfigMultiSource extends _DataUtilPropConfig {
	static _DIR = null;
	static _PROP = null;
	static _IS_MUT_ENTITIES = false;

	static get _isFluff () { return this._PROP.endsWith("Fluff"); }

	static _P_INDEX = null;

	static pLoadIndex () {
		this._P_INDEX = this._P_INDEX || DataUtil.loadJSON(`${Renderer.get().baseUrl}data/${this._DIR}/${this._isFluff ? `fluff-` : ""}index.json`);
		return this._P_INDEX;
	}

	static async pLoadAll () {
		const json = await this.loadJSON();
		return json[this._PROP];
	}

	static async loadJSON () { return this._loadJSON({isUnmerged: false}); }
	static async loadUnmergedJSON () { return this._loadJSON({isUnmerged: true}); }

	static async _loadJSON ({isUnmerged = false} = {}) {
		const index = await this.pLoadIndex();

		const allData = await Object.entries(index)
			.pMap(async ([source, file]) => this._pLoadSourceEntities({source, isUnmerged, file}));

		return {[this._PROP]: allData.flat()};
	}

	static async pLoadSingleSource (source) {
		const index = await this.pLoadIndex();

		const file = index[source];
		if (!file) return null;

		return {[this._PROP]: await this._pLoadSourceEntities({source, file})};
	}

	static async _pLoadSourceEntities ({source, isUnmerged = false, file}) {
		await this._pInitPreData();

		const fnLoad = isUnmerged ? DataUtil.loadRawJSON.bind(DataUtil) : DataUtil.loadJSON.bind(DataUtil);

		let data = await fnLoad(`${Renderer.get().baseUrl}data/${this._DIR}/${file}`);
		data = data[this._PROP].filter(it => it.source === source);

		if (!this._IS_MUT_ENTITIES) return data;

		return data.map(ent => this._mutEntity(ent));
	}

	static _P_INIT_PRE_DATA = null;

	static async _pInitPreData () {
		return (this._P_INIT_PRE_DATA = this._P_INIT_PRE_DATA || this._pInitPreData_());
	}

	static async _pInitPreData_ () { /* Implement as required */ }

	static _mutEntity (ent) { return ent; }
}

class _DataUtilPropConfigCustom extends _DataUtilPropConfig {
	static async loadJSON () { throw new Error("Unimplemented!"); }
	static async loadUnmergedJSON () { throw new Error("Unimplemented!"); }
}

class _DataUtilBrewHelper {
	constructor ({defaultUrlRoot}) {
		this._defaultUrlRoot = defaultUrlRoot;
	}

	_getCleanUrlRoot (urlRoot) {
		if (urlRoot && urlRoot.trim()) {
			urlRoot = urlRoot.trim();
			if (!urlRoot.endsWith("/")) urlRoot = `${urlRoot}/`;
			return urlRoot;
		}
		return this._defaultUrlRoot;
	}

	async pLoadTimestamps (urlRoot) {
		urlRoot = this._getCleanUrlRoot(urlRoot);
		return DataUtil.loadJSON(`${urlRoot}_generated/index-timestamps.json`);
	}

	async pLoadPropIndex (urlRoot) {
		urlRoot = this._getCleanUrlRoot(urlRoot);
		return DataUtil.loadJSON(`${urlRoot}_generated/index-props.json`);
	}

	async pLoadMetaIndex (urlRoot) {
		urlRoot = this._getCleanUrlRoot(urlRoot);
		return DataUtil.loadJSON(`${urlRoot}_generated/index-meta.json`);
	}

	async pLoadSourceIndex (urlRoot) {
		urlRoot = this._getCleanUrlRoot(urlRoot);
		return DataUtil.loadJSON(`${urlRoot}_generated/index-sources.json`);
	}

	getFileUrl (path, urlRoot) {
		urlRoot = this._getCleanUrlRoot(urlRoot);
		return `${urlRoot}${path}`;
	}
}

globalThis.DataUtil = {
	_loading: {},
	_loaded: {},
	_merging: {},
	_merged: {},

	async _pLoad ({url, id, isBustCache = false}) {
		if (DataUtil._loading[id] && !isBustCache) {
			await DataUtil._loading[id];
			return DataUtil._loaded[id];
		}

		DataUtil._loading[id] = new Promise((resolve, reject) => {
			const request = new XMLHttpRequest();

			request.open("GET", url, true);
			/*
			// These would be nice to have, but kill CORS when e.g. hitting GitHub `raw.`s.
			// This may be why `fetch` dies horribly here, too. Prefer `XMLHttpRequest` for now, as it seems to have a
			//   higher innate tolerance to CORS nonsense.
			if (isBustCache) request.setRequestHeader("Cache-Control", "no-cache, no-store");
			request.setRequestHeader("Content-Type", "application/json");
			request.setRequestHeader("Referrer-Policy", "no-referrer");
			 */
			request.overrideMimeType("application/json");

			request.onload = function () {
				try {
					DataUtil._loaded[id] = JSON.parse(this.response);
					resolve();
				} catch (e) {
					reject(new Error(`Could not parse JSON from ${url}: ${e.message}`));
				}
			};
			request.onerror = (e) => reject(new Error(`Error during JSON request: ${e.target.status}`));

			request.send();
		});

		await DataUtil._loading[id];
		return DataUtil._loaded[id];
	},

	_mutAddProps (data) {
		if (data && typeof data === "object") {
			for (const k in data) {
				if (data[k] instanceof Array) {
					for (const it of data[k]) {
						if (typeof it !== "object") continue;
						it.__prop = k;
					}
				}
			}
		}
	},

	async loadJSON (url) {
		return DataUtil._loadJson(url, {isDoDataMerge: true});
	},

	async loadRawJSON (url, {isBustCache} = {}) {
		return DataUtil._loadJson(url, {isBustCache});
	},

	async _loadJson (url, {isDoDataMerge = false, isBustCache = false} = {}) {
		const procUrl = UrlUtil.link(url, {isBustCache});

		let data;
		try {
			data = await DataUtil._pLoad({url: procUrl, id: url, isBustCache});
		} catch (e) {
			setTimeout(() => { throw e; });
		}

		// Fallback to the un-processed URL
		if (!data) data = await DataUtil._pLoad({url: url, id: url, isBustCache});

		if (isDoDataMerge) await DataUtil.pDoMetaMerge(url, data);

		return data;
	},

	async pDoMetaMerge (ident, data, options) {
		DataUtil._mutAddProps(data);
		DataUtil._merging[ident] = DataUtil._merging[ident] || DataUtil._pDoMetaMerge(ident, data, options);
		await DataUtil._merging[ident];
		const out = DataUtil._merged[ident];

		// Cache the result, but immediately flush it.
		//   We do this because the cache is both a cache and a locking mechanism.
		if (options?.isSkipMetaMergeCache) {
			delete DataUtil._merging[ident];
			delete DataUtil._merged[ident];
		}

		return out;
	},

	_pDoMetaMerge_handleCopyProp (prop, arr, entry, options) {
		if (!entry._copy) return;
		let fnMergeCopy = DataUtil[prop]?.pMergeCopy;
		if (!fnMergeCopy) throw new Error(`No dependency _copy merge strategy specified for property "${prop}"`);
		fnMergeCopy = fnMergeCopy.bind(DataUtil[prop]);
		return fnMergeCopy(arr, entry, options);
	},

	async _pDoMetaMerge (ident, data, options) {
		if (data._meta) {
			const loadedSourceIds = new Set();

			if (data._meta.dependencies) {
				await Promise.all(Object.entries(data._meta.dependencies).map(async ([dataProp, sourceIds]) => {
					sourceIds.forEach(sourceId => loadedSourceIds.add(sourceId));

					if (!data[dataProp]) return; // if e.g. monster dependencies are declared, but there are no monsters to merge with, bail out

					const isHasInternalCopies = (data._meta.internalCopies || []).includes(dataProp);

					const dependencyData = await Promise.all(sourceIds.map(sourceId => DataUtil.pLoadByMeta(dataProp, sourceId)));

					const flatDependencyData = dependencyData.map(dd => dd[dataProp]).flat().filter(Boolean);
					await Promise.all(data[dataProp].map(entry => DataUtil._pDoMetaMerge_handleCopyProp(dataProp, flatDependencyData, entry, {...options, isErrorOnMissing: !isHasInternalCopies})));
				}));
				delete data._meta.dependencies;
			}

			if (data._meta.internalCopies) {
				for (const prop of data._meta.internalCopies) {
					if (!data[prop]) continue;
					for (const entry of data[prop]) {
						await DataUtil._pDoMetaMerge_handleCopyProp(prop, data[prop], entry, {...options, isErrorOnMissing: true});
					}
				}
				delete data._meta.internalCopies;
			}

			// Load any other included data
			if (data._meta.includes) {
				const includesData = await Promise.all(Object.entries(data._meta.includes).map(async ([dataProp, sourceIds]) => {
					// Avoid re-loading any sources we already loaded as dependencies
					sourceIds = sourceIds.filter(it => !loadedSourceIds.has(it));

					sourceIds.forEach(sourceId => loadedSourceIds.add(sourceId));

					const includesData = await Promise.all(sourceIds.map(sourceId => DataUtil.pLoadByMeta(dataProp, sourceId)));

					const flatIncludesData = includesData.map(dd => dd[dataProp]).flat().filter(Boolean);
					return {dataProp, flatIncludesData};
				}));
				delete data._meta.includes;

				// Add the includes data to our current data
				includesData.forEach(({dataProp, flatIncludesData}) => {
					data[dataProp] = [...data[dataProp] || [], ...flatIncludesData];
				});
			}
		}

		if (data._meta && data._meta.otherSources) {
			await Promise.all(Object.entries(data._meta.otherSources).map(async ([dataProp, sourceIds]) => {
				const additionalData = await Promise.all(Object.entries(sourceIds).map(async ([sourceId, findWith]) => ({
					findWith,
					dataOther: await DataUtil.pLoadByMeta(dataProp, sourceId),
				})));

				additionalData.forEach(({findWith, dataOther}) => {
					const toAppend = dataOther[dataProp].filter(it => it.otherSources && it.otherSources.find(os => os.source === findWith));
					if (toAppend.length) data[dataProp] = (data[dataProp] || []).concat(toAppend);
				});
			}));
			delete data._meta.otherSources;
		}

		if (data._meta && !Object.keys(data._meta).length) delete data._meta;

		DataUtil._merged[ident] = data;
	},

	getCleanFilename (filename) {
		return filename.replace(/[^-_a-zA-Z0-9]/g, "_");
	},

	getCsv (headers, rows) {
		function escapeCsv (str) {
			return `"${str.replace(/"/g, `""`).replace(/ +/g, " ").replace(/\n\n+/gi, "\n\n")}"`;
		}

		function toCsv (row) {
			return row.map(str => escapeCsv(str)).join(",");
		}

		return `${toCsv(headers)}\n${rows.map(r => toCsv(r)).join("\n")}`;
	},

	userDownload (filename, data, {fileType = null, isSkipAdditionalMetadata = false, propVersion = "siteVersion", valVersion = VERSION_NUMBER} = {}) {
		filename = `${filename}.json`;
		if (isSkipAdditionalMetadata || data instanceof Array) return DataUtil._userDownload(filename, JSON.stringify(data, null, "\t"), "text/json");

		data = {[propVersion]: valVersion, ...data};
		if (fileType != null) data = {fileType, ...data};
		return DataUtil._userDownload(filename, JSON.stringify(data, null, "\t"), "text/json");
	},

	userDownloadText (filename, string) {
		return DataUtil._userDownload(filename, string, "text/plain");
	},

	_userDownload (filename, data, mimeType) {
		const a = document.createElement("a");
		const t = new Blob([data], {type: mimeType});
		a.href = window.URL.createObjectURL(t);
		a.download = filename;
		a.dispatchEvent(new MouseEvent("click", {bubbles: true, cancelable: true, view: window}));
		setTimeout(() => window.URL.revokeObjectURL(a.href), 100);
	},

	/** Always returns an array of files, even in "single" mode. */
	pUserUpload (
		{
			isMultiple = false,
			expectedFileTypes = null,
			propVersion = "siteVersion",
		} = {},
	) {
		return new Promise(resolve => {
			const $iptAdd = $(`<input type="file" ${isMultiple ? "multiple" : ""} class="ve-hidden" accept=".json">`)
				.on("change", (evt) => {
					const input = evt.target;

					const reader = new FileReader();
					let readIndex = 0;
					const out = [];
					const errs = [];

					reader.onload = async () => {
						const name = input.files[readIndex - 1].name;
						const text = reader.result;

						try {
							const json = JSON.parse(text);

							const isSkipFile = expectedFileTypes != null
								&& json.fileType
								&& !expectedFileTypes.includes(json.fileType)
								&& !(await InputUiUtil.pGetUserBoolean({
									textYes: "Yes",
									textNo: "Cancel",
									title: "File Type Mismatch",
									htmlDescription: `The file "${name}" has the type "${json.fileType}" when the expected file type was "${expectedFileTypes.join("/")}".<br>Are you sure you want to upload this file?`,
								}));

							if (!isSkipFile) {
								delete json.fileType;
								delete json[propVersion];

								out.push({name, json});
							}
						} catch (e) {
							errs.push({filename: name, message: e.message});
						}

						if (input.files[readIndex]) {
							reader.readAsText(input.files[readIndex++]);
							return;
						}

						resolve({
							files: out,
							errors: errs,
							jsons: out.map(({json}) => json),
						});
					};

					reader.readAsText(input.files[readIndex++]);
				})
				.appendTo(document.body);

			$iptAdd.click();
		});
	},

	doHandleFileLoadErrorsGeneric (errors) {
		if (!errors) return;
		errors.forEach(err => {
			JqueryUtil.doToast({
				content: `Could not load file "${err.filename}": <code>${err.message}</code>. ${VeCt.STR_SEE_CONSOLE}`,
				type: "danger",
			});
		});
	},

	cleanJson (cpy, {isDeleteUniqueId = true} = {}) {
		if (!cpy) return cpy;
		cpy.name = cpy._displayName || cpy.name;
		if (isDeleteUniqueId) delete cpy.uniqueId;
		DataUtil.__cleanJsonObject(cpy);
		return cpy;
	},

	_CLEAN_JSON_ALLOWED_UNDER_KEYS: [
		"_copy",
		"_versions",
		"_version",
	],
	__cleanJsonObject (obj) {
		if (obj == null) return obj;
		if (typeof obj !== "object") return obj;

		if (obj instanceof Array) {
			return obj.forEach(it => DataUtil.__cleanJsonObject(it));
		}

		Object.entries(obj).forEach(([k, v]) => {
			if (DataUtil._CLEAN_JSON_ALLOWED_UNDER_KEYS.includes(k)) return;
			// TODO(Future) use "__" prefix for temp data, instead of "_"
			if ((k.startsWith("_") && k !== "_") || k === "customHashId") delete obj[k];
			else DataUtil.__cleanJsonObject(v);
		});
	},

	_MULTI_SOURCE_PROP_TO_DIR: {
		"monster": "bestiary",
		"monsterFluff": "bestiary",
		"spell": "spells",
		"spellFluff": "spells",
		"class": "class",
		"subclass": "class",
		"classFeature": "class",
		"subclassFeature": "class",
	},
	_MULTI_SOURCE_PROP_TO_INDEX_NAME: {
		"class": "index.json",
		"subclass": "index.json",
		"classFeature": "index.json",
		"subclassFeature": "index.json",
	},
	async pLoadByMeta (prop, source) {
		// TODO(future) expand support

		switch (prop) {
			// region Predefined multi-source
			case "monster":
			case "spell":
			case "monsterFluff":
			case "spellFluff": {
				const data = await DataUtil[prop].pLoadSingleSource(source);
				if (data) return data;

				return DataUtil._pLoadByMeta_pGetPrereleaseBrewUrl(source);
			}
			// endregion

			// region Multi-source
			case "class":
			case "subclass":
			case "classFeature":
			case "subclassFeature": {
				const baseUrlPart = `${Renderer.get().baseUrl}data/${DataUtil._MULTI_SOURCE_PROP_TO_DIR[prop]}`;
				const index = await DataUtil.loadJSON(`${baseUrlPart}/${DataUtil._MULTI_SOURCE_PROP_TO_INDEX_NAME[prop]}`);
				if (index[source]) return DataUtil.loadJSON(`${baseUrlPart}/${index[source]}`);

				return DataUtil._pLoadByMeta_pGetPrereleaseBrewUrl(source);
			}
			// endregion

			// region Special
			case "item":
			case "itemGroup": {
				const data = await DataUtil.item.loadRawJSON();
				if (data[prop] && data[prop].some(it => it.source === source)) return data;
				return DataUtil._pLoadByMeta_pGetPrereleaseBrewUrl(source);
			}
			case "race": {
				const data = await DataUtil.race.loadJSON({isAddBaseRaces: true});
				if (data[prop] && data[prop].some(it => it.source === source)) return data;
				return DataUtil._pLoadByMeta_pGetPrereleaseBrewUrl(source);
			}
			// endregion

			// region Standard
			default: {
				const impl = DataUtil[prop];
				if (impl && (impl.getDataUrl || impl.loadJSON)) {
					const data = await (impl.loadJSON ? impl.loadJSON() : DataUtil.loadJSON(impl.getDataUrl()));
					if (data[prop] && data[prop].some(it => it.source === source)) return data;

					return DataUtil._pLoadByMeta_pGetPrereleaseBrewUrl(source);
				}

				throw new Error(`Could not get loadable URL for \`${JSON.stringify({key: prop, value: source})}\``);
			}
			// endregion
		}
	},

	async _pLoadByMeta_pGetPrereleaseBrewUrl (source) {
		const fromPrerelease = await DataUtil.pLoadPrereleaseBySource(source);
		if (fromPrerelease) return fromPrerelease;

		const fromBrew = await DataUtil.pLoadBrewBySource(source);
		if (fromBrew) return fromBrew;

		throw new Error(`Could not find prerelease/brew URL for source "${source}"`);
	},

	async pLoadPrereleaseBySource (source) {
		if (typeof PrereleaseUtil === "undefined") return null;
		const url = await PrereleaseUtil.pGetSourceUrl(source);
		if (!url) return null;
		return DataUtil.loadJSON(url);
	},

	async pLoadBrewBySource (source) {
		if (typeof BrewUtil2 === "undefined") return null;
		const url = await BrewUtil2.pGetSourceUrl(source);
		if (!url) return null;
		return DataUtil.loadJSON(url);
	},

	// region Dbg
	dbg: {
		isTrackCopied: false,
	},
	// endregion

	generic: {
		_MERGE_REQUIRES_PRESERVE_BASE: {
			page: true,
			otherSources: true,
			srd: true,
			basicRules: true,
			reprintedAs: true,
			hasFluff: true,
			hasFluffImages: true,
			hasToken: true,
			_versions: true,
		},

		_walker_replaceTxt: null,

		/**
		 * @param uid
		 * @param tag
		 * @param [opts]
		 * @param [opts.isLower] If the returned values should be lowercase.
		 */
		unpackUid (uid, tag, opts) {
			opts = opts || {};
			if (opts.isLower) uid = uid.toLowerCase();
			let [name, source, displayText, ...others] = uid.split("|").map(it => it.trim());

			source = source || Parser.getTagSource(tag, source);
			if (opts.isLower) source = source.toLowerCase();

			return {
				name,
				source,
				displayText,
				others,
			};
		},

		packUid (ent, tag) {
			// <name>|<source>
			const sourceDefault = Parser.getTagSource(tag);
			return [
				ent.name,
				(ent.source || "").toLowerCase() === sourceDefault.toLowerCase() ? "" : ent.source,
			].join("|").replace(/\|+$/, ""); // Trim trailing pipes
		},

		getNormalizedUid (uid, tag) {
			const {name, source} = DataUtil.generic.unpackUid(uid, tag, {isLower: true});
			return [name, source].join("|");
		},

		getUid (ent, {isMaintainCase = false} = {}) {
			const {name} = ent;
			const source = SourceUtil.getEntitySource(ent);
			if (!name || !source) throw new Error(`Entity did not have a name and source!`);
			const out = [name, source].join("|");
			if (isMaintainCase) return out;
			return out.toLowerCase();
		},

		async _pMergeCopy (impl, page, entryList, entry, options) {
			if (!entry._copy) return;

			const hashCurrent = UrlUtil.URL_TO_HASH_BUILDER[page](entry);
			const hash = UrlUtil.URL_TO_HASH_BUILDER[page](entry._copy);

			if (hashCurrent === hash) throw new Error(`${hashCurrent} _copy self-references! This is a bug!`);

			const it = (impl._mergeCache = impl._mergeCache || {})[hash] || DataUtil.generic._pMergeCopy_search(impl, page, entryList, entry, options);

			if (!it) {
				if (options.isErrorOnMissing) {
					// In development/script mode, throw an exception
					if (!IS_DEPLOYED && !IS_VTT) throw new Error(`Could not find "${page}" entity "${entry._copy.name}" ("${entry._copy.source}") to copy in copier "${entry.name}" ("${entry.source}")`);
				}
				return;
			}

			if (DataUtil.dbg.isTrackCopied) it.dbg_isCopied = true;
			// Handle recursive copy
			if (it._copy) await DataUtil.generic._pMergeCopy(impl, page, entryList, it, options);

			// Preload traits, if required
			const traitData = entry._copy?._trait
				? (await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/bestiary/traits.json`))
				: null;
			return DataUtil.generic._applyCopy(impl, MiscUtil.copyFast(it), entry, traitData, options);
		},

		_pMergeCopy_search (impl, page, entryList, entry, options) {
			const entryHash = UrlUtil.URL_TO_HASH_BUILDER[page](entry._copy);
			return entryList.find(it => {
				const hash = UrlUtil.URL_TO_HASH_BUILDER[page](it);
				impl._mergeCache[hash] = it;
				return hash === entryHash;
			});
		},

		COPY_ENTRY_PROPS: [
			"action", "bonus", "reaction", "trait", "legendary", "mythic", "variant", "spellcasting",
			"actionHeader", "bonusHeader", "reactionHeader", "legendaryHeader", "mythicHeader",
		],
		_applyCopy (impl, copyFrom, copyTo, traitData, options = {}) {
			if (options.doKeepCopy) copyTo.__copy = MiscUtil.copyFast(copyFrom);

			// convert everything to arrays
			function normaliseMods (obj) {
				Object.entries(obj._mod).forEach(([k, v]) => {
					if (!(v instanceof Array)) obj._mod[k] = [v];
				});
			}

			const msgPtFailed = `Failed to apply _copy to "${copyTo.name}" ("${copyTo.source}").`;

			const copyMeta = copyTo._copy || {};

			if (copyMeta._mod) normaliseMods(copyMeta);

			// fetch and apply any external traits -- append them to existing copy mods where available
			let racials = null;
			if (copyMeta._trait) {
				racials = traitData.trait.find(t => t.name.toLowerCase() === copyMeta._trait.name.toLowerCase() && t.source.toLowerCase() === copyMeta._trait.source.toLowerCase());
				if (!racials) throw new Error(`${msgPtFailed} Could not find traits to apply with name "${copyMeta._trait.name}" and source "${copyMeta._trait.source}"`);
				racials = MiscUtil.copyFast(racials);

				if (racials.apply._mod) {
					normaliseMods(racials.apply);

					if (copyMeta._mod) {
						Object.entries(racials.apply._mod).forEach(([k, v]) => {
							if (copyMeta._mod[k]) copyMeta._mod[k] = copyMeta._mod[k].concat(v);
							else copyMeta._mod[k] = v;
						});
					} else copyMeta._mod = racials.apply._mod;
				}

				delete copyMeta._trait;
			}

			const copyToRootProps = new Set(Object.keys(copyTo));

			// copy over required values
			Object.keys(copyFrom).forEach(k => {
				if (copyTo[k] === null) return delete copyTo[k];
				if (copyTo[k] == null) {
					if (DataUtil.generic._MERGE_REQUIRES_PRESERVE_BASE[k] || impl?._MERGE_REQUIRES_PRESERVE[k]) {
						if (copyTo._copy._preserve?.["*"] || copyTo._copy._preserve?.[k]) copyTo[k] = copyFrom[k];
					} else copyTo[k] = copyFrom[k];
				}
			});

			// apply any root racial properties after doing base copy
			if (racials && racials.apply._root) {
				Object.entries(racials.apply._root)
					.filter(([k, v]) => !copyToRootProps.has(k)) // avoid overwriting any real root properties
					.forEach(([k, v]) => copyTo[k] = v);
			}

			// mod helpers /////////////////
			function doEnsureArray (obj, prop) {
				if (!(obj[prop] instanceof Array)) obj[prop] = [obj[prop]];
			}

			function getRegexFromReplaceModInfo (replace, flags) {
				return new RegExp(replace, `g${flags || ""}`);
			}

			function doReplaceStringHandler (re, withStr, str) {
				// TODO(Future) may need to have this handle replaces inside _some_ tags
				const split = Renderer.splitByTags(str);
				const len = split.length;
				for (let i = 0; i < len; ++i) {
					if (split[i].startsWith("{@")) continue;
					split[i] = split[i].replace(re, withStr);
				}
				return split.join("");
			}

			function doMod_appendStr (modInfo, prop) {
				if (copyTo[prop]) copyTo[prop] = `${copyTo[prop]}${modInfo.joiner || ""}${modInfo.str}`;
				else copyTo[prop] = modInfo.str;
			}

			function doMod_replaceName (modInfo, prop) {
				if (!copyTo[prop]) return;

				DataUtil.generic._walker_replaceTxt = DataUtil.generic._walker_replaceTxt || MiscUtil.getWalker();
				const re = getRegexFromReplaceModInfo(modInfo.replace, modInfo.flags);
				const handlers = {string: doReplaceStringHandler.bind(null, re, modInfo.with)};

				copyTo[prop].forEach(it => {
					if (it.name) it.name = DataUtil.generic._walker_replaceTxt.walk(it.name, handlers);
				});
			}

			function doMod_replaceTxt (modInfo, prop) {
				if (!copyTo[prop]) return;

				DataUtil.generic._walker_replaceTxt = DataUtil.generic._walker_replaceTxt || MiscUtil.getWalker();
				const re = getRegexFromReplaceModInfo(modInfo.replace, modInfo.flags);
				const handlers = {string: doReplaceStringHandler.bind(null, re, modInfo.with)};

				const props = modInfo.props || [null, "entries", "headerEntries", "footerEntries"];
				if (!props.length) return;

				if (props.includes(null)) {
					// Handle any pure strings, e.g. `"legendaryHeader"`
					copyTo[prop] = copyTo[prop].map(it => {
						if (typeof it !== "string") return it;
						return DataUtil.generic._walker_replaceTxt.walk(it, handlers);
					});
				}

				copyTo[prop].forEach(it => {
					props.forEach(prop => {
						if (prop == null) return;
						if (it[prop]) it[prop] = DataUtil.generic._walker_replaceTxt.walk(it[prop], handlers);
					});
				});
			}

			function doMod_prependArr (modInfo, prop) {
				doEnsureArray(modInfo, "items");
				copyTo[prop] = copyTo[prop] ? modInfo.items.concat(copyTo[prop]) : modInfo.items;
			}

			function doMod_appendArr (modInfo, prop) {
				doEnsureArray(modInfo, "items");
				copyTo[prop] = copyTo[prop] ? copyTo[prop].concat(modInfo.items) : modInfo.items;
			}

			function doMod_appendIfNotExistsArr (modInfo, prop) {
				doEnsureArray(modInfo, "items");
				if (!copyTo[prop]) return copyTo[prop] = modInfo.items;
				copyTo[prop] = copyTo[prop].concat(modInfo.items.filter(it => !copyTo[prop].some(x => CollectionUtil.deepEquals(it, x))));
			}

			function doMod_replaceArr (modInfo, prop, isThrow = true) {
				doEnsureArray(modInfo, "items");

				if (!copyTo[prop]) {
					if (isThrow) throw new Error(`${msgPtFailed} Could not find "${prop}" array`);
					return false;
				}

				let ixOld;
				if (modInfo.replace.regex) {
					const re = new RegExp(modInfo.replace.regex, modInfo.replace.flags || "");
					ixOld = copyTo[prop].findIndex(it => it.name ? re.test(it.name) : typeof it === "string" ? re.test(it) : false);
				} else if (modInfo.replace.index != null) {
					ixOld = modInfo.replace.index;
				} else {
					ixOld = copyTo[prop].findIndex(it => it.name ? it.name === modInfo.replace : it === modInfo.replace);
				}

				if (~ixOld) {
					copyTo[prop].splice(ixOld, 1, ...modInfo.items);
					return true;
				} else if (isThrow) throw new Error(`${msgPtFailed} Could not find "${prop}" item with name "${modInfo.replace}" to replace`);
				return false;
			}

			function doMod_replaceOrAppendArr (modInfo, prop) {
				const didReplace = doMod_replaceArr(modInfo, prop, false);
				if (!didReplace) doMod_appendArr(modInfo, prop);
			}

			function doMod_insertArr (modInfo, prop) {
				doEnsureArray(modInfo, "items");
				if (!copyTo[prop]) throw new Error(`${msgPtFailed} Could not find "${prop}" array`);
				copyTo[prop].splice(~modInfo.index ? modInfo.index : copyTo[prop].length, 0, ...modInfo.items);
			}

			function doMod_removeArr (modInfo, prop) {
				if (modInfo.names) {
					doEnsureArray(modInfo, "names");
					modInfo.names.forEach(nameToRemove => {
						const ixOld = copyTo[prop].findIndex(it => it.name === nameToRemove);
						if (~ixOld) copyTo[prop].splice(ixOld, 1);
						else {
							if (!modInfo.force) throw new Error(`${msgPtFailed} Could not find "${prop}" item with name "${nameToRemove}" to remove`);
						}
					});
				} else if (modInfo.items) {
					doEnsureArray(modInfo, "items");
					modInfo.items.forEach(itemToRemove => {
						const ixOld = copyTo[prop].findIndex(it => it === itemToRemove);
						if (~ixOld) copyTo[prop].splice(ixOld, 1);
						else throw new Error(`${msgPtFailed} Could not find "${prop}" item "${itemToRemove}" to remove`);
					});
				} else throw new Error(`${msgPtFailed} One of "names" or "items" must be provided!`);
			}

			function doMod_calculateProp (modInfo, prop) {
				copyTo[prop] = copyTo[prop] || {};
				const toExec = modInfo.formula.replace(/<\$([^$]+)\$>/g, (...m) => {
					switch (m[1]) {
						case "prof_bonus": return Parser.crToPb(copyTo.cr);
						case "dex_mod": return Parser.getAbilityModNumber(copyTo.dex);
						default: throw new Error(`${msgPtFailed} Unknown variable "${m[1]}"`);
					}
				});
				// eslint-disable-next-line no-eval
				copyTo[prop][modInfo.prop] = eval(toExec);
			}

			function doMod_scalarAddProp (modInfo, prop) {
				function applyTo (k) {
					const out = Number(copyTo[prop][k]) + modInfo.scalar;
					const isString = typeof copyTo[prop][k] === "string";
					copyTo[prop][k] = isString ? `${out >= 0 ? "+" : ""}${out}` : out;
				}

				if (!copyTo[prop]) return;
				if (modInfo.prop === "*") Object.keys(copyTo[prop]).forEach(k => applyTo(k));
				else applyTo(modInfo.prop);
			}

			function doMod_scalarMultProp (modInfo, prop) {
				function applyTo (k) {
					let out = Number(copyTo[prop][k]) * modInfo.scalar;
					if (modInfo.floor) out = Math.floor(out);
					const isString = typeof copyTo[prop][k] === "string";
					copyTo[prop][k] = isString ? `${out >= 0 ? "+" : ""}${out}` : out;
				}

				if (!copyTo[prop]) return;
				if (modInfo.prop === "*") Object.keys(copyTo[prop]).forEach(k => applyTo(k));
				else applyTo(modInfo.prop);
			}

			function doMod_addSenses (modInfo) {
				doEnsureArray(modInfo, "senses");
				copyTo.senses = copyTo.senses || [];
				modInfo.senses.forEach(sense => {
					let found = false;
					for (let i = 0; i < copyTo.senses.length; ++i) {
						const m = new RegExp(`${sense.type} (\\d+)`, "i").exec(copyTo.senses[i]);
						if (m) {
							found = true;
							// if the creature already has a greater sense of this type, do nothing
							if (Number(m[1]) < sense.range) {
								copyTo.senses[i] = `${sense.type} ${sense.range} ft.`;
							}
							break;
						}
					}

					if (!found) copyTo.senses.push(`${sense.type} ${sense.range} ft.`);
				});
			}

			function doMod_addSaves (modInfo) {
				copyTo.save = copyTo.save || {};
				Object.entries(modInfo.saves).forEach(([save, mode]) => {
					// mode: 1 = proficient; 2 = expert
					const total = mode * Parser.crToPb(copyTo.cr) + Parser.getAbilityModNumber(copyTo[save]);
					const asText = total >= 0 ? `+${total}` : total;
					if (copyTo.save && copyTo.save[save]) {
						// update only if ours is larger (prevent reduction in save)
						if (Number(copyTo.save[save]) < total) copyTo.save[save] = asText;
					} else copyTo.save[save] = asText;
				});
			}

			function doMod_addSkills (modInfo) {
				copyTo.skill = copyTo.skill || {};
				Object.entries(modInfo.skills).forEach(([skill, mode]) => {
					// mode: 1 = proficient; 2 = expert
					const total = mode * Parser.crToPb(copyTo.cr) + Parser.getAbilityModNumber(copyTo[Parser.skillToAbilityAbv(skill)]);
					const asText = total >= 0 ? `+${total}` : total;
					if (copyTo.skill && copyTo.skill[skill]) {
						// update only if ours is larger (prevent reduction in skill score)
						if (Number(copyTo.skill[skill]) < total) copyTo.skill[skill] = asText;
					} else copyTo.skill[skill] = asText;
				});
			}

			function doMod_addAllSaves (modInfo) {
				return doMod_addSaves({
					mode: "addSaves",
					saves: Object.keys(Parser.ATB_ABV_TO_FULL).mergeMap(it => ({[it]: modInfo.saves})),
				});
			}

			function doMod_addAllSkills (modInfo) {
				return doMod_addSkills({
					mode: "addSkills",
					skills: Object.keys(Parser.SKILL_TO_ATB_ABV).mergeMap(it => ({[it]: modInfo.skills})),
				});
			}

			function doMod_addSpells (modInfo) {
				if (!copyTo.spellcasting) throw new Error(`${msgPtFailed} Creature did not have a spellcasting property!`);

				// TODO could accept a "position" or "name" parameter should spells need to be added to other spellcasting traits
				const spellcasting = copyTo.spellcasting[0];

				if (modInfo.spells) {
					const spells = spellcasting.spells;

					Object.keys(modInfo.spells).forEach(k => {
						if (!spells[k]) spells[k] = modInfo.spells[k];
						else {
							// merge the objects
							const spellCategoryNu = modInfo.spells[k];
							const spellCategoryOld = spells[k];
							Object.keys(spellCategoryNu).forEach(kk => {
								if (!spellCategoryOld[kk]) spellCategoryOld[kk] = spellCategoryNu[kk];
								else {
									if (typeof spellCategoryOld[kk] === "object") {
										if (spellCategoryOld[kk] instanceof Array) spellCategoryOld[kk] = spellCategoryOld[kk].concat(spellCategoryNu[kk]).sort(SortUtil.ascSortLower);
										else throw new Error(`${msgPtFailed} Object at key ${kk} not an array!`);
									} else spellCategoryOld[kk] = spellCategoryNu[kk];
								}
							});
						}
					});
				}

				["constant", "will", "ritual"].forEach(prop => {
					if (!modInfo[prop]) return;
					modInfo[prop].forEach(sp => (spellcasting[prop] = spellcasting[prop] || []).push(sp));
				});

				["rest", "daily", "weekly", "yearly"].forEach(prop => {
					if (!modInfo[prop]) return;

					for (let i = 1; i <= 9; ++i) {
						const e = `${i}e`;

						spellcasting[prop] = spellcasting[prop] || {};

						if (modInfo[prop][i]) {
							modInfo[prop][i].forEach(sp => (spellcasting[prop][i] = spellcasting[prop][i] || []).push(sp));
						}

						if (modInfo[prop][e]) {
							modInfo[prop][e].forEach(sp => (spellcasting[prop][e] = spellcasting[prop][e] || []).push(sp));
						}
					}
				});
			}

			function doMod_replaceSpells (modInfo) {
				if (!copyTo.spellcasting) throw new Error(`${msgPtFailed} Creature did not have a spellcasting property!`);

				// TODO could accept a "position" or "name" parameter should spells need to be added to other spellcasting traits
				const spellcasting = copyTo.spellcasting[0];

				const handleReplace = (curSpells, replaceMeta, k) => {
					doEnsureArray(replaceMeta, "with");

					const ix = curSpells[k].indexOf(replaceMeta.replace);
					if (~ix) {
						curSpells[k].splice(ix, 1, ...replaceMeta.with);
						curSpells[k].sort(SortUtil.ascSortLower);
					} else throw new Error(`${msgPtFailed} Could not find spell "${replaceMeta.replace}" to replace`);
				};

				if (modInfo.spells) {
					const trait0 = spellcasting.spells;
					Object.keys(modInfo.spells).forEach(k => { // k is e.g. "4"
						if (trait0[k]) {
							const replaceMetas = modInfo.spells[k];
							const curSpells = trait0[k];
							replaceMetas.forEach(replaceMeta => handleReplace(curSpells, replaceMeta, "spells"));
						}
					});
				}

				// TODO should be extended  to handle all non-slot-based spellcasters
				if (modInfo.daily) {
					for (let i = 1; i <= 9; ++i) {
						const e = `${i}e`;

						if (modInfo.daily[i]) {
							modInfo.daily[i].forEach(replaceMeta => handleReplace(spellcasting.daily, replaceMeta, i));
						}

						if (modInfo.daily[e]) {
							modInfo.daily[e].forEach(replaceMeta => handleReplace(spellcasting.daily, replaceMeta, e));
						}
					}
				}
			}

			function doMod_removeSpells (modInfo) {
				if (!copyTo.spellcasting) throw new Error(`${msgPtFailed} Creature did not have a spellcasting property!`);

				// TODO could accept a "position" or "name" parameter should spells need to be added to other spellcasting traits
				const spellcasting = copyTo.spellcasting[0];

				if (modInfo.spells) {
					const spells = spellcasting.spells;

					Object.keys(modInfo.spells).forEach(k => {
						if (!spells[k]?.spells) return;

						spells[k].spells = spells[k].spells.filter(it => !modInfo.spells[k].includes(it));
					});
				}

				["constant", "will", "ritual"].forEach(prop => {
					if (!modInfo[prop]) return;
					spellcasting[prop].filter(it => !modInfo[prop].includes(it));
				});

				["rest", "daily", "weekly", "yearly"].forEach(prop => {
					if (!modInfo[prop]) return;

					for (let i = 1; i <= 9; ++i) {
						const e = `${i}e`;

						spellcasting[prop] = spellcasting[prop] || {};

						if (modInfo[prop][i]) {
							spellcasting[prop][i] = spellcasting[prop][i].filter(it => !modInfo[prop][i].includes(it));
						}

						if (modInfo[prop][e]) {
							spellcasting[prop][e] = spellcasting[prop][e].filter(it => !modInfo[prop][e].includes(it));
						}
					}
				});
			}

			function doMod_scalarAddHit (modInfo, prop) {
				if (!copyTo[prop]) return;
				copyTo[prop] = JSON.parse(JSON.stringify(copyTo[prop]).replace(/{@hit ([-+]?\d+)}/g, (m0, m1) => `{@hit ${Number(m1) + modInfo.scalar}}`));
			}

			function doMod_scalarAddDc (modInfo, prop) {
				if (!copyTo[prop]) return;
				copyTo[prop] = JSON.parse(JSON.stringify(copyTo[prop]).replace(/{@dc (\d+)(?:\|[^}]+)?}/g, (m0, m1) => `{@dc ${Number(m1) + modInfo.scalar}}`));
			}

			function doMod_maxSize (modInfo) {
				const sizes = [...copyTo.size].sort(SortUtil.ascSortSize);

				const ixsCur = sizes.map(it => Parser.SIZE_ABVS.indexOf(it));
				const ixMax = Parser.SIZE_ABVS.indexOf(modInfo.max);

				if (!~ixMax || ixsCur.some(ix => !~ix)) throw new Error(`${msgPtFailed} Unhandled size!`);

				const ixsNxt = ixsCur.filter(ix => ix <= ixMax);
				if (!ixsNxt.length) ixsNxt.push(ixMax);

				copyTo.size = ixsNxt.map(ix => Parser.SIZE_ABVS[ix]);
			}

			function doMod_scalarMultXp (modInfo) {
				function getOutput (input) {
					let out = input * modInfo.scalar;
					if (modInfo.floor) out = Math.floor(out);
					return out;
				}

				if (copyTo.cr.xp) copyTo.cr.xp = getOutput(copyTo.cr.xp);
				else {
					const curXp = Parser.crToXpNumber(copyTo.cr);
					if (!copyTo.cr.cr) copyTo.cr = {cr: copyTo.cr};
					copyTo.cr.xp = getOutput(curXp);
				}
			}

			function doMod (modInfos, ...properties) {
				function handleProp (prop) {
					modInfos.forEach(modInfo => {
						if (typeof modInfo === "string") {
							switch (modInfo) {
								case "remove": return delete copyTo[prop];
								default: throw new Error(`${msgPtFailed} Unhandled mode: ${modInfo}`);
							}
						} else {
							switch (modInfo.mode) {
								case "appendStr": return doMod_appendStr(modInfo, prop);
								case "replaceName": return doMod_replaceName(modInfo, prop);
								case "replaceTxt": return doMod_replaceTxt(modInfo, prop);
								case "prependArr": return doMod_prependArr(modInfo, prop);
								case "appendArr": return doMod_appendArr(modInfo, prop);
								case "replaceArr": return doMod_replaceArr(modInfo, prop);
								case "replaceOrAppendArr": return doMod_replaceOrAppendArr(modInfo, prop);
								case "appendIfNotExistsArr": return doMod_appendIfNotExistsArr(modInfo, prop);
								case "insertArr": return doMod_insertArr(modInfo, prop);
								case "removeArr": return doMod_removeArr(modInfo, prop);
								case "calculateProp": return doMod_calculateProp(modInfo, prop);
								case "scalarAddProp": return doMod_scalarAddProp(modInfo, prop);
								case "scalarMultProp": return doMod_scalarMultProp(modInfo, prop);
								// region Bestiary specific
								case "addSenses": return doMod_addSenses(modInfo);
								case "addSaves": return doMod_addSaves(modInfo);
								case "addSkills": return doMod_addSkills(modInfo);
								case "addAllSaves": return doMod_addAllSaves(modInfo);
								case "addAllSkills": return doMod_addAllSkills(modInfo);
								case "addSpells": return doMod_addSpells(modInfo);
								case "replaceSpells": return doMod_replaceSpells(modInfo);
								case "removeSpells": return doMod_removeSpells(modInfo);
								case "scalarAddHit": return doMod_scalarAddHit(modInfo, prop);
								case "scalarAddDc": return doMod_scalarAddDc(modInfo, prop);
								case "maxSize": return doMod_maxSize(modInfo);
								case "scalarMultXp": return doMod_scalarMultXp(modInfo);
								// endregion
								default: throw new Error(`${msgPtFailed} Unhandled mode: ${modInfo.mode}`);
							}
						}
					});
				}

				properties.forEach(prop => handleProp(prop));
				// special case for "no property" modifications, i.e. underscore-key'd
				if (!properties.length) handleProp();
			}

			// apply mods
			if (copyMeta._mod) {
				// pre-convert any dynamic text
				Object.entries(copyMeta._mod).forEach(([k, v]) => {
					copyMeta._mod[k] = DataUtil.generic.variableResolver.resolve({obj: v, ent: copyTo});
				});

				Object.entries(copyMeta._mod).forEach(([prop, modInfos]) => {
					if (prop === "*") doMod(modInfos, ...DataUtil.generic.COPY_ENTRY_PROPS);
					else if (prop === "_") doMod(modInfos);
					else doMod(modInfos, prop);
				});
			}

			// add filter tag
			copyTo._isCopy = true;

			// cleanup
			delete copyTo._copy;
		},

		variableResolver: class {
			static _getSize ({ent}) { return ent.size?.[0] || Parser.SZ_MEDIUM; }

			static _SIZE_TO_MULT = {
				[Parser.SZ_LARGE]: 2,
				[Parser.SZ_HUGE]: 3,
				[Parser.SZ_GARGANTUAN]: 4,
			};

			static _getSizeMult (size) { return this._SIZE_TO_MULT[size] ?? 1; }

			static _getCleanMathExpression (str) { return str.replace(/[^-+/*0-9.,]+/g, ""); }

			static resolve ({obj, ent, msgPtFailed = null}) {
				return JSON.parse(
					JSON.stringify(obj)
						.replace(/<\$(?<variable>[^$]+)\$>/g, (...m) => {
							const [mode, detail] = m.last().variable.split("__");

							switch (mode) {
								case "name": return ent.name;
								case "short_name":
								case "title_short_name": {
									return Renderer.monster.getShortName(ent, {isTitleCase: mode === "title_short_name"});
								}

								case "dc":
								case "spell_dc": {
									if (!Parser.ABIL_ABVS.includes(detail)) throw new Error(`${msgPtFailed ? `${msgPtFailed} ` : ""} Unknown ability score "${detail}"`);
									return 8 + Parser.getAbilityModNumber(Number(ent[detail])) + Parser.crToPb(ent.cr);
								}

								case "to_hit": {
									if (!Parser.ABIL_ABVS.includes(detail)) throw new Error(`${msgPtFailed ? `${msgPtFailed} ` : ""} Unknown ability score "${detail}"`);
									const total = Parser.crToPb(ent.cr) + Parser.getAbilityModNumber(Number(ent[detail]));
									return total >= 0 ? `+${total}` : total;
								}

								case "damage_mod": {
									if (!Parser.ABIL_ABVS.includes(detail)) throw new Error(`${msgPtFailed ? `${msgPtFailed} ` : ""} Unknown ability score "${detail}"`);
									const total = Parser.getAbilityModNumber(Number(ent[detail]));
									return total === 0 ? "" : total > 0 ? ` + ${total}` : ` - ${Math.abs(total)}`;
								}

								case "damage_avg": {
									const replaced = detail
										.replace(/\b(?<abil>str|dex|con|int|wis|cha)\b/gi, (...m) => Parser.getAbilityModNumber(Number(ent[m.last().abil])))
										.replace(/\bsize_mult\b/g, () => this._getSizeMult(this._getSize({ent})));

									// eslint-disable-next-line no-eval
									return Math.floor(eval(this._getCleanMathExpression(replaced)));
								}

								case "size_mult": {
									const mult = this._getSizeMult(this._getSize({ent}));

									if (!detail) return mult;

									// eslint-disable-next-line no-eval
									return Math.floor(eval(`${mult} * ${this._getCleanMathExpression(detail)}`));
								}

								default: return m[0];
							}
						}),
				);
			}
		},

		getVersions (parent) {
			if (!parent?._versions?.length) return [];

			return parent._versions
				.map(ver => {
					if (ver._template && ver._implementations?.length) return DataUtil.generic._getVersions_template({ver});
					return DataUtil.generic._getVersions_basic({ver});
				})
				.flat()
				.map(ver => DataUtil.generic._getVersion({parentEntity: parent, version: ver}));
		},

		_getVersions_template ({ver}) {
			return ver._implementations
				.map(impl => {
					let cpyTemplate = MiscUtil.copyFast(ver._template);
					const cpyImpl = MiscUtil.copyFast(impl);

					DataUtil.generic._getVersions_mutExpandCopy({ent: cpyTemplate});

					if (cpyImpl._variables) {
						cpyTemplate = MiscUtil.getWalker()
							.walk(
								cpyTemplate,
								{
									string: str => str.replace(/{{([^}]+)}}/g, (...m) => cpyImpl._variables[m[1]]),
								},
							);
						delete cpyImpl._variables;
					}

					Object.assign(cpyTemplate, cpyImpl);

					return cpyTemplate;
				});
		},

		_getVersions_basic ({ver}) {
			const cpyVer = MiscUtil.copyFast(ver);
			DataUtil.generic._getVersions_mutExpandCopy({ent: cpyVer});
			return cpyVer;
		},

		_getVersions_mutExpandCopy ({ent}) {
			// Tweak the data structure to match what `_applyCopy` expects
			ent._copy = {
				_mod: ent._mod,
				_preserve: {"*": true},
			};
			delete ent._mod;
		},

		_getVersion ({parentEntity, version}) {
			const additionalData = {
				_versionBase_isVersion: true,
				_versionBase_name: parentEntity.name,
				_versionBase_source: parentEntity.source,
				_versionBase_hasToken: parentEntity.hasToken,
				_versionBase_hasFluff: parentEntity.hasFluff,
				_versionBase_hasFluffImages: parentEntity.hasFluffImages,
			};
			const cpyParentEntity = MiscUtil.copyFast(parentEntity);

			delete cpyParentEntity._versions;
			delete cpyParentEntity.hasToken;
			delete cpyParentEntity.hasFluff;
			delete cpyParentEntity.hasFluffImages;

			DataUtil.generic._applyCopy(
				null,
				cpyParentEntity,
				version,
				null,
			);
			Object.assign(version, additionalData);
			return version;
		},
	},

	proxy: {
		getVersions (prop, ent) {
			if (DataUtil[prop]?.getVersions) return DataUtil[prop]?.getVersions(ent);
			return DataUtil.generic.getVersions(ent);
		},

		unpackUid (prop, uid, tag, opts) {
			if (DataUtil[prop]?.unpackUid) return DataUtil[prop]?.unpackUid(uid, tag, opts);
			return DataUtil.generic.unpackUid(uid, tag, opts);
		},

		getNormalizedUid (prop, uid, tag, opts) {
			if (DataUtil[prop]?.getNormalizedUid) return DataUtil[prop].getNormalizedUid(uid, tag, opts);
			return DataUtil.generic.getNormalizedUid(uid, tag, opts);
		},

		getUid (prop, ent, opts) {
			if (DataUtil[prop]?.getUid) return DataUtil[prop].getUid(ent, opts);
			return DataUtil.generic.getUid(ent, opts);
		},
	},

	monster: class extends _DataUtilPropConfigMultiSource {
		static _MERGE_REQUIRES_PRESERVE = {
			legendaryGroup: true,
			environment: true,
			soundClip: true,
			altArt: true,
			variant: true,
			dragonCastingColor: true,
			familiar: true,
		};

		static _PAGE = UrlUtil.PG_BESTIARY;

		static _DIR = "bestiary";
		static _PROP = "monster";

		static async loadJSON () {
			await DataUtil.monster.pPreloadMeta();
			return super.loadJSON();
		}

		static getVersions (mon) {
			const additionalVersionData = DataUtil.monster._getAdditionalVersionsData(mon);
			if (additionalVersionData.length) {
				mon = MiscUtil.copyFast(mon);
				(mon._versions = mon._versions || []).push(...additionalVersionData);
			}
			return DataUtil.generic.getVersions(mon);
		}

		static _getAdditionalVersionsData (mon) {
			if (!mon.variant?.length) return [];

			return mon.variant
				.filter(it => it._version)
				.map(it => {
					const toAdd = {
						name: it._version.name || it.name,
						source: it._version.source || it.source || mon.source,
						variant: null,
					};

					if (it._version.addAs) {
						const cpy = MiscUtil.copyFast(it);
						delete cpy._version;
						delete cpy.type;
						delete cpy.source;
						delete cpy.page;

						toAdd._mod = {
							[it._version.addAs]: {
								mode: "appendArr",
								items: cpy,
							},
						};

						return toAdd;
					}

					if (it._version.addHeadersAs) {
						const cpy = MiscUtil.copyFast(it);
						cpy.entries = cpy.entries.filter(it => it.name && it.entries);
						cpy.entries.forEach(cpyEnt => {
							delete cpyEnt.type;
							delete cpyEnt.source;
						});

						toAdd._mod = {
							[it._version.addHeadersAs]: {
								mode: "appendArr",
								items: cpy.entries,
							},
						};

						return toAdd;
					}
				})
				.filter(Boolean);
		}

		static async pPreloadMeta () {
			DataUtil.monster._pLoadMeta = DataUtil.monster._pLoadMeta || ((async () => {
				const legendaryGroups = await DataUtil.legendaryGroup.pLoadAll();
				DataUtil.monster.populateMetaReference({legendaryGroup: legendaryGroups});
			})());
			await DataUtil.monster._pLoadMeta;
		}

		static _pLoadMeta = null;
		static metaGroupMap = {};
		static getMetaGroup (mon) {
			if (!mon.legendaryGroup || !mon.legendaryGroup.source || !mon.legendaryGroup.name) return null;
			return (DataUtil.monster.metaGroupMap[mon.legendaryGroup.source] || {})[mon.legendaryGroup.name];
		}
		static populateMetaReference (data) {
			(data.legendaryGroup || []).forEach(it => {
				(DataUtil.monster.metaGroupMap[it.source] =
					DataUtil.monster.metaGroupMap[it.source] || {})[it.name] = it;
			});
		}
	},

	monsterFluff: class extends _DataUtilPropConfigMultiSource {
		static _PAGE = UrlUtil.PG_BESTIARY;
		static _DIR = "bestiary";
		static _PROP = "monsterFluff";
	},

	spell: class extends _DataUtilPropConfigMultiSource {
		static _PAGE = UrlUtil.PG_SPELLS;
		static _DIR = "spells";
		static _PROP = "spell";
		static _IS_MUT_ENTITIES = true;

		static _SPELL_SOURCE_LOOKUP = null;

		// region Utilities for external applications (i.e., the spell source generation script) to use
		static setSpellSourceLookup (lookup, {isExternalApplication = false} = {}) {
			if (!isExternalApplication) throw new Error("Should not be calling this!");
			this._SPELL_SOURCE_LOOKUP = MiscUtil.copyFast(lookup);
		}

		static mutEntity (sp, {isExternalApplication = false} = {}) {
			if (!isExternalApplication) throw new Error("Should not be calling this!");
			return this._mutEntity(sp);
		}

		static unmutEntity (sp, {isExternalApplication = false} = {}) {
			if (!isExternalApplication) throw new Error("Should not be calling this!");
			delete sp.classes;
			delete sp.races;
			delete sp.optionalfeatures;
			delete sp.backgrounds;
			delete sp.feats;
			delete sp.charoptions;
			delete sp.rewards;
			delete sp._isMutEntity;
		}
		// endregion

		static async _pInitPreData_ () {
			this._SPELL_SOURCE_LOOKUP = await DataUtil.loadRawJSON(`${Renderer.get().baseUrl}data/generated/gendata-spell-source-lookup.json`);
		}

		static _mutEntity (sp) {
			if (sp._isMutEntity) return sp;

			const spSources = this._SPELL_SOURCE_LOOKUP[sp.source.toLowerCase()]?.[sp.name.toLowerCase()];
			if (!spSources) return;

			this._mutSpell_class({sp, spSources, propSources: "class", propClasses: "fromClassList"});
			this._mutSpell_class({sp, spSources, propSources: "classVariant", propClasses: "fromClassListVariant"});
			this._mutSpell_subclass({sp, spSources});
			this._mutSpell_race({sp, spSources});
			this._mutSpell_optionalfeature({sp, spSources});
			this._mutSpell_background({sp, spSources});
			this._mutSpell_feat({sp, spSources});
			this._mutSpell_charoption({sp, spSources});
			this._mutSpell_reward({sp, spSources});

			sp._isMutEntity = true;

			return sp;
		}

		static _mutSpell_class ({sp, spSources, propSources, propClasses}) {
			if (!spSources[propSources]) return;

			Object.entries(spSources[propSources])
				.forEach(([source, nameTo]) => {
					const tgt = MiscUtil.getOrSet(sp, "classes", propClasses, []);

					Object.entries(nameTo)
						.forEach(([name, val]) => {
							if (tgt.some(it => it.name === nameTo && it.source === source)) return;

							const toAdd = {name, source};
							if (val === true) return tgt.push(toAdd);

							if (val.definedInSource) {
								toAdd.definedInSource = val.definedInSource;
								tgt.push(toAdd);
								return;
							}

							if (val.definedInSources) {
								val.definedInSources
									.forEach(definedInSource => {
										const cpyToAdd = MiscUtil.copyFast(toAdd);

										if (definedInSource == null) {
											return tgt.push(cpyToAdd);
										}

										cpyToAdd.definedInSource = definedInSource;
										tgt.push(cpyToAdd);
									});

								return;
							}

							throw new Error("Unimplemented!");
						});
				});
		}

		static _mutSpell_subclass ({sp, spSources}) {
			if (!spSources.subclass) return;

			Object.entries(spSources.subclass)
				.forEach(([classSource, classNameTo]) => {
					Object.entries(classNameTo)
						.forEach(([className, sourceTo]) => {
							Object.entries(sourceTo)
								.forEach(([source, nameTo]) => {
									const tgt = MiscUtil.getOrSet(sp, "classes", "fromSubclass", []);

									Object.entries(nameTo)
										.forEach(([name, val]) => {
											if (val === true) throw new Error("Unimplemented!");

											if (tgt.some(it => it.class.name === className && it.class.source === classSource && it.subclass.name === name && it.subclass.source === source && ((it.subclass.subSubclass == null && val.subSubclasses == null) || val.subSubclasses.includes(it.subclass.subSubclass)))) return;

											const toAdd = {
												class: {
													name: className,
													source: classSource,
												},
												subclass: {
													name: val.name,
													shortName: name,
													source,
												},
											};

											if (!val.subSubclasses?.length) return tgt.push(toAdd);

											val.subSubclasses
												.forEach(subSubclass => {
													const cpyToAdd = MiscUtil.copyFast(toAdd);
													cpyToAdd.subclass.subSubclass = subSubclass;
													tgt.push(cpyToAdd);
												});
										});
								});
						});
				});
		}

		static _mutSpell_race ({sp, spSources}) {
			this._mutSpell_generic({sp, spSources, propSources: "race", propSpell: "races"});
		}

		static _mutSpell_optionalfeature ({sp, spSources}) {
			this._mutSpell_generic({sp, spSources, propSources: "optionalfeature", propSpell: "optionalfeatures"});
		}

		static _mutSpell_background ({sp, spSources}) {
			this._mutSpell_generic({sp, spSources, propSources: "background", propSpell: "backgrounds"});
		}

		static _mutSpell_feat ({sp, spSources}) {
			this._mutSpell_generic({sp, spSources, propSources: "feat", propSpell: "feats"});
		}

		static _mutSpell_charoption ({sp, spSources}) {
			this._mutSpell_generic({sp, spSources, propSources: "charoption", propSpell: "charoptions"});
		}

		static _mutSpell_reward ({sp, spSources}) {
			this._mutSpell_generic({sp, spSources, propSources: "reward", propSpell: "rewards"});
		}

		static _mutSpell_generic ({sp, spSources, propSources, propSpell}) {
			if (!spSources[propSources]) return;

			Object.entries(spSources[propSources])
				.forEach(([source, nameTo]) => {
					const tgt = MiscUtil.getOrSet(sp, propSpell, []);

					Object.entries(nameTo)
						.forEach(([name, val]) => {
							if (tgt.some(it => it.name === nameTo && it.source === source)) return;

							const toAdd = {name, source};
							if (val === true) return tgt.push(toAdd);

							Object.assign(toAdd, {...val});
							tgt.push(toAdd);
						});
				});
		}
	},

	spellFluff: class extends _DataUtilPropConfigMultiSource {
		static _PAGE = UrlUtil.PG_SPELLS;
		static _DIR = "spells";
		static _PROP = "spellFluff";
	},

	background: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_BACKGROUNDS;
		static _FILENAME = "backgrounds.json";
	},

	backgroundFluff: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_BACKGROUNDS;
		static _FILENAME = "fluff-backgrounds.json";
	},

	charoption: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_CHAR_CREATION_OPTIONS;
		static _FILENAME = "charcreationoptions.json";
	},

	charoptionFluff: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_CHAR_CREATION_OPTIONS;
		static _FILENAME = "fluff-charcreationoptions.json";
	},

	condition: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_CONDITIONS_DISEASES;
		static _FILENAME = "conditionsdiseases.json";
	},

	conditionFluff: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_CONDITIONS_DISEASES;
		static _FILENAME = "fluff-conditionsdiseases.json";
	},

	disease: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_CONDITIONS_DISEASES;
		static _FILENAME = "conditionsdiseases.json";
	},

	feat: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_FEATS;
		static _FILENAME = "feats.json";
	},

	featFluff: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_FEATS;
		static _FILENAME = "fluff-feats.json";
	},

	item: class extends _DataUtilPropConfigCustom {
		static _MERGE_REQUIRES_PRESERVE = {
			lootTables: true,
			tier: true,
		};
		static _PAGE = UrlUtil.PG_ITEMS;

		static async loadRawJSON () {
			if (DataUtil.item._loadedRawJson) return DataUtil.item._loadedRawJson;

			DataUtil.item._pLoadingRawJson = (async () => {
				const urlItems = `${Renderer.get().baseUrl}data/items.json`;
				const urlItemsBase = `${Renderer.get().baseUrl}data/items-base.json`;
				const urlVariants = `${Renderer.get().baseUrl}data/magicvariants.json`;

				const [dataItems, dataItemsBase, dataVariants] = await Promise.all([
					DataUtil.loadJSON(urlItems),
					DataUtil.loadJSON(urlItemsBase),
					DataUtil.loadJSON(urlVariants),
				]);

				DataUtil.item._loadedRawJson = {
					item: MiscUtil.copyFast(dataItems.item),
					itemGroup: MiscUtil.copyFast(dataItems.itemGroup),
					magicvariant: MiscUtil.copyFast(dataVariants.magicvariant),
					baseitem: MiscUtil.copyFast(dataItemsBase.baseitem),
				};
			})();
			await DataUtil.item._pLoadingRawJson;

			return DataUtil.item._loadedRawJson;
		}

		static async loadJSON () {
			return {item: await Renderer.item.pBuildList()};
		}

		static async loadPrerelease () {
			return {item: await Renderer.item.pGetItemsFromPrerelease()};
		}

		static async loadBrew () {
			return {item: await Renderer.item.pGetItemsFromBrew()};
		}
	},

	itemGroup: class extends _DataUtilPropConfig {
		static _MERGE_REQUIRES_PRESERVE = {
			lootTables: true,
			tier: true,
		};
		static _PAGE = UrlUtil.PG_ITEMS;

		static async pMergeCopy (...args) { return DataUtil.item.pMergeCopy(...args); }
		static async loadRawJSON (...args) { return DataUtil.item.loadRawJSON(...args); }
	},

	itemFluff: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_ITEMS;
		static _FILENAME = "fluff-items.json";
	},

	language: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_LANGUAGES;
		static _FILENAME = "languages.json";

		static async loadJSON () {
			const rawData = await super.loadJSON();

			// region Populate fonts, based on script
			const scriptLookup = {};
			(rawData.languageScript || []).forEach(script => scriptLookup[script.name] = script);

			const out = {language: MiscUtil.copyFast(rawData.language)};
			out.language.forEach(lang => {
				if (!lang.script || lang.fonts === false) return;

				const script = scriptLookup[lang.script];
				if (!script) return;

				lang._fonts = [...script.fonts];
			});
			// endregion

			return out;
		}
	},

	languageFluff: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_LANGUAGES;
		static _FILENAME = "fluff-languages.json";
	},

	object: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_OBJECTS;
		static _FILENAME = "objects.json";
	},

	objectFluff: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_OBJECTS;
		static _FILENAME = "fluff-objects.json";
	},

	race: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_RACES;
		static _FILENAME = "races.json";

		static _loadCache = {};
		static _pIsLoadings = {};
		static async loadJSON ({isAddBaseRaces = false} = {}) {
			if (!DataUtil.race._pIsLoadings[isAddBaseRaces]) {
				DataUtil.race._pIsLoadings[isAddBaseRaces] = (async () => {
					DataUtil.race._loadCache[isAddBaseRaces] = DataUtil.race.getPostProcessedSiteJson(
						await this.loadRawJSON(),
						{isAddBaseRaces},
					);
				})();
			}
			await DataUtil.race._pIsLoadings[isAddBaseRaces];
			return DataUtil.race._loadCache[isAddBaseRaces];
		}

		static getPostProcessedSiteJson (rawRaceData, {isAddBaseRaces = false} = {}) {
			rawRaceData = MiscUtil.copyFast(rawRaceData);
			(rawRaceData.subrace || []).forEach(sr => {
				const r = rawRaceData.race.find(it => it.name === sr.raceName && it.source === sr.raceSource);
				if (!r) return JqueryUtil.doToast({content: `Failed to find race "${sr.raceName}" (${sr.raceSource})`, type: "danger"});
				const cpySr = MiscUtil.copyFast(sr);
				delete cpySr.raceName;
				delete cpySr.raceSource;
				(r.subraces = r.subraces || []).push(sr);
			});
			delete rawRaceData.subrace;
			const raceData = Renderer.race.mergeSubraces(rawRaceData.race, {isAddBaseRaces});
			raceData.forEach(it => it.__prop = "race");
			return {race: raceData};
		}

		static async loadPrerelease ({isAddBaseRaces = true} = {}) {
			return DataUtil.race._loadPrereleaseBrew({isAddBaseRaces, brewUtil: typeof PrereleaseUtil !== "undefined" ? PrereleaseUtil : null});
		}

		static async loadBrew ({isAddBaseRaces = true} = {}) {
			return DataUtil.race._loadPrereleaseBrew({isAddBaseRaces, brewUtil: typeof BrewUtil2 !== "undefined" ? BrewUtil2 : null});
		}

		static async _loadPrereleaseBrew ({isAddBaseRaces = true, brewUtil} = {}) {
			if (!brewUtil) return {};

			const rawSite = await DataUtil.race.loadRawJSON();
			const brew = await brewUtil.pGetBrewProcessed();
			return DataUtil.race.getPostProcessedPrereleaseBrewJson(rawSite, brew, {isAddBaseRaces});
		}

		static getPostProcessedPrereleaseBrewJson (rawSite, brew, {isAddBaseRaces = false} = {}) {
			rawSite = MiscUtil.copyFast(rawSite);
			brew = MiscUtil.copyFast(brew);

			const rawSiteUsed = [];
			(brew.subrace || []).forEach(sr => {
				const rSite = rawSite.race.find(it => it.name === sr.raceName && it.source === sr.raceSource);
				const rBrew = (brew.race || []).find(it => it.name === sr.raceName && it.source === sr.raceSource);
				if (!rSite && !rBrew) return JqueryUtil.doToast({content: `Failed to find race "${sr.raceName}" (${sr.raceSource})`, type: "danger"});
				const rTgt = rSite || rBrew;
				const cpySr = MiscUtil.copyFast(sr);
				delete cpySr.raceName;
				delete cpySr.raceSource;
				(rTgt.subraces = rTgt.subraces || []).push(sr);
				if (rSite && !rawSiteUsed.includes(rSite)) rawSiteUsed.push(rSite);
			});
			delete brew.subrace;

			const raceDataBrew = Renderer.race.mergeSubraces(brew.race || [], {isAddBaseRaces});
			// Never add base races from site races when building brew race list
			const raceDataSite = Renderer.race.mergeSubraces(rawSiteUsed, {isAddBaseRaces: false});

			const out = [...raceDataBrew, ...raceDataSite];
			out.forEach(it => it.__prop = "race");
			return {race: out};
		}
	},

	raceFluff: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_RACES;
		static _FILENAME = "fluff-races.json";

		static _getApplyUncommonMonstrous (data) {
			data = MiscUtil.copyFast(data);
			data.raceFluff
				.forEach(raceFluff => {
					if (raceFluff.uncommon) {
						raceFluff.entries = raceFluff.entries || [];
						raceFluff.entries.push(MiscUtil.copyFast(data.raceFluffMeta.uncommon));
						delete raceFluff.uncommon;
					}

					if (raceFluff.monstrous) {
						raceFluff.entries = raceFluff.entries || [];
						raceFluff.entries.push(MiscUtil.copyFast(data.raceFluffMeta.monstrous));
						delete raceFluff.monstrous;
					}
				});
			return data;
		}

		static async loadJSON () {
			const data = await super.loadJSON();
			return this._getApplyUncommonMonstrous(data);
		}

		static async loadUnmergedJSON () {
			const data = await super.loadUnmergedJSON();
			return this._getApplyUncommonMonstrous(data);
		}
	},

	recipe: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_RECIPES;
		static _FILENAME = "recipes.json";

		static async loadJSON () {
			const out = [];

			const rawData = await super.loadJSON();

			DataUtil.recipe.postProcessData(rawData);

			// region Merge together main data and fluff, as we render the fluff in the main tab
			for (const r of rawData.recipe) {
				const fluff = await Renderer.utils.pGetFluff({
					entity: r,
					fnGetFluffData: DataUtil.recipeFluff.loadJSON.bind(DataUtil.recipeFluff),
					fluffProp: "recipeFluff",
				});

				if (!fluff) {
					out.push(r);
					continue;
				}

				const cpyR = MiscUtil.copyFast(r);
				cpyR.fluff = MiscUtil.copyFast(fluff);
				delete cpyR.fluff.name;
				delete cpyR.fluff.source;
				out.push(cpyR);
			}
			// endregion

			return {recipe: out};
		}

		static postProcessData (data) {
			if (!data.recipe || !data.recipe.length) return;

			// Apply ingredient properties
			data.recipe.forEach(r => Renderer.recipe.populateFullIngredients(r));
		}

		static async loadPrerelease () {
			return this._loadPrereleaseBrew({brewUtil: typeof PrereleaseUtil !== "undefined" ? PrereleaseUtil : null});
		}

		static async loadBrew () {
			return this._loadPrereleaseBrew({brewUtil: typeof BrewUtil2 !== "undefined" ? BrewUtil2 : null});
		}

		static async _loadPrereleaseBrew ({brewUtil}) {
			if (!brewUtil) return {};

			const brew = await brewUtil.pGetBrewProcessed();
			DataUtil.recipe.postProcessData(brew);
			return brew;
		}
	},

	recipeFluff: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_RECIPES;
		static _FILENAME = "fluff-recipes.json";
	},

	vehicle: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_VEHICLES;
		static _FILENAME = "vehicles.json";
	},

	vehicleFluff: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_VEHICLES;
		static _FILENAME = "fluff-vehicles.json";
	},

	optionalfeature: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_OPT_FEATURES;
		static _FILENAME = "optionalfeatures.json";
	},

	class: class clazz extends _DataUtilPropConfigCustom {
		static _PAGE = UrlUtil.PG_CLASSES;

		static _pLoadJson = null;
		static _pLoadRawJson = null;

		static loadJSON () {
			return DataUtil.class._pLoadJson = DataUtil.class._pLoadJson || (async () => {
				return {
					class: await DataLoader.pCacheAndGetAllSite("class"),
					subclass: await DataLoader.pCacheAndGetAllSite("subclass"),
				};
			})();
		}

		static loadRawJSON () {
			return DataUtil.class._pLoadRawJson = DataUtil.class._pLoadRawJson || (async () => {
				const index = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/class/index.json`);
				const allData = await Promise.all(Object.values(index).map(it => DataUtil.loadJSON(`${Renderer.get().baseUrl}data/class/${it}`)));

				return {
					class: MiscUtil.copyFast(allData.map(it => it.class || []).flat()),
					subclass: MiscUtil.copyFast(allData.map(it => it.subclass || []).flat()),
					classFeature: allData.map(it => it.classFeature || []).flat(),
					subclassFeature: allData.map(it => it.subclassFeature || []).flat(),
				};
			})();
		}

		static async loadPrerelease () {
			return {
				class: await DataLoader.pCacheAndGetAllPrerelease("class"),
				subclass: await DataLoader.pCacheAndGetAllPrerelease("subclass"),
			};
		}

		static async loadBrew () {
			return {
				class: await DataLoader.pCacheAndGetAllBrew("class"),
				subclass: await DataLoader.pCacheAndGetAllBrew("subclass"),
			};
		}

		static packUidSubclass (it) {
			// <name>|<className>|<classSource>|<source>
			const sourceDefault = Parser.getTagSource("subclass");
			return [
				it.name,
				it.className,
				(it.classSource || "").toLowerCase() === sourceDefault.toLowerCase() ? "" : it.classSource,
				(it.source || "").toLowerCase() === sourceDefault.toLowerCase() ? "" : it.source,
			].join("|").replace(/\|+$/, ""); // Trim trailing pipes
		}

		/**
		 * @param uid
		 * @param [opts]
		 * @param [opts.isLower] If the returned values should be lowercase.
		 */
		static unpackUidClassFeature (uid, opts) {
			opts = opts || {};
			if (opts.isLower) uid = uid.toLowerCase();
			let [name, className, classSource, level, source, displayText] = uid.split("|").map(it => it.trim());
			classSource = classSource || (opts.isLower ? Parser.SRC_PHB.toLowerCase() : Parser.SRC_PHB);
			source = source || classSource;
			level = Number(level);
			return {
				name,
				className,
				classSource,
				level,
				source,
				displayText,
			};
		}

		static isValidClassFeatureUid (uid) {
			const {name, className, level} = DataUtil.class.unpackUidClassFeature(uid);
			return !(!name || !className || isNaN(level));
		}

		static packUidClassFeature (f) {
			// <name>|<className>|<classSource>|<level>|<source>
			return [
				f.name,
				f.className,
				f.classSource === Parser.SRC_PHB ? "" : f.classSource, // assume the class has PHB source
				f.level,
				f.source === f.classSource ? "" : f.source, // assume the class feature has the class source
			].join("|").replace(/\|+$/, ""); // Trim trailing pipes
		}

		/**
		 * @param uid
		 * @param [opts]
		 * @param [opts.isLower] If the returned values should be lowercase.
		 */
		static unpackUidSubclassFeature (uid, opts) {
			opts = opts || {};
			if (opts.isLower) uid = uid.toLowerCase();
			let [name, className, classSource, subclassShortName, subclassSource, level, source, displayText] = uid.split("|").map(it => it.trim());
			classSource = classSource || (opts.isLower ? Parser.SRC_PHB.toLowerCase() : Parser.SRC_PHB);
			subclassSource = subclassSource || (opts.isLower ? Parser.SRC_PHB.toLowerCase() : Parser.SRC_PHB);
			source = source || subclassSource;
			level = Number(level);
			return {
				name,
				className,
				classSource,
				subclassShortName,
				subclassSource,
				level,
				source,
				displayText,
			};
		}

		static isValidSubclassFeatureUid (uid) {
			const {name, className, subclassShortName, level} = DataUtil.class.unpackUidSubclassFeature(uid);
			return !(!name || !className || !subclassShortName || isNaN(level));
		}

		static packUidSubclassFeature (f) {
			// <name>|<className>|<classSource>|<subclassShortName>|<subclassSource>|<level>|<source>
			return [
				f.name,
				f.className,
				f.classSource === Parser.SRC_PHB ? "" : f.classSource, // assume the class has the PHB source
				f.subclassShortName,
				f.subclassSource === Parser.SRC_PHB ? "" : f.subclassSource, // assume the subclass has the PHB source
				f.level,
				f.source === f.subclassSource ? "" : f.source, // assume the feature has the same source as the subclass
			].join("|").replace(/\|+$/, ""); // Trim trailing pipes
		}

		// region Subclass lookup
		static _CACHE_SUBCLASS_LOOKUP_PROMISE = null;
		static _CACHE_SUBCLASS_LOOKUP = null;
		static async pGetSubclassLookup () {
			DataUtil.class._CACHE_SUBCLASS_LOOKUP_PROMISE = DataUtil.class._CACHE_SUBCLASS_LOOKUP_PROMISE || (async () => {
				const subclassLookup = {};
				Object.assign(subclassLookup, await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/generated/gendata-subclass-lookup.json`));
				DataUtil.class._CACHE_SUBCLASS_LOOKUP = subclassLookup;
			})();
			await DataUtil.class._CACHE_SUBCLASS_LOOKUP_PROMISE;
			return DataUtil.class._CACHE_SUBCLASS_LOOKUP;
		}
		// endregion
	},

	subclass: class extends _DataUtilPropConfig {
		static _PAGE = "subclass";
	},

	deity: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_DEITIES;
		static _FILENAME = "deities.json";

		static doPostLoad (data) {
			const PRINT_ORDER = [
				Parser.SRC_PHB,
				Parser.SRC_DMG,
				Parser.SRC_SCAG,
				Parser.SRC_VGM,
				Parser.SRC_MTF,
				Parser.SRC_ERLW,
			];

			const inSource = {};
			PRINT_ORDER.forEach(src => {
				inSource[src] = {};
				data.deity.filter(it => it.source === src).forEach(it => inSource[src][it.reprintAlias || it.name] = it); // TODO need to handle similar names
			});

			const laterPrinting = [PRINT_ORDER.last()];
			[...PRINT_ORDER].reverse().slice(1).forEach(src => {
				laterPrinting.forEach(laterSrc => {
					Object.keys(inSource[src]).forEach(name => {
						const newer = inSource[laterSrc][name];
						if (newer) {
							const old = inSource[src][name];
							old.reprinted = true;
							if (!newer._isEnhanced) {
								newer.previousVersions = newer.previousVersions || [];
								newer.previousVersions.push(old);
							}
						}
					});
				});

				laterPrinting.push(src);
			});
			data.deity.forEach(g => g._isEnhanced = true);

			return data;
		}

		static async loadJSON () {
			const data = await super.loadJSON();
			DataUtil.deity.doPostLoad(data);
			return data;
		}

		static getUid (ent, opts) {
			return this.packUidDeity(ent, opts);
		}

		static getNormalizedUid (uid, tag) {
			const {name, pantheon, source} = this.unpackUidDeity(uid, tag, {isLower: true});
			return [name, pantheon, source].join("|");
		}

		static unpackUidDeity (uid, opts) {
			opts = opts || {};
			if (opts.isLower) uid = uid.toLowerCase();
			let [name, pantheon, source, displayText, ...others] = uid.split("|").map(it => it.trim());

			pantheon = pantheon || "forgotten realms";
			if (opts.isLower) pantheon = pantheon.toLowerCase();

			source = source || Parser.getTagSource("deity", source);
			if (opts.isLower) source = source.toLowerCase();

			return {
				name,
				pantheon,
				source,
				displayText,
				others,
			};
		}

		static packUidDeity (it) {
			// <name>|<pantheon>|<source>
			const sourceDefault = Parser.getTagSource("deity");
			return [
				it.name,
				(it.pantheon || "").toLowerCase() === "forgotten realms" ? "" : it.pantheon,
				(it.source || "").toLowerCase() === sourceDefault.toLowerCase() ? "" : it.source,
			].join("|").replace(/\|+$/, ""); // Trim trailing pipes
		}
	},

	table: class extends _DataUtilPropConfigCustom {
		static async loadJSON () {
			const datas = await Promise.all([
				`${Renderer.get().baseUrl}data/generated/gendata-tables.json`,
				`${Renderer.get().baseUrl}data/tables.json`,
			].map(url => DataUtil.loadJSON(url)));
			const combined = {};
			datas.forEach(data => {
				Object.entries(data).forEach(([k, v]) => {
					if (combined[k] && combined[k] instanceof Array && v instanceof Array) combined[k] = combined[k].concat(v);
					else if (combined[k] == null) combined[k] = v;
					else throw new Error(`Could not merge keys for key "${k}"`);
				});
			});

			return combined;
		}
	},

	legendaryGroup: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_BESTIARY;
		static _FILENAME = "bestiary/legendarygroups.json";

		static async pLoadAll () {
			return (await this.loadJSON()).legendaryGroup;
		}
	},

	variantrule: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_VARIANTRULES;
		static _FILENAME = "variantrules.json";

		static async loadJSON () {
			const rawData = await super.loadJSON();
			const rawDataGenerated = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/generated/gendata-variantrules.json`);

			return {variantrule: [...rawData.variantrule, ...rawDataGenerated.variantrule]};
		}
	},

	deck: class extends _DataUtilPropConfigCustom {
		static _PAGE = UrlUtil.PG_DECKS;

		static _pLoadJson = null;
		static _pLoadRawJson = null;

		static loadJSON () {
			return DataUtil.deck._pLoadJson = DataUtil.deck._pLoadJson || (async () => {
				return {
					deck: await DataLoader.pCacheAndGetAllSite("deck"),
					card: await DataLoader.pCacheAndGetAllSite("card"),
				};
			})();
		}

		static loadRawJSON () {
			return DataUtil.deck._pLoadRawJson = DataUtil.deck._pLoadRawJson || DataUtil.loadJSON(`${Renderer.get().baseUrl}data/decks.json`);
		}

		static async loadPrerelease () {
			return {
				deck: await DataLoader.pCacheAndGetAllPrerelease("deck"),
				card: await DataLoader.pCacheAndGetAllPrerelease("card"),
			};
		}

		static async loadBrew () {
			return {
				deck: await DataLoader.pCacheAndGetAllBrew("deck"),
				card: await DataLoader.pCacheAndGetAllBrew("card"),
			};
		}

		/**
		 * @param uid
		 * @param [opts]
		 * @param [opts.isLower] If the returned values should be lowercase.
		 */
		static unpackUidCard (uid, opts) {
			opts = opts || {};
			if (opts.isLower) uid = uid.toLowerCase();
			let [name, set, source, displayText] = uid.split("|").map(it => it.trim());
			set = set || "none";
			source = source || Parser.getTagSource("card", source)[opts.isLower ? "toLowerCase" : "toString"]();
			return {
				name,
				set,
				source,
				displayText,
			};
		}
	},

	quickreference: {
		/**
		 * @param uid
		 * @param [opts]
		 * @param [opts.isLower] If the returned values should be lowercase.
		 */
		unpackUid (uid, opts) {
			opts = opts || {};
			if (opts.isLower) uid = uid.toLowerCase();
			let [name, source, ixChapter, ixHeader, displayText] = uid.split("|").map(it => it.trim());
			source = source || (opts.isLower ? Parser.SRC_PHB.toLowerCase() : Parser.SRC_PHB);
			ixChapter = Number(ixChapter || 0);
			return {
				name,
				ixChapter,
				ixHeader,
				source,
				displayText,
			};
		},
	},

	brew: new _DataUtilBrewHelper({defaultUrlRoot: VeCt.URL_ROOT_BREW}),
	prerelease: new _DataUtilBrewHelper({defaultUrlRoot: VeCt.URL_ROOT_PRERELEASE}),
};

// ROLLING =============================================================================================================
globalThis.RollerUtil = {
	isCrypto () {
		return typeof window !== "undefined" && typeof window.crypto !== "undefined";
	},

	randomise (max, min = 1) {
		if (min > max) return 0;
		if (max === min) return max;
		if (RollerUtil.isCrypto()) {
			return RollerUtil._randomise(min, max + 1);
		} else {
			return RollerUtil.roll(max) + min;
		}
	},

	rollOnArray (array) {
		return array[RollerUtil.randomise(array.length) - 1];
	},

	/**
	 * Cryptographically secure RNG
	 */
	_randomise: (min, max) => {
		if (isNaN(min) || isNaN(max)) throw new Error(`Invalid min/max!`);

		const range = max - min;
		const bytesNeeded = Math.ceil(Math.log2(range) / 8);
		const randomBytes = new Uint8Array(bytesNeeded);
		const maximumRange = (2 ** 8) ** bytesNeeded;
		const extendedRange = Math.floor(maximumRange / range) * range;
		let i;
		let randomInteger;
		while (true) {
			window.crypto.getRandomValues(randomBytes);
			randomInteger = 0;
			for (i = 0; i < bytesNeeded; i++) {
				randomInteger <<= 8;
				randomInteger += randomBytes[i];
			}
			if (randomInteger < extendedRange) {
				randomInteger %= range;
				return min + randomInteger;
			}
		}
	},

	/**
	 * Result in range: 0 to (max-1); inclusive
	 * e.g. roll(20) gives results ranging from 0 to 19
	 * @param max range max (exclusive)
	 * @param fn funciton to call to generate random numbers
	 * @returns {number} rolled
	 */
	roll (max, fn = Math.random) {
		return Math.floor(fn() * max);
	},

	addListRollButton (isCompact) {

	},

	getColRollType (colLabel) {
		if (typeof colLabel !== "string") return false;
		colLabel = Renderer.stripTags(colLabel);

		if (Renderer.dice.lang.getTree3(colLabel)) return RollerUtil.ROLL_COL_STANDARD;

		// Remove trailing variables, if they exist
		colLabel = colLabel.replace(RollerUtil._REGEX_ROLLABLE_COL_LABEL, "$1");
		if (Renderer.dice.lang.getTree3(colLabel)) return RollerUtil.ROLL_COL_VARIABLE;

		return RollerUtil.ROLL_COL_NONE;
	},

	getFullRollCol (lbl) {
		if (lbl.includes("@dice")) return lbl;

		if (Renderer.dice.lang.getTree3(lbl)) return `{@dice ${lbl}}`;

		// Try to split off any trailing variables, e.g. `d100 + Level` -> `d100`, `Level`
		const m = RollerUtil._REGEX_ROLLABLE_COL_LABEL.exec(lbl);
		if (!m) return lbl;

		return `{@dice ${m[1]}${m[2]}#$prompt_number:title=Enter a ${m[3].trim()}$#|${lbl}}`;
	},

	_DICE_REGEX_STR: "((([1-9]\\d*)?d([1-9]\\d*)(\\s*?[-+×x*÷/]\\s*?(\\d,\\d|\\d)+(\\.\\d+)?)?))+?",
};
RollerUtil.DICE_REGEX = new RegExp(RollerUtil._DICE_REGEX_STR, "g");
RollerUtil.REGEX_DAMAGE_DICE = /(?<average>\d+)(?<prefix> \((?:{@dice |{@damage ))(?<diceExp>[-+0-9d ]*)(?<suffix>}\)(?:\s*\+\s*the spell's level)? [a-z]+( \([-a-zA-Z0-9 ]+\))?( or [a-z]+( \([-a-zA-Z0-9 ]+\))?)? damage)/gi;
RollerUtil.REGEX_DAMAGE_FLAT = /(?<prefix>Hit: |{@h})(?<flatVal>[0-9]+)(?<suffix> [a-z]+( \([-a-zA-Z0-9 ]+\))?( or [a-z]+( \([-a-zA-Z0-9 ]+\))?)? damage)/gi;
RollerUtil._REGEX_ROLLABLE_COL_LABEL = /^(.*?\d)(\s*[-+/*^×÷]\s*)([a-zA-Z0-9 ]+)$/;
RollerUtil.ROLL_COL_NONE = 0;
RollerUtil.ROLL_COL_STANDARD = 1;
RollerUtil.ROLL_COL_VARIABLE = 2;

// STORAGE =============================================================================================================
// Dependency: localforage
function StorageUtilBase () {
	this._META_KEY = "_STORAGE_META_STORAGE";

	this._fakeStorageBacking = {};
	this._fakeStorageBackingAsync = {};

	this._getFakeStorageSync = function () {
		return {
			isSyncFake: true,
			getItem: k => this._fakeStorageBacking[k],
			removeItem: k => delete this._fakeStorageBacking[k],
			setItem: (k, v) => this._fakeStorageBacking[k] = v,
		};
	};

	this._getFakeStorageAsync = function () {
		return {
			pIsAsyncFake: true,
			setItem: async (k, v) => this._fakeStorageBackingAsync[k] = v,
			getItem: async (k) => this._fakeStorageBackingAsync[k],
			removeItem: async (k) => delete this._fakeStorageBackingAsync[k],
		};
	};

	this._getSyncStorage = function () { throw new Error(`Unimplemented!`); };
	this._getAsyncStorage = async function () { throw new Error(`Unimplemented!`); };

	this.getPageKey = function (key, page) { return `${key}_${page || UrlUtil.getCurrentPage()}`; };

	// region Synchronous
	this.syncGet = function (key) {
		const rawOut = this._getSyncStorage().getItem(key);
		if (rawOut && rawOut !== "undefined" && rawOut !== "null") return JSON.parse(rawOut);
		return null;
	};

	this.syncSet = function (key, value) {
		this._getSyncStorage().setItem(key, JSON.stringify(value));
		this._syncTrackKey(key);
	};

	this.syncRemove = function (key) {
		this._getSyncStorage().removeItem(key);
		this._syncTrackKey(key, true);
	};

	this.syncGetForPage = function (key) { return this.syncGet(`${key}_${UrlUtil.getCurrentPage()}`); };
	this.syncSetForPage = function (key, value) { this.syncSet(`${key}_${UrlUtil.getCurrentPage()}`, value); };

	this.isSyncFake = function () {
		return !!this._getSyncStorage().isSyncFake;
	};

	this._syncTrackKey = function (key, isRemove) {
		const meta = this.syncGet(this._META_KEY) || {};
		if (isRemove) delete meta[key];
		else meta[key] = 1;
		this._getSyncStorage().setItem(this._META_KEY, JSON.stringify(meta));
	};

	this.syncGetDump = function () {
		const out = {};
		this._syncGetPresentKeys().forEach(key => out[key] = this.syncGet(key));
		return out;
	};

	this._syncGetPresentKeys = function () {
		const meta = this.syncGet(this._META_KEY) || {};
		return Object.entries(meta).filter(([, isPresent]) => isPresent).map(([key]) => key);
	};

	this.syncSetFromDump = function (dump) {
		const keysToRemove = new Set(this._syncGetPresentKeys());
		Object.entries(dump).map(([k, v]) => {
			keysToRemove.delete(k);
			return this.syncSet(k, v);
		});
		[...keysToRemove].map(k => this.syncRemove(k));
	};
	// endregion

	// region Asynchronous
	this.pIsAsyncFake = async function () {
		const storage = await this._getAsyncStorage();
		return !!storage.pIsAsyncFake;
	};

	this.pSet = async function (key, value) {
		this._pTrackKey(key).then(null);
		const storage = await this._getAsyncStorage();
		return storage.setItem(key, value);
	};

	this.pGet = async function (key) {
		const storage = await this._getAsyncStorage();
		return storage.getItem(key);
	};

	this.pRemove = async function (key) {
		this._pTrackKey(key, true).then(null);
		const storage = await this._getAsyncStorage();
		return storage.removeItem(key);
	};

	this.pGetForPage = async function (key, {page = null} = {}) { return this.pGet(this.getPageKey(key, page)); };
	this.pSetForPage = async function (key, value, {page = null} = {}) { return this.pSet(this.getPageKey(key, page), value); };
	this.pRemoveForPage = async function (key, {page = null} = {}) { return this.pRemove(this.getPageKey(key, page)); };

	this._pTrackKey = async function (key, isRemove) {
		const storage = await this._getAsyncStorage();
		const meta = (await this.pGet(this._META_KEY)) || {};
		if (isRemove) delete meta[key];
		else meta[key] = 1;
		return storage.setItem(this._META_KEY, meta);
	};

	this.pGetDump = async function () {
		const out = {};
		await Promise.all(
			(await this._pGetPresentKeys()).map(async (key) => out[key] = await this.pGet(key)),
		);
		return out;
	};

	this._pGetPresentKeys = async function () {
		const meta = (await this.pGet(this._META_KEY)) || {};
		return Object.entries(meta).filter(([, isPresent]) => isPresent).map(([key]) => key);
	};

	this.pSetFromDump = async function (dump) {
		const keysToRemove = new Set(await this._pGetPresentKeys());
		await Promise.all(
			Object.entries(dump).map(([k, v]) => {
				keysToRemove.delete(k);
				return this.pSet(k, v);
			}),
		);
		await Promise.all(
			[...keysToRemove].map(k => this.pRemove(k)),
		);
	};
	// endregion
}

function StorageUtilMemory () {
	StorageUtilBase.call(this);

	this._fakeStorage = null;
	this._fakeStorageAsync = null;

	this._getSyncStorage = function () {
		this._fakeStorage = this._fakeStorage || this._getFakeStorageSync();
		return this._fakeStorage;
	};

	this._getAsyncStorage = async function () {
		this._fakeStorageAsync = this._fakeStorageAsync || this._getFakeStorageAsync();
		return this._fakeStorageAsync;
	};
}

globalThis.StorageUtilMemory = StorageUtilMemory;

function StorageUtilBacked () {
	StorageUtilBase.call(this);

	this._isInit = false;
	this._isInitAsync = false;
	this._fakeStorage = null;
	this._fakeStorageAsync = null;

	this._initSyncStorage = function () {
		if (this._isInit) return;

		if (typeof window === "undefined") {
			this._fakeStorage = this._getFakeStorageSync();
			this._isInit = true;
			return;
		}

		try {
			window.localStorage.setItem("_test_storage", true);
		} catch (e) {
			// if the user has disabled cookies, build a fake version
			this._fakeStorage = this._getFakeStorageSync();
		}

		this._isInit = true;
	};

	this._getSyncStorage = function () {
		this._initSyncStorage();
		if (this._fakeStorage) return this._fakeStorage;
		return window.localStorage;
	};

	this._initAsyncStorage = async function () {
		if (this._isInitAsync) return;

		if (typeof window === "undefined") {
			this._fakeStorageAsync = this._getFakeStorageAsync();
			this._isInitAsync = true;
			return;
		}

		try {
			// check if IndexedDB is available (i.e. not in Firefox private browsing)
			await new Promise((resolve, reject) => {
				const request = window.indexedDB.open("_test_db", 1);
				request.onerror = reject;
				request.onsuccess = resolve;
			});
			await localforage.setItem("_storage_check", true);
		} catch (e) {
			this._fakeStorageAsync = this._getFakeStorageAsync();
		}

		this._isInitAsync = true;
	};

	this._getAsyncStorage = async function () {
		await this._initAsyncStorage();
		if (this._fakeStorageAsync) return this._fakeStorageAsync;
		else return localforage;
	};
}

globalThis.StorageUtil = new StorageUtilBacked();

// TODO transition cookie-like storage items over to this
globalThis.SessionStorageUtil = {
	_fakeStorage: {},
	__storage: null,
	getStorage: () => {
		try {
			return window.sessionStorage;
		} catch (e) {
			// if the user has disabled cookies, build a fake version
			if (SessionStorageUtil.__storage) return SessionStorageUtil.__storage;
			else {
				return SessionStorageUtil.__storage = {
					isFake: true,
					getItem: (k) => {
						return SessionStorageUtil._fakeStorage[k];
					},
					removeItem: (k) => {
						delete SessionStorageUtil._fakeStorage[k];
					},
					setItem: (k, v) => {
						SessionStorageUtil._fakeStorage[k] = v;
					},
				};
			}
		}
	},

	isFake () {
		return SessionStorageUtil.getStorage().isSyncFake;
	},

	setForPage: (key, value) => {
		SessionStorageUtil.set(`${key}_${UrlUtil.getCurrentPage()}`, value);
	},

	set (key, value) {
		SessionStorageUtil.getStorage().setItem(key, JSON.stringify(value));
	},

	getForPage: (key) => {
		return SessionStorageUtil.get(`${key}_${UrlUtil.getCurrentPage()}`);
	},

	get (key) {
		const rawOut = SessionStorageUtil.getStorage().getItem(key);
		if (rawOut && rawOut !== "undefined" && rawOut !== "null") return JSON.parse(rawOut);
		return null;
	},

	removeForPage: (key) => {
		SessionStorageUtil.remove(`${key}_${UrlUtil.getCurrentPage()}`);
	},

	remove (key) {
		SessionStorageUtil.getStorage().removeItem(key);
	},
};

// ID GENERATION =======================================================================================================
globalThis.CryptUtil = {
	// region md5 internals
	// stolen from http://www.myersdaily.org/joseph/javascript/md5.js
	_md5cycle: (x, k) => {
		let a = x[0];
		let b = x[1];
		let c = x[2];
		let d = x[3];

		a = CryptUtil._ff(a, b, c, d, k[0], 7, -680876936);
		d = CryptUtil._ff(d, a, b, c, k[1], 12, -389564586);
		c = CryptUtil._ff(c, d, a, b, k[2], 17, 606105819);
		b = CryptUtil._ff(b, c, d, a, k[3], 22, -1044525330);
		a = CryptUtil._ff(a, b, c, d, k[4], 7, -176418897);
		d = CryptUtil._ff(d, a, b, c, k[5], 12, 1200080426);
		c = CryptUtil._ff(c, d, a, b, k[6], 17, -1473231341);
		b = CryptUtil._ff(b, c, d, a, k[7], 22, -45705983);
		a = CryptUtil._ff(a, b, c, d, k[8], 7, 1770035416);
		d = CryptUtil._ff(d, a, b, c, k[9], 12, -1958414417);
		c = CryptUtil._ff(c, d, a, b, k[10], 17, -42063);
		b = CryptUtil._ff(b, c, d, a, k[11], 22, -1990404162);
		a = CryptUtil._ff(a, b, c, d, k[12], 7, 1804603682);
		d = CryptUtil._ff(d, a, b, c, k[13], 12, -40341101);
		c = CryptUtil._ff(c, d, a, b, k[14], 17, -1502002290);
		b = CryptUtil._ff(b, c, d, a, k[15], 22, 1236535329);

		a = CryptUtil._gg(a, b, c, d, k[1], 5, -165796510);
		d = CryptUtil._gg(d, a, b, c, k[6], 9, -1069501632);
		c = CryptUtil._gg(c, d, a, b, k[11], 14, 643717713);
		b = CryptUtil._gg(b, c, d, a, k[0], 20, -373897302);
		a = CryptUtil._gg(a, b, c, d, k[5], 5, -701558691);
		d = CryptUtil._gg(d, a, b, c, k[10], 9, 38016083);
		c = CryptUtil._gg(c, d, a, b, k[15], 14, -660478335);
		b = CryptUtil._gg(b, c, d, a, k[4], 20, -405537848);
		a = CryptUtil._gg(a, b, c, d, k[9], 5, 568446438);
		d = CryptUtil._gg(d, a, b, c, k[14], 9, -1019803690);
		c = CryptUtil._gg(c, d, a, b, k[3], 14, -187363961);
		b = CryptUtil._gg(b, c, d, a, k[8], 20, 1163531501);
		a = CryptUtil._gg(a, b, c, d, k[13], 5, -1444681467);
		d = CryptUtil._gg(d, a, b, c, k[2], 9, -51403784);
		c = CryptUtil._gg(c, d, a, b, k[7], 14, 1735328473);
		b = CryptUtil._gg(b, c, d, a, k[12], 20, -1926607734);

		a = CryptUtil._hh(a, b, c, d, k[5], 4, -378558);
		d = CryptUtil._hh(d, a, b, c, k[8], 11, -2022574463);
		c = CryptUtil._hh(c, d, a, b, k[11], 16, 1839030562);
		b = CryptUtil._hh(b, c, d, a, k[14], 23, -35309556);
		a = CryptUtil._hh(a, b, c, d, k[1], 4, -1530992060);
		d = CryptUtil._hh(d, a, b, c, k[4], 11, 1272893353);
		c = CryptUtil._hh(c, d, a, b, k[7], 16, -155497632);
		b = CryptUtil._hh(b, c, d, a, k[10], 23, -1094730640);
		a = CryptUtil._hh(a, b, c, d, k[13], 4, 681279174);
		d = CryptUtil._hh(d, a, b, c, k[0], 11, -358537222);
		c = CryptUtil._hh(c, d, a, b, k[3], 16, -722521979);
		b = CryptUtil._hh(b, c, d, a, k[6], 23, 76029189);
		a = CryptUtil._hh(a, b, c, d, k[9], 4, -640364487);
		d = CryptUtil._hh(d, a, b, c, k[12], 11, -421815835);
		c = CryptUtil._hh(c, d, a, b, k[15], 16, 530742520);
		b = CryptUtil._hh(b, c, d, a, k[2], 23, -995338651);

		a = CryptUtil._ii(a, b, c, d, k[0], 6, -198630844);
		d = CryptUtil._ii(d, a, b, c, k[7], 10, 1126891415);
		c = CryptUtil._ii(c, d, a, b, k[14], 15, -1416354905);
		b = CryptUtil._ii(b, c, d, a, k[5], 21, -57434055);
		a = CryptUtil._ii(a, b, c, d, k[12], 6, 1700485571);
		d = CryptUtil._ii(d, a, b, c, k[3], 10, -1894986606);
		c = CryptUtil._ii(c, d, a, b, k[10], 15, -1051523);
		b = CryptUtil._ii(b, c, d, a, k[1], 21, -2054922799);
		a = CryptUtil._ii(a, b, c, d, k[8], 6, 1873313359);
		d = CryptUtil._ii(d, a, b, c, k[15], 10, -30611744);
		c = CryptUtil._ii(c, d, a, b, k[6], 15, -1560198380);
		b = CryptUtil._ii(b, c, d, a, k[13], 21, 1309151649);
		a = CryptUtil._ii(a, b, c, d, k[4], 6, -145523070);
		d = CryptUtil._ii(d, a, b, c, k[11], 10, -1120210379);
		c = CryptUtil._ii(c, d, a, b, k[2], 15, 718787259);
		b = CryptUtil._ii(b, c, d, a, k[9], 21, -343485551);

		x[0] = CryptUtil._add32(a, x[0]);
		x[1] = CryptUtil._add32(b, x[1]);
		x[2] = CryptUtil._add32(c, x[2]);
		x[3] = CryptUtil._add32(d, x[3]);
	},

	_cmn: (q, a, b, x, s, t) => {
		a = CryptUtil._add32(CryptUtil._add32(a, q), CryptUtil._add32(x, t));
		return CryptUtil._add32((a << s) | (a >>> (32 - s)), b);
	},

	_ff: (a, b, c, d, x, s, t) => {
		return CryptUtil._cmn((b & c) | ((~b) & d), a, b, x, s, t);
	},

	_gg: (a, b, c, d, x, s, t) => {
		return CryptUtil._cmn((b & d) | (c & (~d)), a, b, x, s, t);
	},

	_hh: (a, b, c, d, x, s, t) => {
		return CryptUtil._cmn(b ^ c ^ d, a, b, x, s, t);
	},

	_ii: (a, b, c, d, x, s, t) => {
		return CryptUtil._cmn(c ^ (b | (~d)), a, b, x, s, t);
	},

	_md51: (s) => {
		let n = s.length;
		let state = [1732584193, -271733879, -1732584194, 271733878];
		let i;
		for (i = 64; i <= s.length; i += 64) {
			CryptUtil._md5cycle(state, CryptUtil._md5blk(s.substring(i - 64, i)));
		}
		s = s.substring(i - 64);
		let tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
		for (i = 0; i < s.length; i++) tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
		tail[i >> 2] |= 0x80 << ((i % 4) << 3);
		if (i > 55) {
			CryptUtil._md5cycle(state, tail);
			for (i = 0; i < 16; i++) tail[i] = 0;
		}
		tail[14] = n * 8;
		CryptUtil._md5cycle(state, tail);
		return state;
	},

	_md5blk: (s) => {
		let md5blks = [];
		for (let i = 0; i < 64; i += 4) {
			md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
		}
		return md5blks;
	},

	_hex_chr: "0123456789abcdef".split(""),

	_rhex: (n) => {
		let s = "";
		for (let j = 0; j < 4; j++) {
			s += CryptUtil._hex_chr[(n >> (j * 8 + 4)) & 0x0F] + CryptUtil._hex_chr[(n >> (j * 8)) & 0x0F];
		}
		return s;
	},

	_add32: (a, b) => {
		return (a + b) & 0xFFFFFFFF;
	},
	// endregion

	hex: (x) => {
		for (let i = 0; i < x.length; i++) {
			x[i] = CryptUtil._rhex(x[i]);
		}
		return x.join("");
	},

	hex2Dec (hex) {
		return parseInt(`0x${hex}`);
	},

	md5: (s) => {
		return CryptUtil.hex(CryptUtil._md51(s));
	},

	/**
	 * Based on Java's implementation.
	 * @param obj An object to hash.
	 * @return {*} An integer hashcode for the object.
	 */
	hashCode (obj) {
		if (typeof obj === "string") {
			if (!obj) return 0;
			let h = 0;
			for (let i = 0; i < obj.length; ++i) h = 31 * h + obj.charCodeAt(i);
			return h;
		} else if (typeof obj === "number") return obj;
		else throw new Error(`No hashCode implementation for ${obj}`);
	},

	uid () { // https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
		if (RollerUtil.isCrypto()) {
			return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));
		} else {
			let d = Date.now();
			if (typeof performance !== "undefined" && typeof performance.now === "function") {
				d += performance.now();
			}
			return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
				const r = (d + Math.random() * 16) % 16 | 0;
				d = Math.floor(d / 16);
				return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
			});
		}
	},
};

// COLLECTIONS =========================================================================================================
globalThis.CollectionUtil = {
	ObjectSet: class ObjectSet {
		constructor () {
			this.map = new Map();
			this[Symbol.iterator] = this.values;
		}
		// Each inserted element has to implement _toIdString() method that returns a string ID.
		// Two objects are considered equal if their string IDs are equal.
		add (item) {
			this.map.set(item._toIdString(), item);
		}

		values () {
			return this.map.values();
		}
	},

	setEq (a, b) {
		if (a.size !== b.size) return false;
		for (const it of a) if (!b.has(it)) return false;
		return true;
	},

	setDiff (set1, set2) {
		return new Set([...set1].filter(it => !set2.has(it)));
	},

	objectDiff (obj1, obj2) {
		const out = {};

		[...new Set([...Object.keys(obj1), ...Object.keys(obj2)])]
			.forEach(k => {
				const diff = CollectionUtil._objectDiff_recurse(obj1[k], obj2[k]);
				if (diff !== undefined) out[k] = diff;
			});

		return out;
	},

	_objectDiff_recurse (a, b) {
		if (CollectionUtil.deepEquals(a, b)) return undefined;

		if (a && b && typeof a === "object" && typeof b === "object") {
			return CollectionUtil.objectDiff(a, b);
		}

		return b;
	},

	objectIntersect (obj1, obj2) {
		const out = {};

		[...new Set([...Object.keys(obj1), ...Object.keys(obj2)])]
			.forEach(k => {
				const diff = CollectionUtil._objectIntersect_recurse(obj1[k], obj2[k]);
				if (diff !== undefined) out[k] = diff;
			});

		return out;
	},

	_objectIntersect_recurse (a, b) {
		if (CollectionUtil.deepEquals(a, b)) return a;

		if (a && b && typeof a === "object" && typeof b === "object") {
			return CollectionUtil.objectIntersect(a, b);
		}

		return undefined;
	},

	deepEquals (a, b) {
		if (Object.is(a, b)) return true;
		if (a && b && typeof a === "object" && typeof b === "object") {
			if (CollectionUtil._eq_isPlainObject(a) && CollectionUtil._eq_isPlainObject(b)) return CollectionUtil._eq_areObjectsEqual(a, b);
			const isArrayA = Array.isArray(a);
			const isArrayB = Array.isArray(b);
			if (isArrayA || isArrayB) return isArrayA === isArrayB && CollectionUtil._eq_areArraysEqual(a, b);
			const isSetA = a instanceof Set;
			const isSetB = b instanceof Set;
			if (isSetA || isSetB) return isSetA === isSetB && CollectionUtil.setEq(a, b);
			return CollectionUtil._eq_areObjectsEqual(a, b);
		}
		return false;
	},

	_eq_isPlainObject: (value) => value.constructor === Object || value.constructor == null,
	_eq_areObjectsEqual (a, b) {
		const keysA = Object.keys(a);
		const {length} = keysA;
		if (Object.keys(b).length !== length) return false;
		for (let i = 0; i < length; i++) {
			if (!b.hasOwnProperty(keysA[i])) return false;
			if (!CollectionUtil.deepEquals(a[keysA[i]], b[keysA[i]])) return false;
		}
		return true;
	},
	_eq_areArraysEqual (a, b) {
		const {length} = a;
		if (b.length !== length) return false;
		for (let i = 0; i < length; i++) if (!CollectionUtil.deepEquals(a[i], b[i])) return false;
		return true;
	},

	// region Find first <X>
	dfs (obj, opts) {
		const {prop = null, fnMatch = null} = opts;
		if (!prop && !fnMatch) throw new Error(`One of "prop" or "fnMatch" must be specified!`);

		if (obj instanceof Array) {
			for (const child of obj) {
				const n = CollectionUtil.dfs(child, opts);
				if (n) return n;
			}
			return;
		}

		if (obj instanceof Object) {
			if (prop && obj[prop]) return obj[prop];
			if (fnMatch && fnMatch(obj)) return obj;

			for (const child of Object.values(obj)) {
				const n = CollectionUtil.dfs(child, opts);
				if (n) return n;
			}
		}
	},

	bfs (obj, opts) {
		const {prop = null, fnMatch = null} = opts;
		if (!prop && !fnMatch) throw new Error(`One of "prop" or "fnMatch" must be specified!`);

		if (obj instanceof Array) {
			for (const child of obj) {
				if (!(child instanceof Array) && child instanceof Object) {
					if (prop && child[prop]) return child[prop];
					if (fnMatch && fnMatch(child)) return child;
				}
			}

			for (const child of obj) {
				const n = CollectionUtil.bfs(child, opts);
				if (n) return n;
			}

			return;
		}

		if (obj instanceof Object) {
			if (prop && obj[prop]) return obj[prop];
			if (fnMatch && fnMatch(obj)) return obj;

			return CollectionUtil.bfs(Object.values(obj));
		}
	},
	// endregion
};

Array.prototype.last || Object.defineProperty(Array.prototype, "last", {
	enumerable: false,
	writable: true,
	value: function (arg) {
		if (arg !== undefined) this[this.length - 1] = arg;
		else return this[this.length - 1];
	},
});

Array.prototype.filterIndex || Object.defineProperty(Array.prototype, "filterIndex", {
	enumerable: false,
	writable: true,
	value: function (fnCheck) {
		const out = [];
		this.forEach((it, i) => {
			if (fnCheck(it)) out.push(i);
		});
		return out;
	},
});

Array.prototype.equals || Object.defineProperty(Array.prototype, "equals", {
	enumerable: false,
	writable: true,
	value: function (array2) {
		const array1 = this;
		if (!array1 && !array2) return true;
		else if ((!array1 && array2) || (array1 && !array2)) return false;

		let temp = [];
		if ((!array1[0]) || (!array2[0])) return false;
		if (array1.length !== array2.length) return false;
		let key;
		// Put all the elements from array1 into a "tagged" array
		for (let i = 0; i < array1.length; i++) {
			key = `${(typeof array1[i])}~${array1[i]}`; // Use "typeof" so a number 1 isn't equal to a string "1".
			if (temp[key]) temp[key]++;
			else temp[key] = 1;
		}
		// Go through array2 - if same tag missing in "tagged" array, not equal
		for (let i = 0; i < array2.length; i++) {
			key = `${(typeof array2[i])}~${array2[i]}`;
			if (temp[key]) {
				if (temp[key] === 0) return false;
				else temp[key]--;
			} else return false;
		}
		return true;
	},
});

// Alternate name due to clash with Foundry VTT
Array.prototype.segregate || Object.defineProperty(Array.prototype, "segregate", {
	enumerable: false,
	writable: true,
	value: function (fnIsValid) {
		return this.reduce(([pass, fail], elem) => fnIsValid(elem) ? [[...pass, elem], fail] : [pass, [...fail, elem]], [[], []]);
	},
});

Array.prototype.partition || Object.defineProperty(Array.prototype, "partition", {
	enumerable: false,
	writable: true,
	value: Array.prototype.segregate,
});

Array.prototype.getNext || Object.defineProperty(Array.prototype, "getNext", {
	enumerable: false,
	writable: true,
	value: function (curVal) {
		let ix = this.indexOf(curVal);
		if (!~ix) throw new Error("Value was not in array!");
		if (++ix >= this.length) ix = 0;
		return this[ix];
	},
});

Array.prototype.shuffle || Object.defineProperty(Array.prototype, "shuffle", {
	enumerable: false,
	writable: true,
	value: function () {
		for (let i = 0; i < 10000; ++i) this.sort(() => Math.random() - 0.5);
		return this;
	},
});

/** Map each array item to a k:v pair, then flatten them into one object. */
Array.prototype.mergeMap || Object.defineProperty(Array.prototype, "mergeMap", {
	enumerable: false,
	writable: true,
	value: function (fnMap) {
		return this.map((...args) => fnMap(...args)).filter(it => it != null).reduce((a, b) => Object.assign(a, b), {});
	},
});

Array.prototype.first || Object.defineProperty(Array.prototype, "first", {
	enumerable: false,
	writable: true,
	value: function (fnMapFind) {
		for (let i = 0, len = this.length; i < len; ++i) {
			const result = fnMapFind(this[i], i, this);
			if (result) return result;
		}
	},
});

Array.prototype.pMap || Object.defineProperty(Array.prototype, "pMap", {
	enumerable: false,
	writable: true,
	value: async function (fnMap) {
		return Promise.all(this.map((it, i) => fnMap(it, i, this)));
	},
});

/** Map each item via an async function, awaiting for each to complete before starting the next. */
Array.prototype.pSerialAwaitMap || Object.defineProperty(Array.prototype, "pSerialAwaitMap", {
	enumerable: false,
	writable: true,
	value: async function (fnMap) {
		const out = [];
		for (let i = 0, len = this.length; i < len; ++i) out.push(await fnMap(this[i], i, this));
		return out;
	},
});

Array.prototype.pSerialAwaitFilter || Object.defineProperty(Array.prototype, "pSerialAwaitFilter", {
	enumerable: false,
	writable: true,
	value: async function (fnFilter) {
		const out = [];
		for (let i = 0, len = this.length; i < len; ++i) {
			if (await fnFilter(this[i], i, this)) out.push(this[i]);
		}
		return out;
	},
});

Array.prototype.pSerialAwaitFind || Object.defineProperty(Array.prototype, "pSerialAwaitFind", {
	enumerable: false,
	writable: true,
	value: async function (fnFind) {
		for (let i = 0, len = this.length; i < len; ++i) if (await fnFind(this[i], i, this)) return this[i];
	},
});

Array.prototype.pSerialAwaitSome || Object.defineProperty(Array.prototype, "pSerialAwaitSome", {
	enumerable: false,
	writable: true,
	value: async function (fnSome) {
		for (let i = 0, len = this.length; i < len; ++i) if (await fnSome(this[i], i, this)) return true;
		return false;
	},
});

Array.prototype.pSerialAwaitFirst || Object.defineProperty(Array.prototype, "pSerialAwaitFirst", {
	enumerable: false,
	writable: true,
	value: async function (fnMapFind) {
		for (let i = 0, len = this.length; i < len; ++i) {
			const result = await fnMapFind(this[i], i, this);
			if (result) return result;
		}
	},
});

Array.prototype.unique || Object.defineProperty(Array.prototype, "unique", {
	enumerable: false,
	writable: true,
	value: function (fnGetProp) {
		const seen = new Set();
		return this.filter((...args) => {
			const val = fnGetProp ? fnGetProp(...args) : args[0];
			if (seen.has(val)) return false;
			seen.add(val);
			return true;
		});
	},
});

Array.prototype.zip || Object.defineProperty(Array.prototype, "zip", {
	enumerable: false,
	writable: true,
	value: function (otherArray) {
		const out = [];
		const len = Math.max(this.length, otherArray.length);
		for (let i = 0; i < len; ++i) {
			out.push([this[i], otherArray[i]]);
		}
		return out;
	},
});

Array.prototype.nextWrap || Object.defineProperty(Array.prototype, "nextWrap", {
	enumerable: false,
	writable: true,
	value: function (item) {
		const ix = this.indexOf(item);
		if (~ix) {
			if (ix + 1 < this.length) return this[ix + 1];
			else return this[0];
		} else return this.last();
	},
});

Array.prototype.prevWrap || Object.defineProperty(Array.prototype, "prevWrap", {
	enumerable: false,
	writable: true,
	value: function (item) {
		const ix = this.indexOf(item);
		if (~ix) {
			if (ix - 1 >= 0) return this[ix - 1];
			else return this.last();
		} else return this[0];
	},
});

Array.prototype.findLast || Object.defineProperty(Array.prototype, "findLast", {
	enumerable: false,
	writable: true,
	value: function (fn) {
		for (let i = this.length - 1; i >= 0; --i) if (fn(this[i])) return this[i];
	},
});

Array.prototype.findLastIndex || Object.defineProperty(Array.prototype, "findLastIndex", {
	enumerable: false,
	writable: true,
	value: function (fn) {
		for (let i = this.length - 1; i >= 0; --i) if (fn(this[i])) return i;
		return -1;
	},
});

Array.prototype.sum || Object.defineProperty(Array.prototype, "sum", {
	enumerable: false,
	writable: true,
	value: function () {
		let tmp = 0;
		const len = this.length;
		for (let i = 0; i < len; ++i) tmp += this[i];
		return tmp;
	},
});

Array.prototype.mean || Object.defineProperty(Array.prototype, "mean", {
	enumerable: false,
	writable: true,
	value: function () {
		return this.sum() / this.length;
	},
});

Array.prototype.meanAbsoluteDeviation || Object.defineProperty(Array.prototype, "meanAbsoluteDeviation", {
	enumerable: false,
	writable: true,
	value: function () {
		const mean = this.mean();
		return (this.map(num => Math.abs(num - mean)) || []).mean();
	},
});

Map.prototype.getOrSet || Object.defineProperty(Map.prototype, "getOrSet", {
	enumerable: false,
	writable: true,
	value: function (k, orV) {
		if (this.has(k)) return this.get(k);
		this.set(k, orV);
		return orV;
	},
});

// OVERLAY VIEW ========================================================================================================
/**
 * Relies on:
 * - page implementing HashUtil's `loadSubHash` with handling to show/hide the book view based on hashKey changes
 * - page running no-argument `loadSubHash` when `hashchange` occurs
 *
 * @param opts Options object.
 * @param opts.hashKey to use in the URL so that forward/back can open/close the view
 * @param opts.$openBtn jQuery-selected button to bind click open/close
 * @param opts.$eleNoneVisible "error" message to display if user has not selected any viewable content
 * @param opts.pageTitle Title.
 * @param opts.state State to modify when opening/closing.
 * @param opts.stateKey Key in state to set true/false when opening/closing.
 * @param opts.popTblGetNumShown function which should populate the view with HTML content and return the number of items displayed
 * @param [opts.hasPrintColumns] True if the overlay should contain a dropdown for adjusting print columns.
 * @param [opts.isHideContentOnNoneShown]
 * @param [opts.isHideButtonCloseNone]
 * @constructor
 */
function BookModeView (opts) {
	opts = opts || {};
	const {hashKey, $openBtn, $eleNoneVisible, pageTitle, popTblGetNumShown, isFlex, state, stateKey, isHideContentOnNoneShown, isHideButtonCloseNone} = opts;

	if (hashKey && stateKey) throw new Error();

	this.hashKey = hashKey;
	this.stateKey = stateKey;
	this.state = state;
	this.$openBtn = $openBtn;
	this.$eleNoneVisible = $eleNoneVisible;
	this.popTblGetNumShown = popTblGetNumShown;
	this.isHideContentOnNoneShown = isHideContentOnNoneShown;
	this.isHideButtonCloseNone = isHideButtonCloseNone;

	this.active = false;
	this._$body = null;
	this._$wrpBook = null;

	this._$wrpRenderedContent = null;
	this._$wrpNoneShown = null;
	this._doRenderContent = null; // N.B. currently unused, but can be used to refresh the contents of the view

	this.$openBtn.off("click").on("click", () => {
		if (this.stateKey) {
			this.state[this.stateKey] = true;
		} else {
			Hist.cleanSetHash(`${window.location.hash}${HASH_PART_SEP}${this.hashKey}${HASH_SUB_KV_SEP}true`);
		}
	});

	this.close = () => { return this._doHashTeardown(); };

	this._doHashTeardown = () => {
		if (this.stateKey) {
			this.state[this.stateKey] = false;
		} else {
			Hist.cleanSetHash(window.location.hash.replace(`${this.hashKey}${HASH_SUB_KV_SEP}true`, ""));
		}
	};

	this._renderContent = async ($wrpContent, $dispName, $wrpControlsToPass) => {
		this._$wrpRenderedContent = this._$wrpRenderedContent
			? this._$wrpRenderedContent.empty().append($wrpContent)
			: $$`<div class="bkmv__scroller smooth-scroll h-100 overflow-y-auto ${isFlex ? "ve-flex" : ""}">${this.isHideContentOnNoneShown ? null : $wrpContent}</div>`;
		this._$wrpRenderedContent.appendTo(this._$wrpBook);

		const numShown = await this.popTblGetNumShown({$wrpContent, $dispName, $wrpControls: $wrpControlsToPass});

		if (numShown) {
			if (this.isHideContentOnNoneShown) this._$wrpRenderedContent.append($wrpContent);
			if (this._$wrpNoneShown) {
				this._$wrpNoneShown.detach();
			}
		} else {
			if (this.isHideContentOnNoneShown) $wrpContent.detach();
			if (!this._$wrpNoneShown) {
				const $btnClose = $(`<button class="btn btn-default">Close</button>`)
					.click(() => this.close());

				this._$wrpNoneShown = $$`<div class="w-100 ve-flex-col ve-flex-h-center no-shrink bkmv__footer mb-3">
					<div class="mb-2 ve-flex-vh-center min-h-0">${this.$eleNoneVisible}</div>
					${this.isHideButtonCloseNone ? null : $$`<div class="ve-flex-vh-center">${$btnClose}</div>`}
				</div>`;
			}
			this._$wrpNoneShown.appendTo(this.isHideContentOnNoneShown ? this._$wrpRenderedContent : this._$wrpBook);
		}
	};

	// NOTE: Avoid using `ve-flex` css, as it doesn't play nice with printing
	this.pOpen = async () => {
		if (this.active) return;
		this.active = true;
		document.title = `${pageTitle} - 5etools`;

		this._$body = $(`body`);
		this._$wrpBook = $(`<div class="bkmv"></div>`);

		this._$body.css("overflow", "hidden");
		this._$body.addClass("bkmv-active");

		const $btnClose = $(`<button class="btn btn-xs btn-danger br-0 bt-0 bb-0 btl-0 bbl-0 h-20p" title="Close"><span class="glyphicon glyphicon-remove"></span></button>`)
			.click(() => this._doHashTeardown());
		const $dispName = $(`<div></div>`); // pass this to the content function to allow it to set a main header
		$$`<div class="bkmv__spacer-name split-v-center no-shrink">${$dispName}${$btnClose}</div>`.appendTo(this._$wrpBook);

		// region controls
		// Optionally usable "controls" section at the top of the pane
		const $wrpControls = $(`<div class="w-100 ve-flex-col bkmv__wrp-controls"></div>`)
			.appendTo(this._$wrpBook);

		let $wrpControlsToPass = $wrpControls;
		if (opts.hasPrintColumns) {
			$wrpControls.addClass("px-2 mt-2");

			const injectPrintCss = (cols) => {
				$(`#bkmv__print-style`).remove();
				$(`<style media="print" id="bkmv__print-style">.bkmv__wrp { column-count: ${cols}; }</style>`)
					.appendTo($(document.body));
			};

			const lastColumns = StorageUtil.syncGetForPage(BookModeView._BOOK_VIEW_COLUMNS_K);

			const $selColumns = $(`<select class="form-control input-sm">
				<option value="0">Two (book style)</option>
				<option value="1">One</option>
			</select>`)
				.change(() => {
					const val = Number($selColumns.val());
					if (val === 0) injectPrintCss(2);
					else injectPrintCss(1);

					StorageUtil.syncSetForPage(BookModeView._BOOK_VIEW_COLUMNS_K, val);
				});
			if (lastColumns != null) $selColumns.val(lastColumns);
			$selColumns.change();

			$wrpControlsToPass = $$`<div class="w-100 ve-flex">
				<div class="ve-flex-vh-center"><div class="mr-2 no-wrap help-subtle" title="Applied when printing the page.">Print columns:</div>${$selColumns}</div>
			</div>`.appendTo($wrpControls);
		}
		// endregion

		const $wrpContent = $(`<div class="bkmv__wrp p-2"></div>`);

		await this._renderContent($wrpContent, $dispName, $wrpControlsToPass);

		this._pRenderContent = () => this._renderContent($wrpContent, $dispName, $wrpControlsToPass);

		this._$body.append(this._$wrpBook);
	};

	this.teardown = () => {
		if (this.active) {
			if (this._$wrpRenderedContent) this._$wrpRenderedContent.detach();
			if (this._$wrpNoneShown) this._$wrpNoneShown.detach();

			this._$body.css("overflow", "");
			this._$body.removeClass("bkmv-active");
			this._$wrpBook.remove();
			this.active = false;

			this._pRenderContent = null;
		}
	};

	this.pHandleSub = (sub) => {
		if (this.stateKey) return; // Assume anything with state will handle this itself.

		const bookViewHash = sub.find(it => it.startsWith(this.hashKey));
		if (bookViewHash && UrlUtil.unpackSubHash(bookViewHash)[this.hashKey][0] === "true") return this.pOpen();
		else this.teardown();
	};
}
BookModeView._BOOK_VIEW_COLUMNS_K = "bookViewColumns";

// CONTENT EXCLUSION ===================================================================================================
globalThis.ExcludeUtil = {
	isInitialised: false,
	_excludes: null,
	_cache_excludesLookup: null,
	_lock: null,

	async pInitialise ({lockToken = null} = {}) {
		try {
			await ExcludeUtil._lock.pLock({token: lockToken});
			await ExcludeUtil._pInitialise();
		} finally {
			ExcludeUtil._lock.unlock();
		}
	},

	async _pInitialise () {
		if (ExcludeUtil.isInitialised) return;

		ExcludeUtil.pSave = MiscUtil.throttle(ExcludeUtil._pSave, 50);
		try {
			ExcludeUtil._excludes = await StorageUtil.pGet(VeCt.STORAGE_EXCLUDES) || [];
			ExcludeUtil._excludes = ExcludeUtil._excludes.filter(it => it.hash); // remove legacy rows
		} catch (e) {
			JqueryUtil.doToast({
				content: "Error when loading content blocklist! Purged blocklist data. (See the log for more information.)",
				type: "danger",
			});
			try {
				await StorageUtil.pRemove(VeCt.STORAGE_EXCLUDES);
			} catch (e) {
				setTimeout(() => { throw e; });
			}
			ExcludeUtil._excludes = null;
			window.location.hash = "";
			setTimeout(() => { throw e; });
		}
		ExcludeUtil.isInitialised = true;
	},

	getList () {
		return MiscUtil.copyFast(ExcludeUtil._excludes || []);
	},

	async pSetList (toSet) {
		ExcludeUtil._excludes = toSet;
		ExcludeUtil._cache_excludesLookup = null;
		await ExcludeUtil.pSave();
	},

	async pExtendList (toAdd) {
		try {
			const lockToken = await ExcludeUtil._lock.pLock();
			await ExcludeUtil._pExtendList({toAdd, lockToken});
		} finally {
			ExcludeUtil._lock.unlock();
		}
	},

	async _pExtendList ({toAdd, lockToken}) {
		await ExcludeUtil.pInitialise({lockToken});
		this._doBuildCache();

		const out = MiscUtil.copyFast(ExcludeUtil._excludes || []);
		MiscUtil.copyFast(toAdd || [])
			.filter(({hash, category, source}) => {
				if (!hash || !category || !source) return false;
				const cacheUid = ExcludeUtil._getCacheUids(hash, category, source, true);
				return !ExcludeUtil._cache_excludesLookup[cacheUid];
			})
			.forEach(it => out.push(it));

		await ExcludeUtil.pSetList(out);
	},

	_doBuildCache () {
		if (ExcludeUtil._cache_excludesLookup) return;
		if (!ExcludeUtil._excludes) return;

		ExcludeUtil._cache_excludesLookup = {};
		ExcludeUtil._excludes.forEach(({source, category, hash}) => {
			const cacheUid = ExcludeUtil._getCacheUids(hash, category, source, true);
			ExcludeUtil._cache_excludesLookup[cacheUid] = true;
		});
	},

	_getCacheUids (hash, category, source, isExact) {
		hash = (hash || "").toLowerCase();
		category = (category || "").toLowerCase();
		source = (source?.source || source || "").toLowerCase();

		const exact = `${hash}__${category}__${source}`;
		if (isExact) return [exact];

		return [
			`${hash}__${category}__${source}`,
			`*__${category}__${source}`,
			`${hash}__*__${source}`,
			`${hash}__${category}__*`,
			`*__*__${source}`,
			`*__${category}__*`,
			`${hash}__*__*`,
			`*__*__*`,
		];
	},

	_excludeCount: 0,
	/**
	 * @param hash
	 * @param category
	 * @param source
	 * @param [opts]
	 * @param [opts.isNoCount]
	 */
	isExcluded (hash, category, source, opts) {
		if (!ExcludeUtil._excludes || !ExcludeUtil._excludes.length) return false;
		if (!source) throw new Error(`Entity had no source!`);
		opts = opts || {};

		this._doBuildCache();

		hash = (hash || "").toLowerCase();
		category = (category || "").toLowerCase();
		source = (source.source || source || "").toLowerCase();

		const isExcluded = ExcludeUtil._isExcluded(hash, category, source);
		if (!isExcluded) return isExcluded;

		if (!opts.isNoCount) ++ExcludeUtil._excludeCount;

		return isExcluded;
	},

	_isExcluded (hash, category, source) {
		for (const cacheUid of ExcludeUtil._getCacheUids(hash, category, source)) {
			if (ExcludeUtil._cache_excludesLookup[cacheUid]) return true;
		}
		return false;
	},

	isAllContentExcluded (list) { return (!list.length && ExcludeUtil._excludeCount) || (list.length > 0 && list.length === ExcludeUtil._excludeCount); },
	getAllContentBlocklistedHtml () { return `<div class="initial-message">(All content <a href="blocklist.html">blocklisted</a>)</div>`; },

	async _pSave () {
		return StorageUtil.pSet(VeCt.STORAGE_EXCLUDES, ExcludeUtil._excludes);
	},

	// The throttled version, available post-initialisation
	async pSave () { /* no-op */ },
};

// EXTENSIONS ==========================================================================================================
globalThis.ExtensionUtil = {
	ACTIVE: false,

	_doSend (type, data) {
		const detail = MiscUtil.copy({type, data}); // Note that this needs to include `JSON.parse` to function
		window.dispatchEvent(new CustomEvent("rivet.send", {detail}));
	},

	async pDoSendStats (evt, ele) {
		const {page, source, hash, extensionData} = ExtensionUtil._getElementData({ele});

		if (page && source && hash) {
			let toSend = ExtensionUtil._getEmbeddedFromCache(page, source, hash)
				|| await DataLoader.pCacheAndGet(page, source, hash);

			if (extensionData) {
				switch (page) {
					case UrlUtil.PG_BESTIARY: {
						if (extensionData._scaledCr) toSend = await ScaleCreature.scale(toSend, extensionData._scaledCr);
						else if (extensionData._scaledSpellSummonLevel) toSend = await ScaleSpellSummonedCreature.scale(toSend, extensionData._scaledSpellSummonLevel);
						else if (extensionData._scaledClassSummonLevel) toSend = await ScaleClassSummonedCreature.scale(toSend, extensionData._scaledClassSummonLevel);
					}
				}
			}

			ExtensionUtil._doSend("entity", {page, entity: toSend, isTemp: !!evt.shiftKey});
		}
	},

	async doDragStart (evt, ele) {
		const {page, source, hash} = ExtensionUtil._getElementData({ele});
		const meta = {
			type: VeCt.DRAG_TYPE_IMPORT,
			page,
			source,
			hash,
		};
		evt.dataTransfer.setData("application/json", JSON.stringify(meta));
	},

	_getElementData ({ele}) {
		const $parent = $(ele).closest(`[data-page]`);
		const page = $parent.attr("data-page");
		const source = $parent.attr("data-source");
		const hash = $parent.attr("data-hash");
		const rawExtensionData = $parent.attr("data-extension");
		const extensionData = rawExtensionData ? JSON.parse(rawExtensionData) : null;

		return {page, source, hash, extensionData};
	},

	pDoSendStatsPreloaded ({page, entity, isTemp, options}) {
		ExtensionUtil._doSend("entity", {page, entity, isTemp, options});
	},

	pDoSendCurrency ({currency}) {
		ExtensionUtil._doSend("currency", {currency});
	},

	doSendRoll (data) { ExtensionUtil._doSend("roll", data); },

	pDoSend ({type, data}) { ExtensionUtil._doSend(type, data); },

	/* -------------------------------------------- */

	_CACHE_EMBEDDED_STATS: {},

	addEmbeddedToCache (page, source, hash, ent) {
		MiscUtil.set(ExtensionUtil._CACHE_EMBEDDED_STATS, page.toLowerCase(), source.toLowerCase(), hash.toLowerCase(), MiscUtil.copyFast(ent));
	},

	_getEmbeddedFromCache (page, source, hash) {
		return MiscUtil.get(ExtensionUtil._CACHE_EMBEDDED_STATS, page.toLowerCase(), source.toLowerCase(), hash.toLowerCase());
	},

	/* -------------------------------------------- */
};
if (typeof window !== "undefined") window.addEventListener("rivet.active", () => ExtensionUtil.ACTIVE = true);

// TOKENS ==============================================================================================================
globalThis.TokenUtil = {
	handleStatblockScroll (event, ele) {
		$(`#token_image`)
			.toggle(ele.scrollTop < 32)
			.css({
				opacity: (32 - ele.scrollTop) / 32,
				top: -ele.scrollTop,
			});
	},
};

// LOCKS ===============================================================================================================
/**
 * @param {string} name
 * @param {boolean} isDbg
 * @constructor
 */
globalThis.VeLock = function ({name = null, isDbg = false} = {}) {
	this._name = name;
	this._isDbg = isDbg;
	this._lockMeta = null;

	this._getCaller = () => {
		return (new Error()).stack.split("\n")[3].trim();
	};

	this.pLock = async ({token = null} = {}) => {
		if (token != null && this._lockMeta?.token === token) {
			++this._lockMeta.depth;
			// eslint-disable-next-line no-console
			if (this._isDbg) console.warn(`Lock "${this._name || "(unnamed)"}" add (now ${this._lockMeta.depth}) at ${this._getCaller()}`);
			return token;
		}

		while (this._lockMeta) await this._lockMeta.lock;

		// eslint-disable-next-line no-console
		if (this._isDbg) console.warn(`Lock "${this._name || "(unnamed)"}" acquired at ${this._getCaller()}`);

		let unlock = null;
		const lock = new Promise(resolve => unlock = resolve);
		this._lockMeta = {
			lock,
			unlock,
			token: CryptUtil.uid(),
			depth: 0,
		};

		return this._lockMeta.token;
	};

	this.unlock = () => {
		if (!this._lockMeta) return;

		if (this._lockMeta.depth > 0) {
			// eslint-disable-next-line no-console
			if (this._isDbg) console.warn(`Lock "${this._name || "(unnamed)"}" sub (now ${this._lockMeta.depth - 1}) at ${this._getCaller()}`);
			return --this._lockMeta.depth;
		}

		// eslint-disable-next-line no-console
		if (this._isDbg) console.warn(`Lock "${this._name || "(unnamed)"}" released at ${this._getCaller()}`);

		const lockMeta = this._lockMeta;
		this._lockMeta = null;
		lockMeta.unlock();
	};
};
ExcludeUtil._lock = new VeLock();

// DATETIME ============================================================================================================
globalThis.DatetimeUtil = {
	getDateStr ({date, isShort = false, isPad = false} = {}) {
		const month = DatetimeUtil._MONTHS[date.getMonth()];
		return `${isShort ? month.substring(0, 3) : month} ${isPad && date.getDate() < 10 ? "\u00A0" : ""}${Parser.getOrdinalForm(date.getDate())}, ${date.getFullYear()}`;
	},

	getDatetimeStr ({date, isPlainText = false} = {}) {
		date = date ?? new Date();
		const monthName = DatetimeUtil._MONTHS[date.getMonth()];
		return `${date.getDate()} ${!isPlainText ? `<span title="${monthName}">` : ""}${monthName.substring(0, 3)}.${!isPlainText ? `</span>` : ""} ${date.getFullYear()}, ${DatetimeUtil._getPad2(date.getHours())}:${DatetimeUtil._getPad2(date.getMinutes())}:${DatetimeUtil._getPad2(date.getSeconds())}`;
	},

	_getPad2 (num) { return `${num}`.padStart(2, "0"); },

	getIntervalStr (millis) {
		if (millis < 0 || isNaN(millis)) return "(Unknown interval)";

		const s = number => (number !== 1) ? "s" : "";

		const stack = [];

		let numSecs = Math.floor(millis / 1000);

		const numYears = Math.floor(numSecs / DatetimeUtil._SECS_PER_YEAR);
		if (numYears) {
			stack.push(`${numYears} year${s(numYears)}`);
			numSecs = numSecs - (numYears * DatetimeUtil._SECS_PER_YEAR);
		}

		const numDays = Math.floor(numSecs / DatetimeUtil._SECS_PER_DAY);
		if (numDays) {
			stack.push(`${numDays} day${s(numDays)}`);
			numSecs = numSecs - (numDays * DatetimeUtil._SECS_PER_DAY);
		}

		const numHours = Math.floor(numSecs / DatetimeUtil._SECS_PER_HOUR);
		if (numHours) {
			stack.push(`${numHours} hour${s(numHours)}`);
			numSecs = numSecs - (numHours * DatetimeUtil._SECS_PER_HOUR);
		}

		const numMinutes = Math.floor(numSecs / DatetimeUtil._SECS_PER_MINUTE);
		if (numMinutes) {
			stack.push(`${numMinutes} minute${s(numMinutes)}`);
			numSecs = numSecs - (numMinutes * DatetimeUtil._SECS_PER_MINUTE);
		}

		if (numSecs) stack.push(`${numSecs} second${s(numSecs)}`);
		else if (!stack.length) stack.push("less than a second"); // avoid adding this if there's already info

		return stack.join(", ");
	},
};
DatetimeUtil._MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
DatetimeUtil._SECS_PER_YEAR = 31536000;
DatetimeUtil._SECS_PER_DAY = 86400;
DatetimeUtil._SECS_PER_HOUR = 3600;
DatetimeUtil._SECS_PER_MINUTE = 60;

globalThis.EditorUtil = {
	getTheme () {
		const {isNight} = styleSwitcher.getSummary();
		return isNight ? "ace/theme/tomorrow_night" : "ace/theme/textmate";
	},

	initEditor (id, additionalOpts = null) {
		additionalOpts = additionalOpts || {};

		const editor = ace.edit(id);
		editor.setOptions({
			theme: EditorUtil.getTheme(),
			wrap: true,
			showPrintMargin: false,
			tabSize: 2,
			useWorker: false,
			...additionalOpts,
		});

		styleSwitcher.addFnOnChange(() => editor.setOptions({theme: EditorUtil.getTheme()}));

		return editor;
	},
};

// MISC WEBPAGE ONLOADS ================================================================================================
if (!IS_VTT && typeof window !== "undefined") {
	window.addEventListener("load", () => {
		const docRoot = document.querySelector(":root");

		if (CSS?.supports("top: constant(safe-area-inset-top)")) {
			docRoot.style.setProperty("--safe-area-inset-top", "constant(safe-area-inset-top, 0)");
			docRoot.style.setProperty("--safe-area-inset-right", "constant(safe-area-inset-right, 0)");
			docRoot.style.setProperty("--safe-area-inset-bottom", "constant(safe-area-inset-bottom, 0)");
			docRoot.style.setProperty("--safe-area-inset-left", "constant(safe-area-inset-left, 0)");
		} else if (CSS?.supports("top: env(safe-area-inset-top)")) {
			docRoot.style.setProperty("--safe-area-inset-top", "env(safe-area-inset-top, 0)");
			docRoot.style.setProperty("--safe-area-inset-right", "env(safe-area-inset-right, 0)");
			docRoot.style.setProperty("--safe-area-inset-bottom", "env(safe-area-inset-bottom, 0)");
			docRoot.style.setProperty("--safe-area-inset-left", "env(safe-area-inset-left, 0)");
		}
	});

	window.addEventListener("load", () => {
		$(document.body)
			.on("click", `[data-packed-dice]`, evt => {
				Renderer.dice.pRollerClickUseData(evt, evt.currentTarget);
			});
		Renderer.events.bindGeneric();
	});

	if (location.origin === VeCt.LOC_ORIGIN_CANCER) {
		const ivsCancer = [];

		window.addEventListener("load", () => {
			let isPadded = false;
			let anyFound = false;
			[
				"div-gpt-ad-5etools35927", // main banner
				"div-gpt-ad-5etools35930", // side banner
				"div-gpt-ad-5etools35928", // sidebar top
				"div-gpt-ad-5etools35929", // sidebar bottom
				"div-gpt-ad-5etools36159", // bottom floater
				"div-gpt-ad-5etools36834", // mobile middle
			].forEach(id => {
				const iv = setInterval(() => {
					const $wrp = $(`#${id}`);
					if (!$wrp.length) return;
					if (!$wrp.children().length) return;
					if ($wrp.children()[0].tagName === "SCRIPT") return;
					const $tgt = $wrp.closest(".cancer__anchor").find(".cancer__disp-cancer");
					if ($tgt.length) {
						anyFound = true;
						$tgt.css({display: "flex"}).text("Advertisements");
						clearInterval(iv);
					}
				}, 250);

				ivsCancer.push(iv);
			});

			const ivPad = setInterval(() => {
				if (!anyFound) return;
				if (isPadded) return;
				isPadded = true;
				// Pad the bottom of the page so the adhesive unit doesn't overlap the content
				$(`.view-col-group--cancer`).append(`<div class="w-100 no-shrink" style="height: 110px;"></div>`);
			}, 300);
			ivsCancer.push(ivPad);
		});

		// Hack to lock the ad space at original size--prevents the screen from shifting around once loaded
		setTimeout(() => {
			const $wrp = $(`.cancer__wrp-leaderboard-inner`);
			const h = $wrp.outerHeight();
			$wrp.css({height: h});
			ivsCancer.forEach(iv => clearInterval(iv));
		}, 5000);
	} else {
		window.addEventListener("load", () => $(`.cancer__anchor`).remove());
	}

	// window.addEventListener("load", () => {
	// 	$(`.cancer__sidebar-rhs-inner--top`).append(`<div class="TEST_RHS_TOP"></div>`)
	// 	$(`.cancer__sidebar-rhs-inner--bottom`).append(`<div class="TEST_RHS_BOTTOM"></div>`)
	// });
}

globalThis._Donate = {
	// TAG Disabled until further notice
	/*
	init () {
		if (IS_DEPLOYED) {
			DataUtil.loadJSON(`https://get.5etools.com/money.php`).then(dosh => {
				const pct = Number(dosh.donated) / Number(dosh.Goal);
				$(`#don-total`).text(`€${dosh.Goal}`);
				if (isNaN(pct)) {
					throw new Error(`Was not a number! Values were ${dosh.donated} and ${dosh.Goal}`);
				} else {
					const $bar = $(`.don__bar_inner`);
					$bar.css("width", `${Math.min(Math.ceil(100 * pct), 100)}%`).html(pct !== 0 ? `€${dosh.donated}&nbsp;` : "");
					if (pct >= 1) $bar.css("background-color", "lightgreen");
				}
			}).catch(noDosh => {
				$(`#don-wrapper`).remove();
				throw noDosh;
			});
		}
	},

	async pNotDonating () {
		const isFake = await StorageUtil.pIsAsyncFake();
		const isNotDonating = await StorageUtil.pGet("notDonating");
		return isFake || isNotDonating;
	},
	*/

	// region Test code, please ignore
	cycleLeader (ele) {
		const modes = [{width: 970, height: 90}, {width: 970, height: 250}, {width: 320, height: 50}, {width: 728, height: 90}];
		_Donate._cycleMode(ele, modes);
	},

	cycleSide (ele) {
		const modes = [{width: 300, height: 250}, {width: 300, height: 600}];
		_Donate._cycleMode(ele, modes);
	},

	_cycleMode (ele, modes) {
		const $e = $(ele);
		const pos = $e.data("pos") || 0;
		const mode = modes[pos];
		$e.css(mode);
		$e.text(`${mode.width}*${mode.height}`);
		$e.data("pos", (pos + 1) % modes.length);
	},
	// endregion
};

}).toString());



EXT_LIB_SCRIPTS.push((function lib_script_5 () {
"use strict";

class Prx {
	static addHook (prop, hook) {
		this.px._hooks[prop] = this.px._hooks[prop] || [];
		this.px._hooks[prop].push(hook);
	}

	static addHookAll (hook) {
		this.px._hooksAll.push(hook);
	}

	static toString () {
		return JSON.stringify(this, (k, v) => k === "px" ? undefined : v);
	}

	static copy () {
		return JSON.parse(Prx.toString.bind(this)());
	}

	static get (toProxy) {
		toProxy.px = {
			addHook: Prx.addHook.bind(toProxy),
			addHookAll: Prx.addHookAll.bind(toProxy),
			toString: Prx.toString.bind(toProxy),
			copy: Prx.copy.bind(toProxy),
			_hooksAll: [],
			_hooks: {},
		};

		return new Proxy(toProxy, {
			set: (object, prop, value) => {
				object[prop] = value;
				toProxy.px._hooksAll.forEach(hook => hook(prop, value));
				if (toProxy.px._hooks[prop]) toProxy.px._hooks[prop].forEach(hook => hook(prop, value));
				return true;
			},
			deleteProperty: (object, prop) => {
				delete object[prop];
				toProxy.px._hooksAll.forEach(hook => hook(prop, null));
				if (toProxy.px._hooks[prop]) toProxy.px._hooks[prop].forEach(hook => hook(prop, null));
				return true;
			},
		});
	}
}

function MixinProxyBase (Cls) {
	class MixedProxyBase extends Cls {
		constructor (...args) {
			super(...args);
			this.__hooks = {};
			this.__hooksAll = {};
			this.__hooksTmp = null;
			this.__hooksAllTmp = null;
		}

		_getProxy (hookProp, toProxy) {
			return new Proxy(toProxy, {
				set: (object, prop, value) => {
					return this._doProxySet(hookProp, object, prop, value);
				},
				deleteProperty: (object, prop) => {
					if (!(prop in object)) return true;
					const prevValue = object[prop];
					Reflect.deleteProperty(object, prop);
					this._doFireHooksAll(hookProp, prop, undefined, prevValue);
					if (this.__hooks[hookProp] && this.__hooks[hookProp][prop]) this.__hooks[hookProp][prop].forEach(hook => hook(prop, undefined, prevValue));
					return true;
				},
			});
		}

		_doProxySet (hookProp, object, prop, value) {
			if (object[prop] === value) return true;
			const prevValue = object[prop];
			Reflect.set(object, prop, value);
			this._doFireHooksAll(hookProp, prop, value, prevValue);
			this._doFireHooks(hookProp, prop, value, prevValue);
			return true;
		}

		/** As per `_doProxySet`, but the hooks are run strictly in serial. */
		async _pDoProxySet (hookProp, object, prop, value) {
			if (object[prop] === value) return true;
			const prevValue = object[prop];
			Reflect.set(object, prop, value);
			if (this.__hooksAll[hookProp]) for (const hook of this.__hooksAll[hookProp]) await hook(prop, value, prevValue);
			if (this.__hooks[hookProp] && this.__hooks[hookProp][prop]) for (const hook of this.__hooks[hookProp][prop]) await hook(prop, value, prevValue);
			return true;
		}

		_doFireHooks (hookProp, prop, value, prevValue) {
			if (this.__hooks[hookProp] && this.__hooks[hookProp][prop]) this.__hooks[hookProp][prop].forEach(hook => hook(prop, value, prevValue));
		}

		_doFireHooksAll (hookProp, prop, value, prevValue) {
			if (this.__hooksAll[hookProp]) this.__hooksAll[hookProp].forEach(hook => hook(prop, undefined, prevValue));
		}

		// ...Not to be confused with...

		_doFireAllHooks (hookProp) {
			if (this.__hooks[hookProp]) Object.entries(this.__hooks[hookProp]).forEach(([prop, hk]) => hk(prop));
		}

		/**
		 * Register a hook versus a root property on the state object. **INTERNAL CHANGES TO CHILD OBJECTS ON THE STATE
		 *   OBJECT ARE NOT TRACKED**.
		 * @param hookProp The state object.
		 * @param prop The root property to track.
		 * @param hook The hook to run. Will be called with two arguments; the property and the value of the property being
		 *   modified.
		 */
		_addHook (hookProp, prop, hook) {
			ProxyBase._addHook_to(this.__hooks, hookProp, prop, hook);
			if (this.__hooksTmp) ProxyBase._addHook_to(this.__hooksTmp, hookProp, prop, hook);
			return hook;
		}

		static _addHook_to (obj, hookProp, prop, hook) {
			((obj[hookProp] = obj[hookProp] || {})[prop] = (obj[hookProp][prop] || [])).push(hook);
		}

		_addHookAll (hookProp, hook) {
			ProxyBase._addHookAll_to(this.__hooksAll, hookProp, hook);
			if (this.__hooksAllTmp) ProxyBase._addHookAll_to(this.__hooksAllTmp, hookProp, hook);
		}

		static _addHookAll_to (obj, hookProp, hook) {
			(obj[hookProp] = obj[hookProp] || []).push(hook);
		}

		_removeHook (hookProp, prop, hook) {
			ProxyBase._removeHook_from(this.__hooks, hookProp, prop, hook);
			if (this.__hooksTmp) ProxyBase._removeHook_from(this.__hooksTmp, hookProp, prop, hook);
		}

		static _removeHook_from (obj, hookProp, prop, hook) {
			if (obj[hookProp] && obj[hookProp][prop]) {
				const ix = obj[hookProp][prop].findIndex(hk => hk === hook);
				if (~ix) obj[hookProp][prop].splice(ix, 1);
			}
		}

		_removeHooks (hookProp, prop) {
			if (this.__hooks[hookProp]) delete this.__hooks[hookProp][prop];
			if (this.__hooksTmp && this.__hooksTmp[hookProp]) delete this.__hooksTmp[hookProp][prop];
		}

		_removeHookAll (hookProp, hook) {
			ProxyBase._removeHookAll_from(this.__hooksAll, hookProp, hook);
			if (this.__hooksAllTmp) ProxyBase._removeHook_from(this.__hooksAllTmp, hookProp, hook);
		}

		static _removeHookAll_from (obj, hookProp, hook) {
			if (obj[hookProp]) {
				const ix = obj[hookProp].findIndex(hk => hk === hook);
				if (~ix) obj[hookProp].splice(ix, 1);
			}
		}

		_resetHooks (hookProp) {
			if (hookProp !== undefined) delete this.__hooks[hookProp];
			else Object.keys(this.__hooks).forEach(prop => delete this.__hooks[prop]);
		}

		_resetHooksAll (hookProp) {
			if (hookProp !== undefined) delete this.__hooksAll[hookProp];
			else Object.keys(this.__hooksAll).forEach(prop => delete this.__hooksAll[prop]);
		}

		_saveHookCopiesTo (obj) { this.__hooksTmp = obj; }
		_saveHookAllCopiesTo (obj) { this.__hooksAllTmp = obj; }

		/**
		 * Object.assign equivalent, overwrites values on the current proxied object with some new values,
		 *   then trigger all the appropriate event handlers.
		 * @param hookProp Hook property, e.g. "state".
		 * @param proxyProp Proxied object property, e.g. "_state".
		 * @param underProp Underlying object property, e.g. "__state".
		 * @param toObj
		 * @param isOverwrite If the overwrite should clean/delete all data from the object beforehand.
		 */
		_proxyAssign (hookProp, proxyProp, underProp, toObj, isOverwrite) {
			const oldKeys = Object.keys(this[proxyProp]);
			const nuKeys = new Set(Object.keys(toObj));
			const dirtyKeyValues = {};

			if (isOverwrite) {
				oldKeys.forEach(k => {
					if (!nuKeys.has(k) && this[underProp] !== undefined) {
						const prevValue = this[proxyProp][k];
						delete this[underProp][k];
						dirtyKeyValues[k] = prevValue;
					}
				});
			}

			nuKeys.forEach(k => {
				if (!CollectionUtil.deepEquals(this[underProp][k], toObj[k])) {
					const prevValue = this[proxyProp][k];
					this[underProp][k] = toObj[k];
					dirtyKeyValues[k] = prevValue;
				}
			});

			Object.entries(dirtyKeyValues)
				.forEach(([k, prevValue]) => {
					this._doFireHooksAll(hookProp, k, this[underProp][k], prevValue);
					if (this.__hooks[hookProp] && this.__hooks[hookProp][k]) this.__hooks[hookProp][k].forEach(hk => hk(k, this[underProp][k], prevValue));
				});
		}

		_proxyAssignSimple (hookProp, toObj, isOverwrite) {
			return this._proxyAssign(hookProp, `_${hookProp}`, `__${hookProp}`, toObj, isOverwrite);
		}
	}

	return MixedProxyBase;
}

class ProxyBase extends MixinProxyBase(class {}) {}

globalThis.ProxyBase = ProxyBase;

class UiUtil {
	/**
	 * @param string String to parse.
	 * @param [fallbackEmpty] Fallback number if string is empty.
	 * @param [opts] Options Object.
	 * @param [opts.max] Max allowed return value.
	 * @param [opts.min] Min allowed return value.
	 * @param [opts.fallbackOnNaN] Return value if not a number.
	 */
	static strToInt (string, fallbackEmpty = 0, opts) { return UiUtil._strToNumber(string, fallbackEmpty, opts, true); }

	/**
	 * @param string String to parse.
	 * @param [fallbackEmpty] Fallback number if string is empty.
	 * @param [opts] Options Object.
	 * @param [opts.max] Max allowed return value.
	 * @param [opts.min] Min allowed return value.
	 * @param [opts.fallbackOnNaN] Return value if not a number.
	 */
	static strToNumber (string, fallbackEmpty = 0, opts) { return UiUtil._strToNumber(string, fallbackEmpty, opts, false); }

	static _strToNumber (string, fallbackEmpty = 0, opts, isInt) {
		opts = opts || {};
		let out;
		string = string.trim();
		if (!string) out = fallbackEmpty;
		else {
			const num = UiUtil._parseStrAsNumber(string, isInt);
			out = isNaN(num) || !isFinite(num)
				? opts.fallbackOnNaN !== undefined ? opts.fallbackOnNaN : 0
				: num;
		}
		if (opts.max != null) out = Math.min(out, opts.max);
		if (opts.min != null) out = Math.max(out, opts.min);
		return out;
	}

	/**
	 * @param string String to parse.
	 * @param [fallbackEmpty] Fallback value if string is empty.
	 * @param [opts] Options Object.
	 * @param [opts.fallbackOnNaB] Return value if not a boolean.
	 */
	static strToBool (string, fallbackEmpty = null, opts) {
		opts = opts || {};
		if (!string) return fallbackEmpty;
		string = string.trim().toLowerCase();
		if (!string) return fallbackEmpty;
		return string === "true" ? true : string === "false" ? false : opts.fallbackOnNaB;
	}

	static intToBonus (int, {isPretty = false} = {}) { return `${int >= 0 ? "+" : int < 0 ? (isPretty ? "\u2012" : "-") : ""}${Math.abs(int)}`; }

	static getEntriesAsText (entryArray) {
		if (!entryArray || !entryArray.length) return "";
		if (!(entryArray instanceof Array)) return UiUtil.getEntriesAsText([entryArray]);

		return entryArray
			.map(it => {
				if (typeof it === "string" || typeof it === "number") return it;

				return JSON.stringify(it, null, 2)
					.split("\n")
					.map(it => `  ${it}`) // Indent non-string content
				;
			})
			.flat()
			.join("\n");
	}

	static getTextAsEntries (text) {
		try {
			const lines = text
				.split("\n")
				.filter(it => it.trim())
				.map(it => {
					if (/^\s/.exec(it)) return it; // keep indented lines as-is
					return `"${it.replace(/"/g, `\\"`)}",`; // wrap strings
				})
				.map(it => {
					if (/[}\]]$/.test(it.trim())) return `${it},`; // Add trailing commas to closing `}`/`]`
					return it;
				});
			const json = `[\n${lines.join("")}\n]`
				// remove trailing commas
				.replace(/(.*?)(,)(:?\s*]|\s*})/g, "$1$3");
			return JSON.parse(json);
		} catch (e) {
			const lines = text.split("\n").filter(it => it.trim());
			const slice = lines.join(" \\ ").substring(0, 30);
			JqueryUtil.doToast({
				content: `Could not parse entries! Error was: ${e.message}<br>Text was: ${slice}${slice.length === 30 ? "..." : ""}`,
				type: "danger",
			});
			return lines;
		}
	}

	/**
	 * @param {Object} [opts] Options object.
	 * @param {string} [opts.title] Modal title.
	 *
	 * @param {string} [opts.title] Modal title.
	 *
	 * @param {string} [opts.window] Browser window.
	 *
	 * @param [opts.isUncappedHeight] {boolean}
	 * @param [opts.isUncappedWidth] {boolean}
	 * @param [opts.isHeight100] {boolean}
	 * @param [opts.isWidth100] {boolean}
	 * @param [opts.isMinHeight0] {boolean}
	 * @param [opts.isMaxWidth640p] {boolean}
	 * @param [opts.isFullscreenModal] {boolean} An alternate mode.
	 * @param [opts.isHeaderBorder] {boolean}
	 *
	 * @param {function} [opts.cbClose] Callback run when the modal is closed.
	 * @param {JQuery} [opts.$titleSplit] Element to have split alongside the title.
	 * @param {int} [opts.zIndex] Z-index of the modal.
	 * @param {number} [opts.overlayColor] Overlay color.
	 * @param {boolean} [opts.isPermanent] If the modal should be impossible to close.
	 * @param {boolean} [opts.isIndestructible] If the modal elements should be detached, not removed.
	 * @param {boolean} [opts.isClosed] If the modal should start off closed.
	 * @param {boolean} [opts.isEmpty] If the modal should contain no content.
	 * @param {boolean} [opts.hasFooter] If the modal has a footer.
	 * @returns {object}
	 */
	static getShowModal (opts) {
		opts = opts || {};

		const doc = (opts.window || window).document;

		UiUtil._initModalEscapeHandler({doc});
		UiUtil._initModalMouseupHandlers({doc});
		if (doc.activeElement) doc.activeElement.blur(); // blur any active element as it will be behind the modal

		let resolveModal;
		const pResolveModal = new Promise(resolve => { resolveModal = resolve; });

		// if the user closed the modal by clicking the "cancel" background, isDataEntered is false
		const pHandleCloseClick = async (isDataEntered, ...args) => {
			if (opts.cbClose) await opts.cbClose(isDataEntered, ...args);
			resolveModal([isDataEntered, ...args]);

			if (opts.isIndestructible) wrpOverlay.detach();
			else wrpOverlay.remove();

			doTeardown();
		};

		const doTeardown = () => {
			UiUtil._popFromModalStack(modalStackMeta);
			if (!UiUtil._MODAL_STACK.length) doc.body.classList.remove(`ui-modal__body-active`);
		};

		const doOpen = () => {
			wrpOverlay.appendTo(doc.body);
			doc.body.classList.add(`ui-modal__body-active`);
		};

		const wrpOverlay = e_({tag: "div", clazz: "ui-modal__overlay"});
		if (opts.zIndex != null) wrpOverlay.style.zIndex = `${opts.zIndex}`;
		if (opts.overlayColor != null) wrpOverlay.style.backgroundColor = `${opts.overlayColor}`;

		// In "fullscreen" mode, blank out the modal background
		const overlayBlind = opts.isFullscreenModal
			? e_({
				tag: "div",
				clazz: `ui-modal__overlay-blind w-100 h-100 ve-flex-col`,
			}).appendTo(wrpOverlay)
			: null;

		const wrpScroller = e_({
			tag: "div",
			clazz: `ui-modal__scroller ve-flex-col`,
		});

		const modalWindowClasses = [
			opts.isWidth100 ? `w-100` : "",
			opts.isHeight100 ? "h-100" : "",
			opts.isUncappedHeight ? "ui-modal__inner--uncap-height" : "",
			opts.isUncappedWidth ? "ui-modal__inner--uncap-width" : "",
			opts.isMinHeight0 ? `ui-modal__inner--no-min-height` : "",
			opts.isMaxWidth640p ? `ui-modal__inner--max-width-640p` : "",
			opts.isFullscreenModal ? `ui-modal__inner--mode-fullscreen my-0 pt-0` : "",
			opts.hasFooter ? `pb-0` : "",
		].filter(Boolean);

		const btnCloseModal = opts.isFullscreenModal ? e_({
			tag: "button",
			clazz: `btn btn-danger btn-xs`,
			html: `<span class="glyphicon glyphicon-remove></span>`,
			click: pHandleCloseClick(false),
		}) : null;

		const modalFooter = opts.hasFooter
			? e_({
				tag: "div",
				clazz: `"no-shrink w-100 ve-flex-col ui-modal__footer ${opts.isFullscreenModal ? `ui-modal__footer--fullscreen mt-1` : ""}`,
			})
			: null;

		const modal = e_({
			tag: "div",
			clazz: `ui-modal__inner ve-flex-col ${modalWindowClasses.join(" ")}`,
			children: [
				!opts.isEmpty && opts.title
					? e_({
						tag: "div",
						clazz: `split-v-center no-shrink ${opts.isHeaderBorder ? `ui-modal__header--border` : ""} ${opts.isFullscreenModal ? `ui-modal__header--fullscreen mb-1` : ""}`,
						children: [
							opts.title
								? e_({
									tag: "h4",
									clazz: `my-2`,
									html: opts.title.qq(),
								})
								: null,

							opts.$titleSplit ? opts.$titleSplit[0] : null,

							btnCloseModal,
						].filter(Boolean),
					})
					: null,

				!opts.isEmpty ? wrpScroller : null,

				modalFooter,
			].filter(Boolean),
		}).appendTo(opts.isFullscreenModal ? overlayBlind : wrpOverlay);

		wrpOverlay
			.addEventListener("mouseup", evt => {
				if (evt.target !== wrpOverlay) return;
				if (evt.target !== UiUtil._MODAL_LAST_MOUSEDOWN) return;
				if (opts.isPermanent) return;
				evt.stopPropagation();
				evt.preventDefault();
				return pHandleCloseClick(false);
			});

		if (!opts.isClosed) doOpen();

		const modalStackMeta = {
			isPermanent: opts.isPermanent,
			pHandleCloseClick,
			doTeardown,
		};
		if (!opts.isClosed) UiUtil._pushToModalStack(modalStackMeta);

		const out = {
			$modal: $(modal),
			$modalInner: $(wrpScroller),
			$modalFooter: $(modalFooter),
			doClose: pHandleCloseClick,
			doTeardown,
			pGetResolved: () => pResolveModal,
		};

		if (opts.isIndestructible || opts.isClosed) {
			out.doOpen = () => {
				UiUtil._pushToModalStack(modalStackMeta);
				doOpen();
			};
		}

		return out;
	}

	/**
	 * Async to support external overrides; should be used in common applications.
	 */
	static async pGetShowModal (opts) {
		return UiUtil.getShowModal(opts);
	}

	static _pushToModalStack (modalStackMeta) {
		if (!UiUtil._MODAL_STACK.includes(modalStackMeta)) {
			UiUtil._MODAL_STACK.push(modalStackMeta);
		}
	}

	static _popFromModalStack (modalStackMeta) {
		const ixStack = UiUtil._MODAL_STACK.indexOf(modalStackMeta);
		if (~ixStack) UiUtil._MODAL_STACK.splice(ixStack, 1);
	}

	static _initModalEscapeHandler ({doc}) {
		if (UiUtil._MODAL_STACK) return;
		UiUtil._MODAL_STACK = [];

		doc.addEventListener("keydown", evt => {
			if (evt.which !== 27) return;
			if (!UiUtil._MODAL_STACK.length) return;
			if (EventUtil.isInInput(evt)) return;

			const outerModalMeta = UiUtil._MODAL_STACK.last();
			if (!outerModalMeta) return;
			evt.stopPropagation();
			if (!outerModalMeta.isPermanent) return outerModalMeta.pHandleCloseClick(false);
		});
	}

	static _initModalMouseupHandlers ({doc}) {
		doc.addEventListener("mousedown", evt => {
			UiUtil._MODAL_LAST_MOUSEDOWN = evt.target;
		});
	}

	static isAnyModalOpen () {
		return !!UiUtil._MODAL_STACK?.length;
	}

	static addModalSep ($modalInner) {
		$modalInner.append(`<hr class="ui-modal__row-sep">`);
	}

	static $getAddModalRow ($modalInner, tag = "div") {
		return $(`<${tag} class="ui-modal__row"></${tag}>`).appendTo($modalInner);
	}

	/**
	 * @param $modalInner Element this row should be added to.
	 * @param headerText Header text.
	 * @param [opts] Options object.
	 * @param [opts.helpText] Help text (title) of select dropdown.
	 * @param [opts.$eleRhs] Element to attach to the right-hand side of the header.
	 */
	static $getAddModalRowHeader ($modalInner, headerText, opts) {
		opts = opts || {};
		const $row = UiUtil.$getAddModalRow($modalInner, "h5").addClass("bold");
		if (opts.$eleRhs) $$`<div class="split ve-flex-v-center w-100 pr-1"><span>${headerText}</span>${opts.$eleRhs}</div>`.appendTo($row);
		else $row.text(headerText);
		if (opts.helpText) $row.title(opts.helpText);
		return $row;
	}

	static $getAddModalRowCb ($modalInner, labelText, objectWithProp, propName, helpText) {
		const $row = UiUtil.$getAddModalRow($modalInner, "label").addClass(`ui-modal__row--cb`);
		if (helpText) $row.title(helpText);
		$row.append(`<span>${labelText}</span>`);
		const $cb = $(`<input type="checkbox">`).appendTo($row)
			.keydown(evt => {
				if (evt.key === "Escape") $cb.blur();
			})
			.prop("checked", objectWithProp[propName])
			.on("change", () => objectWithProp[propName] = $cb.prop("checked"));
		return $cb;
	}

	/**
	 *
	 * @param $modalInner Element this row should be added to.
	 * @param labelText Row label.
	 * @param objectWithProp Object to mutate when changing select values.
	 * @param propName Property to set in `objectWithProp`.
	 * @param values Values to display in select dropdown.
	 * @param [opts] Options object.
	 * @param [opts.helpText] Help text (title) of select dropdown.
	 * @param [opts.fnDisplay] Function used to map values to displayable versions.
	 */
	static $getAddModalRowSel ($modalInner, labelText, objectWithProp, propName, values, opts) {
		opts = opts || {};
		const $row = UiUtil.$getAddModalRow($modalInner, "label").addClass(`ui-modal__row--sel`);
		if (opts.helpText) $row.title(opts.helpText);
		$row.append(`<span>${labelText}</span>`);
		const $sel = $(`<select class="form-control input-xs w-30">`).appendTo($row);
		values.forEach((val, i) => $(`<option value="${i}"></option>`).text(opts.fnDisplay ? opts.fnDisplay(val) : val).appendTo($sel));
		// N.B. this doesn't support null values
		const ix = values.indexOf(objectWithProp[propName]);
		$sel.val(`${~ix ? ix : 0}`)
			.change(() => objectWithProp[propName] = values[$sel.val()]);
		return $sel;
	}

	static _parseStrAsNumber (str, isInt) {
		const wrpTree = Renderer.dice.lang.getTree3(str);
		if (!wrpTree) return NaN;
		const out = wrpTree.tree.evl({});
		if (!isNaN(out) && isInt) return Math.round(out);
		return out;
	}

	static bindTypingEnd ({$ipt, fnKeyup, fnKeypress, fnKeydown, fnClick} = {}) {
		let timerTyping;
		$ipt
			.on("keyup search paste", evt => {
				clearTimeout(timerTyping);
				timerTyping = setTimeout(() => { fnKeyup(evt); }, UiUtil.TYPE_TIMEOUT_MS);
			})
			// Trigger on blur, as tabbing out of a field triggers the keyup on the element which was tabbed into. Our
			//   intent. however, is to trigger on any keyup which began in this field.
			.on("blur", evt => {
				clearTimeout(timerTyping);
				fnKeyup(evt);
			})
			.on("keypress", evt => {
				if (fnKeypress) fnKeypress(evt);
			})
			.on("keydown", evt => {
				if (fnKeydown) fnKeydown(evt);
				clearTimeout(timerTyping);
			})
			.on("click", () => {
				if (fnClick) fnClick();
			})
			.on("instantKeyup", () => {
				clearTimeout(timerTyping);
				fnKeyup();
			})
		;
	}

	/** Brute-force select the input, in case something has delayed the rendering (e.g. a VTT application window) */
	static async pDoForceFocus (ele, {timeout = 250} = {}) {
		if (!ele) return;
		ele.focus();

		const forceFocusStart = Date.now();
		while ((Date.now() < forceFocusStart + timeout) && document.activeElement !== ele) {
			await MiscUtil.pDelay(33);
			ele.focus();
		}
	}
}
UiUtil.SEARCH_RESULTS_CAP = 75;
UiUtil.TYPE_TIMEOUT_MS = 100; // auto-search after 100ms
UiUtil._MODAL_STACK = null;
UiUtil._MODAL_LAST_MOUSEDOWN = null;

class ListSelectClickHandlerBase {
	static _EVT_PASS_THOUGH_TAGS = new Set(["A", "BUTTON"]);

	constructor () {
		this._firstSelection = null;
		this._lastSelection = null;

		this._selectionInitialValue = null;
	}

	/**
	 * @abstract
	 * @return {Array}
	 */
	get _visibleItems () { throw new Error("Unimplemented!"); }

	/**
	 * @abstract
	 * @return {Array}
	 */
	get _allItems () { throw new Error("Unimplemented!"); }

	/** @abstract */
	_getCb (item, opts) { throw new Error("Unimplemented!"); }

	/** @abstract */
	_setCheckbox (item, opts) { throw new Error("Unimplemented!"); }

	/** @abstract */
	_setHighlighted (item, opts) { throw new Error("Unimplemented!"); }

	/**
	 * (Public method for Plutonium use)
	 * Handle doing a checkbox-based selection toggle on a list.
	 * @param item List item.
	 * @param evt Click event.
	 * @param [opts] Options object.
	 * @param [opts.isNoHighlightSelection] If highlighting selected rows should be skipped.
	 * @param [opts.fnOnSelectionChange] Function to call when selection status of an item changes.
	 * @param [opts.fnGetCb] Function which gets the checkbox from a list item.
	 * @param [opts.isPassThroughEvents] If e.g. click events to links/buttons in the list item should be allowed/ignored.
	 */
	handleSelectClick (item, evt, opts) {
		opts = opts || {};

		if (opts.isPassThroughEvents) {
			const evtPath = evt.composedPath();
			const subEles = evtPath.slice(0, evtPath.indexOf(evt.currentTarget));
			if (subEles.some(ele => this.constructor._EVT_PASS_THOUGH_TAGS.has(ele?.tagName))) return;
		}

		evt.preventDefault();
		evt.stopPropagation();

		const cb = this._getCb(item, opts);
		if (cb.disabled) return true;

		if (evt && evt.shiftKey && this._firstSelection) {
			if (this._lastSelection === item) {
				// on double-tapping the end of the selection, toggle it on/off

				this._setCheckbox(item, {...opts, toVal: !cb.checked});
			} else if (this._firstSelection === item && this._lastSelection) {
				// If the item matches the last clicked, clear all checkboxes from our last selection

				const ix1 = this._visibleItems.indexOf(this._firstSelection);
				const ix2 = this._visibleItems.indexOf(this._lastSelection);

				const [ixStart, ixEnd] = [ix1, ix2].sort(SortUtil.ascSort);
				for (let i = ixStart; i <= ixEnd; ++i) {
					const it = this._visibleItems[i];
					this._setCheckbox(it, {...opts, toVal: false});
				}

				this._setCheckbox(item, opts);
			} else {
				// on a shift-click, toggle all the checkboxes to the value of the initial item...
				this._selectionInitialValue = this._getCb(this._firstSelection, opts).checked;

				const ix1 = this._visibleItems.indexOf(this._firstSelection);
				const ix2 = this._visibleItems.indexOf(item);
				const ix2Prev = this._lastSelection ? this._visibleItems.indexOf(this._lastSelection) : null;

				const [ixStart, ixEnd] = [ix1, ix2].sort(SortUtil.ascSort);
				const nxtOpts = {...opts, toVal: this._selectionInitialValue};
				for (let i = ixStart; i <= ixEnd; ++i) {
					const it = this._visibleItems[i];
					this._setCheckbox(it, nxtOpts);
				}

				// ...except when selecting; for those between the last selection and this selection, those to unchecked
				if (this._selectionInitialValue && ix2Prev != null) {
					if (ix2Prev > ixEnd) {
						const nxtOpts = {...opts, toVal: !this._selectionInitialValue};
						for (let i = ixEnd + 1; i <= ix2Prev; ++i) {
							const it = this._visibleItems[i];
							this._setCheckbox(it, nxtOpts);
						}
					} else if (ix2Prev < ixStart) {
						const nxtOpts = {...opts, toVal: !this._selectionInitialValue};
						for (let i = ix2Prev; i < ixStart; ++i) {
							const it = this._visibleItems[i];
							this._setCheckbox(it, nxtOpts);
						}
					}
				}
			}

			this._lastSelection = item;
		} else {
			// on a normal click, or if there's been no initial selection, just toggle the checkbox

			const cbMaster = this._getCb(item, opts);
			if (cbMaster) {
				cbMaster.checked = !cbMaster.checked;

				if (opts.fnOnSelectionChange) opts.fnOnSelectionChange(item, cbMaster.checked);

				if (!opts.isNoHighlightSelection) {
					this._setHighlighted(item, cbMaster.checked);
				}
			} else {
				if (!opts.isNoHighlightSelection) {
					this._setHighlighted(item, false);
				}
			}

			this._firstSelection = item;
			this._lastSelection = null;
			this._selectionInitialValue = null;
		}
	}

	/**
	 * Handle doing a radio-based selection toggle on a list.
	 * @param item List item.
	 * @param evt Click event.
	 */
	handleSelectClickRadio (item, evt) {
		evt.preventDefault();
		evt.stopPropagation();

		this._allItems.forEach(itemOther => {
			const cb = this._getCb(itemOther);

			if (itemOther === item) {
				// Setting this to true *should* cause the browser to update the rest for us, but since list items can
				//   be filtered/hidden, the browser won't necessarily update them all. Therefore, forcibly set
				//   `checked = false` below.
				cb.checked = true;
				this._setHighlighted(itemOther, true);
			} else {
				cb.checked = false;
				this._setHighlighted(itemOther, false);
			}
		});
	}
}

globalThis.ListSelectClickHandlerBase = ListSelectClickHandlerBase;

class ListSelectClickHandler extends ListSelectClickHandlerBase {
	constructor ({list}) {
		super();
		this._list = list;
	}

	get _visibleItems () { return this._list.visibleItems; }

	get _allItems () { return this._list.items; }

	_getCb (item, opts = {}) { return opts.fnGetCb ? opts.fnGetCb(item) : item.data.cbSel; }

	_setCheckbox (item, opts = {}) { return this.setCheckbox(item, opts); }

	_setHighlighted (item, isHighlighted) {
		if (isHighlighted) item.ele instanceof $ ? item.ele.addClass("list-multi-selected") : item.ele.classList.add("list-multi-selected");
		else item.ele instanceof $ ? item.ele.removeClass("list-multi-selected") : item.ele.classList.remove("list-multi-selected");
	}

	/* -------------------------------------------- */

	setCheckbox (item, {fnGetCb, fnOnSelectionChange, isNoHighlightSelection, toVal = true} = {}) {
		const cbSlave = this._getCb(item, {fnGetCb, fnOnSelectionChange, isNoHighlightSelection});

		if (cbSlave?.disabled) return;

		if (cbSlave) {
			cbSlave.checked = toVal;
			if (fnOnSelectionChange) fnOnSelectionChange(item, toVal);
		}

		if (isNoHighlightSelection) return;

		this._setHighlighted(item, toVal);
	}

	/**
	 * (Public method for Plutonium use)
	 */
	bindSelectAllCheckbox ($cbAll) {
		$cbAll.change(() => {
			const isChecked = $cbAll.prop("checked");
			this.setCheckboxes({isChecked});
		});
	}

	setCheckboxes ({isChecked, isIncludeHidden}) {
		(isIncludeHidden ? this._list.items : this._list.visibleItems)
			.forEach(item => {
				if (item.data.cbSel?.disabled) return;

				if (item.data.cbSel) item.data.cbSel.checked = isChecked;

				this._setHighlighted(item, isChecked);
			});
	}
}

globalThis.ListSelectClickHandler = ListSelectClickHandler;

class ListUiUtil {
	static bindPreviewButton (page, allData, item, btnShowHidePreview, {$fnGetPreviewStats} = {}) {
		btnShowHidePreview.addEventListener("click", evt => {
			const entity = allData[item.ix];
			page = page || entity?.__prop;

			const elePreviewWrp = this.getOrAddListItemPreviewLazy(item);

			this.handleClickBtnShowHideListPreview(evt, page, entity, btnShowHidePreview, elePreviewWrp, {$fnGetPreviewStats});
		});
	}

	static handleClickBtnShowHideListPreview (evt, page, entity, btnShowHidePreview, elePreviewWrp, {nxtText = null, $fnGetPreviewStats} = {}) {
		evt.stopPropagation();
		evt.preventDefault();

		nxtText = nxtText ?? btnShowHidePreview.innerHTML.trim() === this.HTML_GLYPHICON_EXPAND ? this.HTML_GLYPHICON_CONTRACT : this.HTML_GLYPHICON_EXPAND;
		const isHidden = nxtText === this.HTML_GLYPHICON_EXPAND;
		const isFluff = !!evt.shiftKey;

		elePreviewWrp.classList.toggle("ve-hidden", isHidden);
		btnShowHidePreview.innerHTML = nxtText;

		const elePreviewWrpInner = elePreviewWrp.lastElementChild;

		const isForce = (elePreviewWrp.dataset.dataType === "stats" && isFluff) || (elePreviewWrp.dataset.dataType === "fluff" && !isFluff);
		if (!isForce && elePreviewWrpInner.innerHTML) return;

		$(elePreviewWrpInner).empty().off("click").on("click", evt => { evt.stopPropagation(); });

		if (isHidden) return;

		elePreviewWrp.dataset.dataType = isFluff ? "fluff" : "stats";

		const doAppendStatView = () => ($fnGetPreviewStats || Renderer.hover.$getHoverContent_stats)(page, entity, {isStatic: true}).appendTo(elePreviewWrpInner);

		if (!evt.shiftKey || !UrlUtil.URL_TO_HASH_BUILDER[page]) {
			doAppendStatView();
			return;
		}

		Renderer.hover.pGetHoverableFluff(page, entity.source, UrlUtil.URL_TO_HASH_BUILDER[page](entity))
			.then(fluffEntity => {
				// Avoid clobbering existing elements, as other events might have updated the preview area while we were
				//  loading the fluff.
				if (elePreviewWrpInner.innerHTML) return;

				if (!fluffEntity) return doAppendStatView();
				Renderer.hover.$getHoverContent_fluff(page, fluffEntity).appendTo(elePreviewWrpInner);
			});
	}

	static getOrAddListItemPreviewLazy (item) {
		// We lazily add the preview UI, to mitigate rendering performance issues
		let elePreviewWrp;
		if (item.ele.children.length === 1) {
			elePreviewWrp = e_({
				ag: "div",
				clazz: "ve-hidden ve-flex",
				children: [
					e_({tag: "div", clazz: "col-0-5"}),
					e_({tag: "div", clazz: "col-11-5 ui-list__wrp-preview py-2 pr-2"}),
				],
			}).appendTo(item.ele);
		} else elePreviewWrp = item.ele.lastElementChild;
		return elePreviewWrp;
	}

	static bindPreviewAllButton ($btnAll, list) {
		$btnAll
			.click(async () => {
				const nxtHtml = $btnAll.html() === ListUiUtil.HTML_GLYPHICON_EXPAND
					? ListUiUtil.HTML_GLYPHICON_CONTRACT
					: ListUiUtil.HTML_GLYPHICON_EXPAND;

				if (nxtHtml === ListUiUtil.HTML_GLYPHICON_CONTRACT && list.visibleItems.length > 500) {
					const isSure = await InputUiUtil.pGetUserBoolean({
						title: "Are You Sure?",
						htmlDescription: `You are about to expand ${list.visibleItems.length} rows. This may seriously degrade performance.<br>Are you sure you want to continue?`,
					});
					if (!isSure) return;
				}

				$btnAll.html(nxtHtml);

				list.visibleItems.forEach(listItem => {
					if (listItem.data.btnShowHidePreview.innerHTML !== nxtHtml) listItem.data.btnShowHidePreview.click();
				});
			});
	}

	// ==================

	static ListSyntax = class {
		static _READONLY_WALKER = null;

		constructor (
			{
				fnGetDataList,
				pFnGetFluff,
			},
		) {
			this._fnGetDataList = fnGetDataList;
			this._pFnGetFluff = pFnGetFluff;
		}

		get _dataList () { return this._fnGetDataList(); }

		build () {
			return {
				stats: {
					help: `"stats:<text>" ("/text/" for regex) to search within stat blocks.`,
					fn: (listItem, searchTerm) => {
						if (listItem.data._textCacheStats == null) listItem.data._textCacheStats = this._getSearchCacheStats(this._dataList[listItem.ix]);
						return this._listSyntax_isTextMatch(listItem.data._textCacheStats, searchTerm);
					},
				},
				info: {
					help: `"info:<text>" ("/text/" for regex) to search within info.`,
					fn: async (listItem, searchTerm) => {
						if (listItem.data._textCacheFluff == null) listItem.data._textCacheFluff = await this._pGetSearchCacheFluff(this._dataList[listItem.ix]);
						return this._listSyntax_isTextMatch(listItem.data._textCacheFluff, searchTerm);
					},
					isAsync: true,
				},
				text: {
					help: `"text:<text>" ("/text/" for regex) to search within stat blocks plus info.`,
					fn: async (listItem, searchTerm) => {
						if (listItem.data._textCacheAll == null) {
							const {textCacheStats, textCacheFluff, textCacheAll} = await this._pGetSearchCacheAll(this._dataList[listItem.ix], {textCacheStats: listItem.data._textCacheStats, textCacheFluff: listItem.data._textCacheFluff});
							listItem.data._textCacheStats = listItem.data._textCacheStats || textCacheStats;
							listItem.data._textCacheFluff = listItem.data._textCacheFluff || textCacheFluff;
							listItem.data._textCacheAll = textCacheAll;
						}
						return this._listSyntax_isTextMatch(listItem.data._textCacheAll, searchTerm);
					},
					isAsync: true,
				},
			};
		}

		_listSyntax_isTextMatch (str, searchTerm) {
			if (!str) return false;
			if (searchTerm instanceof RegExp) return searchTerm.test(str);
			return str.includes(searchTerm);
		}

		// TODO(Future) the ideal solution to this is to render every entity to plain text (or failing that, Markdown) and
		//   indexing that text with e.g. elasticlunr.
		_getSearchCacheStats (entity) {
			return this._getSearchCache_entries(entity);
		}

		static _INDEXABLE_PROPS_ENTRIES = [
			"entries",
		];

		_getSearchCache_entries (entity, {indexableProps = null} = {}) {
			if ((indexableProps || this.constructor._INDEXABLE_PROPS_ENTRIES).every(it => !entity[it])) return "";
			const ptrOut = {_: ""};
			(indexableProps || this.constructor._INDEXABLE_PROPS_ENTRIES).forEach(it => this._getSearchCache_handleEntryProp(entity, it, ptrOut));
			return ptrOut._;
		}

		_getSearchCache_handleEntryProp (entity, prop, ptrOut) {
			if (!entity[prop]) return;

			this.constructor._READONLY_WALKER = this.constructor._READONLY_WALKER || MiscUtil.getWalker({
				keyBlocklist: new Set(["type", "colStyles", "style"]),
				isNoModification: true,
			});

			this.constructor._READONLY_WALKER.walk(
				entity[prop],
				{
					string: (str) => this._getSearchCache_handleString(ptrOut, str),
				},
			);
		}

		_getSearchCache_handleString (ptrOut, str) {
			ptrOut._ += `${Renderer.stripTags(str).toLowerCase()} -- `;
		}

		async _pGetSearchCacheFluff (entity) {
			const fluff = this._pFnGetFluff ? await this._pFnGetFluff(entity) : null;
			return fluff ? this._getSearchCache_entries(fluff, {indexableProps: ["entries"]}) : "";
		}

		async _pGetSearchCacheAll (entity, {textCacheStats = null, textCacheFluff = null}) {
			textCacheStats = textCacheStats || this._getSearchCacheStats(entity);
			textCacheFluff = textCacheFluff || await this._pGetSearchCacheFluff(entity);
			return {
				textCacheStats,
				textCacheFluff,
				textCacheAll: [textCacheStats, textCacheFluff].filter(Boolean).join(" -- "),
			};
		}
	};

	// ==================
}
ListUiUtil.HTML_GLYPHICON_EXPAND = `[+]`;
ListUiUtil.HTML_GLYPHICON_CONTRACT = `[\u2012]`;

globalThis.ListUiUtil = ListUiUtil;

class ProfUiUtil {
	/**
	 * @param state Initial state.
	 * @param [opts] Options object.
	 * @param [opts.isSimple] If the cycler only has "not proficient" and "proficient" options
	 */
	static getProfCycler (state = 0, opts) {
		opts = opts || {};

		const STATES = opts.isSimple ? Object.keys(ProfUiUtil.PROF_TO_FULL).slice(0, 2) : Object.keys(ProfUiUtil.PROF_TO_FULL);

		const NUM_STATES = Object.keys(STATES).length;

		// validate initial state
		state = Number(state) || 0;
		if (state >= NUM_STATES) state = NUM_STATES - 1;
		else if (state < 0) state = 0;

		const $btnCycle = $(`<button class="ui-prof__btn-cycle"></button>`)
			.click(() => {
				$btnCycle
					.attr("data-state", ++state >= NUM_STATES ? state = 0 : state)
					.title(ProfUiUtil.PROF_TO_FULL[state].name)
					.trigger("change");
			})
			.contextmenu(evt => {
				evt.preventDefault();
				$btnCycle
					.attr("data-state", --state < 0 ? state = NUM_STATES - 1 : state)
					.title(ProfUiUtil.PROF_TO_FULL[state].name)
					.trigger("change");
			});
		const setState = (nuState) => {
			state = nuState;
			if (state > NUM_STATES) state = 0;
			else if (state < 0) state = NUM_STATES - 1;
			$btnCycle.attr("data-state", state).title(ProfUiUtil.PROF_TO_FULL[state].name);
		};
		return {
			$ele: $btnCycle,
			setState,
			getState: () => state,
		};
	}
}
ProfUiUtil.PROF_TO_FULL = {
	"0": {
		name: "No proficiency",
		mult: 0,
	},
	"1": {
		name: "Proficiency",
		mult: 1,
	},
	"2": {
		name: "Expertise",
		mult: 2,
	},
	"3": {
		name: "Half proficiency",
		mult: 0.5,
	},
};

class TabUiUtilBase {
	static decorate (obj, {isInitMeta = false} = {}) {
		if (isInitMeta) {
			obj.__meta = {};
			obj._meta = obj._getProxy("meta", obj.__meta);
		}

		obj.__tabState = {};

		obj._getTabProps = function ({propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP} = {}) {
			return {
				propProxy,
				_propProxy: `_${propProxy}`,
				__propProxy: `__${propProxy}`,
				propActive: `ixActiveTab__${tabGroup}`,
			};
		};

		/** Render a collection of tabs. */
		obj._renderTabs = function (tabMetas, {$parent, propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP, cbTabChange, additionalClassesWrpHeads} = {}) {
			if (!tabMetas.length) throw new Error(`One or more tab meta must be specified!`);
			obj._resetTabs({tabGroup});

			const isSingleTab = tabMetas.length === 1;

			const {propActive, _propProxy, __propProxy} = obj._getTabProps({propProxy, tabGroup});

			this[__propProxy][propActive] = this[__propProxy][propActive] || 0;

			const $dispTabTitle = obj.__$getDispTabTitle({isSingleTab});

			const renderTabMetas_standard = (it, i) => {
				const $btnTab = obj.__$getBtnTab({
					isSingleTab,
					tabMeta: it,
					_propProxy,
					propActive,
					ixTab: i,
				});

				const $wrpTab = obj.__$getWrpTab({tabMeta: it, ixTab: i});

				return {
					...it,
					ix: i,
					$btnTab,
					$wrpTab,
				};
			};

			const tabMetasOut = tabMetas.map((it, i) => {
				if (it.type) return obj.__renderTypedTabMeta({tabMeta: it, ixTab: i});
				return renderTabMetas_standard(it, i);
			}).filter(Boolean);

			if ($parent) obj.__renderTabs_addToParent({$dispTabTitle, $parent, tabMetasOut, additionalClassesWrpHeads});

			const hkActiveTab = () => {
				tabMetasOut.forEach(it => {
					if (it.type) return; // For specially typed tabs (e.g. buttons), do nothing

					const isActive = it.ix === this[_propProxy][propActive];
					if (isActive && $dispTabTitle) $dispTabTitle.text(isSingleTab ? "" : it.name);
					if (it.$btnTab) it.$btnTab.toggleClass("active", isActive);
					it.$wrpTab.toggleVe(isActive);
				});

				if (cbTabChange) cbTabChange();
			};
			this._addHook(propProxy, propActive, hkActiveTab);
			hkActiveTab();

			obj.__tabState[tabGroup] = {
				fnReset: () => {
					this._removeHook(propProxy, propActive, hkActiveTab);
				},
				tabMetasOut,
			};

			return tabMetasOut;
		};

		obj.__renderTabs_addToParent = function ({$dispTabTitle, $parent, tabMetasOut, additionalClassesWrpHeads}) {
			const hasBorder = tabMetasOut.some(it => it.hasBorder);
			$$`<div class="ve-flex-col w-100 h-100">
				${$dispTabTitle}
				<div class="ve-flex-col w-100 h-100 min-h-0">
					<div class="ve-flex ${hasBorder ? `ui-tab__wrp-tab-heads--border` : ""} ${additionalClassesWrpHeads || ""}">${tabMetasOut.map(it => it.$btnTab)}</div>
					<div class="ve-flex w-100 h-100 min-h-0">${tabMetasOut.map(it => it.$wrpTab).filter(Boolean)}</div>
				</div>
			</div>`.appendTo($parent);
		};

		obj._resetTabs = function ({tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP} = {}) {
			if (!obj.__tabState[tabGroup]) return;
			obj.__tabState[tabGroup].fnReset();
			delete obj.__tabState[tabGroup];
		};

		obj._hasPrevTab = function ({propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP} = {}) {
			return obj.__hasTab({propProxy, tabGroup, offset: -1});
		};
		obj._hasNextTab = function ({propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP} = {}) {
			return obj.__hasTab({propProxy, tabGroup, offset: 1});
		};

		obj.__hasTab = function ({propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP, offset}) {
			const {propActive, _propProxy} = obj._getTabProps({propProxy, tabGroup});
			const ixActive = obj[_propProxy][propActive];
			return !!(obj.__tabState[tabGroup]?.tabMetasOut && obj.__tabState[tabGroup]?.tabMetasOut[ixActive + offset]);
		};

		obj._doSwitchToPrevTab = function ({propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP} = {}) {
			return obj.__doSwitchToTab({propProxy, tabGroup, offset: -1});
		};
		obj._doSwitchToNextTab = function ({propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP} = {}) {
			return obj.__doSwitchToTab({propProxy, tabGroup, offset: 1});
		};

		obj.__doSwitchToTab = function ({propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP, offset}) {
			if (!obj.__hasTab({propProxy, tabGroup, offset})) return;
			const {propActive, _propProxy} = obj._getTabProps({propProxy, tabGroup});
			obj[_propProxy][propActive] = obj[_propProxy][propActive] + offset;
		};

		obj._addHookActiveTab = function (hook, {propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP} = {}) {
			const {propActive} = obj._getTabProps({propProxy, tabGroup});
			this._addHook(propProxy, propActive, hook);
		};

		obj._getIxActiveTab = function ({propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP} = {}) {
			const {propActive, _propProxy} = obj._getTabProps({propProxy, tabGroup});
			return obj[_propProxy][propActive];
		};

		obj._setIxActiveTab = function ({propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP, ixActiveTab} = {}) {
			const {propActive, _propProxy} = obj._getTabProps({propProxy, tabGroup});
			obj[_propProxy][propActive] = ixActiveTab;
		};

		obj._getActiveTab = function ({propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP} = {}) {
			const tabState = obj.__tabState[tabGroup];
			const ixActiveTab = obj._getIxActiveTab({propProxy, tabGroup});
			return tabState.tabMetasOut[ixActiveTab];
		};

		obj._setActiveTab = function ({propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP, tab}) {
			const tabState = obj.__tabState[tabGroup];
			const ix = tabState.tabMetasOut.indexOf(tab);
			obj._setIxActiveTab({propProxy, tabGroup, ixActiveTab: ix});
		};

		obj.__$getBtnTab = function () { throw new Error("Unimplemented!"); };
		obj.__$getWrpTab = function () { throw new Error("Unimplemented!"); };
		obj.__renderTypedTabMeta = function () { throw new Error("Unimplemented!"); };
		obj.__$getDispTabTitle = function () { throw new Error("Unimplemented!"); };
	}
}
TabUiUtilBase._DEFAULT_TAB_GROUP = "_default";
TabUiUtilBase._DEFAULT_PROP_PROXY = "meta";

TabUiUtilBase.TabMeta = class {
	constructor ({name, icon = null, type = null, buttons = null} = {}) {
		this.name = name;
		this.icon = icon;
		this.type = type;
		this.buttons = buttons;
	}
};

class TabUiUtil extends TabUiUtilBase {
	static decorate (obj, {isInitMeta = false} = {}) {
		super.decorate(obj, {isInitMeta});

		obj.__$getBtnTab = function ({tabMeta, _propProxy, propActive, ixTab}) {
			return $(`<button class="btn btn-default ui-tab__btn-tab-head ${tabMeta.isHeadHidden ? "ve-hidden" : ""}">${tabMeta.name.qq()}</button>`)
				.click(() => obj[_propProxy][propActive] = ixTab);
		};

		obj.__$getWrpTab = function ({tabMeta}) {
			return $(`<div class="ui-tab__wrp-tab-body ve-flex-col ve-hidden ${tabMeta.hasBorder ? "ui-tab__wrp-tab-body--border" : ""} ${tabMeta.hasBackground ? "ui-tab__wrp-tab-body--background" : ""}"></div>`);
		};

		obj.__renderTypedTabMeta = function ({tabMeta, ixTab}) {
			switch (tabMeta.type) {
				case "buttons": return obj.__renderTypedTabMeta_buttons({tabMeta, ixTab});
				default: throw new Error(`Unhandled tab type "${tabMeta.type}"`);
			}
		};

		obj.__renderTypedTabMeta_buttons = function ({tabMeta, ixTab}) {
			const $btns = tabMeta.buttons.map((meta, j) => {
				const $btn = $(`<button class="btn ui-tab__btn-tab-head ${meta.type ? `btn-${meta.type}` : "btn-primary"}" ${meta.title ? `title="${meta.title.qq()}"` : ""}>${meta.html}</button>`)
					.click(evt => meta.pFnClick(evt, $btn));
				return $btn;
			});

			const $btnTab = $$`<div class="btn-group ve-flex-v-right ve-flex-h-right ml-2 w-100">${$btns}</div>`;

			return {
				...tabMeta,
				ix: ixTab,
				$btns,
				$btnTab,
			};
		};

		obj.__$getDispTabTitle = function () { return null; };
	}
}

globalThis.TabUiUtil = TabUiUtil;

TabUiUtil.TabMeta = class extends TabUiUtilBase.TabMeta {
	constructor (opts) {
		super(opts);
		this.hasBorder = !!opts.hasBorder;
		this.hasBackground = !!opts.hasBackground;
		this.isHeadHidden = !!opts.isHeadHidden;
		this.isNoPadding = !!opts.isNoPadding;
	}
};

class TabUiUtilSide extends TabUiUtilBase {
	static decorate (obj, {isInitMeta = false} = {}) {
		super.decorate(obj, {isInitMeta});

		obj.__$getBtnTab = function ({isSingleTab, tabMeta, _propProxy, propActive, ixTab}) {
			return isSingleTab ? null : $(`<button class="btn btn-default btn-sm ui-tab-side__btn-tab mb-2 br-0 btr-0 bbr-0 text-left ve-flex-v-center" title="${tabMeta.name.qq()}"><div class="${tabMeta.icon} ui-tab-side__icon-tab mr-2 mobile-ish__mr-0 text-center"></div><div class="mobile-ish__hidden">${tabMeta.name.qq()}</div></button>`)
				.click(() => this[_propProxy][propActive] = ixTab);
		};

		obj.__$getWrpTab = function ({tabMeta}) {
			return $(`<div class="ve-flex-col w-100 h-100 ui-tab-side__wrp-tab ${tabMeta.isNoPadding ? "" : "px-3 py-2"} overflow-y-auto"></div>`);
		};

		obj.__renderTabs_addToParent = function ({$dispTabTitle, $parent, tabMetasOut}) {
			$$`<div class="ve-flex-col w-100 h-100">
				${$dispTabTitle}
				<div class="ve-flex w-100 h-100 min-h-0">
					<div class="ve-flex-col h-100 pt-2">${tabMetasOut.map(it => it.$btnTab)}</div>
					<div class="ve-flex-col w-100 h-100 min-w-0">${tabMetasOut.map(it => it.$wrpTab).filter(Boolean)}</div>
				</div>
			</div>`.appendTo($parent);
		};

		obj.__renderTypedTabMeta = function ({tabMeta, ixTab}) {
			switch (tabMeta.type) {
				case "buttons": return obj.__renderTypedTabMeta_buttons({tabMeta, ixTab});
				default: throw new Error(`Unhandled tab type "${tabMeta.type}"`);
			}
		};

		obj.__renderTypedTabMeta_buttons = function ({tabMeta, ixTab}) {
			const $btns = tabMeta.buttons.map((meta, j) => {
				const $btn = $(`<button class="btn ${meta.type ? `btn-${meta.type}` : "btn-primary"} btn-sm" ${meta.title ? `title="${meta.title.qq()}"` : ""}>${meta.html}</button>`)
					.click(evt => meta.pFnClick(evt, $btn));

				if (j === tabMeta.buttons.length - 1) $btn.addClass(`br-0 btr-0 bbr-0`);

				return $btn;
			});

			const $btnTab = $$`<div class="btn-group ve-flex-v-center ve-flex-h-right mb-2">${$btns}</div>`;

			return {
				...tabMeta,
				ix: ixTab,
				$btnTab,
			};
		};

		obj.__$getDispTabTitle = function ({isSingleTab}) {
			return $(`<div class="ui-tab-side__disp-active-tab-name ${isSingleTab ? `ui-tab-side__disp-active-tab-name--single` : ""} bold"></div>`);
		};
	}
}

globalThis.TabUiUtilSide = TabUiUtilSide;

// TODO have this respect the blocklist?
class SearchUiUtil {
	static async pDoGlobalInit () {
		elasticlunr.clearStopWords();
		await Renderer.item.pPopulatePropertyAndTypeReference();
	}

	static _isNoHoverCat (cat) {
		return SearchUiUtil.NO_HOVER_CATEGORIES.has(cat);
	}

	static async pGetContentIndices (options) {
		options = options || {};

		const availContent = {};

		const [searchIndexRaw] = await Promise.all([
			DataUtil.loadJSON(`${Renderer.get().baseUrl}search/index.json`),
			ExcludeUtil.pInitialise(),
		]);

		const data = Omnidexer.decompressIndex(searchIndexRaw);

		const additionalData = {};
		if (options.additionalIndices) {
			await Promise.all(options.additionalIndices.map(async add => {
				additionalData[add] = Omnidexer.decompressIndex(await DataUtil.loadJSON(`${Renderer.get().baseUrl}search/index-${add}.json`));
				const maxId = additionalData[add].last().id;

				const prereleaseIndex = await PrereleaseUtil.pGetAdditionalSearchIndices(maxId, add);
				if (prereleaseIndex.length) additionalData[add] = additionalData[add].concat(prereleaseIndex);

				const brewIndex = await BrewUtil2.pGetAdditionalSearchIndices(maxId, add);
				if (brewIndex.length) additionalData[add] = additionalData[add].concat(brewIndex);
			}));
		}

		const alternateData = {};
		if (options.alternateIndices) {
			await Promise.all(options.alternateIndices.map(async alt => {
				alternateData[alt] = Omnidexer.decompressIndex(await DataUtil.loadJSON(`${Renderer.get().baseUrl}search/index-alt-${alt}.json`));
				const maxId = alternateData[alt].last().id;

				const prereleaseIndex = await BrewUtil2.pGetAlternateSearchIndices(maxId, alt);
				if (prereleaseIndex.length) alternateData[alt] = alternateData[alt].concat(prereleaseIndex);

				const brewIndex = await BrewUtil2.pGetAlternateSearchIndices(maxId, alt);
				if (brewIndex.length) alternateData[alt] = alternateData[alt].concat(brewIndex);
			}));
		}

		const fromDeepIndex = (d) => d.d; // flag for "deep indexed" content that refers to the same item

		availContent.ALL = elasticlunr(function () {
			this.addField("n");
			this.addField("s");
			this.setRef("id");
		});
		SearchUtil.removeStemmer(availContent.ALL);

		// Add main site index
		let ixMax = 0;

		const initIndexForFullCat = (doc) => {
			if (!availContent[doc.cf]) {
				availContent[doc.cf] = elasticlunr(function () {
					this.addField("n");
					this.addField("s");
					this.setRef("id");
				});
				SearchUtil.removeStemmer(availContent[doc.cf]);
			}
		};

		const handleDataItem = (d, isAlternate) => {
			if (
				SearchUiUtil._isNoHoverCat(d.c)
				|| fromDeepIndex(d)
				|| ExcludeUtil.isExcluded(d.u, Parser.pageCategoryToProp(d.c), d.s, {isNoCount: true})
			) return;
			d.cf = d.c === Parser.CAT_ID_CREATURE ? "Creature" : Parser.pageCategoryToFull(d.c);
			if (isAlternate) d.cf = `alt_${d.cf}`;
			initIndexForFullCat(d);
			if (!isAlternate) availContent.ALL.addDoc(d);
			availContent[d.cf].addDoc(d);
			ixMax = Math.max(ixMax, d.id);
		};

		data.forEach(d => handleDataItem(d));
		Object.values(additionalData).forEach(arr => arr.forEach(d => handleDataItem(d)));
		Object.values(alternateData).forEach(arr => arr.forEach(d => handleDataItem(d, true)));

		const pAddPrereleaseBrewIndex = async ({brewUtil}) => {
			const brewIndex = await brewUtil.pGetSearchIndex({id: availContent.ALL.documentStore.length});

			brewIndex.forEach(d => {
				if (SearchUiUtil._isNoHoverCat(d.c) || fromDeepIndex(d)) return;
				d.cf = Parser.pageCategoryToFull(d.c);
				d.cf = d.c === Parser.CAT_ID_CREATURE ? "Creature" : Parser.pageCategoryToFull(d.c);
				initIndexForFullCat(d);
				availContent.ALL.addDoc(d);
				availContent[d.cf].addDoc(d);
			});
		};

		await pAddPrereleaseBrewIndex({brewUtil: PrereleaseUtil});
		await pAddPrereleaseBrewIndex({brewUtil: BrewUtil2});

		return availContent;
	}
}
SearchUiUtil.NO_HOVER_CATEGORIES = new Set([
	Parser.CAT_ID_ADVENTURE,
	Parser.CAT_ID_BOOK,
	Parser.CAT_ID_QUICKREF,
	Parser.CAT_ID_PAGE,
]);

// based on DM screen's AddMenuSearchTab
class SearchWidget {
	static getSearchNoResults () {
		return `<div class="ui-search__message"><i>No results.</i></div>`;
	}

	static getSearchLoading () {
		return `<div class="ui-search__message"><i>\u2022\u2022\u2022</i></div>`;
	}

	static getSearchEnter () {
		return `<div class="ui-search__message"><i>Enter a search.</i></div>`;
	}

	/**
	 * @param $iptSearch input element
	 * @param opts Options object.
	 * @param opts.fnSearch Function which runs the search.
	 * @param opts.fnShowWait Function which displays loading dots
	 * @param opts.flags Flags object; modified during user interaction.
	 * @param opts.flags.isWait Flag tracking "waiting for user to stop typing"
	 * @param opts.flags.doClickFirst Flag tracking "should first result get clicked"
	 * @param opts.flags.doClickFirst Flag tracking "should first result get clicked"
	 * @param opts.$ptrRows Pointer to array of rows.
	 */
	static bindAutoSearch ($iptSearch, opts) {
		UiUtil.bindTypingEnd({
			$ipt: $iptSearch,
			fnKeyup: evt => {
				if (evt.type === "blur") return;

				// Handled in `fnKeydown`
				switch (evt.key) {
					case "ArrowDown": {
						evt.preventDefault();
						return;
					}
					case "Enter": return;
				}

				opts.fnSearch && opts.fnSearch();
			},
			fnKeypress: evt => {
				switch (evt.key) {
					case "ArrowDown": {
						evt.preventDefault();
						return;
					}
					case "Enter": {
						opts.flags.doClickFirst = true;
						opts.fnSearch && opts.fnSearch();
					}
				}
			},
			fnKeydown: evt => {
				if (opts.flags.isWait) {
					opts.flags.isWait = false;
					opts.fnShowWait && opts.fnShowWait();
					return;
				}

				switch (evt.key) {
					case "ArrowDown": {
						if (opts.$ptrRows && opts.$ptrRows._[0]) {
							evt.stopPropagation();
							evt.preventDefault();
							opts.$ptrRows._[0][0].focus();
						}
						break;
					}
					case "Enter": {
						if (opts.$ptrRows && opts.$ptrRows._[0]) {
							evt.preventDefault();
							opts.$ptrRows._[0].click();
						}
						break;
					}
				}
			},
			fnClick: () => {
				if (opts.fnSearch && $iptSearch.val() && $iptSearch.val().trim().length) opts.fnSearch();
			},
		});
	}

	static bindRowHandlers ({result, $row, $ptrRows, fnHandleClick, $iptSearch}) {
		return $row
			.keydown(evt => {
				switch (evt.which) {
					case 13: { // enter
						return fnHandleClick(result);
					}
					case 38: { // up
						evt.preventDefault();
						const ixRow = $ptrRows._.indexOf($row);
						const $prev = $ptrRows._[ixRow - 1];
						if ($prev) $prev.focus();
						else $iptSearch.focus();
						break;
					}
					case 40: { // down
						evt.preventDefault();
						const ixRow = $ptrRows._.indexOf($row);
						const $nxt = $ptrRows._[ixRow + 1];
						if ($nxt) $nxt.focus();
						break;
					}
				}
			})
			.click(() => fnHandleClick(result));
	}

	static docToPageSourceHash (doc) {
		const page = UrlUtil.categoryToHoverPage(doc.c);
		const source = doc.s;
		const hash = doc.u;

		return {page, source, hash};
	}

	/**
	 * @param indexes An object with index names (categories) as the keys, and indexes as the values.
	 * @param cbSearch Callback to run on user clicking a search result.
	 * @param options Options object.
	 * @param options.defaultCategory Default search category.
	 * @param options.fnFilterResults Function which takes a document and returns false if it is to be filtered out of the results.
	 * @param options.searchOptions Override for default elasticlunr search options.
	 * @param options.fnTransform Function which transforms the document before passing it back to cbSearch.
	 */
	constructor (indexes, cbSearch, options) {
		options = options || {};

		this._indexes = indexes;
		this._cat = options.defaultCategory || "ALL";
		this._cbSearch = cbSearch;
		this._fnFilterResults = options.fnFilterResults || null;
		this._searchOptions = options.searchOptions || null;
		this._fnTransform = options.fnTransform || null;

		this._flags = {
			doClickFirst: false,
			isWait: false,
		};
		this._$ptrRows = {_: []};

		this._$selCat = null;
		this._$iptSearch = null;
		this._$wrpResults = null;

		this._$rendered = null;
	}

	static pDoGlobalInit () {
		if (!SearchWidget.P_LOADING_CONTENT) {
			SearchWidget.P_LOADING_CONTENT = (async () => {
				Object.assign(SearchWidget.CONTENT_INDICES, await SearchUiUtil.pGetContentIndices({additionalIndices: ["item"], alternateIndices: ["spell"]}));
			})();
		}
		return SearchWidget.P_LOADING_CONTENT;
	}

	__getSearchOptions () {
		return this._searchOptions || {
			fields: {
				n: {boost: 5, expand: true},
				s: {expand: true},
			},
			bool: "AND",
			expand: true,
		};
	}

	__$getRow (r) {
		return $(`<div class="ui-search__row" tabindex="0">
			<span>${r.doc.n}</span>
			<span>${r.doc.s ? `<i title="${Parser.sourceJsonToFull(r.doc.s)}">${Parser.sourceJsonToAbv(r.doc.s)}${r.doc.p ? ` p${r.doc.p}` : ""}</i>` : ""}</span>
		</div>`);
	}

	static __getAllTitle () {
		return "All Categories";
	}

	static __getCatOptionText (it) {
		return it;
	}

	get $wrpSearch () {
		if (!this._$rendered) this._render();
		return this._$rendered;
	}

	__showMsgInputRequired () {
		this._flags.isWait = true;
		this._$wrpResults.empty().append(SearchWidget.getSearchEnter());
	}

	__showMsgWait () {
		this._$wrpResults.empty().append(SearchWidget.getSearchLoading());
	}

	__showMsgNoResults () {
		this._flags.isWait = true;
		this._$wrpResults.empty().append(SearchWidget.getSearchNoResults());
	}

	__doSearch () {
		const searchInput = this._$iptSearch.val().trim();

		const index = this._indexes[this._cat];
		const results = index.search(searchInput, this.__getSearchOptions());

		const {toProcess, resultCount} = (() => {
			if (results.length) {
				if (this._fnFilterResults) {
					const filtered = results.filter(it => this._fnFilterResults(it.doc));
					return {
						toProcess: filtered.slice(0, UiUtil.SEARCH_RESULTS_CAP),
						resultCount: filtered.length,
					};
				} else {
					return {
						toProcess: results.slice(0, UiUtil.SEARCH_RESULTS_CAP),
						resultCount: results.length,
					};
				}
			} else {
				// If the user has entered a search and we found nothing, return no results
				if (searchInput.trim()) {
					return {
						toProcess: [],
						resultCount: 0,
					};
				}

				// Otherwise, we have no search term, so show a default list of results
				if (this._fnFilterResults) {
					const filtered = Object.values(index.documentStore.docs).filter(it => this._fnFilterResults(it)).map(it => ({doc: it}));
					return {
						toProcess: filtered.slice(0, UiUtil.SEARCH_RESULTS_CAP),
						resultCount: filtered.length,
					};
				} else {
					return {
						toProcess: Object.values(index.documentStore.docs).slice(0, UiUtil.SEARCH_RESULTS_CAP).map(it => ({doc: it})),
						resultCount: Object.values(index.documentStore.docs).length,
					};
				}
			}
		})();

		this._$wrpResults.empty();
		this._$ptrRows._ = [];

		if (resultCount) {
			const handleClick = (r) => {
				if (this._fnTransform) this._cbSearch(this._fnTransform(r.doc));
				else this._cbSearch(r.doc);
			};

			if (this._flags.doClickFirst) {
				handleClick(toProcess[0]);
				this._flags.doClickFirst = false;
				return;
			}

			const res = toProcess.slice(0, UiUtil.SEARCH_RESULTS_CAP);

			res.forEach(r => {
				const $row = this.__$getRow(r).appendTo(this._$wrpResults);
				SearchWidget.bindRowHandlers({result: r, $row, $ptrRows: this._$ptrRows, fnHandleClick: handleClick, $iptSearch: this._$iptSearch});
				this._$ptrRows._.push($row);
			});

			if (resultCount > UiUtil.SEARCH_RESULTS_CAP) {
				const diff = resultCount - UiUtil.SEARCH_RESULTS_CAP;
				this._$wrpResults.append(`<div class="ui-search__row ui-search__row--readonly">...${diff} more result${diff === 1 ? " was" : "s were"} hidden. Refine your search!</div>`);
			}
		} else {
			if (!searchInput.trim()) this.__showMsgInputRequired();
			else this.__showMsgNoResults();
		}
	}

	_render () {
		if (!this._$rendered) {
			this._$rendered = $(`<div class="ui-search__wrp-output"></div>`);
			const $wrpControls = $(`<div class="ui-search__wrp-controls"></div>`).appendTo(this._$rendered);

			this._$selCat = $(`<select class="form-control ui-search__sel-category">
				<option value="ALL">${SearchWidget.__getAllTitle()}</option>
				${Object.keys(this._indexes).sort().filter(it => it !== "ALL").map(it => `<option value="${it}">${SearchWidget.__getCatOptionText(it)}</option>`).join("")}
			</select>`)
				.appendTo($wrpControls).toggle(Object.keys(this._indexes).length !== 1)
				.on("change", () => {
					this._cat = this._$selCat.val();
					this.__doSearch();
				});

			this._$iptSearch = $(`<input class="ui-search__ipt-search search form-control" autocomplete="off" placeholder="Search...">`).appendTo($wrpControls);
			this._$wrpResults = $(`<div class="ui-search__wrp-results"></div>`).appendTo(this._$rendered);

			let lastSearchTerm = "";
			SearchWidget.bindAutoSearch(this._$iptSearch, {
				flags: this._flags,
				fnSearch: this.__doSearch.bind(this),
				fnShowWait: this.__showMsgWait.bind(this),
				$ptrRows: this._$ptrRows,
			});

			// On the first keypress, switch to loading dots
			this._$iptSearch.keydown(evt => {
				if (evt.key === "Escape") this._$iptSearch.blur();
				if (!this._$iptSearch.val().trim().length) return;
				if (evt.which !== 13) {
					if (lastSearchTerm === "") this.__showMsgWait();
					lastSearchTerm = this._$iptSearch.val();
				}
			});

			this.__doSearch();
		}
	}

	doFocus () {
		this._$iptSearch.focus();
	}

	static async pAddToIndexes (prop, entry) {
		const nextId = Object.values(SearchWidget.CONTENT_INDICES.ALL.documentStore.docs).length;

		const indexer = new Omnidexer(nextId);

		const toIndex = {[prop]: [entry]};

		const toIndexMultiPart = Omnidexer.TO_INDEX__FROM_INDEX_JSON.filter(it => it.listProp === prop);
		for (const it of toIndexMultiPart) await indexer.pAddToIndex(it, toIndex);

		const toIndexSinglePart = Omnidexer.TO_INDEX.filter(it => it.listProp === prop);
		for (const it of toIndexSinglePart) await indexer.pAddToIndex(it, toIndex);

		const toAdd = Omnidexer.decompressIndex(indexer.getIndex());
		toAdd.forEach(d => {
			d.cf = d.c === Parser.CAT_ID_CREATURE ? "Creature" : Parser.pageCategoryToFull(d.c);
			SearchWidget.CONTENT_INDICES.ALL.addDoc(d);
			SearchWidget.CONTENT_INDICES[d.cf].addDoc(d);
		});
	}

	// region entity searches
	static async pGetUserSpellSearch (opts) {
		opts = opts || {};
		await SearchWidget.P_LOADING_CONTENT;

		const nxtOpts = {
			fnTransform: doc => {
				const cpy = MiscUtil.copyFast(doc);
				Object.assign(cpy, SearchWidget.docToPageSourceHash(cpy));
				cpy.tag = `{@spell ${doc.n.toSpellCase()}${doc.s !== Parser.SRC_PHB ? `|${doc.s}` : ""}}`;
				return cpy;
			},
		};
		if (opts.level != null) nxtOpts.fnFilterResults = result => result.lvl === opts.level;

		const title = opts.level === 0 ? "Select Cantrip" : "Select Spell";
		return SearchWidget.pGetUserEntitySearch(
			title,
			"alt_Spell",
			nxtOpts,
		);
	}

	static async pGetUserLegendaryGroupSearch () {
		await SearchWidget.pLoadCustomIndex({
			contentIndexName: "entity_LegendaryGroups",
			errorName: "legendary groups",
			customIndexSubSpecs: [
				new SearchWidget.CustomIndexSubSpec({
					dataSource: `${Renderer.get().baseUrl}data/bestiary/legendarygroups.json`,
					prop: "legendaryGroup",
					catId: Parser.CAT_ID_LEGENDARY_GROUP,
					page: "legendaryGroup",
				}),
			],
		});

		return SearchWidget.pGetUserEntitySearch(
			"Select Legendary Group",
			"entity_LegendaryGroups",
			{
				fnTransform: doc => {
					const cpy = MiscUtil.copyFast(doc);
					Object.assign(cpy, SearchWidget.docToPageSourceHash(cpy));
					cpy.page = "legendaryGroup";
					return cpy;
				},
			},
		);
	}

	static async pGetUserFeatSearch () {
		// FIXME convert to be more like spell/creature search instead of running custom indexes
		await SearchWidget.pLoadCustomIndex({
			contentIndexName: "entity_Feats",
			errorName: "feats",
			customIndexSubSpecs: [
				new SearchWidget.CustomIndexSubSpec({
					dataSource: `${Renderer.get().baseUrl}data/feats.json`,
					prop: "feat",
					catId: Parser.CAT_ID_FEAT,
					page: UrlUtil.PG_FEATS,
				}),
			],
		});

		return SearchWidget.pGetUserEntitySearch(
			"Select Feat",
			"entity_Feats",
			{
				fnTransform: doc => {
					const cpy = MiscUtil.copyFast(doc);
					Object.assign(cpy, SearchWidget.docToPageSourceHash(cpy));
					cpy.tag = `{@feat ${doc.n}${doc.s !== Parser.SRC_PHB ? `|${doc.s}` : ""}}`;
					return cpy;
				},
			},
		);
	}

	static async pGetUserBackgroundSearch () {
		// FIXME convert to be more like spell/creature search instead of running custom indexes
		await SearchWidget.pLoadCustomIndex({
			contentIndexName: "entity_Backgrounds",
			errorName: "backgrounds",
			customIndexSubSpecs: [
				new SearchWidget.CustomIndexSubSpec({
					dataSource: `${Renderer.get().baseUrl}data/backgrounds.json`,
					prop: "background",
					catId: Parser.CAT_ID_BACKGROUND,
					page: UrlUtil.PG_BACKGROUNDS,
				}),
			],
		});

		return SearchWidget.pGetUserEntitySearch(
			"Select Background",
			"entity_Backgrounds",
			{
				fnTransform: doc => {
					const cpy = MiscUtil.copyFast(doc);
					Object.assign(cpy, SearchWidget.docToPageSourceHash(cpy));
					cpy.tag = `{@background ${doc.n}${doc.s !== Parser.SRC_PHB ? `|${doc.s}` : ""}}`;
					return cpy;
				},
			},
		);
	}

	static async pGetUserRaceSearch () {
		// FIXME convert to be more like spell/creature search instead of running custom indexes
		const dataSource = () => {
			return DataUtil.race.loadJSON();
		};
		await SearchWidget.pLoadCustomIndex({
			contentIndexName: "entity_Races",
			errorName: "races",
			customIndexSubSpecs: [
				new SearchWidget.CustomIndexSubSpec({
					dataSource,
					prop: "race",
					catId: Parser.CAT_ID_RACE,
					page: UrlUtil.PG_RACES,
				}),
			],
		});

		return SearchWidget.pGetUserEntitySearch(
			"Select Race",
			"entity_Races",
			{
				fnTransform: doc => {
					const cpy = MiscUtil.copyFast(doc);
					Object.assign(cpy, SearchWidget.docToPageSourceHash(cpy));
					cpy.tag = `{@race ${doc.n}${doc.s !== Parser.SRC_PHB ? `|${doc.s}` : ""}}`;
					return cpy;
				},
			},
		);
	}

	static async pGetUserOptionalFeatureSearch () {
		// FIXME convert to be more like spell/creature search instead of running custom indexes
		await SearchWidget.pLoadCustomIndex({
			contentIndexName: "entity_OptionalFeatures",
			errorName: "optional features",
			customIndexSubSpecs: [
				new SearchWidget.CustomIndexSubSpec({
					dataSource: `${Renderer.get().baseUrl}data/optionalfeatures.json`,
					prop: "optionalfeature",
					catId: Parser.CAT_ID_OPTIONAL_FEATURE_OTHER,
					page: UrlUtil.PG_OPT_FEATURES,
				}),
			],
		});

		return SearchWidget.pGetUserEntitySearch(
			"Select Optional Feature",
			"entity_OptionalFeatures",
			{
				fnTransform: doc => {
					const cpy = MiscUtil.copyFast(doc);
					Object.assign(cpy, SearchWidget.docToPageSourceHash(cpy));
					cpy.tag = `{@optfeature ${doc.n}${doc.s !== Parser.SRC_PHB ? `|${doc.s}` : ""}}`;
					return cpy;
				},
			},
		);
	}

	static async pGetUserAdventureSearch (opts) {
		await SearchWidget.pLoadCustomIndex({
			contentIndexName: "entity_Adventures",
			errorName: "adventures",
			customIndexSubSpecs: [
				new SearchWidget.CustomIndexSubSpec({
					dataSource: `${Renderer.get().baseUrl}data/adventures.json`,
					prop: "adventure",
					catId: Parser.CAT_ID_ADVENTURE,
					page: UrlUtil.PG_ADVENTURE,
				}),
			],
		});
		return SearchWidget.pGetUserEntitySearch("Select Adventure", "entity_Adventures", opts);
	}

	static async pGetUserBookSearch (opts) {
		await SearchWidget.pLoadCustomIndex({
			contentIndexName: "entity_Books",
			errorName: "books",
			customIndexSubSpecs: [
				new SearchWidget.CustomIndexSubSpec({
					dataSource: `${Renderer.get().baseUrl}data/books.json`,
					prop: "book",
					catId: Parser.CAT_ID_BOOK,
					page: UrlUtil.PG_BOOK,
				}),
			],
		});
		return SearchWidget.pGetUserEntitySearch("Select Book", "entity_Books", opts);
	}

	static async pGetUserAdventureBookSearch (opts) {
		const contentIndexName = opts.contentIndexName || "entity_AdventuresBooks";
		await SearchWidget.pLoadCustomIndex({
			contentIndexName,
			errorName: "adventures/books",
			customIndexSubSpecs: [
				new SearchWidget.CustomIndexSubSpec({
					dataSource: `${Renderer.get().baseUrl}data/adventures.json`,
					prop: "adventure",
					catId: Parser.CAT_ID_ADVENTURE,
					page: UrlUtil.PG_ADVENTURE,
					pFnGetDocExtras: opts.pFnGetDocExtras,
				}),
				new SearchWidget.CustomIndexSubSpec({
					dataSource: `${Renderer.get().baseUrl}data/books.json`,
					prop: "book",
					catId: Parser.CAT_ID_BOOK,
					page: UrlUtil.PG_BOOK,
					pFnGetDocExtras: opts.pFnGetDocExtras,
				}),
			],
		});
		return SearchWidget.pGetUserEntitySearch("Select Adventure or Book", contentIndexName, opts);
	}

	static async pGetUserCreatureSearch () {
		await SearchWidget.P_LOADING_CONTENT;

		const nxtOpts = {
			fnTransform: doc => {
				const cpy = MiscUtil.copyFast(doc);
				Object.assign(cpy, SearchWidget.docToPageSourceHash(cpy));
				cpy.tag = `{@creature ${doc.n}${doc.s !== Parser.SRC_MM ? `|${doc.s}` : ""}}`;
				return cpy;
			},
		};

		return SearchWidget.pGetUserEntitySearch(
			"Select Creature",
			"Creature",
			nxtOpts,
		);
	}

	static async __pLoadItemIndex (isBasicIndex) {
		const dataSource = async () => {
			const allItems = (await Renderer.item.pBuildList()).filter(it => !it._isItemGroup);
			return {
				item: allItems.filter(it => {
					if (it.type === "GV") return false;
					if (isBasicIndex == null) return true;
					const isBasic = it.rarity === "none" || it.rarity === "unknown" || it._category === "basic";
					return isBasicIndex ? isBasic : !isBasic;
				}),
			};
		};
		const indexName = isBasicIndex == null ? "entity_Items" : isBasicIndex ? "entity_ItemsBasic" : "entity_ItemsMagic";

		return SearchWidget.pLoadCustomIndex({
			contentIndexName: indexName,
			errorName: "items",
			customIndexSubSpecs: [
				new SearchWidget.CustomIndexSubSpec({
					dataSource,
					prop: "item",
					catId: Parser.CAT_ID_ITEM,
					page: UrlUtil.PG_ITEMS,
				}),
			],
		});
	}

	static async __pGetUserItemSearch (isBasicIndex) {
		const indexName = isBasicIndex == null ? "entity_Items" : isBasicIndex ? "entity_ItemsBasic" : "entity_ItemsMagic";
		return SearchWidget.pGetUserEntitySearch(
			"Select Item",
			indexName,
			{
				fnTransform: doc => {
					const cpy = MiscUtil.copyFast(doc);
					Object.assign(cpy, SearchWidget.docToPageSourceHash(cpy));
					cpy.tag = `{@item ${doc.n}${doc.s !== Parser.SRC_DMG ? `|${doc.s}` : ""}}`;
					return cpy;
				},
			},
		);
	}

	static async pGetUserBasicItemSearch () {
		await SearchWidget.__pLoadItemIndex(true);
		return SearchWidget.__pGetUserItemSearch(true);
	}

	static async pGetUserMagicItemSearch () {
		await SearchWidget.__pLoadItemIndex(false);
		return SearchWidget.__pGetUserItemSearch(false);
	}

	static async pGetUserItemSearch () {
		await SearchWidget.__pLoadItemIndex();
		return SearchWidget.__pGetUserItemSearch();
	}
	// endregion

	/**
	 *
	 * @param title
	 * @param indexName
	 * @param [opts]
	 * @param [opts.fnFilterResults]
	 * @param [opts.fnTransform]
	 */
	static async pGetUserEntitySearch (title, indexName, opts) {
		opts = opts || {};

		return new Promise(resolve => {
			const searchOpts = {defaultCategory: indexName};
			if (opts.fnFilterResults) searchOpts.fnFilterResults = opts.fnFilterResults;
			if (opts.fnTransform) searchOpts.fnTransform = opts.fnTransform;

			const searchWidget = new SearchWidget(
				{[indexName]: SearchWidget.CONTENT_INDICES[indexName]},
				(docOrTransformed) => {
					doClose(false); // "cancel" close
					resolve(docOrTransformed);
				},
				searchOpts,
			);
			const {$modalInner, doClose} = UiUtil.getShowModal({
				title,
				cbClose: (doResolve) => {
					searchWidget.$wrpSearch.detach();
					if (doResolve) resolve(null); // ensure resolution
				},
			});
			$modalInner.append(searchWidget.$wrpSearch);
			searchWidget.doFocus();
		});
	}

	// region custom search indexes
	static CustomIndexSubSpec = class {
		constructor ({dataSource, prop, catId, page, pFnGetDocExtras}) {
			this.dataSource = dataSource;
			this.prop = prop;
			this.catId = catId;
			this.page = page;
			this.pFnGetDocExtras = pFnGetDocExtras;
		}
	};

	static async pLoadCustomIndex ({contentIndexName, customIndexSubSpecs, errorName}) {
		if (SearchWidget.P_LOADING_INDICES[contentIndexName]) await SearchWidget.P_LOADING_INDICES[contentIndexName];
		else {
			const doClose = SearchWidget._showLoadingModal();

			try {
				SearchWidget.P_LOADING_INDICES[contentIndexName] = (SearchWidget.CONTENT_INDICES[contentIndexName] = await SearchWidget._pGetIndex(customIndexSubSpecs));
				SearchWidget.P_LOADING_INDICES[contentIndexName] = null;
			} catch (e) {
				JqueryUtil.doToast({type: "danger", content: `Could not load ${errorName}! ${VeCt.STR_SEE_CONSOLE}`});
				throw e;
			} finally {
				doClose();
			}
		}
	}

	static async _pGetIndex (customIndexSubSpecs) {
		const index = elasticlunr(function () {
			this.addField("n");
			this.addField("s");
			this.setRef("id");
		});

		let id = 0;
		for (const subSpec of customIndexSubSpecs) {
			const [json, prerelease, brew] = await Promise.all([
				typeof subSpec.dataSource === "string"
					? DataUtil.loadJSON(subSpec.dataSource)
					: subSpec.dataSource(),
				PrereleaseUtil.pGetBrewProcessed(),
				BrewUtil2.pGetBrewProcessed(),
			]);

			await [
				...json[subSpec.prop],
				...(prerelease[subSpec.prop] || []),
				...(brew[subSpec.prop] || []),
			]
				.pSerialAwaitMap(async ent => {
					const doc = {
						id: id++,
						c: subSpec.catId,
						cf: Parser.pageCategoryToFull(subSpec.catId),
						h: 1,
						n: ent.name,
						q: subSpec.page,
						s: ent.source,
						u: UrlUtil.URL_TO_HASH_BUILDER[subSpec.page](ent),
					};
					if (subSpec.pFnGetDocExtras) Object.assign(doc, await subSpec.pFnGetDocExtras({ent, doc, subSpec}));
					index.addDoc(doc);
				});
		}

		return index;
	}

	static _showLoadingModal () {
		const {$modalInner, doClose} = UiUtil.getShowModal({isPermanent: true});
		$(`<div class="ve-flex-vh-center w-100 h-100"><span class="dnd-font italic ve-muted">Loading...</span></div>`).appendTo($modalInner);
		return doClose;
	}
	// endregion
}
SearchWidget.P_LOADING_CONTENT = null;
SearchWidget.CONTENT_INDICES = {};
SearchWidget.P_LOADING_INDICES = {};

class InputUiUtil {
	static async _pGetShowModal (getShowModalOpts) {
		return UiUtil.getShowModal(getShowModalOpts);
	}

	static _$getBtnOk ({comp = null, opts, doClose}) {
		return $(`<button class="btn btn-primary mr-2">${opts.buttonText || "OK"}</button>`)
			.click(evt => {
				evt.stopPropagation();
				if (comp && !comp._state.isValid) return JqueryUtil.doToast({content: `Please enter valid input!`, type: "warning"});
				doClose(true);
			});
	}

	static _$getBtnCancel ({comp = null, opts, doClose}) {
		return $(`<button class="btn btn-default">Cancel</button>`)
			.click(evt => {
				evt.stopPropagation();
				doClose(false);
			});
	}

	static _$getBtnSkip ({comp = null, opts, doClose}) {
		return !opts.isSkippable ? null : $(`<button class="btn btn-default ml-3">Skip</button>`)
			.click(evt => {
				evt.stopPropagation();
				doClose(VeCt.SYM_UI_SKIP);
			});
	}

	/**
	 * @param opts Options.
	 * @param opts.min Minimum value.
	 * @param opts.max Maximum value.
	 * @param opts.int If the value returned should be an integer.
	 * @param opts.title Prompt title.
	 * @param opts.default Default value.
	 * @param [opts.$elePre] Element to add before the number input.
	 * @param [opts.$elePost] Element to add after the number input.
	 * @param [opts.isPermanent] If the prompt can only be closed by entering a number.
	 * @param [opts.isSkippable] If the prompt is skippable.
	 * @param [opts.storageKey_default] Storage key for a "default" value override using the user's last/previous input.
	 * @param [opts.isGlobal_default] If the "default" storage key is global (rather than page-specific).
	 * @return {Promise<number>} A promise which resolves to the number if the user entered one, or null otherwise.
	 */
	static async pGetUserNumber (opts) {
		opts = opts || {};

		let defaultVal = opts.default !== undefined ? opts.default : null;
		if (opts.storageKey_default) {
			const prev = await (opts.isGlobal_default ? StorageUtil.pGet(opts.storageKey_default) : StorageUtil.pGetForPage(opts.storageKey_default));
			if (prev != null) defaultVal = prev;
		}

		const $iptNumber = $(`<input class="form-control mb-2 text-right" ${opts.min ? `min="${opts.min}"` : ""} ${opts.max ? `max="${opts.max}"` : ""}>`)
			.keydown(evt => {
				if (evt.key === "Escape") { $iptNumber.blur(); return; }

				evt.stopPropagation();
				if (evt.key === "Enter") {
					evt.preventDefault();
					doClose(true);
				}
			});
		if (defaultVal !== undefined) $iptNumber.val(defaultVal);

		const {$modalInner, doClose, pGetResolved, doAutoResize: doAutoResizeModal} = await InputUiUtil._pGetShowModal({
			title: opts.title || "Enter a Number",
			isMinHeight0: true,
		});

		const $btnOk = this._$getBtnOk({opts, doClose});
		const $btnCancel = this._$getBtnCancel({opts, doClose});
		const $btnSkip = this._$getBtnSkip({opts, doClose});

		if (opts.$elePre) opts.$elePre.appendTo($modalInner);
		$iptNumber.appendTo($modalInner);
		if (opts.$elePost) opts.$elePost.appendTo($modalInner);
		$$`<div class="ve-flex-v-center ve-flex-h-right pb-1 px-1">${$btnOk}${$btnCancel}${$btnSkip}</div>`.appendTo($modalInner);

		if (doAutoResizeModal) doAutoResizeModal();

		$iptNumber.focus();
		$iptNumber.select();

		// region Output
		const [isDataEntered] = await pGetResolved();

		if (typeof isDataEntered === "symbol") return isDataEntered;

		if (!isDataEntered) return null;
		const outRaw = $iptNumber.val();
		if (!outRaw.trim()) return null;
		let out = UiUtil.strToInt(outRaw);
		if (opts.min) out = Math.max(opts.min, out);
		if (opts.max) out = Math.min(opts.max, out);
		if (opts.int) out = Math.round(out);

		if (opts.storageKey_default) {
			opts.isGlobal_default
				? StorageUtil.pSet(opts.storageKey_default, out).then(null)
				: StorageUtil.pSetForPage(opts.storageKey_default, out).then(null);
		}

		return out;
		// endregion
	}

	/**
	 * @param [opts] Options.
	 * @param [opts.title] Prompt title.
	 * @param [opts.textYesRemember] Text for "yes, and remember" button.
	 * @param [opts.textYes] Text for "yes" button.
	 * @param [opts.textNo] Text for "no" button.
	 * @param [opts.textSkip] Text for "skip" button.
	 * @param [opts.htmlDescription] Description HTML for the modal.
	 * @param [opts.storageKey] Storage key to use when "remember" options are passed.
	 * @param [opts.isGlobal] If the stored setting is global when "remember" options are passed.
	 * @param [opts.fnRemember] Custom function to run when saving the "yes and remember" option.
	 * @param [opts.isSkippable] If the prompt is skippable.
	 * @param [opts.isAlert] If this prompt is just a notification/alert.
	 * @return {Promise} A promise which resolves to true/false if the user chose, or null otherwise.
	 */
	static async pGetUserBoolean (opts) {
		opts = opts || {};

		if (opts.storageKey) {
			const prev = await (opts.isGlobal ? StorageUtil.pGet(opts.storageKey) : StorageUtil.pGetForPage(opts.storageKey));
			if (prev != null) return prev;
		}

		const $btnTrueRemember = opts.textYesRemember ? $(`<button class="btn btn-primary ve-flex-v-center mr-2"><span class="glyphicon glyphicon-ok mr-2"></span><span>${opts.textYesRemember}</span></button>`)
			.click(() => {
				doClose(true, true);
				if (opts.fnRemember) {
					opts.fnRemember(true);
				} else {
					opts.isGlobal
						? StorageUtil.pSet(opts.storageKey, true)
						: StorageUtil.pSetForPage(opts.storageKey, true);
				}
			}) : null;

		const $btnTrue = $(`<button class="btn btn-primary ve-flex-v-center mr-3"><span class="glyphicon glyphicon-ok mr-2"></span><span>${opts.textYes || "OK"}</span></button>`)
			.click(evt => {
				evt.stopPropagation();
				doClose(true, true);
			});

		const $btnFalse = opts.isAlert ? null : $(`<button class="btn btn-default btn-sm ve-flex-v-center"><span class="glyphicon glyphicon-remove mr-2"></span><span>${opts.textNo || "Cancel"}</span></button>`)
			.click(evt => {
				evt.stopPropagation();
				doClose(true, false);
			});

		const $btnSkip = !opts.isSkippable ? null : $(`<button class="btn btn-default btn-sm ml-3"><span class="glyphicon glyphicon-forward"></span><span>${opts.textSkip || "Skip"}</span></button>`)
			.click(evt => {
				evt.stopPropagation();
				doClose(VeCt.SYM_UI_SKIP);
			});

		const {$modalInner, doClose, pGetResolved, doAutoResize: doAutoResizeModal} = await InputUiUtil._pGetShowModal({
			title: opts.title || "Choose",
			isMinHeight0: true,
		});

		if (opts.htmlDescription && opts.htmlDescription.trim()) $$`<div class="ve-flex w-100 mb-1">${opts.htmlDescription}</div>`.appendTo($modalInner);
		$$`<div class="ve-flex-v-center ve-flex-h-right py-1 px-1">${$btnTrueRemember}${$btnTrue}${$btnFalse}${$btnSkip}</div>`.appendTo($modalInner);

		if (doAutoResizeModal) doAutoResizeModal();

		$btnTrue.focus();
		$btnTrue.select();

		// region Output
		const [isDataEntered, out] = await pGetResolved();

		if (typeof isDataEntered === "symbol") return isDataEntered;

		if (!isDataEntered) return null;
		if (out == null) throw new Error(`Callback must receive a value!`); // sanity check
		return out;
		// endregion
	}

	/**
	 * @param opts Options.
	 * @param opts.values Array of values.
	 * @param [opts.placeholder] Placeholder text.
	 * @param [opts.title] Prompt title.
	 * @param [opts.default] Default selected index.
	 * @param [opts.fnDisplay] Function which takes a value and returns display text.
	 * @param [opts.isResolveItem] True if the promise should resolve the item instead of the index.
	 * @param [opts.$elePost] Element to add below the select box.
	 * @param [opts.fnGetExtraState] Function which returns additional state from, generally, other elements in the modal.
	 * @param [opts.isAllowNull] If an empty input should be treated as null.
	 * @param [opts.isSkippable] If the prompt is skippable.
	 * @return {Promise} A promise which resolves to the index of the item the user selected (or an object if fnGetExtraState is passed), or null otherwise.
	 */
	static async pGetUserEnum (opts) {
		opts = opts || {};

		const $selEnum = $(`<select class="form-control mb-2"><option value="-1" disabled>${opts.placeholder || "Select..."}</option></select>`)
			.keydown(async evt => {
				evt.stopPropagation();
				if (evt.key === "Enter") {
					evt.preventDefault();
					doClose(true);
				}
			});

		if (opts.isAllowNull) $(`<option value="-1"></option>`).text(opts.fnDisplay ? opts.fnDisplay(null, -1) : "(None)").appendTo($selEnum);

		opts.values.forEach((v, i) => $(`<option value="${i}"></option>`).text(opts.fnDisplay ? opts.fnDisplay(v, i) : v).appendTo($selEnum));
		if (opts.default != null) $selEnum.val(opts.default);
		else $selEnum[0].selectedIndex = 0;

		const {$modalInner, doClose, pGetResolved, doAutoResize: doAutoResizeModal} = await InputUiUtil._pGetShowModal({
			title: opts.title || "Select an Option",
			isMinHeight0: true,
		});

		const $btnOk = this._$getBtnOk({opts, doClose});
		const $btnCancel = this._$getBtnCancel({opts, doClose});
		const $btnSkip = this._$getBtnSkip({opts, doClose});

		$selEnum.appendTo($modalInner);
		if (opts.$elePost) opts.$elePost.appendTo($modalInner);
		$$`<div class="ve-flex-v-center ve-flex-h-right pb-1 px-1">${$btnOk}${$btnCancel}${$btnSkip}</div>`.appendTo($modalInner);

		if (doAutoResizeModal) doAutoResizeModal();

		$selEnum.focus();

		// region Output
		const [isDataEntered] = await pGetResolved();
		if (typeof isDataEntered === "symbol") return isDataEntered;

		if (!isDataEntered) return null;
		const ix = Number($selEnum.val());
		if (!~ix) return null;
		if (opts.fnGetExtraState) {
			const out = {extraState: opts.fnGetExtraState()};
			if (opts.isResolveItem) out.item = opts.values[ix];
			else out.ix = ix;
			return out;
		}

		return opts.isResolveItem ? opts.values[ix] : ix;
		// endregion
	}

	/**
	 * @param opts Options.
	 * @param [opts.values] Array of values. Mutually incompatible with "valueGroups".
	 * @param [opts.valueGroups] Array of value groups (of the form `{name: "Group Name", values: [...]}`). Mutually incompatible with "values".
	 * @param [opts.title] Prompt title.
	 * @param [opts.htmlDescription] Description HTML for the modal.
	 * @param [opts.count] Number of choices the user can make (cannot be used with min/max).
	 * @param [opts.min] Minimum number of choices the user can make (cannot be used with count).
	 * @param [opts.max] Maximum number of choices the user can make (cannot be used with count).
	 * @param [opts.defaults] Array of default-selected indices.
	 * @param [opts.required] Array of always-selected indices.
	 * @param [opts.isResolveItems] True if the promise should resolve to an array of the items instead of the indices.
	 * @param [opts.fnDisplay] Function which takes a value and returns display text.
	 * @param [opts.modalOpts] Options to pass through to the underlying modal class.
	 * @param [opts.isSkippable] If the prompt is skippable.
	 * @param [opts.isSearchable] If a search input should be created.
	 * @param [opts.fnGetSearchText] Function which takes a value and returns search text.
	 * @return {Promise} A promise which resolves to the indices of the items the user selected, or null otherwise.
	 */
	static async pGetUserMultipleChoice (opts) {
		const prop = "formData";

		const initialState = {};
		if (opts.defaults) opts.defaults.forEach(ix => initialState[ComponentUiUtil.getMetaWrpMultipleChoice_getPropIsActive(prop, ix)] = true);
		if (opts.required) {
			opts.required.forEach(ix => {
				initialState[ComponentUiUtil.getMetaWrpMultipleChoice_getPropIsActive(prop, ix)] = true; // "requires" implies "default"
				initialState[ComponentUiUtil.getMetaWrpMultipleChoice_getPropIsRequired(prop, ix)] = true;
			});
		}

		const comp = BaseComponent.fromObject(initialState);

		let title = opts.title;
		if (!title) {
			if (opts.count != null) title = `Choose ${Parser.numberToText(opts.count).uppercaseFirst()}`;
			else if (opts.min != null && opts.max != null) title = `Choose Between ${Parser.numberToText(opts.min).uppercaseFirst()} and ${Parser.numberToText(opts.max).uppercaseFirst()} Options`;
			else if (opts.min != null) title = `Choose At Least ${Parser.numberToText(opts.min).uppercaseFirst()}`;
			else title = `Choose At Most ${Parser.numberToText(opts.max).uppercaseFirst()}`;
		}

		const {$ele: $wrpList, $iptSearch, propIsAcceptable} = ComponentUiUtil.getMetaWrpMultipleChoice(comp, prop, opts);
		$wrpList.addClass(`mb-1`);

		const {$modalInner, doClose, pGetResolved, doAutoResize: doAutoResizeModal} = await InputUiUtil._pGetShowModal({
			...(opts.modalOpts || {}),
			title,
			isMinHeight0: true,
			isUncappedHeight: true,
		});

		const $btnOk = this._$getBtnOk({opts, doClose});
		const $btnCancel = this._$getBtnCancel({opts, doClose});
		const $btnSkip = this._$getBtnSkip({opts, doClose});

		const hkIsAcceptable = () => $btnOk.attr("disabled", !comp._state[propIsAcceptable]);
		comp._addHookBase(propIsAcceptable, hkIsAcceptable);
		hkIsAcceptable();

		if (opts.htmlDescription) $modalInner.append(opts.htmlDescription);
		if ($iptSearch) {
			$$`<label class="mb-1">
				${$iptSearch}
			</label>`.appendTo($modalInner);
		}
		$wrpList.appendTo($modalInner);
		$$`<div class="ve-flex-v-center ve-flex-h-right no-shrink pb-1 px-1">${$btnOk}${$btnCancel}${$btnSkip}</div>`.appendTo($modalInner);

		if (doAutoResizeModal) doAutoResizeModal();

		$wrpList.focus();

		// region Output
		const [isDataEntered] = await pGetResolved();

		if (typeof isDataEntered === "symbol") return isDataEntered;

		if (!isDataEntered) return null;

		const ixs = ComponentUiUtil.getMetaWrpMultipleChoice_getSelectedIxs(comp, prop);

		if (!opts.isResolveItems) return ixs;

		if (opts.values) return ixs.map(ix => opts.values[ix]);

		if (opts.valueGroups) {
			const allValues = opts.valueGroups.map(it => it.values).flat();
			return ixs.map(ix => allValues[ix]);
		}

		throw new Error(`Should never occur!`);
		// endregion
	}

	/**
	 * NOTE: designed to work with FontAwesome.
	 *
	 * @param opts Options.
	 * @param opts.values Array of icon metadata. Items should be of the form: `{name: "<n>", iconClass: "<c>", buttonClass: "<cs>", buttonClassActive: "<cs>"}`
	 * @param opts.title Prompt title.
	 * @param opts.default Default selected index.
	 * @param [opts.isSkippable] If the prompt is skippable.
	 * @return {Promise<number>} A promise which resolves to the index of the item the user selected, or null otherwise.
	 */
	static async pGetUserIcon (opts) {
		opts = opts || {};

		let lastIx = opts.default != null ? opts.default : -1;
		const onclicks = [];

		const {$modalInner, doClose, pGetResolved, doAutoResize: doAutoResizeModal} = await InputUiUtil._pGetShowModal({
			title: opts.title || "Select an Option",
			isMinHeight0: true,
		});

		$$`<div class="ve-flex ve-flex-wrap ve-flex-h-center mb-2">${opts.values.map((v, i) => {
			const $btn = $$`<div class="m-2 btn ${v.buttonClass || "btn-default"} ui__btn-xxl-square ve-flex-col ve-flex-h-center">
					${v.iconClass ? `<div class="ui-icn__wrp-icon ${v.iconClass} mb-1"></div>` : ""}
					${v.iconContent ? v.iconContent : ""}
					<div class="whitespace-normal w-100">${v.name}</div>
				</div>`
				.click(() => {
					lastIx = i;
					onclicks.forEach(it => it());
				})
				.toggleClass(v.buttonClassActive || "active", opts.default === i);
			if (v.buttonClassActive && opts.default === i) {
				$btn.removeClass("btn-default").addClass(v.buttonClassActive);
			}

			onclicks.push(() => {
				$btn.toggleClass(v.buttonClassActive || "active", lastIx === i);
				if (v.buttonClassActive) $btn.toggleClass("btn-default", lastIx !== i);
			});
			return $btn;
		})}</div>`.appendTo($modalInner);

		const $btnOk = this._$getBtnOk({opts, doClose});
		const $btnCancel = this._$getBtnCancel({opts, doClose});
		const $btnSkip = this._$getBtnSkip({opts, doClose});

		$$`<div class="ve-flex-v-center ve-flex-h-right pb-1 px-1">${$btnOk}${$btnCancel}${$btnSkip}</div>`.appendTo($modalInner);

		// region Output
		const [isDataEntered] = await pGetResolved();

		if (typeof isDataEntered === "symbol") return isDataEntered;
		if (!isDataEntered) return null;
		return ~lastIx ? lastIx : null;
		// endregion
	}

	/**
	 * @param [opts] Options.
	 * @param [opts.title] Prompt title.
	 * @param [opts.default] Default value.
	 * @param [opts.autocomplete] Array of autocomplete strings. REQUIRES INCLUSION OF THE TYPEAHEAD LIBRARY.
	 * @param [opts.isCode] If the text is code.
	 * @param [opts.isSkippable] If the prompt is skippable.
	 * @param [opts.fnIsValid] A function which checks if the current input is valid, and prevents the user from
	 *        submitting the value if it is.
	 * @param [opts.$elePre] Element to add before the input.
	 * @param [opts.$elePost] Element to add after the input.
	 * @param [opts.cbPostRender] Callback to call after rendering the modal
	 * @return {Promise<String>} A promise which resolves to the string if the user entered one, or null otherwise.
	 */
	static async pGetUserString (opts) {
		opts = opts || {};

		const propValue = "text";
		const comp = BaseComponent.fromObject({
			[propValue]: opts.default || "",
			isValid: true,
		});

		const $iptStr = ComponentUiUtil.$getIptStr(
			comp,
			propValue,
			{
				html: `<input class="form-control mb-2" type="text">`,
				autocomplete: opts.autocomplete,
			},
		)
			.keydown(async evt => {
				if (evt.key === "Escape") return; // Already handled

				if (opts.autocomplete) {
					// prevent double-binding the return key if we have autocomplete enabled
					await MiscUtil.pDelay(17); // arbitrary delay to allow dropdown to render (~1000/60, i.e. 1 60 FPS frame)
					if ($modalInner.find(`.typeahead.dropdown-menu`).is(":visible")) return;
				}

				evt.stopPropagation();
				if (evt.key === "Enter") {
					evt.preventDefault();
					doClose(true);
				}
			});
		if (opts.isCode) $iptStr.addClass("code");

		if (opts.fnIsValid) {
			const hkText = () => comp._state.isValid = !comp._state.text.trim() || !!opts.fnIsValid(comp._state.text);
			comp._addHookBase(propValue, hkText);
			hkText();

			const hkIsValid = () => $iptStr.toggleClass("form-control--error", !comp._state.isValid);
			comp._addHookBase("isValid", hkIsValid);
			hkIsValid();
		}

		const {$modalInner, doClose, pGetResolved, doAutoResize: doAutoResizeModal} = await InputUiUtil._pGetShowModal({
			title: opts.title || "Enter Text",
			isMinHeight0: true,
		});

		const $btnOk = this._$getBtnOk({comp, opts, doClose});
		const $btnCancel = this._$getBtnCancel({comp, opts, doClose});
		const $btnSkip = this._$getBtnSkip({comp, opts, doClose});

		if (opts.$elePre) opts.$elePre.appendTo($modalInner);
		$iptStr.appendTo($modalInner);
		if (opts.$elePost) opts.$elePost.appendTo($modalInner);
		$$`<div class="ve-flex-v-center ve-flex-h-right pb-1 px-1">${$btnOk}${$btnCancel}${$btnSkip}</div>`.appendTo($modalInner);

		if (doAutoResizeModal) doAutoResizeModal();

		$iptStr.focus();
		$iptStr.select();

		if (opts.cbPostRender) {
			opts.cbPostRender({
				comp,
				$iptStr,
				propValue,
			});
		}

		// region Output
		const [isDataEntered] = await pGetResolved();

		if (typeof isDataEntered === "symbol") return isDataEntered;
		if (!isDataEntered) return null;
		const raw = $iptStr.val();
		return raw;
		// endregion
	}

	/**
	 * @param [opts] Options.
	 * @param [opts.title] Prompt title.
	 * @param [opts.buttonText] Prompt title.
	 * @param [opts.default] Default value.
	 * @param [opts.disabled] If the text area is disabled.
	 * @param [opts.isCode] If the text is code.
	 * @param [opts.isSkippable] If the prompt is skippable.
	 * @return {Promise<String>} A promise which resolves to the string if the user entered one, or null otherwise.
	 */
	static async pGetUserText (opts) {
		opts = opts || {};

		const $iptStr = $(`<textarea class="form-control mb-2 resize-vertical w-100" ${opts.disabled ? "disabled" : ""}></textarea>`)
			.val(opts.default);
		if (opts.isCode) $iptStr.addClass("code");

		const {$modalInner, doClose, pGetResolved, doAutoResize: doAutoResizeModal} = await InputUiUtil._pGetShowModal({
			title: opts.title || "Enter Text",
			isMinHeight0: true,
		});

		const $btnOk = this._$getBtnOk({opts, doClose});
		const $btnCancel = this._$getBtnCancel({opts, doClose});
		const $btnSkip = this._$getBtnSkip({opts, doClose});

		$iptStr.appendTo($modalInner);
		$$`<div class="ve-flex-v-center ve-flex-h-right pb-1 px-1">${$btnOk}${$btnCancel}${$btnSkip}</div>`.appendTo($modalInner);

		if (doAutoResizeModal) doAutoResizeModal();

		$iptStr.focus();
		$iptStr.select();

		// region Output
		const [isDataEntered] = await pGetResolved();

		if (typeof isDataEntered === "symbol") return isDataEntered;
		if (!isDataEntered) return null;
		const raw = $iptStr.val();
		if (!raw.trim()) return null;
		else return raw;
		// endregion
	}

	/**
	 * @param opts Options.
	 * @param opts.title Prompt title.
	 * @param opts.default Default value.
	 * @param [opts.isSkippable] If the prompt is skippable.
	 * @return {Promise<String>} A promise which resolves to the color if the user entered one, or null otherwise.
	 */
	static async pGetUserColor (opts) {
		opts = opts || {};

		const $iptRgb = $(`<input class="form-control mb-2" ${opts.default != null ? `value="${opts.default}"` : ""} type="color">`);

		const {$modalInner, doClose, pGetResolved, doAutoResize: doAutoResizeModal} = await InputUiUtil._pGetShowModal({
			title: opts.title || "Choose Color",
			isMinHeight0: true,
		});

		const $btnOk = this._$getBtnOk({opts, doClose});
		const $btnCancel = this._$getBtnCancel({opts, doClose});
		const $btnSkip = this._$getBtnSkip({opts, doClose});

		$iptRgb.appendTo($modalInner);
		$$`<div class="ve-flex-v-center ve-flex-h-right pb-1 px-1">${$btnOk}${$btnCancel}${$btnSkip}</div>`.appendTo($modalInner);

		if (doAutoResizeModal) doAutoResizeModal();

		$iptRgb.focus();
		$iptRgb.select();

		// region Output
		const [isDataEntered] = await pGetResolved();

		if (typeof isDataEntered === "symbol") return isDataEntered;
		if (!isDataEntered) return null;
		const raw = $iptRgb.val();
		if (!raw.trim()) return null;
		else return raw;
		// endregion
	}

	/**
	 *
	 * @param [opts] Options object.
	 * @param [opts.title] Modal title.
	 * @param [opts.default] Default angle.
	 * @param [opts.stepButtons] Array of labels for quick-set buttons, which will be evenly spread around the clock.
	 * @param [opts.step] Number of steps in the gauge (default 360; would be e.g. 12 for a "clock").
	 * @param [opts.isSkippable] If the prompt is skippable.
	 * @returns {Promise<number>} A promise which resolves to the number of degrees if the user pressed "Enter," or null otherwise.
	 */
	static async pGetUserDirection (opts) {
		const X = 0;
		const Y = 1;
		const DEG_CIRCLE = 360;

		opts = opts || {};
		const step = Math.max(2, Math.min(DEG_CIRCLE, opts.step || DEG_CIRCLE));
		const stepDeg = DEG_CIRCLE / step;

		function getAngle (p1, p2) {
			return Math.atan2(p2[Y] - p1[Y], p2[X] - p1[X]) * 180 / Math.PI;
		}

		let active = false;
		let curAngle = Math.min(DEG_CIRCLE, opts.default) || 0;

		const $arm = $(`<div class="ui-dir__arm"></div>`);
		const handleAngle = () => $arm.css({transform: `rotate(${curAngle + 180}deg)`});
		handleAngle();

		const $pad = $$`<div class="ui-dir__face">${$arm}</div>`.on("mousedown touchstart", evt => {
			active = true;
			handleEvent(evt);
		});

		const $document = $(document);
		const evtId = `ui_user_dir_${CryptUtil.uid()}`;
		$document.on(`mousemove.${evtId} touchmove${evtId}`, evt => {
			handleEvent(evt);
		}).on(`mouseup.${evtId} touchend${evtId} touchcancel${evtId}`, evt => {
			evt.preventDefault();
			evt.stopPropagation();
			active = false;
		});
		const handleEvent = (evt) => {
			if (!active) return;

			const coords = [EventUtil.getClientX(evt), EventUtil.getClientY(evt)];

			const {top, left} = $pad.offset();
			const center = [left + ($pad.width() / 2), top + ($pad.height() / 2)];
			curAngle = getAngle(center, coords) + 90;
			if (step !== DEG_CIRCLE) curAngle = Math.round(curAngle / stepDeg) * stepDeg;
			else curAngle = Math.round(curAngle);
			handleAngle();
		};

		const BTN_STEP_SIZE = 26;
		const BORDER_PAD = 16;
		const CONTROLS_RADIUS = (92 + BTN_STEP_SIZE + BORDER_PAD) / 2;
		const $padOuter = opts.stepButtons ? (() => {
			const steps = opts.stepButtons;
			const SEG_ANGLE = 360 / steps.length;

			const $btns = [];

			for (let i = 0; i < steps.length; ++i) {
				const theta = (SEG_ANGLE * i * (Math.PI / 180)) - (1.5708); // offset by -90 degrees
				const x = CONTROLS_RADIUS * Math.cos(theta);
				const y = CONTROLS_RADIUS * Math.sin(theta);
				$btns.push(
					$(`<button class="btn btn-default btn-xxs absolute">${steps[i]}</button>`)
						.css({
							top: y + CONTROLS_RADIUS - (BTN_STEP_SIZE / 2),
							left: x + CONTROLS_RADIUS - (BTN_STEP_SIZE / 2),
							width: BTN_STEP_SIZE,
							height: BTN_STEP_SIZE,
							zIndex: 1002,
						})
						.click(() => {
							curAngle = SEG_ANGLE * i;
							handleAngle();
						}),
				);
			}

			const $wrpInner = $$`<div class="ve-flex-vh-center relative">${$btns}${$pad}</div>`
				.css({
					width: CONTROLS_RADIUS * 2,
					height: CONTROLS_RADIUS * 2,
				});

			return $$`<div class="ve-flex-vh-center">${$wrpInner}</div>`
				.css({
					width: (CONTROLS_RADIUS * 2) + BTN_STEP_SIZE + BORDER_PAD,
					height: (CONTROLS_RADIUS * 2) + BTN_STEP_SIZE + BORDER_PAD,
				});
		})() : null;

		const {$modalInner, doClose, pGetResolved, doAutoResize: doAutoResizeModal} = await InputUiUtil._pGetShowModal({
			title: opts.title || "Select Direction",
			isMinHeight0: true,
		});

		const $btnOk = this._$getBtnOk({opts, doClose});
		const $btnCancel = this._$getBtnCancel({opts, doClose});
		const $btnSkip = this._$getBtnSkip({opts, doClose});

		$$`<div class="ve-flex-vh-center mb-3">
				${$padOuter || $pad}
			</div>`.appendTo($modalInner);
		$$`<div class="ve-flex-v-center ve-flex-h-right pb-1 px-1">${$btnOk}${$btnCancel}${$btnSkip}</div>`.appendTo($modalInner);

		if (doAutoResizeModal) doAutoResizeModal();

		// region Output
		const [isDataEntered] = await pGetResolved();

		if (typeof isDataEntered === "symbol") return isDataEntered;
		$document.off(`mousemove.${evtId} touchmove${evtId} mouseup.${evtId} touchend${evtId} touchcancel${evtId}`);
		if (!isDataEntered) return null;
		if (curAngle < 0) curAngle += 360;
		return curAngle; // TODO returning the step number is more useful if step is specified?
		// endregion
	}

	/**
	 * @param [opts] Options.
	 * @param [opts.title] Prompt title.
	 * @param [opts.default] Default values. Should be an object of the form `{num, faces, bonus}`.
	 * @param [opts.isSkippable] If the prompt is skippable.
	 * @return {Promise<String>} A promise which resolves to a dice string if the user entered values, or null otherwise.
	 */
	static async pGetUserDice (opts) {
		opts = opts || {};

		const comp = BaseComponent.fromObject({
			num: (opts.default && opts.default.num) || 1,
			faces: (opts.default && opts.default.faces) || 6,
			bonus: (opts.default && opts.default.bonus) || null,
		});

		comp.render = function ($parent) {
			$parent.empty();

			const $iptNum = ComponentUiUtil.$getIptInt(this, "num", 0, {$ele: $(`<input class="form-control input-xs form-control--minimal text-center mr-1">`)})
				.appendTo($parent)
				.keydown(evt => {
					if (evt.key === "Escape") { $iptNum.blur(); return; }
					// return key
					if (evt.which === 13) doClose(true);
					evt.stopPropagation();
				});
			const $selFaces = ComponentUiUtil.$getSelEnum(this, "faces", {values: Renderer.dice.DICE})
				.addClass("mr-2").addClass("text-center").css("textAlignLast", "center");

			const $iptBonus = $(`<input class="form-control input-xs form-control--minimal text-center">`)
				.change(() => this._state.bonus = UiUtil.strToInt($iptBonus.val(), null, {fallbackOnNaN: null}))
				.keydown(evt => {
					if (evt.key === "Escape") { $iptBonus.blur(); return; }
					// return key
					if (evt.which === 13) doClose(true);
					evt.stopPropagation();
				});
			const hook = () => $iptBonus.val(this._state.bonus != null ? UiUtil.intToBonus(this._state.bonus) : this._state.bonus);
			comp._addHookBase("bonus", hook);
			hook();

			$$`<div class="ve-flex-vh-center">${$iptNum}<div class="mr-1">d</div>${$selFaces}${$iptBonus}</div>`.appendTo($parent);
		};

		comp.getAsString = function () {
			return `${this._state.num}d${this._state.faces}${this._state.bonus ? UiUtil.intToBonus(this._state.bonus) : ""}`;
		};

		const {$modalInner, doClose, pGetResolved, doAutoResize: doAutoResizeModal} = await InputUiUtil._pGetShowModal({
			title: opts.title || "Enter Dice",
			isMinHeight0: true,
		});

		const $btnOk = this._$getBtnOk({opts, doClose});
		const $btnCancel = this._$getBtnCancel({opts, doClose});
		const $btnSkip = this._$getBtnSkip({opts, doClose});

		comp.render($modalInner);

		$$`<div class="ve-flex-v-center ve-flex-h-right pb-1 px-1 mt-2">${$btnOk}${$btnCancel}${$btnSkip}</div>`.appendTo($modalInner);

		if (doAutoResizeModal) doAutoResizeModal();

		// region Output
		const [isDataEntered] = await pGetResolved();

		if (typeof isDataEntered === "symbol") return isDataEntered;
		if (!isDataEntered) return null;
		return comp.getAsString();
		// endregion
	}
}

class DragReorderUiUtil {
	/**
	 * Create a draggable pad capable of re-ordering rendered components. This requires to components to have:
	 *  - an `id` getter
	 *  - a `pos` getter and setter
	 *  - a `height` getter
	 *
	 * @param opts Options object.
	 * @param opts.$parent The parent element containing the rendered components.
	 * @param opts.componentsParent The object which has the array of components as a property.
	 * @param opts.componentsProp The property name of the components array.
	 * @param opts.componentId This component ID.
	 * @param [opts.marginSide] The margin side; "r" or "l" (defaults to "l").
	 */
	static $getDragPad (opts) {
		opts = opts || {};

		const getComponentById = (id) => opts.componentsParent[opts.componentsProp].find(it => it.id === id);

		const dragMeta = {};
		const doDragCleanup = () => {
			dragMeta.on = false;
			dragMeta.$wrap.remove();
			dragMeta.$dummies.forEach($d => $d.remove());
			$(document.body).off(`mouseup.drag__stop`);
		};

		const doDragRender = () => {
			if (dragMeta.on) doDragCleanup();

			$(document.body).on(`mouseup.drag__stop`, () => {
				if (dragMeta.on) doDragCleanup();
			});

			dragMeta.on = true;
			dragMeta.$wrap = $(`<div class="ve-flex-col ui-drag__wrp-drag-block"></div>`).appendTo(opts.$parent);
			dragMeta.$dummies = [];

			const ids = opts.componentsParent[opts.componentsProp].map(it => it.id);

			ids.forEach(id => {
				const $dummy = $(`<div class="w-100 ${id === opts.componentId ? "ui-drag__wrp-drag-dummy--highlight" : "ui-drag__wrp-drag-dummy--lowlight"}"></div>`)
					.height(getComponentById(id).height)
					.mouseup(() => {
						if (dragMeta.on) doDragCleanup();
					})
					.appendTo(dragMeta.$wrap);
				dragMeta.$dummies.push($dummy);

				if (id !== opts.componentId) { // on entering other areas, swap positions
					$dummy.mouseenter(() => {
						const cachedPos = getComponentById(id).pos;

						getComponentById(id).pos = getComponentById(opts.componentId).pos;
						getComponentById(opts.componentId).pos = cachedPos;

						doDragRender();
					});
				}
			});
		};

		return $(`<div class="m${opts.marginSide || "l"}-2 ui-drag__patch" title="Drag to Reorder">
		<div class="ui-drag__patch-col"><div>&#8729</div><div>&#8729</div><div>&#8729</div></div>
		<div class="ui-drag__patch-col"><div>&#8729</div><div>&#8729</div><div>&#8729</div></div>
		</div>`).mousedown(() => doDragRender());
	}

	/**
	 * @param $fnGetRow Function which returns a $row element. Is a function instead of a value so it can be lazy-loaded later.
	 * @param opts Options object.
	 * @param opts.$parent
	 * @param opts.swapRowPositions
	 * @param [opts.$children] An array of row elements.
	 * @param [opts.$getChildren] Should return an array as described in the "$children" option.
	 * @param [opts.fnOnDragComplete] A function to run when dragging is completed.
	 */
	static $getDragPadOpts ($fnGetRow, opts) {
		if (!opts.$parent || !opts.swapRowPositions || (!opts.$children && !opts.$getChildren)) throw new Error("Missing required option(s)!");

		const dragMeta = {};
		const doDragCleanup = () => {
			dragMeta.on = false;
			dragMeta.$wrap.remove();
			dragMeta.$dummies.forEach($d => $d.remove());
			$(document.body).off(`mouseup.drag__stop`);
			if (opts.fnOnDragComplete) opts.fnOnDragComplete();
		};

		const doDragRender = () => {
			if (dragMeta.on) doDragCleanup();

			$(document.body).on(`mouseup.drag__stop`, () => {
				if (dragMeta.on) doDragCleanup();
			});

			dragMeta.on = true;
			dragMeta.$wrap = $(`<div class="ve-flex-col ui-drag__wrp-drag-block"></div>`).appendTo(opts.$parent);
			dragMeta.$dummies = [];

			const $children = opts.$getChildren ? opts.$getChildren() : opts.$children;
			const ixRow = $children.indexOf($fnGetRow());

			$children.forEach(($child, i) => {
				const dimensions = {w: $child.outerWidth(true), h: $child.outerHeight(true)};
				const $dummy = $(`<div class="no-shrink ${i === ixRow ? "ui-drag__wrp-drag-dummy--highlight" : "ui-drag__wrp-drag-dummy--lowlight"}"></div>`)
					.width(dimensions.w).height(dimensions.h)
					.mouseup(() => {
						if (dragMeta.on) doDragCleanup();
					})
					.appendTo(dragMeta.$wrap);
				dragMeta.$dummies.push($dummy);

				if (i !== ixRow) { // on entering other areas, swap positions
					$dummy.mouseenter(() => {
						opts.swapRowPositions(i, ixRow);
						doDragRender();
					});
				}
			});
		};

		return $(`<div class="mr-2 ui-drag__patch" title="Drag to Reorder">
		<div class="ui-drag__patch-col"><div>&#8729</div><div>&#8729</div><div>&#8729</div></div>
		<div class="ui-drag__patch-col"><div>&#8729</div><div>&#8729</div><div>&#8729</div></div>
		</div>`).mousedown(() => doDragRender());
	}

	/**
	 * @param $fnGetRow Function which returns a $row element. Is a function instead of a value so it can be lazy-loaded later.
	 * @param $parent Parent elements to attach row elements to. Should have (e.g.) "relative" CSS positioning.
	 * @param parent Parent component which has a pod decomposable as {swapRowPositions, <$children|$getChildren>}.
	 * @return jQuery
	 */
	static $getDragPad2 ($fnGetRow, $parent, parent) {
		const {swapRowPositions, $children, $getChildren} = parent;
		const nxtOpts = {$parent, swapRowPositions, $children, $getChildren};
		return this.$getDragPadOpts($fnGetRow, nxtOpts);
	}
}

class SourceUiUtil {
	static _getValidOptions (options) {
		if (!options) throw new Error(`No options were specified!`);
		if (!options.$parent || !options.cbConfirm || !options.cbConfirmExisting || !options.cbCancel) throw new Error(`Missing options!`);
		options.mode = options.mode || "add";
		return options;
	}

	/**
	 * @param options Options object.
	 * @param options.$parent Parent element.
	 * @param options.cbConfirm Confirmation callback for inputting new sources.
	 * @param options.cbConfirmExisting Confirmation callback for selecting existing sources.
	 * @param options.cbCancel Cancellation callback.
	 * @param options.mode (Optional) Mode to build in, "select", "edit" or "add". Defaults to "select".
	 * @param options.source (Optional) Homebrew source object.
	 * @param options.isRequired (Optional) True if a source must be selected.
	 */
	static render (options) {
		options = SourceUiUtil._getValidOptions(options);
		options.$parent.empty();
		options.mode = options.mode || "select";

		const isEditMode = options.mode === "edit";

		let jsonDirty = false;
		const $iptName = $(`<input class="form-control ui-source__ipt-named">`)
			.keydown(evt => { if (evt.key === "Escape") $iptName.blur(); })
			.change(() => {
				if (!jsonDirty && !isEditMode) $iptJson.val($iptName.val().replace(/[^-_a-zA-Z]/g, ""));
				$iptName.removeClass("form-control--error");
			});
		if (options.source) $iptName.val(options.source.full);
		const $iptAbv = $(`<input class="form-control ui-source__ipt-named">`)
			.keydown(evt => { if (evt.key === "Escape") $iptAbv.blur(); })
			.change(() => {
				$iptAbv.removeClass("form-control--error");
			});
		if (options.source) $iptAbv.val(options.source.abbreviation);
		const $iptJson = $(`<input class="form-control ui-source__ipt-named" ${isEditMode ? "disabled" : ""}>`)
			.keydown(evt => { if (evt.key === "Escape") $iptJson.blur(); })
			.change(() => {
				jsonDirty = true;
				$iptJson.removeClass("form-control--error");
			});
		if (options.source) $iptJson.val(options.source.json);
		let hasColor = false;
		const $iptColor = $(`<input type="color" class="w-100 b-0">`)
			.keydown(evt => { if (evt.key === "Escape") $iptColor.blur(); })
			.change(() => hasColor = true);
		if (options.source?.color != null) (hasColor = true) && $iptColor.val(options.source.color);
		const $iptUrl = $(`<input class="form-control ui-source__ipt-named">`)
			.keydown(evt => { if (evt.key === "Escape") $iptUrl.blur(); });
		if (options.source) $iptUrl.val(options.source.url);
		const $iptAuthors = $(`<input class="form-control ui-source__ipt-named">`)
			.keydown(evt => { if (evt.key === "Escape") $iptAuthors.blur(); });
		if (options.source) $iptAuthors.val((options.source.authors || []).join(", "));
		const $iptConverters = $(`<input class="form-control ui-source__ipt-named">`)
			.keydown(evt => { if (evt.key === "Escape") $iptConverters.blur(); });
		if (options.source) $iptConverters.val((options.source.convertedBy || []).join(", "));

		const $btnOk = $(`<button class="btn btn-primary">OK</button>`)
			.click(async () => {
				let incomplete = false;
				[$iptName, $iptAbv, $iptJson].forEach($ipt => {
					const val = $ipt.val();
					if (!val || !val.trim()) (incomplete = true) && $ipt.addClass("form-control--error");
				});
				if (incomplete) return;

				const jsonVal = $iptJson.val().trim();
				if (!isEditMode && BrewUtil2.hasSourceJson(jsonVal)) {
					$iptJson.addClass("form-control--error");
					JqueryUtil.doToast({content: `The JSON identifier "${jsonVal}" already exists!`, type: "danger"});
					return;
				}

				const source = {
					json: jsonVal,
					abbreviation: $iptAbv.val().trim(),
					full: $iptName.val().trim(),
					url: $iptUrl.val().trim(),
					color: $iptColor.val().trim(),
					authors: $iptAuthors.val().trim().split(",").map(it => it.trim()).filter(Boolean),
					convertedBy: $iptConverters.val().trim().split(",").map(it => it.trim()).filter(Boolean),
				};

				await options.cbConfirm(source, options.mode !== "edit");
			});

		const $btnCancel = options.isRequired && !isEditMode
			? null
			: $(`<button class="btn btn-default ml-2">Cancel</button>`).click(() => options.cbCancel());

		const $btnUseExisting = $(`<button class="btn btn-default">Use an Existing Source</button>`)
			.click(() => {
				$stageInitial.hideVe();
				$stageExisting.showVe();

				// cleanup
				[$iptName, $iptAbv, $iptJson].forEach($ipt => $ipt.removeClass("form-control--error"));
			});

		const $stageInitial = $$`<div class="h-100 w-100 ve-flex-vh-center"><div class="ve-flex-col">
			<h3 class="text-center">${isEditMode ? "Edit Homebrew Source" : "Add a Homebrew Source"}</h3>
			<div class="ui-source__row mb-2"><div class="col-12 ve-flex-v-center">
				<span class="mr-2 ui-source__name help" title="The name or title for the homebrew you wish to create. This could be the name of a book or PDF; for example, 'Monster Manual'">Title</span>
				${$iptName}
			</div></div>
			<div class="ui-source__row mb-2"><div class="col-12 ve-flex-v-center">
				<span class="mr-2 ui-source__name help" title="An abbreviated form of the title. This will be shown in lists on the site, and in the top-right corner of stat blocks or data entries; for example, 'MM'">Abbreviation</span>
				${$iptAbv}
			</div></div>
			<div class="ui-source__row mb-2"><div class="col-12 ve-flex-v-center">
				<span class="mr-2 ui-source__name help" title="This will be used to identify your homebrew universally, so should be unique to you and you alone">JSON Identifier</span>
				${$iptJson}
			</div></div>
			<div class="ui-source__row mb-2"><div class="col-12 ve-flex-v-center">
				<span class="mr-2 ui-source__name help" title="A color which should be used when displaying the source abbreviation">Color</span>
				${$iptColor}
			</div></div>
			<div class="ui-source__row mb-2"><div class="col-12 ve-flex-v-center">
				<span class="mr-2 ui-source__name help" title="A link to the original homebrew, e.g. a GM Binder page">Source URL</span>
				${$iptUrl}
			</div></div>
			<div class="ui-source__row mb-2"><div class="col-12 ve-flex-v-center">
				<span class="mr-2 ui-source__name help" title="A comma-separated list of authors, e.g. 'John Doe, Joe Bloggs'">Author(s)</span>
				${$iptAuthors}
			</div></div>
			<div class="ui-source__row mb-2"><div class="col-12 ve-flex-v-center">
				<span class="mr-2 ui-source__name help" title="A comma-separated list of people who converted the homebrew to 5etools' format, e.g. 'John Doe, Joe Bloggs'">Converted By</span>
				${$iptConverters}
			</div></div>
			<div class="text-center mb-2">${$btnOk}${$btnCancel}</div>

			${!isEditMode && BrewUtil2.getMetaLookup("sources")?.length ? $$`<div class="ve-flex-vh-center mb-3 mt-3"><span class="ui-source__divider"></span>or<span class="ui-source__divider"></span></div>
			<div class="ve-flex-vh-center">${$btnUseExisting}</div>` : ""}
		</div></div>`.appendTo(options.$parent);

		const $selExisting = $$`<select class="form-control input-sm">
			<option disabled>Select</option>
			${(BrewUtil2.getMetaLookup("sources") || []).sort((a, b) => SortUtil.ascSortLower(a.full, b.full)).map(s => `<option value="${s.json.escapeQuotes()}">${s.full.escapeQuotes()}</option>`)}
		</select>`.change(() => $selExisting.removeClass("form-control--error"));
		$selExisting[0].selectedIndex = 0;

		const $btnConfirmExisting = $(`<button class="btn btn-default btn-sm">Confirm</button>`)
			.click(async () => {
				if ($selExisting[0].selectedIndex === 0) {
					$selExisting.addClass("form-control--error");
					return;
				}

				const sourceJson = $selExisting.val();
				const source = BrewUtil2.sourceJsonToSource(sourceJson);
				await options.cbConfirmExisting(source);

				// cleanup
				$selExisting[0].selectedIndex = 0;
				$stageExisting.hideVe();
				$stageInitial.showVe();
			});

		const $btnBackExisting = $(`<button class="btn btn-default btn-sm mr-2">Back</button>`)
			.click(() => {
				$selExisting[0].selectedIndex = 0;
				$stageExisting.hideVe();
				$stageInitial.showVe();
			});

		const $stageExisting = $$`<div class="h-100 w-100 ve-flex-vh-center ve-hidden"><div>
			<h3 class="text-center">Select a Homebrew Source</h3>
			<div class="mb-2"><div class="col-12 ve-flex-vh-center">${$selExisting}</div></div>
			<div class="col-12 ve-flex-vh-center">${$btnBackExisting}${$btnConfirmExisting}</div>
		</div></div>`.appendTo(options.$parent);
	}
}

function MixinBaseComponent (Cls) {
	class MixedBaseComponent extends Cls {
		constructor (...args) {
			super(...args);

			this.__locks = {};
			this.__rendered = {};

			// state
			this.__state = {...this._getDefaultState()};
			this._state = this._getProxy("state", this.__state);
		}

		_addHookBase (prop, hook) {
			return this._addHook("state", prop, hook);
		}

		_removeHookBase (prop, hook) {
			return this._removeHook("state", prop, hook);
		}

		_removeHooksBase (prop) {
			return this._removeHooks("state", prop);
		}

		_addHookAllBase (hook) {
			return this._addHookAll("state", hook);
		}

		_removeHookAllBase (hook) {
			return this._removeHookAll("state", hook);
		}

		_setState (toState) {
			this._proxyAssign("state", "_state", "__state", toState, true);
		}

		_setStateValue (prop, value, {isForceTriggerHooks = true} = {}) {
			if (this._state[prop] === value && !isForceTriggerHooks) return value;
			// If the value is new, hooks will be run automatically
			if (this._state[prop] !== value) return this._state[prop] = value;

			this._doFireHooksAll("state", prop, value, value);
			this._doFireHooks("state", prop, value, value);
			return value;
		}

		_getState () { return MiscUtil.copyFast(this.__state); }

		getPod () {
			this.__pod = this.__pod || {
				get: (prop) => this._state[prop],
				set: (prop, val) => this._state[prop] = val,
				delete: (prop) => delete this._state[prop],
				addHook: (prop, hook) => this._addHookBase(prop, hook),
				addHookAll: (hook) => this._addHookAllBase(hook),
				removeHook: (prop, hook) => this._removeHookBase(prop, hook),
				removeHookAll: (hook) => this._removeHookAllBase(hook),
				triggerCollectionUpdate: (prop) => this._triggerCollectionUpdate(prop),
				setState: (state) => this._setState(state),
				getState: () => this._getState(),
				assign: (toObj, isOverwrite) => this._proxyAssign("state", "_state", "__state", toObj, isOverwrite),
				pLock: lockName => this._pLock(lockName),
				unlock: lockName => this._unlock(lockName),
				component: this,
			};
			return this.__pod;
		}

		// to be overridden as required
		_getDefaultState () { return {}; }

		getBaseSaveableState () {
			return {
				state: MiscUtil.copyFast(this.__state),
			};
		}

		setBaseSaveableStateFrom (toLoad, isOverwrite = false) {
			toLoad?.state && this._proxyAssignSimple("state", toLoad.state, isOverwrite);
		}

		/**
		 * @param opts Options object.
		 * @param opts.prop The state property.
		 * @param [opts.namespace] The render namespace.
		 */
		_getRenderedCollection (opts) {
			opts = opts || {};
			const renderedLookupProp = opts.namespace ? `${opts.namespace}.${opts.prop}` : opts.prop;
			return (this.__rendered[renderedLookupProp] = this.__rendered[renderedLookupProp] || {});
		}

		/**
		 * Asynchronous version available below.
		 * @param opts Options object.
		 * @param opts.prop The state property.
		 * @param [opts.fnDeleteExisting] Function to run on deleted render meta. Arguments are `rendered, item`.
		 * @param [opts.fnReorderExisting] Function to run on all meta, as a final step. Useful for re-ordering elements.
		 * @param opts.fnUpdateExisting Function to run on existing render meta. Arguments are `rendered, item`.
		 * @param opts.fnGetNew Function to run which generates existing render meta. Arguments are `item`.
		 * @param [opts.isDiffMode] If a diff of the state should be taken/checked before updating renders.
		 * @param [opts.namespace] A namespace to store these renders under. Useful if multiple renders are being made from
		 *        the same collection.
		 */
		_renderCollection (opts) {
			opts = opts || {};

			const rendered = this._getRenderedCollection(opts);
			const toDelete = new Set(Object.keys(rendered));

			(this._state[opts.prop] || []).forEach((it, i) => {
				if (it.id == null) throw new Error(`Collection item did not have an ID!`);
				const meta = rendered[it.id];

				toDelete.delete(it.id);
				if (meta) {
					if (opts.isDiffMode) {
						// Hashing the stringified JSON relies on the property order remaining consistent, but this is fine
						const nxtHash = CryptUtil.md5(JSON.stringify(it));
						if (nxtHash !== meta.__hash) {
							meta.__hash = nxtHash;
						} else return;
					}

					meta.data = it; // update any existing pointers
					opts.fnUpdateExisting(meta, it, i);
				} else {
					const meta = opts.fnGetNew(it, i);

					// If the "get new" function returns null, skip rendering this entity
					if (meta == null) return;

					meta.data = it;
					if (!meta.$wrpRow && !meta.fmRemoveEles) throw new Error(`A "$wrpRow" or a "fmRemoveEles" property is required for deletes!`);

					if (opts.isDiffMode) meta.hash = CryptUtil.md5(JSON.stringify(it));

					rendered[it.id] = meta;
				}
			});

			toDelete.forEach(id => {
				const meta = rendered[id];
				if (meta.$wrpRow) meta.$wrpRow.remove();
				if (meta.fmRemoveEles) meta.fmRemoveEles();
				delete rendered[id];
				if (opts.fnDeleteExisting) opts.fnDeleteExisting(meta);
			});

			if (opts.fnReorderExisting) {
				(this._state[opts.prop] || []).forEach((it, i) => {
					const meta = rendered[it.id];
					opts.fnReorderExisting(meta, it, i);
				});
			}
		}

		/**
		 * Synchronous version available above.
		 * @param [opts] Options object.
		 * @param opts.prop The state property.
		 * @param [opts.pFnDeleteExisting] Function to run on deleted render meta. Arguments are `rendered, item`.
		 * @param opts.pFnUpdateExisting Function to run on existing render meta. Arguments are `rendered, item`.
		 * @param opts.pFnGetNew Function to run which generates existing render meta. Arguments are `item`.
		 * @param [opts.isDiffMode] If updates should be run in "diff" mode (i.e. no update is run if nothing has changed).
		 * @param [opts.isMultiRender] If multiple renders will be produced.
		 * @param [opts.additionalCaches] Additional cache objects to be cleared on entity delete. Should be objects with
		 *        entity IDs as keys.
		 * @param [opts.namespace] A namespace to store these renders under. Useful if multiple renders are being made from
		 *        the same collection.
		 */
		async _pRenderCollection (opts) {
			opts = opts || {};

			const rendered = this._getRenderedCollection(opts);
			const entities = this._state[opts.prop];
			return this._pRenderCollection_doRender(rendered, entities, opts);
		}

		async _pRenderCollection_doRender (rendered, entities, opts) {
			opts = opts || {};

			const toDelete = new Set(Object.keys(rendered));

			// Run the external functions in serial, to prevent element re-ordering
			for (let i = 0; i < entities.length; ++i) {
				const it = entities[i];

				if (!it.id) throw new Error(`Collection item did not have an ID!`);
				// N.B.: Meta can be an array, if one item maps to multiple renders (e.g. the same is shown in two places)
				const meta = rendered[it.id];

				toDelete.delete(it.id);
				if (meta) {
					if (opts.isDiffMode) {
						// Hashing the stringified JSON relies on the property order remaining consistent, but this is fine
						const nxtHash = CryptUtil.md5(JSON.stringify(it));
						if (nxtHash !== meta.__hash) meta.__hash = nxtHash;
						else continue;
					}

					const nxtMeta = await opts.pFnUpdateExisting(meta, it);
					// Overwrite the existing renders in multi-render mode
					//    Otherwise, just ignore the result--single renders never modify their render
					if (opts.isMultiRender) rendered[it.id] = nxtMeta;
				} else {
					const meta = await opts.pFnGetNew(it);
					// If the generator decides there's nothing to render, skip this item
					if (meta == null) continue;

					if (opts.isMultiRender && meta.some(it => !it.$wrpRow && !it.fmRemoveEles)) throw new Error(`A "$wrpRow" or a "fmRemoveEles" property is required for deletes!`);
					if (!opts.isMultiRender && !meta.$wrpRow && !meta.fmRemoveEles) throw new Error(`A "$wrpRow" or a "fmRemoveEles" property is required for deletes!`);

					if (opts.isDiffMode) meta.__hash = CryptUtil.md5(JSON.stringify(it));

					rendered[it.id] = meta;
				}
			}

			const doRemoveELements = meta => {
				if (meta.$wrpRow) meta.$wrpRow.remove();
				if (meta.fmRemoveEles) meta.fmRemoveEles();
			};

			for (const id of toDelete) {
				const meta = rendered[id];
				if (opts.isMultiRender) meta.forEach(it => doRemoveELements(it));
				else doRemoveELements(meta);
				if (opts.additionalCaches) opts.additionalCaches.forEach(it => delete it[id]);
				delete rendered[id];
				if (opts.pFnDeleteExisting) await opts.pFnDeleteExisting(meta);
			}
		}

		/**
		 * Detach (and thus preserve) rendered collection elements so they can be re-used later.
		 * @param prop The state property.
		 * @param [namespace] A namespace to store these renders under. Useful if multiple renders are being made from
		 *        the same collection.
		 */
		_detachCollection (prop, namespace = null) {
			const renderedLookupProp = namespace ? `${namespace}.${prop}` : prop;
			const rendered = (this.__rendered[renderedLookupProp] = this.__rendered[renderedLookupProp] || {});
			Object.values(rendered).forEach(it => it.$wrpRow.detach());
		}

		/**
		 * Wipe any rendered collection elements, and reset the render cache.
		 * @param prop The state property.
		 * @param [namespace] A namespace to store these renders under. Useful if multiple renders are being made from
		 *        the same collection.
		 */
		_resetCollectionRenders (prop, namespace = null) {
			const renderedLookupProp = namespace ? `${namespace}.${prop}` : prop;
			const rendered = (this.__rendered[renderedLookupProp] = this.__rendered[renderedLookupProp] || {});
			Object.values(rendered).forEach(it => it.$wrpRow.remove());
			delete this.__rendered[renderedLookupProp];
		}

		render () { throw new Error("Unimplemented!"); }

		// to be overridden as required
		getSaveableState () { return {...this.getBaseSaveableState()}; }
		setStateFrom (toLoad, isOverwrite = false) { this.setBaseSaveableStateFrom(toLoad, isOverwrite); }

		async _pLock (lockName) {
			while (this.__locks[lockName]) await this.__locks[lockName].lock;
			let unlock = null;
			const lock = new Promise(resolve => unlock = resolve);
			this.__locks[lockName] = {
				lock,
				unlock,
			};
		}

		async _pGate (lockName) {
			while (this.__locks[lockName]) await this.__locks[lockName].lock;
		}

		_unlock (lockName) {
			const lockMeta = this.__locks[lockName];
			if (lockMeta) {
				delete this.__locks[lockName];
				lockMeta.unlock();
			}
		}

		async _pDoProxySetBase (prop, value) { return this._pDoProxySet("state", this.__state, prop, value); }

		_triggerCollectionUpdate (prop) {
			if (!this._state[prop]) return;
			this._state[prop] = [...this._state[prop]];
		}

		static _toCollection (array) {
			if (array) return array.map(it => ({id: CryptUtil.uid(), entity: it}));
		}

		static _fromCollection (array) {
			if (array) return array.map(it => it.entity);
		}

		static fromObject (obj, ...noModCollections) {
			const comp = new this();
			Object.entries(MiscUtil.copyFast(obj)).forEach(([k, v]) => {
				if (v == null) comp.__state[k] = v;
				else if (noModCollections.includes(k) || noModCollections.includes("*")) comp.__state[k] = v;
				else if (typeof v === "object" && v instanceof Array) comp.__state[k] = BaseComponent._toCollection(v);
				else comp.__state[k] = v;
			});
			return comp;
		}

		static fromObjectNoMod (obj) { return this.fromObject(obj, "*"); }

		toObject (...noModCollections) {
			const cpy = MiscUtil.copyFast(this.__state);
			Object.entries(cpy).forEach(([k, v]) => {
				if (v == null) return;

				if (noModCollections.includes(k) || noModCollections.includes("*")) cpy[k] = v;
				else if (v instanceof Array && v.every(it => it && it.id)) cpy[k] = BaseComponent._fromCollection(v);
			});
			return cpy;
		}

		toObjectNoMod () { return this.toObject("*"); }
	}

	return MixedBaseComponent;
}

class BaseComponent extends MixinBaseComponent(ProxyBase) {}

globalThis.BaseComponent = BaseComponent;

class RenderableCollectionBase {
	/**
	 * @param comp
	 * @param prop
	 * @param [opts]
	 * @param [opts.namespace]
	 * @param [opts.isDiffMode]
	 */
	constructor (comp, prop, opts) {
		opts = opts || {};
		this._comp = comp;
		this._prop = prop;
		this._namespace = opts.namespace;
		this._isDiffMode = opts.isDiffMode;
	}

	getNewRender (entity, i) {
		throw new Error(`Unimplemented!`);
	}

	doUpdateExistingRender (renderedMeta, entity, i) {
		throw new Error(`Unimplemented!`);
	}

	doDeleteExistingRender (renderedMeta) {
		// No-op
	}

	doReorderExistingComponent (renderedMeta, entity, i) {
		// No-op
	}

	_getCollectionItem (id) {
		return this._comp._state[this._prop].find(it => it.id === id);
	}

	/**
	 * @param [opts] Temporary override options.
	 * @param [opts.isDiffMode]
	 */
	render (opts) {
		opts = opts || {};
		this._comp._renderCollection({
			prop: this._prop,
			fnUpdateExisting: (rendered, ent, i) => this.doUpdateExistingRender(rendered, ent, i),
			fnGetNew: (entity, i) => this.getNewRender(entity, i),
			fnDeleteExisting: (rendered) => this.doDeleteExistingRender(rendered),
			fnReorderExisting: (rendered, ent, i) => this.doReorderExistingComponent(rendered, ent, i),
			namespace: this._namespace,
			isDiffMode: opts.isDiffMode != null ? opts.isDiffMode : this._isDiffMode,
		});
	}
}

class RenderableCollectionAsyncBase {
	/**
	 * @param comp
	 * @param prop
	 * @param [opts]
	 * @param [opts.namespace]
	 * @param [opts.isDiffMode]
	 * @param [opts.isMultiRender]
	 * @param [opts.additionalCaches]
	 */
	constructor (comp, prop, opts) {
		opts = opts || {};
		this._comp = comp;
		this._prop = prop;
		this._namespace = opts.namespace;
		this._isDiffMode = opts.isDiffMode;
		this._isMultiRender = opts.isMultiRender;
		this._additionalCaches = opts.additionalCaches;
	}

	pGetNewRender (entity, i) {
		throw new Error(`Unimplemented!`);
	}

	pDoUpdateExistingRender (renderedMeta, entity, i) {
		throw new Error(`Unimplemented!`);
	}

	/**
	 * @param [opts] Temporary override options.
	 * @param [opts.isDiffMode]
	 */
	render (opts) {
		opts = opts || {};
		this._comp._pRenderCollection({
			prop: this._prop,
			fnUpdateExisting: (rendered, source, i) => this.pDoUpdateExistingRender(rendered, source, i),
			fnGetNew: (entity, i) => this.pGetNewRender(entity, i),
			namespace: this._namespace,
			isDiffMode: opts.isDiffMode != null ? opts.isDiffMode : this._isDiffMode,
			isMultiRender: this._isMultiRender,
			additionalCaches: this._additionalCaches,
		});
	}
}

class BaseLayeredComponent extends BaseComponent {
	constructor () {
		super();

		// layers
		this._layers = [];
		this.__layerMeta = {};
		this._layerMeta = this._getProxy("layerMeta", this.__layerMeta);
	}

	_addHookDeep (prop, hook) {
		this._addHookBase(prop, hook);
		this._addHook("layerMeta", prop, hook);
	}

	_removeHookDeep (prop, hook) {
		this._removeHookBase(prop, hook);
		this._removeHook("layerMeta", prop, hook);
	}

	_getBase (prop) {
		return this._state[prop];
	}

	_get (prop) {
		if (this._layerMeta[prop]) {
			for (let i = this._layers.length - 1; i >= 0; --i) {
				const val = this._layers[i].data[prop];
				if (val != null) return val;
			}
			// this should never fall through, but if it does, returning the base value is fine
		}
		return this._state[prop];
	}

	_addLayer (layer) {
		this._layers.push(layer);
		this._addLayer_addLayerMeta(layer);
	}

	_addLayer_addLayerMeta (layer) {
		Object.entries(layer.data).forEach(([k, v]) => this._layerMeta[k] = v != null);
	}

	_removeLayer (layer) {
		const ix = this._layers.indexOf(layer);
		if (~ix) {
			this._layers.splice(ix, 1);

			// regenerate layer meta
			Object.keys(this._layerMeta).forEach(k => delete this._layerMeta[k]);
			this._layers.forEach(l => this._addLayer_addLayerMeta(l));
		}
	}

	updateLayersActive (prop) {
		// this uses the fact that updating a proxy value to the same value still triggers hooks
		//   anything listening to changes in this flag will be forced to recalculate from base + all layers
		this._layerMeta[prop] = this._layers.some(l => l.data[prop] != null);
	}

	getBaseSaveableState () {
		return {
			state: MiscUtil.copyFast(this.__state),
			layers: MiscUtil.copyFast(this._layers.map(l => l.getSaveableState())),
		};
	}

	setBaseSaveableStateFrom (toLoad) {
		toLoad.state && Object.assign(this._state, toLoad.state);
		if (toLoad.layers) toLoad.layers.forEach(l => this._addLayer(CompLayer.fromSavedState(this, l)));
	}

	getPod () {
		this.__pod = this.__pod || {
			...super.getPod(),

			addHookDeep: (prop, hook) => this._addHookDeep(prop, hook),
			removeHookDeep: (prop, hook) => this._removeHookDeep(prop, hook),
			addHookAll: (hook) => this._addHookAll("state", hook),
			getBase: (prop) => this._getBase(prop),
			get: (prop) => this._get(prop),
			addLayer: (name, data) => {
				// FIXME
				const l = new CompLayer(this, name, data);
				this._addLayer(l);
				return l;
			},
			removeLayer: (layer) => this._removeLayer(layer),
			layers: this._layers, // FIXME avoid passing this directly to the child
		};
		return this.__pod;
	}
}

/**
 * A "layer" of state which is applied over the base state.
 *  This allows e.g. a temporary stat reduction to modify a statblock, without actually
 *  modifying the underlying component.
 */
class CompLayer extends ProxyBase {
	constructor (component, layerName, data) {
		super();

		this._name = layerName;
		this.__data = data;

		this.data = this._getProxy("data", this.__data);

		this._addHookAll("data", prop => component.updateLayersActive(prop));
	}

	getSaveableState () {
		return {
			name: this._name,
			data: MiscUtil.copyFast(this.__data),
		};
	}

	static fromSavedState (component, savedState) { return new CompLayer(component, savedState.name, savedState.data); }
}

function MixinComponentHistory (Cls) {
	class MixedComponentHistory extends Cls {
		constructor () {
			super(...arguments);
			this._histStackUndo = [];
			this._histStackRedo = [];
			this._isHistDisabled = true;
			this._histPropBlocklist = new Set();
			this._histPropAllowlist = null;

			this._histInitialState = null;
		}

		set isHistDisabled (val) { this._isHistDisabled = val; }
		addBlocklistProps (...props) { props.forEach(p => this._histPropBlocklist.add(p)); }
		addAllowlistProps (...props) {
			this._histPropAllowlist = this._histPropAllowlist || new Set();
			props.forEach(p => this._histPropAllowlist.add(p));
		}

		/**
		 * This should be initialised after all other hooks have been added
		 */
		initHistory () {
			// Track the initial state, and watch for further modifications
			this._histInitialState = MiscUtil.copyFast(this._state);
			this._isHistDisabled = false;

			this._addHookAll("state", prop => {
				if (this._isHistDisabled) return;
				if (this._histPropBlocklist.has(prop)) return;
				if (this._histPropAllowlist && !this._histPropAllowlist.has(prop)) return;

				this.recordHistory();
			});
		}

		recordHistory () {
			const stateCopy = MiscUtil.copyFast(this._state);

			// remove any un-tracked properties
			this._histPropBlocklist.forEach(prop => delete stateCopy[prop]);
			if (this._histPropAllowlist) Object.keys(stateCopy).filter(k => !this._histPropAllowlist.has(k)).forEach(k => delete stateCopy[k]);

			this._histStackUndo.push(stateCopy);
			this._histStackRedo = [];
		}

		_histAddExcludedProperties (stateCopy) {
			Object.entries(this._state).forEach(([k, v]) => {
				if (this._histPropBlocklist.has(k)) return stateCopy[k] = v;
				if (this._histPropAllowlist && !this._histPropAllowlist.has(k)) stateCopy[k] = v;
			});
		}

		undo () {
			if (this._histStackUndo.length) {
				const lastHistDisabled = this._isHistDisabled;
				this._isHistDisabled = true;

				const curState = this._histStackUndo.pop();
				this._histStackRedo.push(curState);
				const toApply = MiscUtil.copyFast(this._histStackUndo.last() || this._histInitialState);
				this._histAddExcludedProperties(toApply);
				this._setState(toApply);

				this._isHistDisabled = lastHistDisabled;
			} else {
				const lastHistDisabled = this._isHistDisabled;
				this._isHistDisabled = true;

				const toApply = MiscUtil.copyFast(this._histInitialState);
				this._histAddExcludedProperties(toApply);
				this._setState(toApply);

				this._isHistDisabled = lastHistDisabled;
			}
		}

		redo () {
			if (!this._histStackRedo.length) return;

			const lastHistDisabled = this._isHistDisabled;
			this._isHistDisabled = true;

			const toApplyRaw = this._histStackRedo.pop();
			this._histStackUndo.push(toApplyRaw);
			const toApply = MiscUtil.copyFast(toApplyRaw);
			this._histAddExcludedProperties(toApply);
			this._setState(toApply);

			this._isHistDisabled = lastHistDisabled;
		}
	}
	return MixedComponentHistory;
}

// region Globally-linked state components
function MixinComponentGlobalState (Cls) {
	class MixedComponentGlobalState extends Cls {
		constructor (...args) {
			super(...args);

			// Point our proxy at the singleton `__stateGlobal` object
			this._stateGlobal = this._getProxy("stateGlobal", MixinComponentGlobalState._Singleton.__stateGlobal);

			// Load the singleton's state, then fire all our hooks once it's ready
			MixinComponentGlobalState._Singleton._pLoadState()
				.then(() => {
					this._doFireHooksAll("stateGlobal");
					this._doFireAllHooks("stateGlobal");
					this._addHookAll("stateGlobal", MixinComponentGlobalState._Singleton._pSaveStateDebounced);
				});
		}

		get __stateGlobal () { return MixinComponentGlobalState._Singleton.__stateGlobal; }

		_addHookGlobal (prop, hook) {
			return this._addHook("stateGlobal", prop, hook);
		}
	}
	return MixedComponentGlobalState;
}

MixinComponentGlobalState._Singleton = class {
	static async _pSaveState () {
		return StorageUtil.pSet(VeCt.STORAGE_GLOBAL_COMPONENT_STATE, MiscUtil.copyFast(MixinComponentGlobalState._Singleton.__stateGlobal));
	}

	static async _pLoadState () {
		if (MixinComponentGlobalState._Singleton._pLoadingState) return MixinComponentGlobalState._Singleton._pLoadingState;
		return MixinComponentGlobalState._Singleton._pLoadingState = MixinComponentGlobalState._Singleton._pLoadState_();
	}

	static async _pLoadState_ () {
		Object.assign(MixinComponentGlobalState._Singleton.__stateGlobal, (await StorageUtil.pGet(VeCt.STORAGE_GLOBAL_COMPONENT_STATE)) || {});
	}

	static _getDefaultStateGlobal () {
		return {
			isUseSpellPoints: false,
		};
	}
};
MixinComponentGlobalState._Singleton.__stateGlobal = {...MixinComponentGlobalState._Singleton._getDefaultStateGlobal()};
MixinComponentGlobalState._Singleton._pSaveStateDebounced = MiscUtil.debounce(MixinComponentGlobalState._Singleton._pSaveState.bind(MixinComponentGlobalState._Singleton), 100);
MixinComponentGlobalState._Singleton._pLoadingState = null;

// endregion

class ComponentUiUtil {
	static trackHook (hooks, prop, hook) {
		hooks[prop] = hooks[prop] || [];
		hooks[prop].push(hook);
	}

	static $getDisp (comp, prop, {html, $ele, fnGetText} = {}) {
		$ele = ($ele || $(html || `<div></div>`));

		const hk = () => $ele.text(fnGetText ? fnGetText(comp._state[prop]) : comp._state[prop]);
		comp._addHookBase(prop, hk);
		hk();

		return $ele;
	}

	/**
	 * @param component An instance of a class which extends BaseComponent.
	 * @param prop Component to hook on.
	 * @param [fallbackEmpty] Fallback number if string is empty.
	 * @param [opts] Options Object.
	 * @param [opts.$ele] Element to use.
	 * @param [opts.html] HTML to convert to element to use.
	 * @param [opts.max] Max allowed return value.
	 * @param [opts.min] Min allowed return value.
	 * @param [opts.offset] Offset to add to value displayed.
	 * @param [opts.padLength] Number of digits to pad the number to.
	 * @param [opts.fallbackOnNaN] Return value if not a number.
	 * @param [opts.isAllowNull] If an empty input should be treated as null.
	 * @param [opts.asMeta] If a meta-object should be returned containing the hook and the checkbox.
	 * @param [opts.hookTracker] Object in which to track hook.
	 * @param [opts.decorationLeft] Decoration to be added to the left-hand-side of the input. Can be `"ticker"` or `"clear"`. REQUIRES `asMeta` TO BE SET.
	 * @param [opts.decorationRight] Decoration to be added to the right-hand-side of the input. Can be `"ticker"` or `"clear"`. REQUIRES `asMeta` TO BE SET.
	 * @return {JQuery}
	 */
	static $getIptInt (component, prop, fallbackEmpty = 0, opts) {
		return ComponentUiUtil._$getIptNumeric(component, prop, UiUtil.strToInt, fallbackEmpty, opts);
	}

	/**
	 * @param component An instance of a class which extends BaseComponent.
	 * @param prop Component to hook on.
	 * @param [fallbackEmpty] Fallback number if string is empty.
	 * @param [opts] Options Object.
	 * @param [opts.$ele] Element to use.
	 * @param [opts.html] HTML to convert to element to use.
	 * @param [opts.max] Max allowed return value.
	 * @param [opts.min] Min allowed return value.
	 * @param [opts.offset] Offset to add to value displayed.
	 * @param [opts.padLength] Number of digits to pad the number to.
	 * @param [opts.fallbackOnNaN] Return value if not a number.
	 * @param [opts.isAllowNull] If an empty input should be treated as null.
	 * @param [opts.asMeta] If a meta-object should be returned containing the hook and the checkbox.
	 * @param [opts.decorationLeft] Decoration to be added to the left-hand-side of the input. Can be `"ticker"` or `"clear"`. REQUIRES `asMeta` TO BE SET.
	 * @param [opts.decorationRight] Decoration to be added to the right-hand-side of the input. Can be `"ticker"` or `"clear"`. REQUIRES `asMeta` TO BE SET.
	 * @return {JQuery}
	 */
	static $getIptNumber (component, prop, fallbackEmpty = 0, opts) {
		return ComponentUiUtil._$getIptNumeric(component, prop, UiUtil.strToNumber, fallbackEmpty, opts);
	}

	static _$getIptNumeric (component, prop, fnConvert, fallbackEmpty = 0, opts) {
		opts = opts || {};
		opts.offset = opts.offset || 0;

		const setIptVal = () => {
			if (opts.isAllowNull && component._state[prop] == null) {
				return $ipt.val(null);
			}

			const num = (component._state[prop] || 0) + opts.offset;
			const val = opts.padLength ? `${num}`.padStart(opts.padLength, "0") : num;
			$ipt.val(val);
		};

		const $ipt = (opts.$ele || $(opts.html || `<input class="form-control input-xs form-control--minimal text-right">`)).disableSpellcheck()
			.keydown(evt => { if (evt.key === "Escape") $ipt.blur(); })
			.change(() => {
				const raw = $ipt.val().trim();
				const cur = component._state[prop];

				if (opts.isAllowNull && !raw) return component._state[prop] = null;

				if (raw.startsWith("=")) {
					// if it starts with "=", force-set to the value provided
					component._state[prop] = fnConvert(raw.slice(1), fallbackEmpty, opts) - opts.offset;
				} else {
					// otherwise, try to modify the previous value
					const mUnary = prevValue != null && prevValue < 0
						? /^[+/*^]/.exec(raw) // If the previous value was `-X`, then treat minuses as normal values
						: /^[-+/*^]/.exec(raw);
					if (mUnary) {
						let proc = raw;
						proc = proc.slice(1).trim();
						const mod = fnConvert(proc, fallbackEmpty, opts);
						const full = `${cur}${mUnary[0]}${mod}`;
						component._state[prop] = fnConvert(full, fallbackEmpty, opts) - opts.offset;
					} else {
						component._state[prop] = fnConvert(raw, fallbackEmpty, opts) - opts.offset;
					}
				}

				// Ensure the input visually reflects the state
				if (cur === component._state[prop]) setIptVal();
			});

		let prevValue;
		const hook = () => {
			prevValue = component._state[prop];
			setIptVal();
		};
		if (opts.hookTracker) ComponentUiUtil.trackHook(opts.hookTracker, prop, hook);
		component._addHookBase(prop, hook);
		hook();

		if (opts.asMeta) return this._getIptDecoratedMeta(component, prop, $ipt, hook, opts);
		else return $ipt;
	}

	/**
	 * @param component An instance of a class which extends BaseComponent.
	 * @param prop Component to hook on.
	 * @param [opts] Options Object.
	 * @param [opts.$ele] Element to use.
	 * @param [opts.html] HTML to convert to element to use.
	 * @param [opts.isNoTrim] If the text should not be trimmed.
	 * @param [opts.isAllowNull] If null should be allowed (and preferred) for empty inputs
	 * @param [opts.asMeta] If a meta-object should be returned containing the hook and the checkbox.
	 * @param [opts.autocomplete] Array of autocomplete strings. REQUIRES INCLUSION OF THE TYPEAHEAD LIBRARY.
	 * @param [opts.decorationLeft] Decoration to be added to the left-hand-side of the input. Can be `"search"` or `"clear"`. REQUIRES `asMeta` TO BE SET.
	 * @param [opts.decorationRight] Decoration to be added to the right-hand-side of the input. Can be `"search"` or `"clear"`. REQUIRES `asMeta` TO BE SET.
	 * @param [opts.placeholder] Placeholder for the input.
	 */
	static $getIptStr (component, prop, opts) {
		opts = opts || {};

		// Validate options
		if ((opts.decorationLeft || opts.decorationRight) && !opts.asMeta) throw new Error(`Input must be created with "asMeta" option`);

		const $ipt = (opts.$ele || $(opts.html || `<input class="form-control input-xs form-control--minimal">`))
			.keydown(evt => { if (evt.key === "Escape") $ipt.blur(); })
			.disableSpellcheck();
		UiUtil.bindTypingEnd({
			$ipt,
			fnKeyup: () => {
				const nxtVal = opts.isNoTrim ? $ipt.val() : $ipt.val().trim();
				component._state[prop] = opts.isAllowNull && !nxtVal ? null : nxtVal;
			},
		});

		if (opts.placeholder) $ipt.attr("placeholder", opts.placeholder);

		if (opts.autocomplete && opts.autocomplete.length) $ipt.typeahead({source: opts.autocomplete});
		const hook = () => {
			if (component._state[prop] == null) $ipt.val(null);
			else {
				// If the only difference is start/end whitespace, leave it; otherwise, adding spaces is frustrating
				if ($ipt.val().trim() !== component._state[prop]) $ipt.val(component._state[prop]);
			}
		};
		component._addHookBase(prop, hook);
		hook();

		if (opts.asMeta) return this._getIptDecoratedMeta(component, prop, $ipt, hook, opts);
		else return $ipt;
	}

	static _getIptDecoratedMeta (component, prop, $ipt, hook, opts) {
		const out = {$ipt, unhook: () => component._removeHookBase(prop, hook)};

		if (opts.decorationLeft || opts.decorationRight) {
			let $decorLeft;
			let $decorRight;

			if (opts.decorationLeft) {
				$ipt.addClass(`ui-ideco__ipt ui-ideco__ipt--left`);
				$decorLeft = ComponentUiUtil._$getDecor(component, prop, $ipt, opts.decorationLeft, "left", opts);
			}

			if (opts.decorationRight) {
				$ipt.addClass(`ui-ideco__ipt ui-ideco__ipt--right`);
				$decorRight = ComponentUiUtil._$getDecor(component, prop, $ipt, opts.decorationRight, "right", opts);
			}

			out.$wrp = $$`<div class="relative w-100">${$ipt}${$decorLeft}${$decorRight}</div>`;
		}

		return out;
	}

	static _$getDecor (component, prop, $ipt, decorType, side, opts) {
		switch (decorType) {
			case "search": {
				return $(`<div class="ui-ideco__wrp ui-ideco__wrp--${side} no-events ve-flex-vh-center"><span class="glyphicon glyphicon-search"></span></div>`);
			}
			case "clear": {
				return $(`<div class="ui-ideco__wrp ui-ideco__wrp--${side} ve-flex-vh-center clickable" title="Clear"><span class="glyphicon glyphicon-remove"></span></div>`)
					.click(() => $ipt.val("").change().keydown().keyup());
			}
			case "ticker": {
				const isValidValue = val => {
					if (opts.max != null && val > opts.max) return false;
					if (opts.min != null && val < opts.min) return false;
					return true;
				};

				const handleClick = (delta) => {
					// TODO(future) this should be run first to evaluate any lingering expressions in the input, but it
					//  breaks when the number is negative, as we need to add a "=" to the front of the input before
					//  evaluating
					// $ipt.change();
					const nxt = component._state[prop] + delta;
					if (!isValidValue(nxt)) return;
					component._state[prop] = nxt;
					$ipt.focus();
				};

				const $btnUp = $(`<button class="btn btn-default ui-ideco__btn-ticker bold no-select">+</button>`)
					.click(() => handleClick(1));

				const $btnDown = $(`<button class="btn btn-default ui-ideco__btn-ticker bold no-select">\u2012</button>`)
					.click(() => handleClick(-1));

				return $$`<div class="ui-ideco__wrp ui-ideco__wrp--${side} ve-flex-vh-center ve-flex-col">
					${$btnUp}
					${$btnDown}
				</div>`;
			}
			case "spacer": {
				return "";
			}
			default: throw new Error(`Unimplemented!`);
		}
	}

	/**
	 * @param component An instance of a class which extends BaseComponent.
	 * @param prop Component to hook on.
	 * @param [opts] Options Object.
	 * @param [opts.$ele] Element to use.
	 * @return {$}
	 */
	static $getIptEntries (component, prop, opts) {
		opts = opts || {};

		const $ipt = (opts.$ele || $(`<textarea class="form-control input-xs form-control--minimal resize-vertical"></textarea>`))
			.keydown(evt => { if (evt.key === "Escape") $ipt.blur(); })
			.change(() => component._state[prop] = UiUtil.getTextAsEntries($ipt.val().trim()));
		const hook = () => $ipt.val(UiUtil.getEntriesAsText(component._state[prop]));
		component._addHookBase(prop, hook);
		hook();
		return $ipt;
	}

	/**
	 * @param component An instance of a class which extends BaseComponent.
	 * @param prop Component to hook on.
	 * @param [opts] Options Object.
	 * @param [opts.$ele] Element to use.
	 * @return {JQuery}
	 */
	static $getIptColor (component, prop, opts) {
		opts = opts || {};

		const $ipt = (opts.$ele || $(`<input class="form-control input-xs form-control--minimal ui__ipt-color" type="color">`))
			.change(() => component._state[prop] = $ipt.val());
		const hook = () => $ipt.val(component._state[prop]);
		component._addHookBase(prop, hook);
		hook();
		return $ipt;
	}

	/**
	 * @param component An instance of a class which extends BaseComponent.
	 * @param prop Component to hook on.
	 * @param [opts] Options Object.
	 * @param [opts.ele] Element to use.
	 * @param [opts.html] HTML to convert to element to use.
	 * @param [opts.text] Button text, if element is not specified.
	 * @param [opts.fnHookPost] Function to run after primary hook.
	 * @param [opts.stateName] State name.
	 * @param [opts.stateProp] State prop.
	 * @param [opts.isInverted] If the toggle display should be inverted.
	 * @param [opts.activeClass] CSS class to use when setting the button as "active."
	 * @param [opts.title]
	 * @param [opts.activeTitle] Title to use when setting the button as "active."
	 * @param [opts.inactiveTitle] Title to use when setting the button as "active."
	 * @return *
	 */
	static getBtnBool (component, prop, opts) {
		opts = opts || {};

		let ele = opts.ele;
		if (opts.html) ele = e_({outer: opts.html});

		const activeClass = opts.activeClass || "active";
		const stateName = opts.stateName || "state";
		const stateProp = opts.stateProp || `_${stateName}`;

		const btn = (ele ? e_({ele}) : e_({
			ele: ele,
			tag: "button",
			clazz: "btn btn-xs btn-default",
			text: opts.text || "Toggle",
		}))
			.onClick(() => component[stateProp][prop] = !component[stateProp][prop])
			.onContextmenu(evt => {
				evt.preventDefault();
				component[stateProp][prop] = !component[stateProp][prop];
			});

		const hk = () => {
			btn.toggleClass(activeClass, opts.isInverted ? !component[stateProp][prop] : !!component[stateProp][prop]);
			if (opts.activeTitle || opts.inactiveTitle) btn.title(component[stateProp][prop] ? (opts.activeTitle || opts.title || "") : (opts.inactiveTitle || opts.title || ""));
			if (opts.fnHookPost) opts.fnHookPost(component[stateProp][prop]);
		};
		component._addHook(stateName, prop, hk);
		hk();

		return btn;
	}

	/**
	 * @param component An instance of a class which extends BaseComponent.
	 * @param prop Component to hook on.
	 * @param [opts] Options Object.
	 * @param [opts.$ele] Element to use.
	 * @param [opts.html] HTML to convert to element to use.
	 * @param [opts.text] Button text, if element is not specified.
	 * @param [opts.fnHookPost] Function to run after primary hook.
	 * @param [opts.stateName] State name.
	 * @param [opts.stateProp] State prop.
	 * @param [opts.isInverted] If the toggle display should be inverted.
	 * @param [opts.activeClass] CSS class to use when setting the button as "active."
	 * @param [opts.title]
	 * @param [opts.activeTitle] Title to use when setting the button as "active."
	 * @param [opts.inactiveTitle] Title to use when setting the button as "active."
	 * @return {JQuery}
	 */
	static $getBtnBool (component, prop, opts) {
		const nxtOpts = {...opts};
		if (nxtOpts.$ele) {
			nxtOpts.ele = nxtOpts.$ele[0];
			delete nxtOpts.$ele;
		}
		return $(this.getBtnBool(component, prop, nxtOpts));
	}

	/**
	 * @param component An instance of a class which extends BaseComponent.
	 * @param prop Component to hook on.
	 * @param [opts] Options Object.
	 * @param [opts.$ele] Element to use.
	 * @param [opts.asMeta] If a meta-object should be returned containing the hook and the input.
	 * @param [opts.displayNullAsIndeterminate]
	 * @param [opts.stateName] State name.
	 * @param [opts.stateProp] State prop.
	 * @return {JQuery}
	 */
	static $getCbBool (component, prop, opts) {
		opts = opts || {};

		const stateName = opts.stateName || "state";
		const stateProp = opts.stateProp || `_${stateName}`;

		const cb = e_({
			tag: "input",
			type: "checkbox",
			keydown: evt => {
				if (evt.key === "Escape") cb.blur();
			},
			change: () => {
				component[stateProp][prop] = cb.checked;
			},
		});

		const hook = () => {
			cb.checked = !!component[stateProp][prop];
			if (opts.displayNullAsIndeterminate) cb.indeterminate = component[stateProp][prop] == null;
		};
		component._addHook(stateName, prop, hook);
		hook();

		const $cb = $(cb);

		return opts.asMeta ? ({$cb, unhook: () => component._removeHook(stateName, prop, hook)}) : $cb;
	}

	/**
	 * A select2-style dropdown.
	 * @param comp An instance of a class which extends BaseComponent.
	 * @param prop Component to hook on.
	 * @param opts Options Object.
	 * @param opts.values Values to display.
	 * @param [opts.isHiddenPerValue]
	 * @param [opts.$ele] Element to use.
	 * @param [opts.html] HTML to convert to element to use.
	 * @param [opts.isAllowNull] If null is allowed.
	 * @param [opts.fnDisplay] Value display function.
	 * @param [opts.displayNullAs] If null values are allowed, display them as this string.
	 * @param [opts.fnGetAdditionalStyleClasses] Function which converts an item into CSS classes.
	 * @param [opts.asMeta] If a meta-object should be returned containing the hook and the select.
	 * @param [opts.isDisabled] If the selector should be display-only
	 * @return {JQuery}
	 */
	static $getSelSearchable (comp, prop, opts) {
		opts = opts || {};

		const $iptDisplay = (opts.$ele || $(opts.html || `<input class="form-control input-xs form-control--minimal">`))
			.addClass("ui-sel2__ipt-display")
			.attr("tabindex", "-1")
			.click(() => {
				if (opts.isDisabled) return;
				$iptSearch.focus().select();
			})
			.prop("disabled", !!opts.isDisabled)
			.disableSpellcheck();

		const handleSearchChange = () => {
			const cleanTerm = this._$getSelSearchable_getSearchString($iptSearch.val());
			metaOptions.forEach(it => {
				it.isVisible = it.searchTerm.includes(cleanTerm);
				it.$ele.toggleVe(it.isVisible && !it.isForceHidden);
			});
		};
		const handleSearchChangeDebounced = MiscUtil.debounce(handleSearchChange, 30);

		const $iptSearch = (opts.$ele || $(opts.html || `<input class="form-control input-xs form-control--minimal">`))
			.addClass("absolute ui-sel2__ipt-search")
			.keydown(evt => {
				if (opts.isDisabled) return;

				switch (evt.key) {
					case "Escape": evt.stopPropagation(); return $iptSearch.blur();

					case "ArrowDown": {
						evt.preventDefault();
						const visibleMetaOptions = metaOptions.filter(it => it.isVisible && !it.isForceHidden);
						if (!visibleMetaOptions.length) return;
						visibleMetaOptions[0].$ele.focus();
						break;
					}

					case "Enter":
					case "Tab": {
						const visibleMetaOptions = metaOptions.filter(it => it.isVisible && !it.isForceHidden);
						if (!visibleMetaOptions.length) return;
						comp._state[prop] = visibleMetaOptions[0].value;
						$iptSearch.blur();
						break;
					}

					default: handleSearchChangeDebounced();
				}
			})
			.change(() => handleSearchChangeDebounced())
			.click(() => {
				if (opts.isDisabled) return;
				$iptSearch.focus().select();
			})
			.prop("disabled", !!opts.isDisabled)
			.disableSpellcheck();

		const $wrpChoices = $(`<div class="absolute ui-sel2__wrp-options overflow-y-scroll"></div>`);

		const $wrp = $$`<div class="ve-flex relative ui-sel2__wrp w-100">
			${$iptDisplay}
			${$iptSearch}
			${$wrpChoices}
			<div class="ui-sel2__disp-arrow absolute no-events bold"><span class="glyphicon glyphicon-menu-down"></span></div>
		</div>`;

		const procValues = opts.isAllowNull ? [null, ...opts.values] : opts.values;
		const metaOptions = procValues.map((v, i) => {
			const display = v == null ? (opts.displayNullAs || "\u2014") : opts.fnDisplay ? opts.fnDisplay(v) : v;
			const additionalStyleClasses = opts.fnGetAdditionalStyleClasses ? opts.fnGetAdditionalStyleClasses(v) : null;

			const $ele = $(`<div class="ve-flex-v-center py-1 px-1 clickable ui-sel2__disp-option ${v == null ? `italic` : ""} ${additionalStyleClasses ? additionalStyleClasses.join(" ") : ""}" tabindex="0">${display}</div>`)
				.click(() => {
					if (opts.isDisabled) return;

					comp._state[prop] = v;
					$(document.activeElement).blur();
					// Temporarily remove pointer events from the dropdown, so it collapses thanks to its :hover CSS
					$wrp.addClass("no-events");
					setTimeout(() => $wrp.removeClass("no-events"), 50);
				})
				.keydown(evt => {
					if (opts.isDisabled) return;

					switch (evt.key) {
						case "Escape": evt.stopPropagation(); return $ele.blur();

						case "ArrowDown": {
							evt.preventDefault();
							const visibleMetaOptions = metaOptions.filter(it => it.isVisible && !it.isForceHidden);
							if (!visibleMetaOptions.length) return;
							const ixCur = visibleMetaOptions.indexOf(out);
							const nxt = visibleMetaOptions[ixCur + 1];
							if (nxt) nxt.$ele.focus();
							break;
						}

						case "ArrowUp": {
							evt.preventDefault();
							const visibleMetaOptions = metaOptions.filter(it => it.isVisible && !it.isForceHidden);
							if (!visibleMetaOptions.length) return;
							const ixCur = visibleMetaOptions.indexOf(out);
							const prev = visibleMetaOptions[ixCur - 1];
							if (prev) return prev.$ele.focus();
							$iptSearch.focus();
							break;
						}

						case "Enter": {
							comp._state[prop] = v;
							$ele.blur();
							break;
						}
					}
				})
				.appendTo($wrpChoices);

			const isForceHidden = opts.isHiddenPerValue && !!(opts.isAllowNull ? opts.isHiddenPerValue[i - 1] : opts.isHiddenPerValue[i]);
			if (isForceHidden) $ele.hideVe();

			const out = {
				value: v,
				isVisible: true,
				isForceHidden,
				searchTerm: this._$getSelSearchable_getSearchString(display),
				$ele,
			};
			return out;
		});

		const fnUpdateHidden = (isHiddenPerValue, isHideNull = false) => {
			let metaOptions_ = metaOptions;

			if (opts.isAllowNull) {
				metaOptions_[0].isForceHidden = isHideNull;
				metaOptions_ = metaOptions_.slice(1);
			}

			metaOptions_.forEach((it, i) => it.isForceHidden = !!isHiddenPerValue[i]);
			handleSearchChange();
		};

		const hk = () => {
			if (comp._state[prop] == null) $iptDisplay.addClass("italic").addClass("ve-muted").val(opts.displayNullAs || "\u2014");
			else $iptDisplay.removeClass("italic").removeClass("ve-muted").val(opts.fnDisplay ? opts.fnDisplay(comp._state[prop]) : comp._state[prop]);

			metaOptions.forEach(it => it.$ele.removeClass("active"));
			const metaActive = metaOptions.find(it => it.value == null ? comp._state[prop] == null : it.value === comp._state[prop]);
			if (metaActive) metaActive.$ele.addClass("active");
		};
		comp._addHookBase(prop, hk);
		hk();

		return opts.asMeta
			? ({
				$wrp,
				unhook: () => comp._removeHookBase(prop, hk),
				$iptDisplay,
				$iptSearch,
				fnUpdateHidden,
			})
			: $wrp;
	}

	static _$getSelSearchable_getSearchString (str) {
		if (str == null) return "";
		return str.trim().toLowerCase().replace(/\s+/g, " ");
	}

	/**
	 * @param component An instance of a class which extends BaseComponent.
	 * @param prop Component to hook on.
	 * @param opts Options Object.
	 * @param opts.values Values to display.
	 * @param [opts.$ele] Element to use.
	 * @param [opts.html] HTML to convert to element to use.
	 * @param [opts.isAllowNull] If null is allowed.
	 * @param [opts.fnDisplay] Value display function.
	 * @param [opts.displayNullAs] If null values are allowed, display them as this string.
	 * @param [opts.asMeta] If a meta-object should be returned containing the hook and the select.
	 * @param [opts.propProxy] Proxy prop.
	 * @param [opts.isSetIndexes] If the index of the selected item should be set as state, rather than the item itself.
	 */
	static $getSelEnum (component, prop, {values, $ele, html, isAllowNull, fnDisplay, displayNullAs, asMeta, propProxy = "state", isSetIndexes = false} = {}) {
		const _propProxy = `_${propProxy}`;

		let values_;

		let $sel = $ele || (html ? $(html) : null);
		// Use native API, if we can, for performance
		if (!$sel) { const sel = document.createElement("select"); sel.className = "form-control input-xs"; $sel = $(sel); }

		$sel.change(() => {
			const ix = Number($sel.val());
			if (~ix) return void (component[_propProxy][prop] = isSetIndexes ? ix : values_[ix]);

			if (isAllowNull) return void (component[_propProxy][prop] = null);
			component[_propProxy][prop] = isSetIndexes ? 0 : values_[0];
		});

		// If the new value list doesn't contain our current value, reset our current value
		const setValues_handleResetOnMissing = ({isResetOnMissing, nxtValues}) => {
			if (!isResetOnMissing) return;

			if (component[_propProxy][prop] == null) return;

			if (isSetIndexes) {
				if (component[_propProxy][prop] >= 0 && component[_propProxy][prop] < nxtValues.length) {
					if (isAllowNull) return component[_propProxy][prop] = null;
					return component[_propProxy][prop] = 0;
				}

				return;
			}

			if (!nxtValues.includes(component[_propProxy][prop])) {
				if (isAllowNull) return component[_propProxy][prop] = null;
				return component[_propProxy][prop] = nxtValues[0];
			}
		};

		const setValues = (nxtValues, {isResetOnMissing = false, isForce = false} = {}) => {
			if (!isForce && CollectionUtil.deepEquals(values_, nxtValues)) return;
			values_ = nxtValues;
			$sel.empty();
			// Use native API for performance
			if (isAllowNull) { const opt = document.createElement("option"); opt.value = "-1"; opt.text = displayNullAs || "\u2014"; $sel.append(opt); }
			values_.forEach((it, i) => { const opt = document.createElement("option"); opt.value = `${i}`; opt.text = fnDisplay ? fnDisplay(it) : it; $sel.append(opt); });

			setValues_handleResetOnMissing({isResetOnMissing, nxtValues});

			hook();
		};

		const hook = () => {
			if (isSetIndexes) {
				const ix = component[_propProxy][prop] == null ? -1 : component[_propProxy][prop];
				$sel.val(`${ix}`);
				return;
			}

			const searchFor = component[_propProxy][prop] === undefined ? null : component[_propProxy][prop];
			// Null handling is done in change handler
			const ix = values_.indexOf(searchFor);
			$sel.val(`${ix}`);
		};
		component._addHookBase(prop, hook);

		setValues(values);

		if (!asMeta) return $sel;

		return {
			$sel,
			unhook: () => component._removeHookBase(prop, hook),
			setValues,
		};
	}

	/**
	 * @param component An instance of a class which extends BaseComponent.
	 * @param prop Component to hook on.
	 * @param opts Options Object.
	 * @param opts.values Values to display.
	 * @param [opts.fnDisplay] Value display function.
	 */
	static $getPickEnum (component, prop, opts) {
		return this._$getPickEnumOrString(component, prop, opts);
	}

	/**
	 * @param component An instance of a class which extends BaseComponent.
	 * @param prop Component to hook on.
	 * @param [opts] Options Object.
	 * @param [opts.values] Values to display.
	 * @param [opts.isCaseInsensitive] If the values should be case insensitive.
	 */
	static $getPickString (component, prop, opts) {
		return this._$getPickEnumOrString(component, prop, {...opts, isFreeText: true});
	}

	/**
	 * @param component An instance of a class which extends BaseComponent.
	 * @param prop Component to hook on.
	 * @param opts Options Object.
	 * @param [opts.values] Values to display.
	 * @param [opts.fnDisplay] Value display function.
	 * @param [opts.isFreeText] If the picker should accept free text.
	 * @param [opts.isCaseInsensitive] If the picker should accept free text.
	 */
	static _$getPickEnumOrString (component, prop, opts) {
		opts = opts || {};

		const getSubcompValues = () => {
			const initialValuesArray = (opts.values || []).concat(opts.isFreeText ? MiscUtil.copyFast((component._state[prop] || [])) : []);
			const initialValsCompWith = opts.isCaseInsensitive ? component._state[prop].map(it => it.toLowerCase()) : component._state[prop];
			return initialValuesArray
				.map(v => opts.isCaseInsensitive ? v.toLowerCase() : v)
				.mergeMap(v => ({[v]: component._state[prop] && initialValsCompWith.includes(v)}));
		};

		const initialVals = getSubcompValues();

		let $btnAdd;
		if (opts.isFreeText) {
			$btnAdd = $(`<button class="btn btn-xxs btn-default ui-pick__btn-add ml-auto">+</button>`)
				.click(async () => {
					const input = await InputUiUtil.pGetUserString();
					if (input == null || input === VeCt.SYM_UI_SKIP) return;
					const inputClean = opts.isCaseInsensitive ? input.trim().toLowerCase() : input.trim();
					pickComp.getPod().set(inputClean, true);
				});
		} else {
			const menu = ContextUtil.getMenu(opts.values.map(it => new ContextUtil.Action(
				opts.fnDisplay ? opts.fnDisplay(it) : it,
				() => pickComp.getPod().set(it, true),
			)));

			$btnAdd = $(`<button class="btn btn-xxs btn-default ui-pick__btn-add">+</button>`)
				.click(evt => ContextUtil.pOpenMenu(evt, menu));
		}

		const pickComp = BaseComponent.fromObject(initialVals);
		pickComp.render = function ($parent) {
			$parent.empty();

			Object.entries(this._state).forEach(([k, v]) => {
				if (v === false) return;

				const $btnRemove = $(`<button class="btn btn-danger ui-pick__btn-remove text-center">×</button>`)
					.click(() => this._state[k] = false);
				const txt = `${opts.fnDisplay ? opts.fnDisplay(k) : k}`;
				$$`<div class="ve-flex mx-1 mb-1 ui-pick__disp-pill max-w-100 min-w-0"><div class="px-1 ui-pick__disp-text ve-flex-v-center text-clip-ellipsis" title="${txt.qq()}">${txt}</div>${$btnRemove}</div>`.appendTo($parent);
			});
		};

		const $wrpPills = $(`<div class="ve-flex ve-flex-wrap max-w-100 min-w-0"></div>`);
		const $wrp = $$`<div class="ve-flex-v-center w-100">${$btnAdd}${$wrpPills}</div>`;
		pickComp._addHookAll("state", () => {
			component._state[prop] = Object.keys(pickComp._state).filter(k => pickComp._state[k]);
			pickComp.render($wrpPills);
		});
		pickComp.render($wrpPills);

		const hkParent = () => pickComp._proxyAssignSimple("state", getSubcompValues(), true);
		component._addHookBase(prop, hkParent);

		return $wrp;
	}

	/**
	 * @param component An instance of a class which extends BaseComponent.
	 * @param prop Component to hook on.
	 * @param opts Options Object.
	 * @param opts.values Values to display.
	 * @param [opts.fnDisplay] Value display function.
	 * @param [opts.isDisallowNull] True if null is not an allowed value.
	 * @param [opts.asMeta] If a meta-object should be returned containing the hook and the wrapper.
	 * @param [opts.isIndent] If the checkboxes should be indented.
	 * @return {JQuery}
	 */
	static $getCbsEnum (component, prop, opts) {
		opts = opts || {};

		const $wrp = $(`<div class="ve-flex-col w-100"></div>`);
		const metas = opts.values.map(it => {
			const $cb = $(`<input type="checkbox">`)
				.keydown(evt => {
					if (evt.key === "Escape") $cb.blur();
				})
				.change(() => {
					let didUpdate = false;
					const ix = (component._state[prop] || []).indexOf(it);
					if (~ix) component._state[prop].splice(ix, 1);
					else {
						if (component._state[prop]) component._state[prop].push(it);
						else {
							didUpdate = true;
							component._state[prop] = [it];
						}
					}
					if (!didUpdate) component._state[prop] = [...component._state[prop]];
				});

			$$`<label class="split-v-center my-1 stripe-odd ${opts.isIndent ? "ml-4" : ""}"><div class="no-wrap ve-flex-v-center">${opts.fnDisplay ? opts.fnDisplay(it) : it}</div>${$cb}</label>`.appendTo($wrp);

			return {$cb, value: it};
		});

		const hook = () => metas.forEach(meta => meta.$cb.prop("checked", component._state[prop] && component._state[prop].includes(meta.value)));
		component._addHookBase(prop, hook);
		hook();

		return opts.asMeta ? {$wrp, unhook: () => component._removeHookBase(prop, hook)} : $wrp;
	}

	// region Multi Choice
	/**
	 * @param comp
	 * @param prop Base prop. This will be expanded with `__...`-suffixed sub-props as required.
	 * @param opts Options.
	 * @param [opts.values] Array of values. Mutually incompatible with "valueGroups".
	 * @param [opts.valueGroups] Array of value groups (of the form
	 *   `{name: "Group Name", text: "Optional group hint text", values: [...]}` ).
	 *   Mutually incompatible with "values".
	 * @param [opts.valueGroupSplitControlsLookup] A lookup of `<value group name> -> header controls` to embed in the UI.
	 * @param [opts.count] Number of choices the user can make (cannot be used with min/max).
	 * @param [opts.min] Minimum number of choices the user can make (cannot be used with count).
	 * @param [opts.max] Maximum number of choices the user can make (cannot be used with count).
	 * @param [opts.isResolveItems] True if the promise should resolve to an array of the items instead of the indices. // TODO maybe remove?
	 * @param [opts.fnDisplay] Function which takes a value and returns display text.
	 * @param [opts.required] Values which are required.
	 * @param [opts.ixsRequired] Indexes of values which are required.
	 * @param [opts.isSearchable] If a search input should be created.
	 * @param [opts.fnGetSearchText] Function which takes a value and returns search text.
	 */
	static getMetaWrpMultipleChoice (comp, prop, opts) {
		opts = opts || {};
		this._getMetaWrpMultipleChoice_doValidateOptions(opts);

		const rowMetas = [];
		const $eles = [];
		const ixsSelectionOrder = [];
		const $elesSearchable = {};

		const propIsAcceptable = this.getMetaWrpMultipleChoice_getPropIsAcceptable(prop);
		const propPulse = this.getMetaWrpMultipleChoice_getPropPulse(prop);
		const propIxMax = this._getMetaWrpMultipleChoice_getPropValuesLength(prop);

		const cntRequired = ((opts.required || []).length) + ((opts.ixsRequired || []).length);
		const count = opts.count != null ? opts.count - cntRequired : null;
		const countIncludingRequired = opts.count != null ? count + cntRequired : null;
		const min = opts.min != null ? opts.min - cntRequired : null;
		const max = opts.max != null ? opts.max - cntRequired : null;

		const valueGroups = opts.valueGroups || [{values: opts.values}];

		let ixValue = 0;
		valueGroups.forEach((group, i) => {
			if (i !== 0) $eles.push($(`<hr class="w-100 hr-2 hr--dotted">`));

			if (group.name) {
				const $wrpName = $$`<div class="split-v-center py-1">
					<div class="ve-flex-v-center"><span class="mr-2">‒</span><span>${group.name}</span></div>
					${opts.valueGroupSplitControlsLookup?.[group.name]}
				</div>`;
				$eles.push($wrpName);
			}

			if (group.text) $eles.push($(`<div class="ve-flex-v-center py-1"><div class="ml-1 mr-3"></div><i>${group.text}</i></div>`));

			group.values.forEach(v => {
				const ixValueFrozen = ixValue;

				const propIsActive = this.getMetaWrpMultipleChoice_getPropIsActive(prop, ixValueFrozen);
				const propIsRequired = this.getMetaWrpMultipleChoice_getPropIsRequired(prop, ixValueFrozen);

				const isHardRequired = (opts.required && opts.required.includes(v))
					|| (opts.ixsRequired && opts.ixsRequired.includes(ixValueFrozen));
				const isRequired = isHardRequired || comp._state[propIsRequired];

				// In the case of pre-existing selections, add these to our selection order tracking as they appear
				if (comp._state[propIsActive] && !comp._state[propIsRequired]) ixsSelectionOrder.push(ixValueFrozen);

				let hk;
				const $cb = isRequired
					? $(`<input type="checkbox" disabled checked title="This option is required.">`)
					: ComponentUiUtil.$getCbBool(comp, propIsActive);

				if (isRequired) comp._state[propIsActive] = true;

				if (!isRequired) {
					hk = () => {
						// region Selection order
						const ixIx = ixsSelectionOrder.findIndex(it => it === ixValueFrozen);
						if (~ixIx) ixsSelectionOrder.splice(ixIx, 1);
						if (comp._state[propIsActive]) ixsSelectionOrder.push(ixValueFrozen);
						// endregion

						// region Enable/disable
						const activeRows = rowMetas.filter(it => comp._state[it.propIsActive]);

						if (count != null) {
							// If we're above the max allowed count, deselect a checkbox in FIFO order
							if (activeRows.length > countIncludingRequired) {
								// FIFO (`.shift`) makes logical sense, but FILO (`.splice` second-from-last) _feels_ better
								const ixFirstSelected = ixsSelectionOrder.splice(ixsSelectionOrder.length - 2, 1)[0];
								if (ixFirstSelected != null) {
									const propIsActiveOther = this.getMetaWrpMultipleChoice_getPropIsActive(prop, ixFirstSelected);
									comp._state[propIsActiveOther] = false;

									comp._state[propPulse] = !comp._state[propPulse];
								}
								return;
							}
						}

						let isAcceptable = false;
						if (count != null) {
							if (activeRows.length === countIncludingRequired) isAcceptable = true;
						} else {
							if (activeRows.length >= (min || 0) && activeRows.length <= (max || Number.MAX_SAFE_INTEGER)) isAcceptable = true;
						}

						// Save this to a flag in the state object that external code can read
						comp._state[propIsAcceptable] = isAcceptable;
						// endregion

						comp._state[propPulse] = !comp._state[propPulse];
					};
					comp._addHookBase(propIsActive, hk);
					hk();
				}

				const displayValue = opts.fnDisplay ? opts.fnDisplay(v, ixValueFrozen) : v;

				rowMetas.push({
					$cb,
					displayValue,
					value: v,
					propIsActive,
					unhook: () => {
						if (hk) comp._removeHookBase(propIsActive, hk);
					},
				});

				const $ele = $$`<label class="ve-flex-v-center py-1 stripe-even">
					<div class="col-1 ve-flex-vh-center">${$cb}</div>
					<div class="col-11 ve-flex-v-center">${displayValue}</div>
				</label>`;
				$eles.push($ele);

				if (opts.isSearchable) {
					const searchText = `${opts.fnGetSearchText ? opts.fnGetSearchText(v, ixValueFrozen) : v}`.toLowerCase().trim();
					($elesSearchable[searchText] = $elesSearchable[searchText] || []).push($ele);
				}

				ixValue++;
			});
		});

		// Sort the initial selection order (i.e. that from defaults) by lowest to highest, such that new clicks
		//   will remove from the first element in visual order
		ixsSelectionOrder.sort((a, b) => SortUtil.ascSort(a, b));

		comp.__state[propIxMax] = ixValue;

		let $iptSearch;
		if (opts.isSearchable) {
			const compSub = BaseComponent.fromObject({search: ""});
			$iptSearch = ComponentUiUtil.$getIptStr(compSub, "search");
			const hkSearch = () => {
				const cleanSearch = compSub._state.search.trim().toLowerCase();
				if (!cleanSearch) {
					Object.values($elesSearchable).forEach($eles => $eles.forEach($ele => $ele.removeClass("ve-hidden")));
					return;
				}

				Object.entries($elesSearchable)
					.forEach(([searchText, $eles]) => $eles.forEach($ele => $ele.toggleVe(searchText.includes(cleanSearch))));
			};
			compSub._addHookBase("search", hkSearch);
			hkSearch();
		}

		// Always return this as a "meta" object
		const unhook = () => rowMetas.forEach(it => it.unhook());
		return {
			$ele: $$`<div class="ve-flex-col w-100 overflow-y-auto">${$eles}</div>`,
			$iptSearch,
			rowMetas, // Return this to allow for creating custom UI
			propIsAcceptable,
			propPulse,
			unhook,
			cleanup: () => {
				unhook();
				// This will trigger a final "pulse"
				Object.keys(comp._state)
					.filter(it => it.startsWith(`${prop}__`))
					.forEach(it => delete comp._state[it]);
			},
		};
	}

	static getMetaWrpMultipleChoice_getPropIsAcceptable (prop) { return `${prop}__isAcceptable`; }
	static getMetaWrpMultipleChoice_getPropPulse (prop) { return `${prop}__pulse`; }
	static _getMetaWrpMultipleChoice_getPropValuesLength (prop) { return `${prop}__length`; }
	static getMetaWrpMultipleChoice_getPropIsActive (prop, ixValue) { return `${prop}__isActive_${ixValue}`; }
	static getMetaWrpMultipleChoice_getPropIsRequired (prop, ixValue) { return `${prop}__isRequired_${ixValue}`; }

	static getMetaWrpMultipleChoice_getSelectedIxs (comp, prop) {
		const out = [];
		const len = comp._state[this._getMetaWrpMultipleChoice_getPropValuesLength(prop)] || 0;
		for (let i = 0; i < len; ++i) {
			if (comp._state[this.getMetaWrpMultipleChoice_getPropIsActive(prop, i)]) out.push(i);
		}
		return out;
	}

	static getMetaWrpMultipleChoice_getSelectedValues (comp, prop, {values, valueGroups}) {
		const selectedIxs = this.getMetaWrpMultipleChoice_getSelectedIxs(comp, prop);
		if (values) return selectedIxs.map(ix => values[ix]);

		const selectedIxsSet = new Set(selectedIxs);
		const out = [];
		let ixValue = 0;
		valueGroups.forEach(group => {
			group.values.forEach(v => {
				if (selectedIxsSet.has(ixValue)) out.push(v);
				ixValue++;
			});
		});
		return out;
	}

	static _getMetaWrpMultipleChoice_doValidateOptions (opts) {
		if ((Number(!!opts.values) + Number(!!opts.valueGroups)) !== 1) throw new Error(`Exactly one of "values" and "valueGroups" must be specified!`);

		if (opts.count != null && (opts.min != null || opts.max != null)) throw new Error(`Chooser must be either in "count" mode or "min/max" mode!`);
		// If no mode is specified, default to a "count 1" chooser
		if (opts.count == null && opts.min == null && opts.max == null) opts.count = 1;
	}
	// endregion

	/**
	 * @param comp An instance of a class which extends BaseComponent.
	 * @param opts Options Object.
	 * @param opts.propMin
	 * @param opts.propMax
	 * @param opts.propCurMin
	 * @param [opts.propCurMax]
	 * @param [opts.fnDisplay] Value display function.
	 * @param [opts.fnDisplayTooltip]
	 * @param [opts.sparseValues]
	 */
	static $getSliderRange (comp, opts) {
		opts = opts || {};
		const slider = new ComponentUiUtil.RangeSlider({comp, ...opts});
		return slider.$get();
	}

	static $getSliderNumber (
		comp,
		prop,
		{
			min,
			max,
			step,
			$ele,
			asMeta,
		} = {},
	) {
		const $slider = ($ele || $(`<input type="range">`))
			.change(() => comp._state[prop] = Number($slider.val()));

		if (min != null) $slider.attr("min", min);
		if (max != null) $slider.attr("max", max);
		if (step != null) $slider.attr("step", step);

		const hk = () => $slider.val(comp._state[prop]);
		comp._addHookBase(prop, hk);
		hk();

		return asMeta ? ({$slider, unhook: () => comp._removeHookBase(prop, hk)}) : $slider;
	}
}
ComponentUiUtil.RangeSlider = class {
	constructor (
		{
			comp,
			propMin,
			propMax,
			propCurMin,
			propCurMax,
			fnDisplay,
			fnDisplayTooltip,
			sparseValues,
		},
	) {
		this._comp = comp;
		this._propMin = propMin;
		this._propMax = propMax;
		this._propCurMin = propCurMin;
		this._propCurMax = propCurMax;
		this._fnDisplay = fnDisplay;
		this._fnDisplayTooltip = fnDisplayTooltip;
		this._sparseValues = sparseValues;

		this._isSingle = !this._propCurMax;

		// region Make a copy of the interesting bits of the parent component, so we can freely change them without
		//   outside performance implications
		const compCpyState = {
			[this._propMin]: this._comp._state[this._propMin],
			[this._propCurMin]: this._comp._state[this._propCurMin],
			[this._propMax]: this._comp._state[this._propMax],
		};
		if (!this._isSingle) compCpyState[this._propCurMax] = this._comp._state[this._propCurMax];
		this._compCpy = BaseComponent.fromObject(compCpyState);

		// Sync parent changes to our state
		this._comp._addHook("state", this._propMin, () => this._compCpy._state[this._propMin] = this._comp._state[this._propMin]);
		this._comp._addHook("state", this._propCurMin, () => this._compCpy._state[this._propCurMin] = this._comp._state[this._propCurMin]);
		this._comp._addHook("state", this._propMax, () => this._compCpy._state[this._propMax] = this._comp._state[this._propMax]);

		if (!this._isSingle) this._comp._addHook("state", this._propCurMax, () => this._compCpy._state[this._propCurMax] = this._comp._state[this._propCurMax]);
		// endregion

		this._cacheRendered = null;
		this._dispTrackOuter = null;
		this._dispTrackInner = null;
		this._thumbLow = null;
		this._thumbHigh = null;
		this._dragMeta = null;
	}

	$get () {
		const out = this.get();
		return $(out);
	}

	get () {
		this.constructor._init();
		this.constructor._ALL_SLIDERS.add(this);

		if (this._cacheRendered) return this._cacheRendered;

		// region Top part
		const dispValueLeft = this._isSingle ? this._getSpcSingleValue() : this._getDispValue({isVisible: true, side: "left"});
		const dispValueRight = this._getDispValue({isVisible: true, side: "right"});

		this._dispTrackInner = this._isSingle ? null : e_({
			tag: "div",
			clazz: "ui-slidr__track-inner h-100 absolute",
		});

		this._thumbLow = this._getThumb();
		this._thumbHigh = this._isSingle ? null : this._getThumb();

		this._dispTrackOuter = e_({
			tag: "div",
			clazz: `relative w-100 ui-slidr__track-outer`,
			children: [
				this._dispTrackInner,
				this._thumbLow,
				this._thumbHigh,
			].filter(Boolean),
		});

		const wrpTrack = e_({
			tag: "div",
			clazz: `ve-flex-v-center w-100 h-100 ui-slidr__wrp-track clickable`,
			mousedown: evt => {
				const thumb = this._getClosestThumb(evt);
				this._handleMouseDown(evt, thumb);
			},
			children: [
				this._dispTrackOuter,
			],
		});

		const wrpTop = e_({
			tag: "div",
			clazz: "ve-flex-v-center w-100 ui-slidr__wrp-top",
			children: [
				dispValueLeft,
				wrpTrack,
				dispValueRight,
			].filter(Boolean),
		});
		// endregion

		// region Bottom part
		const wrpPips = e_({
			tag: "div",
			clazz: `w-100 ve-flex relative clickable h-100 ui-slidr__wrp-pips`,
			mousedown: evt => {
				const thumb = this._getClosestThumb(evt);
				this._handleMouseDown(evt, thumb);
			},
		});

		const wrpBottom = e_({
			tag: "div",
			clazz: "w-100 ve-flex-vh-center ui-slidr__wrp-bottom",
			children: [
				this._isSingle ? this._getSpcSingleValue() : this._getDispValue({side: "left"}), // Pad the start
				wrpPips,
				this._getDispValue({side: "right"}), // and the end
			].filter(Boolean),
		});
		// endregion

		// region Hooks
		const hkChangeValue = () => {
			const curMin = this._compCpy._state[this._propCurMin];
			const pctMin = this._getLeftPositionPercentage({value: curMin});
			this._thumbLow.style.left = `calc(${pctMin}% - ${this.constructor._W_THUMB_PX / 2}px)`;
			const toDisplayLeft = this._fnDisplay ? `${this._fnDisplay(curMin)}`.qq() : curMin;
			const toDisplayLeftTooltip = this._fnDisplayTooltip ? `${this._fnDisplayTooltip(curMin)}`.qq() : null;
			if (!this._isSingle) {
				dispValueLeft
					.html(toDisplayLeft)
					.tooltip(toDisplayLeftTooltip);
			}

			if (!this._isSingle) {
				this._dispTrackInner.style.left = `${pctMin}%`;

				const curMax = this._compCpy._state[this._propCurMax];
				const pctMax = this._getLeftPositionPercentage({value: curMax});
				this._dispTrackInner.style.right = `${100 - pctMax}%`;
				this._thumbHigh.style.left = `calc(${pctMax}% - ${this.constructor._W_THUMB_PX / 2}px)`;
				dispValueRight
					.html(this._fnDisplay ? `${this._fnDisplay(curMax)}`.qq() : curMax)
					.tooltip(this._fnDisplayTooltip ? `${this._fnDisplayTooltip(curMax)}`.qq() : null);
			} else {
				dispValueRight
					.html(toDisplayLeft)
					.tooltip(toDisplayLeftTooltip);
			}
		};

		const hkChangeLimit = () => {
			const pips = [];

			if (!this._sparseValues) {
				const numPips = this._compCpy._state[this._propMax] - this._compCpy._state[this._propMin];
				let pipIncrement = 1;
				// Cap the number of pips
				if (numPips > ComponentUiUtil.RangeSlider._MAX_PIPS) pipIncrement = Math.ceil(numPips / ComponentUiUtil.RangeSlider._MAX_PIPS);

				let i, len;
				for (
					i = this._compCpy._state[this._propMin], len = this._compCpy._state[this._propMax] + 1;
					i < len;
					i += pipIncrement
				) {
					pips.push(this._getWrpPip({
						isMajor: i === this._compCpy._state[this._propMin] || i === (len - 1),
						value: i,
					}));
				}

				// Ensure the last pip is always rendered, even if we're reducing pips
				if (i !== this._compCpy._state[this._propMax]) pips.push(this._getWrpPip({isMajor: true, value: this._compCpy._state[this._propMax]}));
			} else {
				const len = this._sparseValues.length;
				this._sparseValues.forEach((val, i) => {
					pips.push(this._getWrpPip({
						isMajor: i === 0 || i === (len - 1),
						value: val,
					}));
				});
			}

			wrpPips.empty();
			e_({
				ele: wrpPips,
				children: pips,
			});

			hkChangeValue();
		};

		this._compCpy._addHook("state", this._propMin, hkChangeLimit);
		this._compCpy._addHook("state", this._propMax, hkChangeLimit);
		this._compCpy._addHook("state", this._propCurMin, hkChangeValue);
		if (!this._isSingle) this._compCpy._addHook("state", this._propCurMax, hkChangeValue);

		hkChangeLimit();
		// endregion

		const wrp = e_({
			tag: "div",
			clazz: "ve-flex-col w-100 ui-slidr__wrp",
			children: [
				wrpTop,
				wrpBottom,
			],
		});

		return this._cacheRendered = wrp;
	}

	destroy () {
		this.constructor._ALL_SLIDERS.delete(this);
		if (this._cacheRendered) this._cacheRendered.remove();
	}

	_getDispValue ({isVisible, side}) {
		return e_({
			tag: "div",
			clazz: `overflow-hidden ui-slidr__disp-value no-shrink no-grow ve-flex-vh-center bold no-select ${isVisible ? `ui-slidr__disp-value--visible` : ""} ui-slidr__disp-value--${side}`,
		});
	}

	_getSpcSingleValue () {
		return e_({
			tag: "div",
			clazz: `px-2`,
		});
	}

	_getThumb () {
		const thumb = e_({
			tag: "div",
			clazz: "ui-slidr__thumb absolute clickable",
			mousedown: evt => this._handleMouseDown(evt, thumb),
		}).attr("draggable", true);

		return thumb;
	}

	_getWrpPip ({isMajor, value} = {}) {
		const style = this._getWrpPip_getStyle({value});

		const pip = e_({
			tag: "div",
			clazz: `ui-slidr__pip ${isMajor ? `ui-slidr__pip--major` : `absolute`}`,
		});

		const dispLabel = e_({
			tag: "div",
			clazz: "absolute ui-slidr__pip-label ve-flex-vh-center ve-small no-wrap",
			html: isMajor ? this._fnDisplay ? `${this._fnDisplay(value)}`.qq() : value : "",
			title: isMajor && this._fnDisplayTooltip ? `${this._fnDisplayTooltip(value)}`.qq() : null,
		});

		return e_({
			tag: "div",
			clazz: "ve-flex-col ve-flex-vh-center absolute no-select",
			children: [
				pip,
				dispLabel,
			],
			style,
		});
	}

	_getWrpPip_getStyle ({value}) {
		return `left: ${this._getLeftPositionPercentage({value})}%`;
	}

	_getLeftPositionPercentage ({value}) {
		if (this._sparseValues) {
			const ix = this._sparseValues.sort(SortUtil.ascSort).indexOf(value);
			if (!~ix) throw new Error(`Value "${value}" was not in the list of sparse values!`);
			return (ix / (this._sparseValues.length - 1)) * 100;
		}

		const min = this._compCpy._state[this._propMin]; const max = this._compCpy._state[this._propMax];
		return ((value - min) / (max - min)) * 100;
	}

	/**
	 * Convert pixel-space to track-space.
	 * Example usage:
	 * ```
	 * click: evt => {
	 *   const {x: trackOriginX, width: trackWidth} = this._dispTrackOuter.getBoundingClientRect();
	 *   const value = this._getRelativeValue(evt, {trackOriginX, trackWidth});
	 *   this._handleClick(evt, value);
	 * }
	 * ```
	 */
	_getRelativeValue (evt, {trackOriginX, trackWidth}) {
		const xEvt = EventUtil.getClientX(evt) - trackOriginX;

		if (this._sparseValues) {
			const ixMax = this._sparseValues.length - 1;
			const rawVal = Math.round((xEvt / trackWidth) * ixMax);
			return this._sparseValues[Math.min(ixMax, Math.max(0, rawVal))];
		}

		const min = this._compCpy._state[this._propMin]; const max = this._compCpy._state[this._propMax];

		const rawVal = min
			+ Math.round(
				(xEvt / trackWidth) * (max - min),
			);

		return Math.min(max, Math.max(min, rawVal)); // Clamp eet
	}

	_getClosestThumb (evt) {
		if (this._isSingle) return this._thumbLow;

		const {x: trackOriginX, width: trackWidth} = this._dispTrackOuter.getBoundingClientRect();
		const value = this._getRelativeValue(evt, {trackOriginX, trackWidth});

		if (value < this._compCpy._state[this._propCurMin]) return this._thumbLow;
		if (value > this._compCpy._state[this._propCurMax]) return this._thumbHigh;

		const {distToMin, distToMax} = this._getDistsToCurrentMinAndMax(value);
		if (distToMax < distToMin) return this._thumbHigh;
		return this._thumbLow;
	}

	_getDistsToCurrentMinAndMax (value) {
		if (this._isSingle) throw new Error(`Can not get distance to max value for singleton slider!`);

		// Move the closest slider to this pip's location
		const distToMin = Math.abs(this._compCpy._state[this._propCurMin] - value);
		const distToMax = Math.abs(this._compCpy._state[this._propCurMax] - value);
		return {distToMin, distToMax};
	}

	_handleClick (evt, value) {
		evt.stopPropagation();
		evt.preventDefault();

		// If lower than the lowest value, set the low value
		if (value < this._compCpy._state[this._propCurMin]) this._compCpy._state[this._propCurMin] = value;

		// If higher than the highest value, set the high value
		if (value > this._compCpy._state[this._propCurMax]) this._compCpy._state[this._propCurMax] = value;

		// Move the closest slider to this pip's location
		const {distToMin, distToMax} = this._getDistsToCurrentMinAndMax(value);

		if (distToMax < distToMin) this._compCpy._state[this._propCurMax] = value;
		else this._compCpy._state[this._propCurMin] = value;
	}

	_handleMouseDown (evt, thumb) {
		evt.preventDefault();
		evt.stopPropagation();

		// region Set drag metadata
		const {x: trackOriginX, width: trackWidth} = this._dispTrackOuter.getBoundingClientRect();

		thumb.addClass(`ui-slidr__thumb--hover`);

		this._dragMeta = {
			trackOriginX,
			trackWidth,
			thumb,
		};
		// endregion

		this._handleMouseMove(evt);
	}

	_handleMouseUp () {
		const wasActive = this._doDragCleanup();

		// On finishing a slide, push our state to the parent comp
		if (wasActive) {
			const nxtState = {
				[this._propMin]: this._compCpy._state[this._propMin],
				[this._propMax]: this._compCpy._state[this._propMax],
				[this._propCurMin]: this._compCpy._state[this._propCurMin],
			};
			if (!this._isSingle) nxtState[this._propCurMax] = this._compCpy._state[this._propCurMax];

			this._comp._proxyAssignSimple("state", nxtState);
		}
	}

	_handleMouseMove (evt) {
		if (!this._dragMeta) return;

		const val = this._getRelativeValue(evt, this._dragMeta);

		if (this._dragMeta.thumb === this._thumbLow) {
			if (val > this._compCpy._state[this._propCurMax]) return;
			this._compCpy._state[this._propCurMin] = val;
		} else if (this._dragMeta.thumb === this._thumbHigh) {
			if (val < this._compCpy._state[this._propCurMin]) return;
			this._compCpy._state[this._propCurMax] = val;
		}
	}

	_doDragCleanup () {
		const isActive = this._dragMeta != null;

		if (this._dragMeta?.thumb) this._dragMeta.thumb.removeClass(`ui-slidr__thumb--hover`);

		this._dragMeta = null;

		return isActive;
	}

	static _init () {
		if (this._isInit) return;
		document.addEventListener("mousemove", evt => {
			for (const slider of this._ALL_SLIDERS) {
				slider._handleMouseMove(evt);
			}
		});

		document.addEventListener("mouseup", evt => {
			for (const slider of this._ALL_SLIDERS) {
				slider._handleMouseUp(evt);
			}
		});
	}
};
ComponentUiUtil.RangeSlider._isInit = false;
ComponentUiUtil.RangeSlider._ALL_SLIDERS = new Set();
ComponentUiUtil.RangeSlider._W_THUMB_PX = 16;
ComponentUiUtil.RangeSlider._W_LABEL_PX = 24;
ComponentUiUtil.RangeSlider._MAX_PIPS = 40;

class SettingsUtil {
	static Setting = class {
		constructor (
			{
				type,
				name,
				help,
				defaultVal,
			},
		) {
			this.type = type;
			this.name = name;
			this.help = help;
			this.defaultVal = defaultVal;
		}
	};

	static EnumSetting = class extends SettingsUtil.Setting {
		constructor (
			{
				enumVals,
				...rest
			},
		) {
			super(rest);
			this.enumVals = enumVals;
		}
	};

	static getDefaultSettings (settings) {
		return Object.entries(settings)
			.mergeMap(([prop, {defaultVal}]) => ({[prop]: defaultVal}));
	}
}

globalThis.ProxyBase = ProxyBase;
globalThis.UiUtil = UiUtil;
globalThis.ListUiUtil = ListUiUtil;
globalThis.ProfUiUtil = ProfUiUtil;
globalThis.TabUiUtil = TabUiUtil;
globalThis.SearchUiUtil = SearchUiUtil;
globalThis.SearchWidget = SearchWidget;
globalThis.InputUiUtil = InputUiUtil;
globalThis.DragReorderUiUtil = DragReorderUiUtil;
globalThis.SourceUiUtil = SourceUiUtil;
globalThis.BaseComponent = BaseComponent;
globalThis.ComponentUiUtil = ComponentUiUtil;
globalThis.RenderableCollectionBase = RenderableCollectionBase;

}).toString());



EXT_LIB_SCRIPTS.push((function lib_script_6 () {
// A port of 5etools' `hist.js`

Hist = {}

Hist.util = {
	getCleanHash (hash) {
		return hash.replace(/,+/g, ",").replace(/,$/, "").toLowerCase();
	},

	getHashParts (location) {
		if (location[0] === "#") location = location.slice(1);
		return location.toLowerCase().replace(/%27/g, "'").split(HASH_PART_SEP);
	},

	getSubHash (location, key) {
		const [link, ...sub] = Hist.util.getHashParts(location);
		const hKey = `${key}${HASH_SUB_KV_SEP}`;
		const part = sub.find(it => it.startsWith(hKey));
		if (part) return part.slice(hKey.length);
		return null;
	},

	setSubhash (location, key, val) {
		if (key.endsWith(HASH_SUB_KV_SEP)) key = key.slice(0, -1);

		const [link, ...sub] = Hist.util.getHashParts(location);
		if (!link) return "";

		const hKey = `${key}${HASH_SUB_KV_SEP}`;
		const out = [link];
		if (sub.length) sub.filter(it => !it.startsWith(hKey)).forEach(it => out.push(it));
		if (val != null) out.push(`${hKey}${val}`);

		return Hist.util.getCleanHash(out.join(HASH_PART_SEP));
	}
};

}).toString());



EXT_LIB_API_SCRIPTS.push((function lib_script_7 () {
/**
 * This is a small library for (mostly 2D) vector mathematics.
 * Internally, the vectors used by this library are simple arrays of numbers.
 * The functions provided by this library do not alter the input vectors, 
 * treating each vector as an immutable object.
 */
var VecMath = (function() {
    
    /**
     * Adds two vectors.
     * @param {vec} a
     * @param {vec} b
     * @return {vec}
     */
    var add = function(a, b) {
        var result = [];
        for(var i=0; i<a.length; i++) {
            result[i] = a[i] + b[i];
        }
        return result;
    };
    
    
    /**
     * Creates a cloned copy of a vector.
     * @param {vec} v
     * @return {vec}
     */
    var clone = function(v) {
        var result = [];
        for(var i=0; i < v.length; i++) {
            result.push(v[i]);
        }
        return result;
    };
    
    
    /** 
     * Returns an array representing the cross product of two 3D vectors. 
     * @param {vec3} a
     * @param {vec3} b
     * @return {vec3}
     */
    var cross = function(a, b) {
        var x = a[1]*b[2] - a[2]*b[1];
        var y = a[2]*b[0] - a[0]*b[2];
        var z = a[0]*b[1] - a[1]*b[0];
        return [x, y, z];
    };
    
    
    /** 
     * Returns the degree of a vector - the number of dimensions it has.
     * @param {vec} vector
     * @return {int}
     */
    var degree = function(vector) {
        return vector.length;
    };
    
    
    /**
     * Computes the distance between two points.
     * @param {vec} pt1
     * @param {vec} pt2
     * @return {number}
     */
    var dist = function(pt1, pt2) {
        var v = vec(pt1, pt2);
        return length(v);
    };
    
    
    /** 
     * Returns the dot product of two vectors. 
     * @param {vec} a
     * @param {vec} b
     * @return {number}
     */
    var dot = function(a, b) {
        var result = 0;
        for(var i = 0; i < a.length; i++) {
            result += a[i]*b[i];
        }
        return result;
    };
    
    
    /**
     * Tests if two vectors are equal.
     * @param {vec} a
     * @param {vec} b
     * @param {float} [tolerance] A tolerance threshold for comparing vector 
     *                            components.  
     * @return {boolean} true iff the each of the vectors' corresponding 
     *                  components are equal.
     */
    var equal = function(a, b, tolerance) {
        if(a.length != b.length)
            return false;
        
        for(var i=0; i<a.length; i++) {
            if(tolerance !== undefined) {
                if(Math.abs(a[i] - b[i]) > tolerance) {
                    return false;
                }
            }
            else if(a[i] != b[i])
                return false;
        }
        return true;
    };
    
    
    
    /** 
     * Returns the length of a vector. 
     * @param {vec} vector
     * @return {number}
     */
    var length = function(vector) {
        var length = 0;
        for(var i=0; i < vector.length; i++) {
            length += vector[i]*vector[i];
        }
        return Math.sqrt(length);
    };
    
    
    
    /**
     * Computes the normalization of a vector - its unit vector.
     * @param {vec} v
     * @return {vec}
     */
    var normalize = function(v) {
        var vHat = [];
        
        var vLength = length(v);
        for(var i=0; i < v.length; i++) {
            vHat[i] = v[i]/vLength;
        }
        
        return vHat;
    };
    
    
    /**
     * Computes the projection of vector b onto vector a.
     * @param {vec} a
     * @param {vec} b
     * @return {vec}
     */
    var projection = function(a, b) {
        var scalar = scalarProjection(a, b);
        var aHat = normalize(a);
        
        return scale(aHat, scalar);
    };
    
    
    /** 
     * Computes the distance from a point to an infinitely stretching line. 
     * Works for either 2D or 3D points.
     * @param {vec2 || vec3} pt
     * @param {vec2 || vec3} linePt1   A point on the line.
     * @param {vec2 || vec3} linePt2   Another point on the line.
     * @return {number}
     */
    var ptLineDist = function(pt, linePt1, linePt2) {
        var a = vec(linePt1, linePt2);
        var b = vec(linePt1, pt);
        
        // Make 2D vectors 3D to compute the cross product.
        if(!a[2])
            a[2] = 0;
        if(!b[2])
            b[2] = 0;
        
        var aHat = normalize(a);
        var aHatCrossB = cross(aHat, b);
        return length(aHatCrossB);
    };
    
    
    /** 
     * Computes the distance from a point to a line segment. 
     * Works for either 2D or 3D points.
     * @param {vec2 || vec3} pt
     * @param {vec2 || vec3} linePt1   The start point of the segment.
     * @param {vec2 || vec3} linePt2   The end point of the segment.
     * @return {number}
     */
    var ptSegDist = function(pt, linePt1, linePt2) {
        var a = vec(linePt1, linePt2);
        var b = vec(linePt1, pt);
        var aDotb = dot(a,b);
        
        // Is pt behind linePt1?
        if(aDotb < 0) {
            return length(vec(pt, linePt1));
        }
        
        // Is pt after linePt2?
        else if(aDotb > dot(a,a)) {
            return length(vec(pt, linePt2));
        }
        
        // Pt must be between linePt1 and linePt2.
        else {
            return ptLineDist(pt, linePt1, linePt2);
        }
    };
    
    
    /**
     * Computes the scalar projection of b onto a.
     * @param {vec2} a
     * @param {vec2} b
     * @return {vec2}
     */
    var scalarProjection = function(a, b) {
        var aDotB = dot(a, b);
        var aLength = length(a);
        
        return aDotB/aLength;
    };
    
    
    
    /**
     * Computes a scaled vector.
     * @param {vec2} v
     * @param {number} scalar
     * @return {vec2}
     */
    var scale = function(v, scalar) {
        var result = [];
        
        for(var i=0; i<v.length; i++) {
            result[i] = v[i]*scalar;
        }
        return result;
    };
    
    
    /** 
     * Computes the difference of two vectors.
     * @param {vec} a
     * @param {vec} b
     * @return {vec}
     */
    var sub = function(a, b) {
        var result = [];
        for(var i=0; i<a.length; i++) {
            result.push(a[i] - b[i]);
        }
        return result;
    };
    
    
    /** 
     * Returns the vector from pt1 to pt2. 
     * @param {vec} pt1
     * @param {vec} pt2
     * @return {vec}
     */
    var vec = function(pt1, pt2) {
        var result = [];
        for(var i=0; i<pt1.length; i++) {
            result.push( pt2[i] - pt1[i] );
        }
        
        return result;
    };
    
    
    // The exposed API.
    return {
        add: add,
        clone: clone,
        cross: cross,
        degree: degree,
        dist: dist,
        dot: dot,
        equal: equal,
        length: length,
        normalize: normalize,
        projection: projection,
        ptLineDist: ptLineDist,
        ptSegDist: ptSegDist,
        scalarProjection: scalarProjection,
        scale: scale,
        sub: sub,
        vec: vec
    };
})();


// Perform unit tests. Inform us in the log if any test fails. Otherwise,
// succeed silently.
(function() {
    /**
     * Does a unit test. If the test evaluates to false, then it displays with
     * a message that the unit test failed. Otherwise it passes silently.
     * @param {boolean} test    Some expression to test.
     * @param {string} failMsg  A message displayed if the test fails.
     */
    var assert = function(test, failMsg) {
        if(!test) {
            log("UNIT TEST FAILED: " + failMsg);
        }
    };
    
    
    var a = [1, 5];
    var b = [17, -8];
    
    
    // VecMath.equal
    assert(
        VecMath.equal([2, -3, 4, 8], [2, -3, 4, 8]),
        "VecMath.equal([2, -3, 4, 8], [2, -3, 4, 8])"
    );
    assert(
        !VecMath.equal([1, 3, 5], [-2, 4, -6]),
        "!VecMath.equal([1, 3, 5], [-2, 4, -6])"
    );
    assert(
        !VecMath.equal([1, 3, 5], [1, 3, 4]),
        "!VecMath.equal([1, 3, 5], [1, 3, 4])"
    );
    assert(
        !VecMath.equal([1,2,3], [1,2]),
        "!VecMath.equal([1,2,3], [1,2])"
    );
    assert(
        !VecMath.equal([1,2], [1,2,3]),
        "!VecMath.equal([1,2], [1,2,3])"
    );
    
    // VecMath.add
    assert(
        VecMath.equal(
            VecMath.add([1, 2, 3], [3, -5, 10]),
            [4, -3, 13]
        ),
        "VecMath.add([1, 2, 3], [3, -5, 10]) equals [4, -3, 13]"
    );
    assert(
        VecMath.equal(
            VecMath.add([0, 0, 0], [1, 2, 3]),
            [1, 2, 3]
        ),
        "VecMath.add([0, 0, 0], [1, 2, 3]) equals [1, 2, 3]"
    );
    
    // VecMath.clone
    assert(
        VecMath.equal( VecMath.clone(a), a),
        "VecMath.equal( VecMath.clone(a), a)"
    );
    assert(
        VecMath.clone(a) != a,
        "VecMath.clone(a) != a"
    );
    
    // VecMath.cross
    assert(
        VecMath.equal(
            VecMath.cross([1, 0, 0], [0, 1, 0]),
            [0, 0, 1]
        ),
        "VecMath.cross([1, 0, 0], [0, 1, 0]) equals [0, 0, 1]"
    );
    assert(
        VecMath.equal(
            VecMath.cross([1,2,3], [-10, 3, 5]),
            [1, -35, 23]
        ),
        "VecMath.cross([1,2,3], [-10, 3, 5]) equals [1, -35, 23]"
    );
    
    // VecMath.degree
    assert(
        VecMath.degree([1,2,3]) == 3,
        "VecMath.degree([1,2,3]) == 3"
    );
    assert(
        VecMath.degree([1]) == 1,
        "VecMath.degree([1]) == 1"
    );
    assert(
        VecMath.degree([1,1,1,1,1]) == 5,
        "VecMath.degree([1,1,1,1,1]) == 5"
    );
    
    // VecMath.dist
    assert(
        VecMath.dist([1,2], [4,6]) == 5,
        "VecMath.dist([1,2], [4,6]) == 5"
    );
    assert(
        VecMath.dist([3,4], [-3, -4]) == 10,
        "VecMath.dist([3,4], [-3, -4]) == 10"
    );
    
    // VecMath.dot
    assert(
        VecMath.dot([1, 2, 3], [-1, -2, -3]) == -14,
        "VecMath.dot([1, 2, 3], [-1, -2, -3]) == -14"
    );
    assert(
        VecMath.dot([1,0], [0,1]) == 0,
        "VecMath.dot([1,0], [0,1]) == 0"
    );
    assert(
        VecMath.dot([1,0], [0,-1]) == 0,
        "VecMath.dot([1,0], [0,-1]) == 0"
    );
    assert(
        VecMath.dot([1,0], [-1, 0]) == -1,
        "VecMath.dot([1,0], [-1, 0]) == -1"
    );
    assert(
        VecMath.dot([1,0], [1, 0]) == 1,
        "VecMath.dot([1,0], [1, 0]) == 1"
    );
    
    // VecMath.length
    assert(
        VecMath.length([1,0,0]) == 1,
        "VecMath.length([1,0,0]) == 1"
    );
    assert(
        VecMath.length([3,4]) == 5,
        "VecMath.length([3,4]) == 5"
    );
    assert(
        VecMath.length([-3, 0, 4, 0]) == 5,
        "VecMath.length([-3, 0, 4, 0]) == 5"
    );
    
    // VecMath.normalize
    assert(
        VecMath.equal(
            VecMath.normalize([3,0]),
            [1, 0]
        ),
        "VecMath.normalize([3,0]) equals [1,0]"
    );
    assert(
        VecMath.equal(
            VecMath.normalize([0,-3]),
            [0, -1]
        ),
        "VecMath.normalize([0,-3]) equals [0,-1]"
    );
    
    // VecMath.projection
    assert(
        VecMath.equal(
            VecMath.projection([5,0], [3, 4]),
            [3, 0]
        ),
        "VecMath.projection([5,0], [3, 4]) equals [3, 0]"
    );
    assert(
        VecMath.equal(
            VecMath.projection([5,5], [0, 6]),
            [3, 3],
            0.001
        ),
        "VecMath.projection([5,5], [0, 6]) equals [3, 3]"
    );
    
    // VecMath.ptLineDist
    assert(
        VecMath.ptLineDist([0,3], [-100,5], [100,5]) == 2,
        "VecMath.ptLineDist([0,3], [-100,5], [100,5]) == 2"
    );
    assert(
        VecMath.ptLineDist([3,0], [5,5], [5,10]) == 2,
        "VecMath.ptLineDist([3,0], [5,5], [5,10]) == 2"
    );
    
    // VecMath.ptSegDist
    assert(
        VecMath.ptSegDist([0,3], [-5,5], [5,5]) == 2,
        "VecMath.ptSegDist([0,3], [-5,5], [5,5]) == 2"
    );
    assert(
        VecMath.ptSegDist([3,0], [5,-5], [5,5]) == 2,
        "VecMath.ptSegDist([3,0], [5,-5], [5,5]) == 2"
    );
    assert(
        VecMath.ptSegDist([3,4], [-5,0], [0,0]) == 5,
        "VecMath.ptSegDist([3,4], [-5,0], [0,0]) == 5"
    );
    assert(
        VecMath.ptSegDist([-2,-4], [1,0], [5,0]) == 5,
        "VecMath.ptSegDist([-2,-4], [1,0], [5,0]) == 5"
    );
    
    // VecMath.scalarProjection
    assert(
        VecMath.scalarProjection([5,0], [3, 4]) == 3,
        "VecMath.scalarProjection([5,0], [3, 4]) == 3"
    );
    
    // VecMath.scale
    assert(
        VecMath.equal(
            VecMath.scale([1,-2,3], 6),
            [6, -12, 18]
        ),
        "VecMath.scale([1,-2,3], 6) equals [6, -12, 18]"
    );
    
    // VecMath.sub
    assert(
        VecMath.equal(
            VecMath.sub([10, 8, 6], [-4, 6, 1]),
            [14, 2, 5]
        ),
        "VecMath.sub([10, 8, 6], [-4, 6, 1]) equals [14, 2, 5]"
    );
    
    // VecMath.vec
    assert(
        VecMath.equal(
            VecMath.vec([1,1], [3,4]),
            [2,3]
        ),
        "VecMath.vec([1,1], [3,4]) equals [2,3]"
    );
})();

}).toString());



EXT_LIB_API_SCRIPTS.push((function lib_script_8 () {
/**
 * This script provides a library for performing affine matrix operations
 * inspired by the [glMatrix library](http://glmatrix.net/) developed by
 * Toji and SinisterChipmunk.
 *
 * Unlike glMatrix, this library does not have operations for vectors.
 * However, my VectorMath script provides a library providing many kinds of
 * common vector operations.
 *
 * This project has no behavior on its own, but its functions are used by
 * other scripts to do some cool things, particular for math involving 2D and
 * 3D geometry.
 */
var MatrixMath = (function() {
  /**
   * An NxN square matrix, represented as a 2D array of numbers in column-major
   * order. For example, mat[3][2] would get the value in column 3 and row 2.
   * order.
   * @typedef {number[][]} Matrix
   */

  /**
   * An N-degree vector.
   * @typedef {number[]} Vector
   */

  /**
   * Gets the adjugate of a matrix, the tranpose of its cofactor matrix.
   * @param  {Matrix} mat
   * @return {Matrix}
   */
  function adjoint(mat) {
    var cofactorMat = MatrixMath.cofactorMatrix(mat);
    return MatrixMath.transpose(cofactorMat);
  }

   /**
    * Produces a clone of an NxN square matrix.
    * @param  {Matrix} mat
    * @return {Matrix}
    */
  function clone(mat) {
    return _.map(mat, function(column) {
      return _.map(column, function(value) {
        return value;
      });
    });
  }

  /**
   * Gets the cofactor of a matrix at a specified column and row.
   * @param  {Matrix} mat
   * @param  {uint} col
   * @param  {uint} row
   * @return {number}
   */
  function cofactor(mat, col, row) {
    return Math.pow(-1, col+row)*MatrixMath.minor(mat, col, row);
  }

  /**
   * Gets the cofactor matrix of a matrix.
   * @param  {Matrix} mat
   * @return {Matrix}
   */
  function cofactorMatrix(mat) {
    var result = [];
    var size = MatrixMath.size(mat);
    for(var col=0; col<size; col++) {
      result[col] = [];
      for(var row=0; row<size; row++) {
        result[col][row] = MatrixMath.cofactor(mat, col, row);
      }
    }
    return result;
  }

  /**
   * Gets the determinant of an NxN matrix.
   * @param  {Matrix} mat
   * @return {number}
   */
  function determinant(mat) {
    var size = MatrixMath.size(mat);

    if(size === 2)
      return mat[0][0]*mat[1][1] - mat[1][0]*mat[0][1];
    else {
      var sum = 0;
      for(var col=0; col<size; col++) {
        sum += mat[col][0] * MatrixMath.cofactor(mat, col, 0);
      }
      return sum;
    }
  }

  /**
   * Tests if two matrices are equal.
   * @param  {Matrix} a
   * @param  {Matrix} b
   * @param {number} [tolerance=0]
   *        If specified, this specifies the amount of tolerance to use for
   *        each value of the matrices when testing for equality.
   * @return {boolean}
   */
  function equal(a, b, tolerance) {
    tolerance = tolerance || 0;
    var sizeA = MatrixMath.size(a);
    var sizeB = MatrixMath.size(b);

    if(sizeA !== sizeB)
      return false;

    for(var col=0; col<sizeA; col++) {
      for(var row=0; row<sizeA; row++) {
        if(Math.abs(a[col][row] - b[col][row]) > tolerance)
          return false;
      }
    }
    return true;
  }

  /**
   * Produces an identity matrix of some size.
   * @param  {uint} size
   * @return {Matrix}
   */
  function identity(size) {
    var mat = [];
    for(var col=0; col<size; col++) {
      mat[col] = [];
      for(var row=0; row<size; row++) {
        if(row === col)
          mat[col][row] = 1;
        else
          mat[col][row] = 0;
      }
    }
    return mat;
  }

  /**
   * Gets the inverse of a matrix.
   * @param  {Matrix} mat
   * @return {Matrix}
   */
  function inverse(mat) {
    var determinant = MatrixMath.determinant(mat);
    if(determinant === 0)
      return undefined;

    var adjoint = MatrixMath.adjoint(mat);
    var result = [];
    var size = MatrixMath.size(mat);
    for(var col=0; col<size; col++) {
      result[col] = [];
      for(var row=0; row<size; row++) {
        result[col][row] = adjoint[col][row]/determinant;
      }
    }
    return result;
  }

  /**
   * Gets the determinant of a matrix omitting some column and row.
   * @param  {Matrix} mat
   * @param  {uint} col
   * @param  {uint} row
   * @return {number}
   */
  function minor(mat, col, row) {
    var reducedMat = MatrixMath.omit(mat, col, row);
    return determinant(reducedMat);
  }


  /**
   * Returns the matrix multiplication of a*b.
   * This function works for non-square matrices (and also for transforming
   * vectors by a matrix).
   * For matrix multiplication to work, the # of columns in A must be equal
   * to the # of rows in B.
   * The resulting matrix will have the same number of rows as A and the
   * same number of columns as B.
   * If b was given as a vector, then the result will also be a vector.
   * @param  {Matrix} a
   * @param  {Matrix|Vector} b
   * @return {Matrix|Vector}
   */
  function multiply(a, b) {
    // If a vector is given for b, convert it to a nx1 matrix, where n
    // is the length of b.
    var bIsVector = _.isNumber(b[0]);
    if(bIsVector)
      b = [b];

    var colsA = a.length;
    var rowsA = a[0].length;
    var colsB = b.length;
    var rowsB = b[0].length;
    if(colsA !== rowsB)
      throw new Error('MatrixMath.multiply ERROR: # columns in A must be ' +
        'the same as the # rows in B. Got A: ' + rowsA + 'x' + colsA +
        ', B: ' + rowsB + 'x' + colsB + '.');

    var result = [];
    for(var col=0; col<colsB; col++) {
      result[col] = [];
      for(var row=0; row<rowsA; row++) {
        result[col][row] = 0;
        for(var i=0; i<colsA; i++) {
          result[col][row] += a[i][row] * b[col][i];
        }
      }
    }

    if(bIsVector)
      result = result[0];
    return result;
  }

  /**
   * Returns a matrix with a column and row omitted.
   * @param  {Matrix} mat
   * @param  {uint} col
   * @param  {uint} row
   * @return {Matrix}
   */
  function omit(mat, col, row) {
    var result = [];

    var size = MatrixMath.size(mat);
    for(var i=0; i<size; i++) {
      if(i === col)
        continue;

      var column = [];
      result.push(column);
      for(var j=0; j<size; j++) {
        if(j !== row)
          column.push(mat[i][j]);
      }
    }
    return result;
  }

  /**
   * Produces a 2D rotation affine transformation. The direction of the
   * rotation depends upon the coordinate system.
   * @param  {number} angle
   *         The angle, in radians.
   * @return {Matrix}
   */
  function rotate(angle) {
    var cos = Math.cos(angle);
    var sin = Math.sin(angle);
    return [[cos, sin, 0], [-sin, cos, 0], [0,0,1]];
  }

  /**
   * Produces a 2D scale affine transformation matrix.
   * The matrix is used to transform homogenous coordinates, so it is
   * actually size 3 instead of size 2, despite being used for 2D geometry.
   * @param  {(number|Vector)} amount
   *         If specified as a number, then it is a uniform scale. Otherwise,
   *         it defines a scale by parts.
   * @return {Matrix}
   */
  function scale(amount) {
    if(_.isNumber(amount))
      amount = [amount, amount];
    return [[amount[0], 0, 0], [0, amount[1], 0], [0, 0, 1]];
  }

  /**
   * Gets the size N of a NxN square matrix.
   * @param  {Matrix} mat
   * @return {uint}
   */
  function size(mat) {
    return mat[0].length;
  }

  /**
   * Produces a 2D translation affine transformation matrix.
   * The matrix is used to transform homogenous coordinates, so it is
   * actually size 3 instead of size 2, despite being used for 2D geometry.
   * @param  {Vector} vec
   * @return {Matrix}
   */
  function translate(vec) {
    return [[1,0,0], [0,1,0],[vec[0], vec[1], 1]];
  }

  /**
   * Returns the transpose of a matrix.
   * @param  {Matrix} mat
   * @return {Matrix}
   */
  function transpose(mat) {
    var result = [];

    var size = MatrixMath.size(mat);
    for(var col=0; col<size; col++) {
      result[col] = [];
      for(var row=0; row<size; row++) {
        result[col][row] = mat[row][col];
      }
    }
    return result;
  }


  return {
    adjoint: adjoint,
    clone: clone,
    cofactor: cofactor,
    cofactorMatrix: cofactorMatrix,
    determinant: determinant,
    equal: equal,
    identity: identity,
    inverse: inverse,
    minor: minor,
    multiply: multiply,
    omit: omit,
    rotate: rotate,
    scale: scale,
    size: size,
    translate: translate,
    transpose: transpose
  };
})();



// Perform unit tests. Inform us in the log if any test fails. Otherwise,
// succeed silently.
(function() {
  /**
   * Asserts that some boolean expression is true. Otherwise, it throws
   * an error.
   * @param {boolean} test    Some expression to test.
   * @param {string} failMsg  A message displayed if the test fails.
   */
  function assert(test, failMsg) {
    if(!test)
      throw new Error(failMsg);
  }

  function assertEqual(actual, expected, tolerance) {
    assert(MatrixMath.equal(actual, expected, tolerance),
      'Expected: ' + JSON.stringify(expected) +
      '\nActual: ' + JSON.stringify(actual));
  }

  /**
   * Performs a unit test.
   * If it fails, then the test's name and the error is displayed.
   * It is silent if the test passes.
   * @param  {string} testName
   * @param  {function} testFn
   */
  function unitTest(testName, testFn) {
    try {
      testFn();
    }
    catch(err) {
      log('TEST ' + testName);
      log('ERROR: ');
      var messageLines = err.message.split('\n');
      _.each(messageLines, function(line) {
        log(line);
      });
    }
  }


  unitTest('MatrixMath.equal()', function() {
    var a = [[1,2,3], [4,5,6], [7,8,9]];
    var b = [[1,2,3], [4,5,6], [7,8,9]];
    var c = [[0,0,0], [1,1,1], [2,2,2]];
    assert(MatrixMath.equal(a,b));
    assert(!MatrixMath.equal(a,c));
  });

  unitTest('MatrixMath.adjoint()', function() {
    // Example taken from http://www.mathwords.com/a/adjoint.htm
    var a = [[1,0,1], [2,4,0], [3,5,6]];

    var actual = MatrixMath.adjoint(a);
    var expected = [[24, 5, -4], [-12,3,2], [-2,-5,4]];

    assertEqual(actual, expected);
  });

  unitTest('MatrixMath.clone()', function() {
    var a = [[1,2,3], [4,5,6], [7,8,9]];
    var clone = MatrixMath.clone(a);
    assertEqual(a, clone);
    assert(a !== clone, 'should not be equal by reference.');
  });

  unitTest('MatrixMath.cofactor()', function() {
    // Example taken from http://www.mathwords.com/c/cofactor_matrix.htm.
    var a = [[1,0,1], [2,4,0], [3,5,6]];

    var actual = MatrixMath.cofactor(a,0,0);
    var expected = 24;
    assert(actual === expected, 'Got ' + actual + '\nExpected ' + expected);

    var actual = MatrixMath.cofactor(a,1,0);
    var expected = 5;
    assert(actual === expected, 'Got ' + actual + '\nExpected ' + expected);

    var actual = MatrixMath.cofactor(a,2,0);
    var expected = -4;
    assert(actual === expected, 'Got ' + actual + '\nExpected ' + expected);

    var actual = MatrixMath.cofactor(a,0,1);
    var expected = -12;
    assert(actual === expected, 'Got ' + actual + '\nExpected ' + expected);

    var actual = MatrixMath.cofactor(a,1,1);
    var expected = 3;
    assert(actual === expected, 'Got ' + actual + '\nExpected ' + expected);

    var actual = MatrixMath.cofactor(a,2,1);
    var expected = 2;
    assert(actual === expected, 'Got ' + actual + '\nExpected ' + expected);

    var actual = MatrixMath.cofactor(a,0,2);
    var expected = -2;
    assert(actual === expected, 'Got ' + actual + '\nExpected ' + expected);

    var actual = MatrixMath.cofactor(a,1,2);
    var expected = -5;
    assert(actual === expected, 'Got ' + actual + '\nExpected ' + expected);

    var actual = MatrixMath.cofactor(a,2,2);
    var expected = 4;
    assert(actual === expected, 'Got ' + actual + '\nExpected ' + expected);
  });

  unitTest('MatrixMath.cofactorMatrix()', function() {
    // Example taken from http://www.mathwords.com/c/cofactor_matrix.htm.
    var a = [[1,0,1], [2,4,0], [3,5,6]];
    var actual = MatrixMath.cofactorMatrix(a);
    var expected = [[24, -12, -2], [5, 3, -5], [-4, 2, 4]];
    assertEqual(actual, expected);
  });

  unitTest('MatrixMath.determinant()', function() {
    var a = [[1,2], [3,4]];
    var actual = MatrixMath.determinant(a);
    var expected = -2;
    assert(actual === expected, 'Got ' + actual + '\nExpected ' + expected);

    var a = [[1,5,0,2], [3,1,1,-1], [-2,0,0,0], [1,-1,-2,3]];
    var actual = MatrixMath.determinant(a);
    var expected = -6;
    assert(actual === expected, 'Got ' + actual + '\nExpected ' + expected);
  });

  unitTest('MatrixMath.identity()', function() {
    var actual = MatrixMath.identity(3);
    var expected = [[1,0,0], [0,1,0], [0,0,1]];
    assertEqual(actual, expected);

    var actual = MatrixMath.identity(2);
    var expected = [[1,0], [0,1]];
    assertEqual(actual, expected);
  });

  unitTest('MatrixMath.inverse()', function() {
    // Example taken from http://www.mathwords.com/i/inverse_of_a_matrix.htm
    var a = [[1,0,1], [2,4,0], [3,5,6]];
    var actual = MatrixMath.inverse(a);
    var expected = [[12/11, 5/22, -2/11],
                    [-6/11, 3/22, 1/11],
                    [-1/11, -5/22, 2/11]];
    assertEqual(actual, expected);

    var inverse = MatrixMath.multiply(a, actual);
    var expected = MatrixMath.identity(3);
    assertEqual(inverse, expected, 0.001);
  });

  unitTest('MatrixMath.minor()', function() {
    var a = [[1,2,3], [4,5,6], [7,8,9]];
    var actual = MatrixMath.minor(a, 1, 1);
    var expected = -12;
    assert(actual === expected, 'Got ' + actual + '\nExpected ' + expected);
  });

  unitTest('MatrixMath.multiply()', function() {
    var a = [[1,2,3], [4,5,6], [7,8,9]];
    var b = [[9,8,7], [6,5,4], [3,2,1]];
    var actual = MatrixMath.multiply(a,b);
    var expected = [[90, 114, 138], [54,69,84], [18,24,30]];
    assertEqual(actual, expected);
  });

  unitTest('Matrix.multiply() to transform a vector', function() {
    // A 2D point in homogenous coordinates.
    var pt = [1,2,1];

    var scale = MatrixMath.scale([10,20]);
    var rotate = MatrixMath.rotate(Math.PI/2);
    var translate = MatrixMath.translate([2,-8]);

    var m = MatrixMath.multiply(scale, rotate);
    m = MatrixMath.multiply(m, translate);

    // Transform the point.
    var actual = MatrixMath.multiply(m, pt);
    var expected = [60, 60, 1];
    assertEqual(actual, expected, 0.01);
  });

  unitTest('MatrixMath.omit()', function() {
    var a = [[1,2,3], [4,5,6], [7,8,9]];
    var actual = MatrixMath.omit(a, 1, 2);
    var expected = [[1,2], [7,8]];
    assertEqual(actual, expected);
  });

  unitTest('MatrixMath.size()', function() {
    var a = [[1,2,3], [4,5,6], [7,8,9]];
    assert(MatrixMath.size(a) === 3);

    var b = [[1,2],[3,4]];
    assert(MatrixMath.size(b) === 2);
  });

  unitTest('MatrixMath.transpose()', function() {
    var a = [[1,2,3], [4,5,6], [7,8,9]];
    var expected = [[1,4,7], [2,5,8], [3,6,9]];
    var transpose = MatrixMath.transpose(a);
    assertEqual(transpose, expected);
  });



})();

}).toString());



EXT_LIB_API_SCRIPTS.push((function lib_script_9 () {
/**
 * PathMath script
 *
 * This is a library that provides mathematical operations involving Paths.
 * It intended to be used by other scripts and has no stand-alone
 * functionality of its own. All the library's operations are exposed by the
 * PathMath object created by this script.
 */
var PathMath = (() => {
    'use strict';

    /**
     * A vector used to define a homogeneous point or a direction.
     * @typedef {number[]} Vector
     */

    /**
     * A line segment defined by two homogeneous 2D points.
     * @typedef {Vector[]} Segment
     */

    /**
     * Information about a path's 2D transform.
     * @typedef {Object} PathTransformInfo
     * @property {number} angle
     *           The path's rotation angle in radians.
     * @property {number} cx
     *           The x coordinate of the center of the path's bounding box.
     * @property {number} cy
     *           The y coordinate of the center of the path's bounding box.
     * @property {number} height
     *           The unscaled height of the path's bounding box.
     * @property {number} scaleX
     *           The path's X-scale.
     * @property {number} scaleY
     *           The path's Y-scale.
     * @property {number} width
     *           The unscaled width of the path's bounding box.
     */

    /**
     * Rendering information for shapes.
     * @typedef {Object} RenderInfo
     * @property {string} [controlledby]
     * @property {string} [fill]
     * @property {string} [stroke]
     * @property {string} [strokeWidth]
     */

    /**
     * Some shape defined by a path.
     * @abstract
     */
    class PathShape {
      constructor(vertices) {
        this.vertices = vertices || [];
      }

      /**
       * Gets the distance from this shape to some point.
       * @abstract
       * @param {vec3} pt
       * @return {number}
       */
      distanceToPoint(pt) {
        throw new Error('Must be defined by subclass.');
      }

      /**
       * Gets the bounding box of this shape.
       * @return {BoundingBox}
       */
      getBoundingBox() {
        if(!this._bbox) {
          let left, right, top, bottom;
          _.each(this.vertices, (v, i) => {
            if(i === 0) {
              left = v[0];
              right = v[0];
              top = v[1];
              bottom = v[1];
            }
            else {
              left = Math.min(left, v[0]);
              right = Math.max(right, v[0]);
              top = Math.min(top, v[1]);
              bottom = Math.max(bottom, v[1]);
            }
          });
          let width = right - left;
          let height = bottom - top;
          this._bbox = new BoundingBox(left, top, width, height);
        }
        return this._bbox;
      }

      /**
       * Checks if this shape intersects another shape.
       * @abstract
       * @param {PathShape} other
       * @return {boolean}
       */
      intersects(other) {
        throw new Error('Must be defined by subclass.');
      }

      /**
       * Renders this path.
       * @param {string} pageId
       * @param {string} layer
       * @param {RenderInfo} renderInfo
       */
      render(pageId, layer, renderInfo) {
        let segments = this.toSegments();
        let pathData = segmentsToPath(segments);
        _.extend(pathData, renderInfo, {
          _pageid: pageId,
          layer
        });
        createObj('path', pathData);
      }

      /**
       * Returns the segments that make up this shape.
       * @abstract
       * @return {Segment[]}
       */
      toSegments() {
        throw new Error('Must be defined by subclass.');
      }

      /**
       * Produces a copy of this shape, transformed by an affine
       * transformation matrix.
       * @param {MatrixMath.Matrix} matrix
       * @return {PathShape}
       */
      transform(matrix) {
        let vertices = _.map(this.vertices, v => {
          return MatrixMath.multiply(matrix, v);
        });
        let Clazz = this.constructor;
        return new Clazz(vertices);
      }
    }

    /**
     * An open shape defined by a path or list of vertices.
     */
    class Path extends PathShape {

      /**
       * @param {(Roll20Path|vec3[])} path
       */
      constructor(path) {
        super();
        if(_.isArray(path))
          this.vertices = path;
        else {
          this._segments = toSegments(path);
          _.each(this._segments, (seg, i) => {
            if(i === 0)
              this.vertices.push(seg[0]);
            this.vertices.push(seg[1]);
          });
        }

        this.numVerts = this.vertices.length;
      }

      /**
       * Gets the distance from this path to some point.
       * @param {vec3} pt
       * @return {number}
       */
      distanceToPoint(pt) {
        let dist = _.chain(this.toSegments())
        .map(seg => {
          let [ p, q ] = seg;
          return VecMath.ptSegDist(pt, p, q);
        })
        .min()
        .value();
        return dist;
      }

      /**
       * Checks if this path intersects with another path.
       * @param {Polygon} other
       * @return {boolean}
       */
      intersects(other) {
        let thisBox = this.getBoundingBox();
        let otherBox = other.getBoundingBox();

        // If the bounding boxes don't intersect, then the paths won't
        // intersect.
        if(!thisBox.intersects(otherBox))
          return false;

        // Naive approach: Since our shortcuts didn't return, check each
        // path's segments for intersections with each of the other
        // path's segments. This takes O(n^2) time.
        return !!_.find(this.toSegments(), seg1 => {
          return !!_.find(other.toSegments(), seg2 => {
            return !!segmentIntersection(seg1, seg2);
          });
        });
      }

      /**
       * Produces a list of segments defining this path.
       * @return {Segment[]}
       */
      toSegments() {
        if(!this._segments) {
          this._segments = _.map(_.range(this.numVerts - 1), i => {
            let v = this.vertices[i];
            let vNext = this.vertices[i + 1];
            return [v, vNext];
          });
        }
        return this._segments;
      }
    }

    /**
     * A closed shape defined by a path or a list of vertices.
     */
    class Polygon extends PathShape {

      /**
       * @param {(Roll20Path|vec3[])} path
       */
      constructor(path) {
        super();
        if(_.isArray(path))
          this.vertices = path;
        else {
          this._segments = toSegments(path);
          this.vertices = _.map(this._segments, seg => {
            return seg[0];
          });
        }

        this.numVerts = this.vertices.length;
        if(this.numVerts < 3)
          throw new Error('A polygon must have at least 3 vertices.');
      }

      /**
       * Determines whether a point lies inside the polygon using the
       * winding algorithm.
       * See: http://geomalgorithms.com/a03-_inclusion.html
       * @param {vec3} p
       * @return {boolean}
       */
      containsPt(p) {
        // A helper function that tests if a point is "left" of a line segment.
        let _isLeft = (p0, p1, p2) => {
          return (p1[0] - p0[0])*(p2[1] - p0[1]) - (p2[0]-p0[0])*(p1[1]-p0[1]);
        };

        let total = 0;
        _.each(this.vertices, (v1, i) => {
          let v2 = this.vertices[(i+1) % this.numVerts];

          // Check for valid up intersect.
          if(v1[1] <= p[1] && v2[1] > p[1]) {
            if(_isLeft(v1, v2, p) > 0)
              total++;
          }

          // Check for valid down intersect.
          else if(v1[1] > p[1] && v2[1] <= p[1]) {
            if(_isLeft(v1, v2, p) < 0)
              total--;
          }
        });
        return !!total; // We are inside if our total windings are non-zero.
      }

      /**
       * Gets the distance from this polygon to some point.
       * @param {vec3} pt
       * @return {number}
       */
      distanceToPoint(pt) {
        if(this.containsPt(pt))
          return 0;
        else
          return _.chain(this.toSegments())
          .map(seg => {
            let [ p, q ] = seg;
            return VecMath.ptSegDist(pt, p, q);
          })
          .min()
          .value();
      }

      /**
       * Gets the area of this polygon.
       * @return {number}
       */
      getArea() {
        let triangles = this.tessellate();
        return _.reduce(triangles, (area, tri) => {
          return area + tri.getArea();
        }, 0);
      }

      /**
       * Determines whether each vertex along the polygon is convex (1)
       * or concave (-1). A vertex lying on a straight line is assined 0.
       * @return {int[]}
       */
      getConvexness() {
        return Polygon.getConvexness(this.vertices);
      }

      /**
       * Gets the convexness information about each vertex.
       * @param {vec3[]}
       * @return {int[]}
       */
      static getConvexness(vertices) {
        let totalAngle = 0;
        let numVerts = vertices.length;
        let vertexCurves = _.map(vertices, (v, i) => {
          let vPrev = vertices[(i-1 + numVerts) % numVerts];
          let vNext = vertices[(i+1 + numVerts) % numVerts];

          let u = VecMath.sub(v, vPrev);
          let w = VecMath.sub(vNext, v);
          let uHat = VecMath.normalize(u);
          let wHat = VecMath.normalize(w);

          let cross = VecMath.cross(uHat, wHat);
          let sign = cross[2];
          if(sign)
            sign = sign/Math.abs(sign);

          let dot = VecMath.dot(uHat, wHat);
          let angle = Math.acos(dot)*sign;
          totalAngle += angle;

          return sign;
        });

        if(totalAngle < 0)
          return _.map(vertexCurves, curve => {
            return -curve;
          });
        else
          return vertexCurves;
      }

      /**
       * Checks if this polygon intersects with another polygon.
       * @param {(Polygon|Path)} other
       * @return {boolean}
       */
      intersects(other) {
        let thisBox = this.getBoundingBox();
        let otherBox = other.getBoundingBox();

        // If the bounding boxes don't intersect, then the polygons won't
        // intersect.
        if(!thisBox.intersects(otherBox))
          return false;

        // If either polygon contains the first point of the other, then
        // they intersect.
        if(this.containsPt(other.vertices[0]) ||
          (other instanceof Polygon && other.containsPt(this.vertices[0])))
          return true;

        // Naive approach: Since our shortcuts didn't return, check each
        // polygon's segments for intersections with each of the other
        // polygon's segments. This takes O(n^2) time.
        return !!_.find(this.toSegments(), seg1 => {
          return !!_.find(other.toSegments(), seg2 => {
            return !!segmentIntersection(seg1, seg2);
          });
        });
      }

      /**
       * Checks if this polygon intersects a Path.
       * @param {Path} path
       * @return {boolean}
       */
      intersectsPath(path) {
        let segments1 = this.toSegments();
        let segments2 = PathMath.toSegments(path);

        // The path intersects if any point is inside this polygon.
        if(this.containsPt(segments2[0][0]))
          return true;

        // Check if any of the segments intersect.
        return !!_.find(segments1, seg1 => {
          return _.find(segments2, seg2 => {
            return PathMath.segmentIntersection(seg1, seg2);
          });
        });
      }

      /**
       * Tessellates a closed path representing a simple polygon
       * into a bunch of triangles.
       * @return {Triangle[]}
       */
      tessellate() {
        let triangles = [];
        let vertices = _.clone(this.vertices);

        // Tessellate using ear-clipping algorithm.
        while(vertices.length > 0) {
          if(vertices.length === 3) {
            triangles.push(new Triangle(vertices[0], vertices[1], vertices[2]));
            vertices = [];
          }
          else {
            // Determine whether each vertex is convex, concave, or linear.
            let convexness = Polygon.getConvexness(vertices);
            let numVerts = vertices.length;

            // Find the next ear to clip from the polygon.
            let earIndex = _.find(_.range(numVerts), i => {
              let v = vertices[i];
              let vPrev = vertices[(numVerts + i -1) % numVerts];
              let vNext = vertices[(numVerts + i + 1) % numVerts];

              let vConvexness = convexness[i];
              if(vConvexness === 0) // The vertex lies on a straight line. Clip it.
                return true;
              else if(vConvexness < 0) // The vertex is concave.
                return false;
              else { // The vertex is convex and might be an ear.
                let triangle = new Triangle(vPrev, v, vNext);

                // The vertex is not an ear if there is at least one other
                // vertex inside its triangle.
                return !_.find(vertices, (v2, j) => {
                  if(v2 === v || v2 === vPrev || v2 === vNext)
                    return false;
                  else {
                    return triangle.containsPt(v2);
                  }
                });
              }
            });

            let v = vertices[earIndex];
            let vPrev = vertices[(numVerts + earIndex -1) % numVerts];
            let vNext = vertices[(numVerts + earIndex + 1) % numVerts];
            triangles.push(new Triangle(vPrev, v, vNext));
            vertices.splice(earIndex, 1);
          }
        }
        return triangles;
      }

      /**
       * Produces a list of segments defining this polygon.
       * @return {Segment[]}
       */
      toSegments() {
        if(!this._segments) {
          this._segments = _.map(this.vertices, (v, i) => {
            let vNext = this.vertices[(i + 1) % this.numVerts];
            return [v, vNext];
          });
        }
        return this._segments;
      }
    }

    /**
     * A 3-sided polygon that is great for tessellation!
     */
    class Triangle extends Polygon {
      /**
       * @param {vec3} p1
       * @param {vec3} p2
       * @param {vec3} p3
       */
      constructor(p1, p2, p3) {
        if(_.isArray(p1))
          [p1, p2, p3] = p1;
        super([p1, p2, p3]);

        this.p1 = p1;
        this.p2 = p2;
        this.p3 = p3;
      }

      /**
       * @inheritdoc
       */
      getArea() {
        let base = VecMath.sub(this.p2, this.p1);
        let width = VecMath.length(base);
        let height = VecMath.ptLineDist(this.p3, this.p1, this.p2);

        return width*height/2;
      }
    }

    /**
     * A circle defined by its center point and radius.
     */
    class Circle extends PathShape {

      /**
       * @param {vec3} pt
       * @param {number} r
       */
      constructor(pt, r) {
        super();
        this.center = pt;
        this.radius = r;
        this.diameter = 2*r;
      }

      /**
       * Checks if a point is contained within this circle.
       * @param {vec3} pt
       * @return {boolean}
       */
      containsPt(pt) {
        let dist = VecMath.dist(this.center, pt);
        return dist <= this.radius;
      }

      /**
       * Gets the distance from this circle to some point.
       * @param {vec3} pt
       * @return {number}
       */
      distanceToPoint(pt) {
        if(this.containsPt(pt))
          return 0;
        else {
          return VecMath.dist(this.center, pt) - this.radius;
        }
      }

      /**
       * Gets this circle's area.
       * @return {number}
       */
      getArea() {
        return Math.PI*this.radius*this.radius;
      }

      /**
       * Gets the circle's bounding box.
       * @return {BoundingBox}
       */
      getBoundingBox() {
        let left = this.center[0] - this.radius;
        let top = this.center[1] - this.radius;
        let dia = this.radius*2;
        return new BoundingBox(left, top, dia, dia);
      }

      /**
       * Gets this circle's circumference.
       * @return {number}
       */
      getCircumference() {
        return Math.PI*this.diameter;
      }

      /**
       * Checks if this circle intersects another circle.
       * @param {Circle} other
       * @return {boolean}
       */
      intersects(other) {
        let dist = VecMath.dist(this.center, other.center);
        return dist <= this.radius + other.radius;
      }

      /**
       * Checks if this circle intersects a polygon.
       * @param {Polygon} poly
       * @return {boolean}
       */
      intersectsPolygon(poly) {

        // Quit early if the bounding boxes don't overlap.
        let thisBox = this.getBoundingBox();
        let polyBox = poly.getBoundingBox();
        if(!thisBox.intersects(polyBox))
          return false;

        if(poly.containsPt(this.center))
          return true;
        return !!_.find(poly.toSegments(), seg => {
          return this.segmentIntersection(seg);
        });
      }

      /**
       * Renders this circle.
       * @param {string} pageId
       * @param {string} layer
       * @param {RenderInfo} renderInfo
       */
      render(pageId, layer, renderInfo) {
        let data = createCircleData(this.radius)
        _.extend(data, renderInfo, {
          _pageid: pageId,
          layer,
          left: this.center[0],
          top: this.center[1]
        });
        createObj('path', data);
      }

      /**
       * Gets the intersection coefficient between this circle and a Segment,
       * if such an intersection exists. Otherwise, undefined is returned.
       * @param {Segment} segment
       * @return {Intersection}
       */
      segmentIntersection(segment) {
        if(this.containsPt(segment[0])) {
          let pt = segment[0];
          let s = 0;
          let t = VecMath.dist(this.center, segment[0])/this.radius;
          return [pt, s, t];
        }
        else {
          let u = VecMath.sub(segment[1], segment[0]);
          let uHat = VecMath.normalize(u);
          let uLen = VecMath.length(u);
          let v = VecMath.sub(this.center, segment[0]);

          let height = VecMath.ptLineDist(this.center, segment[0], segment[1]);
          let base = Math.sqrt(this.radius*this.radius - height*height);

          if(isNaN(base))
            return undefined;

          let scalar = VecMath.scalarProjection(u, v)-base;
          let s = scalar/uLen;

          if(s >= 0 && s <= 1) {
            let t = 1;
            let pt = VecMath.add(segment[0], VecMath.scale(uHat, scalar));
            return [pt, s, t];
          }
          else
            return undefined;
        }
      }
    }

    /**
     * The bounding box for a path/polygon.
     */
    class BoundingBox {
      /**
       * @param {Number} left
       * @param {Number} top
       * @param {Number} width
       * @param {Number} height
       */
      constructor(left, top, width, height) {
        this.left = left;
        this.top = top;
        this.width = width;
        this.height = height;
        this.right = left + width;
        this.bottom = top + height;
      }

      /**
       * Adds two bounding boxes.
       * @param  {BoundingBox} a
       * @param  {BoundingBox} b
       * @return {BoundingBox}
       */
      static add(a, b) {
        var left = Math.min(a.left, b.left);
        var top = Math.min(a.top, b.top);
        var right = Math.max(a.left + a.width, b.left + b.width);
        var bottom = Math.max(a.top + a.height, b.top + b.height);

        return new BoundingBox(left, top, right - left, bottom - top);
      }

      /**
       * Gets the area of this bounding box.
       * @return {number}
       */
      getArea() {
        return this.width * this.height;
      }

      /**
       * Checks if this bounding box intersects another bounding box.
       * @param {BoundingBox} other
       * @return {boolean}
       */
      intersects(other) {
        return !( this.left > other.right ||
                  this.right < other.left ||
                  this.top > other.bottom ||
                  this.bottom < other.top);
      }

      /**
       * Renders the bounding box.
       * @param {string} pageId
       * @param {string} layer
       * @param {RenderInfo} renderInfo
       */
      render(pageId, layer, renderInfo) {
        let verts = [
          [this.left, this.top, 1],
          [this.right, this.top, 1],
          [this.right, this.bottom, 1],
          [this.left, this.bottom, 1]
        ];
        let poly = new Polygon(verts);
        poly.render(pageId, layer, renderInfo);
      }
    }

    /**
     * Returns the partial path data for creating a circular path.
     * @param  {number} radius
     * @param {int} [sides]
     *        If specified, then a polygonal path with the specified number of
     *        sides approximating the circle will be created instead of a true
     *        circle.
     * @return {PathData}
     */
    function createCircleData(radius, sides) {
      var _path = [];
      if(sides) {
        var cx = radius;
        var cy = radius;
        var angleInc = Math.PI*2/sides;
        path.push(['M', cx + radius, cy]);
        _.each(_.range(1, sides+1), function(i) {
          var angle = angleInc*i;
          var x = cx + radius*Math.cos(angle);
          var y = cy + radius*Math.sin(angle);
          path.push(['L', x, y]);
        });
      }
      else {
        var r = radius;
        _path = [
          ['M', 0,      r],
          ['C', 0,      r*0.5,  r*0.5,  0,      r,      0],
          ['C', r*1.5,  0,      r*2,    r*0.5,  r*2.0,  r],
          ['C', r*2.0,  r*1.5,  r*1.5,  r*2.0,  r,      r*2.0],
          ['C', r*0.5,  r*2,    0,      r*1.5,  0,      r]
        ];
      }
      return {
        height: radius*2,
        _path: JSON.stringify(_path),
        width: radius*2
      };
    }

    /**
     * Computes the distance from a point to some path.
     * @param {vec3} pt
     * @param {(Roll20Path|PathShape)} path
     */
    function distanceToPoint(pt, path) {
      if(!(path instanceof PathShape))
        path = new Path(path);
      return path.distanceToPoint(pt);
    }

    /**
     * Gets a point along some Bezier curve of arbitrary degree.
     * @param {vec3[]} points
     *        The points of the Bezier curve. The points between the first and
     *        last point are the control points.
     * @param {number} scalar
     *        The parametric value for the point we want along the curve.
     *        This value is expected to be in the range [0, 1].
     * @return {vec3}
     */
    function getBezierPoint(points, scalar) {
      if(points.length < 2)
        throw new Error('Bezier curve cannot have less than 2 points.');
      else if(points.length === 2) {
        let u = VecMath.sub(points[1], points[0]);
        u = VecMath.scale(u, scalar);
        return VecMath.add(points[0], u);
      }
      else {
        let newPts = _.chain(points)
        .map((cur, i) => {
          if(i === 0)
            return undefined;

          let prev = points[i-1];
          return getBezierPoint([prev, cur], scalar);
        })
        .compact()
        .value();

        return getBezierPoint(newPts, scalar);
      }
    }


    /**
     * Calculates the bounding box for a list of paths.
     * @param {Roll20Path | Roll20Path[]} paths
     * @return {BoundingBox}
     */
    function getBoundingBox(paths) {
      if(!_.isArray(paths))
        paths = [paths];

      var result;
      _.each(paths, function(p) {
        var pBox = _getSingleBoundingBox(p);
        if(result)
          result = BoundingBox.add(result, pBox);
        else
          result = pBox;
      });
      return result;
    }

    /**
     * Returns the center of the bounding box countaining a path or list
     * of paths. The center is returned as a 2D homongeneous point
     * (It has a third component which is always 1 which is helpful for
     * affine transformations).
     * @param {(Roll20Path|Roll20Path[])} paths
     * @return {Vector}
     */
    function getCenter(paths) {
        if(!_.isArray(pathjs))
            paths = [paths];

        var bbox = getBoundingBox(paths);
        var cx = bbox.left + bbox.width/2;
        var cy = bbox.top + bbox.height/2;

        return [cx, cy, 1];
    }

    /**
     * @private
     * Calculates the bounding box for a single path.
     * @param  {Roll20Path} path
     * @return {BoundingBox}
     */
    function _getSingleBoundingBox(path) {
        var pathData = normalizePath(path);

        var width = pathData.width;
        var height = pathData.height;
        var left = pathData.left - width/2;
        var top = pathData.top - height/2;

        return new BoundingBox(left, top, width, height);
    }

    /**
     * Gets the 2D transform information about a path.
     * @param  {Roll20Path} path
     * @return {PathTransformInfo}
     */
    function getTransformInfo(path) {
        var scaleX = path.get('scaleX');
        var scaleY = path.get('scaleY');
        var angle = path.get('rotation')/180*Math.PI;

        // The transformed center of the path.
        var cx = path.get('left');
        var cy = path.get('top');

        // The untransformed width and height.
        var width = path.get('width');
        var height = path.get('height');

        return {
            angle: angle,
            cx: cx,
            cy: cy,
            height: height,
            scaleX: scaleX,
            scaleY: scaleY,
            width: width
        };
    }

    /**
     * Checks if a path is closed, and is therefore a polygon.
     * @param {(Roll20Path|Segment[])}
     * @return {boolean}
     */
    function isClosed(path) {
      // Convert to segments.
      if(!_.isArray(path))
        path = toSegments(path);
      return (_.isEqual(path[0][0], path[path.length-1][1]));
    }


    /**
     * Produces a merged path string from a list of path objects.
     * @param {Roll20Path[]} paths
     * @return {String}
     */
    function mergePathStr(paths) {
        var merged = [];
        var bbox = getBoundingBox(paths);

        _.each(paths, function(p) {
            var pbox = getBoundingBox(p);

            // Convert the path to a normalized polygonal path.
            p = normalizePath(p);
            var parsed = JSON.parse(p._path);
            _.each(parsed, function(pathTuple, index) {
                var dx = pbox.left - bbox.left;
                var dy = pbox.top - bbox.top;

                // Move and Line tuples
                var x = pathTuple[1] + dx;
                var y = pathTuple[2] + dy;
                merged.push([pathTuple[0], x, y]);
            });
        });

        return JSON.stringify(merged);
    }

    /**
     * Reproduces the data for a polygonal path such that the scales are 1 and
     * its rotate is 0.
     * This can also normalize freehand paths, but they will be converted to
     * polygonal paths. The quatric Bezier curves used in freehand paths are
     * so short though, that it doesn't make much difference though.
     * @param {Roll20Path}
     * @return {PathData}
     */
    function normalizePath(path) {
        var segments = toSegments(path);
        return segmentsToPath(segments);
    }

    /**
     * Computes the intersection between the projected lines of
     * two homogenous 2D line segments.
     *
     * Explanation of the fancy mathemagics:
     * Let A be the first point in seg1 and B be the second point in seg1.
     * Let C be the first point in seg2 and D be the second point in seg2.
     * Let U be the vector from A to B.
     * Let V be the vector from C to D.
     * Let UHat be the unit vector of U.
     * Let VHat be the unit vector of V.
     *
     * Observe that if the dot product of UHat and VHat is 1 or -1, then
     * seg1 and seg2 are parallel, so they will either never intersect or they
     * will overlap. We will ignore the case where seg1 and seg2 are parallel.
     *
     * We can represent any point P along the line projected by seg1 as
     * P = A + SU, where S is some scalar value such that S = 0 yeilds A,
     * S = 1 yields B, and P is on seg1 if and only if 0 <= S <= 1.
     *
     * We can also represent any point Q along the line projected by seg2 as
     * Q = C + TV, where T is some scalar value such that T = 0 yeilds C,
     * T = 1 yields D, and Q is on seg2 if and only if 0 <= T <= 1.
     *
     * Assume that seg1 and seg2 are not parallel and that their
     * projected lines intersect at some point P.
     * Therefore, we have A + SU = C + TV.
     *
     * We can rearrange this such that we have C - A = SU - TV.
     * Let vector W = C - A, thus W = SU - TV.
     * Also, let coeffs = [S, T, 1].
     *
     * We can now represent this system of equations as the matrix
     * multiplication problem W = M * coeffs, where in column-major
     * form, M = [U, -V, [0,0,1]].
     *
     * By matrix-multiplying both sides by M^-1, we get
     * M^-1 * W = M^-1 * M * coeffs = coeffs, from which we can extract the
     * values for S and T.
     *
     * We can now get the point of intersection on the projected lines of seg1
     * and seg2 by substituting S in P = A + SU or T in Q = C + TV.
     *
     * @param {Segment} seg1
     * @param {Segment} seg2
     * @return {Intersection}
     *      The point of intersection in homogenous 2D coordiantes and its
     *      scalar coefficients along seg1 and seg2,
     *      or undefined if the segments are parallel.
     */
    function raycast(seg1, seg2) {
      var u = VecMath.sub(seg1[1], seg1[0]);
      var v = VecMath.sub(seg2[1], seg2[0]);
      var w = VecMath.sub(seg2[0], seg1[0]);

      // Can't use 0-length vectors.
      if(VecMath.length(u) === 0 || VecMath.length(v) === 0)
          return undefined;

      // If the two segments are parallel, then either they never intersect
      // or they overlap. Either way, return undefined in this case.
      var uHat = VecMath.normalize(u);
      var vHat = VecMath.normalize(v);
      var uvDot = VecMath.dot(uHat,vHat);
      if(Math.abs(uvDot) > 0.9999)
          return undefined;

      // Build the inverse matrix for getting the intersection point's
      // parametric coefficients along the projected segments.
      var m = [[u[0], u[1], 0], [-v[0], -v[1], 0], [0, 0, 1]];
      var mInv = MatrixMath.inverse(m);

      // Get the parametric coefficients for getting the point of intersection
      // on the projected semgents.
      var coeffs = MatrixMath.multiply(mInv, w);
      var s = coeffs[0];
      var t = coeffs[1];

      var uPrime = VecMath.scale(u, s);
      return [VecMath.add(seg1[0], uPrime), s, t];
    }

    /**
     * Computes the intersection between two homogenous 2D line segments,
     * if it exists. To figure out the intersection, a raycast is performed
     * between the two segments.
     * Seg1 and seg2 also intersect at that point if and only if 0 <= S, T <= 1.
     * @param {Segment} seg1
     * @param {Segment} seg2
     * @return {Intersection}
     *      The point of intersection in homogenous 2D coordiantes and its
     *      parametric coefficients along seg1 and seg2,
     *      or undefined if the segments don't intersect.
     */
    function segmentIntersection(seg1, seg2) {
      let intersection = raycast(seg1, seg2);
      if(!intersection)
        return undefined;

      // Return the intersection only if it lies on both the segments.
      let s = intersection[1];
      let t = intersection[2];
      if(s >= 0 && s <= 1 && t >= 0 && t <= 1)
        return intersection;
      else
        return undefined;
    }


    /**
     * Produces the data for creating a path from a list of segments forming a
     * continuous path.
     * @param {Segment[]}
     * @return {PathData}
     */
    function segmentsToPath(segments) {
        var left = segments[0][0][0];
        var right = segments[0][0][0];
        var top = segments[0][0][1];
        var bottom = segments[0][0][1];

        // Get the bounds of the segment.
        var pts = [];
        var isFirst = true;
        _.each(segments, function(segment) {
            var p1 = segment[0];
            if(isFirst) {
                isFirst = false;
                pts.push(p1);
            }

            var p2 = segment[1];

            left = Math.min(left, p1[0], p2[0]);
            right = Math.max(right, p1[0], p2[0]);
            top = Math.min(top, p1[1], p2[1]);
            bottom = Math.max(bottom, p1[1], p2[1]);

            pts.push(p2);
        });

        // Get the path's left and top coordinates.
        var width = right-left;
        var height = bottom-top;
        var cx = left + width/2;
        var cy = top + height/2;

        // Convert the points to a _path.
        var _path = [];
        var firstPt = true;
        _.each(pts, function(pt) {
            var type = 'L';
            if(firstPt) {
                type = 'M';
                firstPt = false;
            }
            _path.push([type, pt[0]-left, pt[1]-top]);
        });

        return {
            _path: JSON.stringify(_path),
            left: cx,
            top: cy,
            width: width,
            height: height
        };
    }

    /**
     * Converts a path into a list of line segments.
     * This supports freehand paths, but not elliptical paths.
     * @param {(Roll20Path|Roll20Path[])} path
     * @return {Segment[]}
     */
    function toSegments(path) {
        if(_.isArray(path))
            return _toSegmentsMany(path);

        var _path = JSON.parse(path.get('_path'));
        var transformInfo = getTransformInfo(path);

        var segments = [];
        var prevPt;

        _.each(_path, tuple => {
            let type = tuple[0];

            // Convert the previous point and tuple into segments.
            let newSegs = [];
            if(type === 'C') { // Cubic Bezier
              newSegs = _toSegmentsC(prevPt, tuple, transformInfo);
              if(newSegs.length > 0)
                prevPt = newSegs[newSegs.length - 1][1];
            }
            if(type === 'L') { // Line
              newSegs = _toSegmentsL(prevPt, tuple, transformInfo);
              if(newSegs.length > 0)
                prevPt = newSegs[0][1];
            }
            if(type === 'M') { // Move
              prevPt = tupleToPoint(tuple, transformInfo);
            }
            if(type === 'Q') { // Freehand (tiny Quadratic Bezier)
              newSegs = _toSegmentsQ(prevPt, tuple, transformInfo);
              if(newSegs.length > 0)
                prevPt = newSegs[0][1];
            }

            _.each(newSegs, s => {
              segments.push(s);
            });
        });

        return segments;
    }

    /**
     * Converts a 'C' type path point to a list of segments approximating the
     * curve.
     * @private
     * @param {vec3} prevPt
     * @param {PathTuple} tuple
     * @param {PathTransformInfo} transformInfo
     * @return {Segment[]}
     */
    function _toSegmentsC(prevPt, tuple, transformInfo) {
      let cPt1 = tupleToPoint(['L', tuple[1], tuple[2]], transformInfo);
      let cPt2 = tupleToPoint(['L', tuple[3], tuple[4]], transformInfo);
      let pt = tupleToPoint(['L', tuple[5], tuple[6]], transformInfo);
      let points = [prevPt, cPt1, cPt2, pt];

      // Choose the number of segments based on the rough approximate arc length.
      // Each segment should be <= 10 pixels.
      let approxArcLength = VecMath.dist(prevPt, cPt1) + VecMath.dist(cPt1, cPt2) + VecMath.dist(cPt2, pt);
      let numSegs = Math.max(Math.ceil(approxArcLength/10), 1);

      let bezierPts = [prevPt];
      _.each(_.range(1, numSegs), i => {
        let scalar = i/numSegs;
        let bPt = getBezierPoint(points, scalar);
        bezierPts.push(bPt);
      });
      bezierPts.push(pt);

      return _.chain(bezierPts)
      .map((cur, i) => {
        if(i === 0)
          return undefined;

        let prev = bezierPts[i-1];
        return [prev, cur];
      })
      .compact()
      .value();
    }

    /**
     * Converts an 'L' type path point to a segment.
     * @private
     * @param {vec3} prevPt
     * @param {PathTuple} tuple
     * @param {PathTransformInfo} transformInfo
     * @return {Segment[]}
     */
    function _toSegmentsL(prevPt, tuple, transformInfo) {
      // Transform the point to 2D homogeneous map coordinates.
      let pt = tupleToPoint(tuple, transformInfo);

      let segments = [];
      if(!(prevPt[0] == pt[0] && prevPt[1] == pt[1]))
        segments.push([prevPt, pt]);
      return segments;
    }

    /**
     * Converts a 'Q' type path point to a segment approximating
     * the freehand curve.
     * @private
     * @param {vec3} prevPt
     * @param {PathTuple} tuple
     * @param {PathTransformInfo} transformInfo
     * @return {Segment[]}
     */
    function _toSegmentsQ(prevPt, tuple, transformInfo) {
      // Freehand Bezier paths are very small, so let's just
      // ignore the control point for it entirely.
      tuple[1] = tuple[3];
      tuple[2] = tuple[4];

      // Transform the point to 2D homogeneous map coordinates.
      let pt = tupleToPoint(tuple, transformInfo);

      let segments = [];
      if(!(prevPt[0] == pt[0] && prevPt[1] == pt[1]))
        segments.push([prevPt, pt]);
      return segments;
    }

    /**
     * Converts several paths into a single list of segments.
     * @private
     * @param  {Roll20Path[]} paths
     * @return {Segment[]}
     */
    function _toSegmentsMany(paths) {
        return _.chain(paths)
          .reduce(function(allSegments, path) {
              return allSegments.concat(toSegments(path));
          }, [])
          .value();
    }

    /**
     * Transforms a tuple for a point in a path into a point in
     * homogeneous 2D map coordinates.
     * @param  {PathTuple} tuple
     * @param  {PathTransformInfo} transformInfo
     * @return {Vector}
     */
    function tupleToPoint(tuple, transformInfo) {
        var width = transformInfo.width;
        var height = transformInfo.height;
        var scaleX = transformInfo.scaleX;
        var scaleY = transformInfo.scaleY;
        var angle = transformInfo.angle;
        var cx = transformInfo.cx;
        var cy = transformInfo.cy;

        // The point in path coordinates, relative to the path center.
        var x = tuple[1] - width/2;
        var y = tuple[2] - height/2;
        var pt = [x,y,1];

        // The transform of the point from path coordinates to map
        // coordinates.
        var scale = MatrixMath.scale([scaleX, scaleY]);
        var rotate = MatrixMath.rotate(angle);
        var transform = MatrixMath.translate([cx, cy]);
        transform = MatrixMath.multiply(transform, rotate);
        transform = MatrixMath.multiply(transform, scale);

        return MatrixMath.multiply(transform, pt);
    }

    on('chat:message', function(msg) {
        if(msg.type === 'api' && msg.content.indexOf('!pathInfo')  === 0) {
            log('!pathInfo');

            try {
                var path = findObjs({
                    _type: 'path',
                    _id: msg.selected[0]._id
                })[0];
                log(path);
                log(path.get('_path'));

                var segments = toSegments(path);
                log('Segments: ');
                log(segments);

                var pathData = segmentsToPath(segments);
                log('New path data: ');
                log(pathData);

                var curPage = path.get('_pageid');
                _.extend(pathData, {
                    stroke: '#ff0000',
                    _pageid: curPage,
                    layer: path.get('layer')
                });

                var newPath = createObj('path', pathData);
                log(newPath);
            }
            catch(err) {
                log('!pathInfo ERROR: ');
                log(err.message);
            }

        }
    });

    return {
        BoundingBox,
        Circle,
        Path,
        Polygon,
        Triangle,

        createCircleData,
        distanceToPoint,
        getBezierPoint,
        getBoundingBox,
        getCenter,
        getTransformInfo,
        mergePathStr,
        normalizePath,
        raycast,
        segmentIntersection,
        segmentsToPath,
        toSegments,
        tupleToPoint
    };
})();

}).toString());
